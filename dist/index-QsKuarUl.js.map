{"version":3,"file":"index-QsKuarUl.js","sources":["../node_modules/.pnpm/tinymce@6.8.6/node_modules/tinymce/plugins/searchreplace/plugin.js"],"sourcesContent":["/**\n * TinyMCE version 6.8.6 (TBD)\n */\n\n(function () {\n    'use strict';\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const isString = isType$1('string');\n    const isArray = isType$1('array');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isNumber = isSimpleType('number');\n\n    const noop = () => {\n    };\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const always = constant(true);\n\n    const punctuationStr = `[~\\u2116|!-*+-\\\\/:;?@\\\\[-\\`{}\\u00A1\\u00AB\\u00B7\\u00BB\\u00BF;\\u00B7\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1361-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u3008\\u3009\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30\\u2E31\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]`;\n\n    const punctuation$1 = constant(punctuationStr);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const punctuation = punctuation$1;\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.Env');\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const nativeSlice = Array.prototype.slice;\n    const nativePush = Array.prototype.push;\n    const map = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const groupBy = (xs, f) => {\n      if (xs.length === 0) {\n        return [];\n      } else {\n        let wasType = f(xs[0]);\n        const r = [];\n        let group = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n          const x = xs[i];\n          const type = f(x);\n          if (type !== wasType) {\n            r.push(group);\n            group = [];\n          }\n          wasType = type;\n          group.push(x);\n        }\n        if (group.length !== 0) {\n          r.push(group);\n        }\n        return r;\n      }\n    };\n    const foldl = (xs, f, acc) => {\n      each(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind = (xs, f) => flatten(map(xs, f));\n    const sort = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n\n    const hasOwnProperty = Object.hasOwnProperty;\n    const has = (obj, key) => hasOwnProperty.call(obj, key);\n\n    typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const type = element => element.dom.nodeType;\n    const isType = t => element => type(element) === t;\n    const isText$1 = isType(TEXT);\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom(node);\n    };\n    const fromDom = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\n    const SugarElement = {\n      fromHtml,\n      fromTag,\n      fromText,\n      fromDom,\n      fromPoint\n    };\n\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const children = element => map(element.dom.childNodes, SugarElement.fromDom);\n    const spot = (element, offset) => ({\n      element,\n      offset\n    });\n    const leaf = (element, offset) => {\n      const cs = children(element);\n      return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);\n    };\n\n    const before = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const append = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const wrap = (element, wrapper) => {\n      before(element, wrapper);\n      append(wrapper, element);\n    };\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api = NodeValue(isText$1, 'text');\n    const get$1 = element => api.get(element);\n\n    const compareDocumentPosition = (a, b, match) => {\n      return (a.compareDocumentPosition(b) & match) !== 0;\n    };\n    const documentPositionPreceding = (a, b) => {\n      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_PRECEDING);\n    };\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    var global = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n\n    const isSimpleBoundary = (dom, node) => dom.isBlock(node) || has(dom.schema.getVoidElements(), node.nodeName);\n    const isContentEditableFalse = (dom, node) => !dom.isEditable(node);\n    const isContentEditableTrueInCef = (dom, node) => dom.getContentEditable(node) === 'true' && node.parentNode && !dom.isEditable(node.parentNode);\n    const isHidden = (dom, node) => !dom.isBlock(node) && has(dom.schema.getWhitespaceElements(), node.nodeName);\n    const isBoundary = (dom, node) => isSimpleBoundary(dom, node) || isContentEditableFalse(dom, node) || isHidden(dom, node) || isContentEditableTrueInCef(dom, node);\n    const isText = node => node.nodeType === 3;\n    const nuSection = () => ({\n      sOffset: 0,\n      fOffset: 0,\n      elements: []\n    });\n    const toLeaf = (node, offset) => leaf(SugarElement.fromDom(node), offset);\n    const walk = (dom, walkerFn, startNode, callbacks, endNode, skipStart = true) => {\n      let next = skipStart ? walkerFn(false) : startNode;\n      while (next) {\n        const isCefNode = isContentEditableFalse(dom, next);\n        if (isCefNode || isHidden(dom, next)) {\n          const stopWalking = isCefNode ? callbacks.cef(next) : callbacks.boundary(next);\n          if (stopWalking) {\n            break;\n          } else {\n            next = walkerFn(true);\n            continue;\n          }\n        } else if (isSimpleBoundary(dom, next)) {\n          if (callbacks.boundary(next)) {\n            break;\n          }\n        } else if (isText(next)) {\n          callbacks.text(next);\n        }\n        if (next === endNode) {\n          break;\n        } else {\n          next = walkerFn(false);\n        }\n      }\n    };\n    const collectTextToBoundary = (dom, section, node, rootNode, forwards) => {\n      var _a;\n      if (isBoundary(dom, node)) {\n        return;\n      }\n      const rootBlock = (_a = dom.getParent(rootNode, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      const walker = new global(node, rootBlock);\n      const walkerFn = forwards ? walker.next.bind(walker) : walker.prev.bind(walker);\n      walk(dom, walkerFn, node, {\n        boundary: always,\n        cef: always,\n        text: next => {\n          if (forwards) {\n            section.fOffset += next.length;\n          } else {\n            section.sOffset += next.length;\n          }\n          section.elements.push(SugarElement.fromDom(next));\n        }\n      });\n    };\n    const collect = (dom, rootNode, startNode, endNode, callbacks, skipStart = true) => {\n      const walker = new global(startNode, rootNode);\n      const sections = [];\n      let current = nuSection();\n      collectTextToBoundary(dom, current, startNode, rootNode, false);\n      const finishSection = () => {\n        if (current.elements.length > 0) {\n          sections.push(current);\n          current = nuSection();\n        }\n        return false;\n      };\n      walk(dom, walker.next.bind(walker), startNode, {\n        boundary: finishSection,\n        cef: node => {\n          finishSection();\n          if (callbacks) {\n            sections.push(...callbacks.cef(node));\n          }\n          return false;\n        },\n        text: next => {\n          current.elements.push(SugarElement.fromDom(next));\n          if (callbacks) {\n            callbacks.text(next, current);\n          }\n        }\n      }, endNode, skipStart);\n      if (endNode) {\n        collectTextToBoundary(dom, current, endNode, rootNode, true);\n      }\n      finishSection();\n      return sections;\n    };\n    const collectRangeSections = (dom, rng) => {\n      const start = toLeaf(rng.startContainer, rng.startOffset);\n      const startNode = start.element.dom;\n      const end = toLeaf(rng.endContainer, rng.endOffset);\n      const endNode = end.element.dom;\n      return collect(dom, rng.commonAncestorContainer, startNode, endNode, {\n        text: (node, section) => {\n          if (node === endNode) {\n            section.fOffset += node.length - end.offset;\n          } else if (node === startNode) {\n            section.sOffset += start.offset;\n          }\n        },\n        cef: node => {\n          const sections = bind(descendants(SugarElement.fromDom(node), '*[contenteditable=true]'), e => {\n            const ceTrueNode = e.dom;\n            return collect(dom, ceTrueNode, ceTrueNode);\n          });\n          return sort(sections, (a, b) => documentPositionPreceding(a.elements[0].dom, b.elements[0].dom) ? 1 : -1);\n        }\n      }, false);\n    };\n    const fromRng = (dom, rng) => rng.collapsed ? [] : collectRangeSections(dom, rng);\n    const fromNode = (dom, node) => {\n      const rng = dom.createRng();\n      rng.selectNode(node);\n      return fromRng(dom, rng);\n    };\n    const fromNodes = (dom, nodes) => bind(nodes, node => fromNode(dom, node));\n\n    const find$2 = (text, pattern, start = 0, finish = text.length) => {\n      const regex = pattern.regex;\n      regex.lastIndex = start;\n      const results = [];\n      let match;\n      while (match = regex.exec(text)) {\n        const matchedText = match[pattern.matchIndex];\n        const matchStart = match.index + match[0].indexOf(matchedText);\n        const matchFinish = matchStart + matchedText.length;\n        if (matchFinish > finish) {\n          break;\n        }\n        results.push({\n          start: matchStart,\n          finish: matchFinish\n        });\n        regex.lastIndex = matchFinish;\n      }\n      return results;\n    };\n    const extract = (elements, matches) => {\n      const nodePositions = foldl(elements, (acc, element) => {\n        const content = get$1(element);\n        const start = acc.last;\n        const finish = start + content.length;\n        const positions = bind(matches, (match, matchIdx) => {\n          if (match.start < finish && match.finish > start) {\n            return [{\n                element,\n                start: Math.max(start, match.start) - start,\n                finish: Math.min(finish, match.finish) - start,\n                matchId: matchIdx\n              }];\n          } else {\n            return [];\n          }\n        });\n        return {\n          results: acc.results.concat(positions),\n          last: finish\n        };\n      }, {\n        results: [],\n        last: 0\n      }).results;\n      return groupBy(nodePositions, position => position.matchId);\n    };\n\n    const find$1 = (pattern, sections) => bind(sections, section => {\n      const elements = section.elements;\n      const content = map(elements, get$1).join('');\n      const positions = find$2(content, pattern, section.sOffset, content.length - section.fOffset);\n      return extract(elements, positions);\n    });\n    const mark = (matches, replacementNode) => {\n      eachr(matches, (match, idx) => {\n        eachr(match, pos => {\n          const wrapper = SugarElement.fromDom(replacementNode.cloneNode(false));\n          set(wrapper, 'data-mce-index', idx);\n          const textNode = pos.element.dom;\n          if (textNode.length === pos.finish && pos.start === 0) {\n            wrap(pos.element, wrapper);\n          } else {\n            if (textNode.length !== pos.finish) {\n              textNode.splitText(pos.finish);\n            }\n            const matchNode = textNode.splitText(pos.start);\n            wrap(SugarElement.fromDom(matchNode), wrapper);\n          }\n        });\n      });\n    };\n    const findAndMark = (dom, pattern, node, replacementNode) => {\n      const textSections = fromNode(dom, node);\n      const matches = find$1(pattern, textSections);\n      mark(matches, replacementNode);\n      return matches.length;\n    };\n    const findAndMarkInSelection = (dom, pattern, selection, replacementNode) => {\n      const bookmark = selection.getBookmark();\n      const nodes = dom.select('td[data-mce-selected],th[data-mce-selected]');\n      const textSections = nodes.length > 0 ? fromNodes(dom, nodes) : fromRng(dom, selection.getRng());\n      const matches = find$1(pattern, textSections);\n      mark(matches, replacementNode);\n      selection.moveToBookmark(bookmark);\n      return matches.length;\n    };\n\n    const getElmIndex = elm => {\n      return elm.getAttribute('data-mce-index');\n    };\n    const markAllMatches = (editor, currentSearchState, pattern, inSelection) => {\n      const marker = editor.dom.create('span', { 'data-mce-bogus': 1 });\n      marker.className = 'mce-match-marker';\n      const node = editor.getBody();\n      done(editor, currentSearchState, false);\n      if (inSelection) {\n        return findAndMarkInSelection(editor.dom, pattern, editor.selection, marker);\n      } else {\n        return findAndMark(editor.dom, pattern, node, marker);\n      }\n    };\n    const unwrap = node => {\n      var _a;\n      const parentNode = node.parentNode;\n      if (node.firstChild) {\n        parentNode.insertBefore(node.firstChild, node);\n      }\n      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);\n    };\n    const findSpansByIndex = (editor, index) => {\n      const spans = [];\n      const nodes = global$1.toArray(editor.getBody().getElementsByTagName('span'));\n      if (nodes.length) {\n        for (let i = 0; i < nodes.length; i++) {\n          const nodeIndex = getElmIndex(nodes[i]);\n          if (nodeIndex === null || !nodeIndex.length) {\n            continue;\n          }\n          if (nodeIndex === index.toString()) {\n            spans.push(nodes[i]);\n          }\n        }\n      }\n      return spans;\n    };\n    const moveSelection = (editor, currentSearchState, forward) => {\n      const searchState = currentSearchState.get();\n      let testIndex = searchState.index;\n      const dom = editor.dom;\n      if (forward) {\n        if (testIndex + 1 === searchState.count) {\n          testIndex = 0;\n        } else {\n          testIndex++;\n        }\n      } else {\n        if (testIndex - 1 === -1) {\n          testIndex = searchState.count - 1;\n        } else {\n          testIndex--;\n        }\n      }\n      dom.removeClass(findSpansByIndex(editor, searchState.index), 'mce-match-marker-selected');\n      const spans = findSpansByIndex(editor, testIndex);\n      if (spans.length) {\n        dom.addClass(findSpansByIndex(editor, testIndex), 'mce-match-marker-selected');\n        editor.selection.scrollIntoView(spans[0]);\n        return testIndex;\n      }\n      return -1;\n    };\n    const removeNode = (dom, node) => {\n      const parent = node.parentNode;\n      dom.remove(node);\n      if (parent && dom.isEmpty(parent)) {\n        dom.remove(parent);\n      }\n    };\n    const escapeSearchText = (text, wholeWord) => {\n      const escapedText = text.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&').replace(/\\s/g, '[^\\\\S\\\\r\\\\n\\\\uFEFF]');\n      const wordRegex = '(' + escapedText + ')';\n      return wholeWord ? `(?:^|\\\\s|${ punctuation() })` + wordRegex + `(?=$|\\\\s|${ punctuation() })` : wordRegex;\n    };\n    const find = (editor, currentSearchState, text, matchCase, wholeWord, inSelection) => {\n      const selection = editor.selection;\n      const escapedText = escapeSearchText(text, wholeWord);\n      const isForwardSelection = selection.isForward();\n      const pattern = {\n        regex: new RegExp(escapedText, matchCase ? 'g' : 'gi'),\n        matchIndex: 1\n      };\n      const count = markAllMatches(editor, currentSearchState, pattern, inSelection);\n      if (global$2.browser.isSafari()) {\n        selection.setRng(selection.getRng(), isForwardSelection);\n      }\n      if (count) {\n        const newIndex = moveSelection(editor, currentSearchState, true);\n        currentSearchState.set({\n          index: newIndex,\n          count,\n          text,\n          matchCase,\n          wholeWord,\n          inSelection\n        });\n      }\n      return count;\n    };\n    const next = (editor, currentSearchState) => {\n      const index = moveSelection(editor, currentSearchState, true);\n      currentSearchState.set({\n        ...currentSearchState.get(),\n        index\n      });\n    };\n    const prev = (editor, currentSearchState) => {\n      const index = moveSelection(editor, currentSearchState, false);\n      currentSearchState.set({\n        ...currentSearchState.get(),\n        index\n      });\n    };\n    const isMatchSpan = node => {\n      const matchIndex = getElmIndex(node);\n      return matchIndex !== null && matchIndex.length > 0;\n    };\n    const replace = (editor, currentSearchState, text, forward, all) => {\n      const searchState = currentSearchState.get();\n      const currentIndex = searchState.index;\n      let currentMatchIndex, nextIndex = currentIndex;\n      forward = forward !== false;\n      const node = editor.getBody();\n      const nodes = global$1.grep(global$1.toArray(node.getElementsByTagName('span')), isMatchSpan);\n      for (let i = 0; i < nodes.length; i++) {\n        const nodeIndex = getElmIndex(nodes[i]);\n        let matchIndex = currentMatchIndex = parseInt(nodeIndex, 10);\n        if (all || matchIndex === searchState.index) {\n          if (text.length) {\n            nodes[i].innerText = text;\n            unwrap(nodes[i]);\n          } else {\n            removeNode(editor.dom, nodes[i]);\n          }\n          while (nodes[++i]) {\n            matchIndex = parseInt(getElmIndex(nodes[i]), 10);\n            if (matchIndex === currentMatchIndex) {\n              removeNode(editor.dom, nodes[i]);\n            } else {\n              i--;\n              break;\n            }\n          }\n          if (forward) {\n            nextIndex--;\n          }\n        } else if (currentMatchIndex > currentIndex) {\n          nodes[i].setAttribute('data-mce-index', String(currentMatchIndex - 1));\n        }\n      }\n      currentSearchState.set({\n        ...searchState,\n        count: all ? 0 : searchState.count - 1,\n        index: nextIndex\n      });\n      if (forward) {\n        next(editor, currentSearchState);\n      } else {\n        prev(editor, currentSearchState);\n      }\n      return !all && currentSearchState.get().count > 0;\n    };\n    const done = (editor, currentSearchState, keepEditorSelection) => {\n      let startContainer;\n      let endContainer;\n      const searchState = currentSearchState.get();\n      const nodes = global$1.toArray(editor.getBody().getElementsByTagName('span'));\n      for (let i = 0; i < nodes.length; i++) {\n        const nodeIndex = getElmIndex(nodes[i]);\n        if (nodeIndex !== null && nodeIndex.length) {\n          if (nodeIndex === searchState.index.toString()) {\n            if (!startContainer) {\n              startContainer = nodes[i].firstChild;\n            }\n            endContainer = nodes[i].firstChild;\n          }\n          unwrap(nodes[i]);\n        }\n      }\n      currentSearchState.set({\n        ...searchState,\n        index: -1,\n        count: 0,\n        text: ''\n      });\n      if (startContainer && endContainer) {\n        const rng = editor.dom.createRng();\n        rng.setStart(startContainer, 0);\n        rng.setEnd(endContainer, endContainer.data.length);\n        if (keepEditorSelection !== false) {\n          editor.selection.setRng(rng);\n        }\n        return rng;\n      } else {\n        return undefined;\n      }\n    };\n    const hasNext = (editor, currentSearchState) => currentSearchState.get().count > 1;\n    const hasPrev = (editor, currentSearchState) => currentSearchState.get().count > 1;\n\n    const get = (editor, currentState) => {\n      const done$1 = keepEditorSelection => {\n        return done(editor, currentState, keepEditorSelection);\n      };\n      const find$1 = (text, matchCase, wholeWord, inSelection = false) => {\n        return find(editor, currentState, text, matchCase, wholeWord, inSelection);\n      };\n      const next$1 = () => {\n        return next(editor, currentState);\n      };\n      const prev$1 = () => {\n        return prev(editor, currentState);\n      };\n      const replace$1 = (text, forward, all) => {\n        return replace(editor, currentState, text, forward, all);\n      };\n      return {\n        done: done$1,\n        find: find$1,\n        next: next$1,\n        prev: prev$1,\n        replace: replace$1\n      };\n    };\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const open = (editor, currentSearchState) => {\n      const dialogApi = value();\n      editor.undoManager.add();\n      const selectedText = global$1.trim(editor.selection.getContent({ format: 'text' }));\n      const updateButtonStates = api => {\n        api.setEnabled('next', hasNext(editor, currentSearchState));\n        api.setEnabled('prev', hasPrev(editor, currentSearchState));\n      };\n      const updateSearchState = api => {\n        const data = api.getData();\n        const current = currentSearchState.get();\n        currentSearchState.set({\n          ...current,\n          matchCase: data.matchcase,\n          wholeWord: data.wholewords,\n          inSelection: data.inselection\n        });\n      };\n      const disableAll = (api, disable) => {\n        const buttons = [\n          'replace',\n          'replaceall',\n          'prev',\n          'next'\n        ];\n        const toggle = name => api.setEnabled(name, !disable);\n        each(buttons, toggle);\n      };\n      const toggleNotFoundAlert = (isVisible, api) => {\n        api.redial(getDialogSpec(isVisible, api.getData()));\n      };\n      const focusButtonIfRequired = (api, name) => {\n        if (global$2.browser.isSafari() && global$2.deviceType.isTouch() && (name === 'find' || name === 'replace' || name === 'replaceall')) {\n          api.focus(name);\n        }\n      };\n      const reset = api => {\n        done(editor, currentSearchState, false);\n        disableAll(api, true);\n        updateButtonStates(api);\n      };\n      const doFind = api => {\n        const data = api.getData();\n        const last = currentSearchState.get();\n        if (!data.findtext.length) {\n          reset(api);\n          return;\n        }\n        if (last.text === data.findtext && last.matchCase === data.matchcase && last.wholeWord === data.wholewords) {\n          next(editor, currentSearchState);\n        } else {\n          const count = find(editor, currentSearchState, data.findtext, data.matchcase, data.wholewords, data.inselection);\n          if (count <= 0) {\n            toggleNotFoundAlert(true, api);\n          }\n          disableAll(api, count === 0);\n        }\n        updateButtonStates(api);\n      };\n      const initialState = currentSearchState.get();\n      const initialData = {\n        findtext: selectedText,\n        replacetext: '',\n        wholewords: initialState.wholeWord,\n        matchcase: initialState.matchCase,\n        inselection: initialState.inSelection\n      };\n      const getPanelItems = error => {\n        const items = [\n          {\n            type: 'bar',\n            items: [\n              {\n                type: 'input',\n                name: 'findtext',\n                placeholder: 'Find',\n                maximized: true,\n                inputMode: 'search'\n              },\n              {\n                type: 'button',\n                name: 'prev',\n                text: 'Previous',\n                icon: 'action-prev',\n                enabled: false,\n                borderless: true\n              },\n              {\n                type: 'button',\n                name: 'next',\n                text: 'Next',\n                icon: 'action-next',\n                enabled: false,\n                borderless: true\n              }\n            ]\n          },\n          {\n            type: 'input',\n            name: 'replacetext',\n            placeholder: 'Replace with',\n            inputMode: 'search'\n          }\n        ];\n        if (error) {\n          items.push({\n            type: 'alertbanner',\n            level: 'error',\n            text: 'Could not find the specified string.',\n            icon: 'warning'\n          });\n        }\n        return items;\n      };\n      const getDialogSpec = (showNoMatchesAlertBanner, initialData) => ({\n        title: 'Find and Replace',\n        size: 'normal',\n        body: {\n          type: 'panel',\n          items: getPanelItems(showNoMatchesAlertBanner)\n        },\n        buttons: [\n          {\n            type: 'menu',\n            name: 'options',\n            icon: 'preferences',\n            tooltip: 'Preferences',\n            align: 'start',\n            items: [\n              {\n                type: 'togglemenuitem',\n                name: 'matchcase',\n                text: 'Match case'\n              },\n              {\n                type: 'togglemenuitem',\n                name: 'wholewords',\n                text: 'Find whole words only'\n              },\n              {\n                type: 'togglemenuitem',\n                name: 'inselection',\n                text: 'Find in selection'\n              }\n            ]\n          },\n          {\n            type: 'custom',\n            name: 'find',\n            text: 'Find',\n            primary: true\n          },\n          {\n            type: 'custom',\n            name: 'replace',\n            text: 'Replace',\n            enabled: false\n          },\n          {\n            type: 'custom',\n            name: 'replaceall',\n            text: 'Replace all',\n            enabled: false\n          }\n        ],\n        initialData,\n        onChange: (api, details) => {\n          if (showNoMatchesAlertBanner) {\n            toggleNotFoundAlert(false, api);\n          }\n          if (details.name === 'findtext' && currentSearchState.get().count > 0) {\n            reset(api);\n          }\n        },\n        onAction: (api, details) => {\n          const data = api.getData();\n          switch (details.name) {\n          case 'find':\n            doFind(api);\n            break;\n          case 'replace':\n            if (!replace(editor, currentSearchState, data.replacetext)) {\n              reset(api);\n            } else {\n              updateButtonStates(api);\n            }\n            break;\n          case 'replaceall':\n            replace(editor, currentSearchState, data.replacetext, true, true);\n            reset(api);\n            break;\n          case 'prev':\n            prev(editor, currentSearchState);\n            updateButtonStates(api);\n            break;\n          case 'next':\n            next(editor, currentSearchState);\n            updateButtonStates(api);\n            break;\n          case 'matchcase':\n          case 'wholewords':\n          case 'inselection':\n            toggleNotFoundAlert(false, api);\n            updateSearchState(api);\n            reset(api);\n            break;\n          }\n          focusButtonIfRequired(api, details.name);\n        },\n        onSubmit: api => {\n          doFind(api);\n          focusButtonIfRequired(api, 'find');\n        },\n        onClose: () => {\n          editor.focus();\n          done(editor, currentSearchState);\n          editor.undoManager.add();\n        }\n      });\n      dialogApi.set(editor.windowManager.open(getDialogSpec(false, initialData), { inline: 'toolbar' }));\n    };\n\n    const register$1 = (editor, currentSearchState) => {\n      editor.addCommand('SearchReplace', () => {\n        open(editor, currentSearchState);\n      });\n    };\n\n    const showDialog = (editor, currentSearchState) => () => {\n      open(editor, currentSearchState);\n    };\n    const register = (editor, currentSearchState) => {\n      editor.ui.registry.addMenuItem('searchreplace', {\n        text: 'Find and replace...',\n        shortcut: 'Meta+F',\n        onAction: showDialog(editor, currentSearchState),\n        icon: 'search'\n      });\n      editor.ui.registry.addButton('searchreplace', {\n        tooltip: 'Find and replace',\n        onAction: showDialog(editor, currentSearchState),\n        icon: 'search'\n      });\n      editor.shortcuts.add('Meta+F', '', showDialog(editor, currentSearchState));\n    };\n\n    var Plugin = () => {\n      global$3.add('searchreplace', editor => {\n        const currentSearchState = Cell({\n          index: -1,\n          count: 0,\n          text: '',\n          matchCase: false,\n          wholeWord: false,\n          inSelection: false\n        });\n        register$1(editor, currentSearchState);\n        register(editor, currentSearchState);\n        return get(editor, currentSearchState);\n      });\n    };\n\n    Plugin();\n\n})();\n"],"names":["Cell","initial","value","v","global$3","hasProto","constructor","predicate","_a","typeOf","x","o","proto","isType$1","type","isSimpleType","isString","isArray","isBoolean","isNullable","a","isNonNullable","isNumber","noop","constant","always","punctuation$1","Optional","tag","onNone","onSome","mapper","binder","replacement","thunk","message","worker","punctuation","global$2","global$1","nativeSlice","nativePush","map","xs","f","len","r","i","each","eachr","groupBy","wasType","group","foldl","acc","flatten","bind","sort","comparator","copy","hasOwnProperty","has","obj","key","DOCUMENT","DOCUMENT_FRAGMENT","ELEMENT","TEXT","element","isText$1","t","rawSet","dom","set","fromHtml","html","scope","div","fromDom","fromTag","node","fromText","text","SugarElement","docElm","y","bypassSelector","all","selector","base","parent","children","spot","offset","leaf","cs","before","marker","append","wrap","wrapper","api","is","name","get","getOption","get$1","compareDocumentPosition","b","match","documentPositionPreceding","descendants","global","isSimpleBoundary","isContentEditableFalse","isContentEditableTrueInCef","isHidden","isBoundary","isText","nuSection","toLeaf","walk","walkerFn","startNode","callbacks","endNode","skipStart","next","isCefNode","collectTextToBoundary","section","rootNode","forwards","rootBlock","walker","collect","sections","current","finishSection","collectRangeSections","rng","start","end","e","ceTrueNode","fromRng","fromNode","fromNodes","nodes","find$2","pattern","finish","regex","results","matchedText","matchStart","matchFinish","extract","elements","matches","nodePositions","content","positions","matchIdx","position","find$1","mark","replacementNode","idx","pos","textNode","matchNode","findAndMark","textSections","findAndMarkInSelection","selection","bookmark","getElmIndex","elm","markAllMatches","editor","currentSearchState","inSelection","done","unwrap","parentNode","findSpansByIndex","index","spans","nodeIndex","moveSelection","forward","searchState","testIndex","removeNode","escapeSearchText","wholeWord","wordRegex","find","matchCase","escapedText","isForwardSelection","count","newIndex","prev","isMatchSpan","matchIndex","replace","currentIndex","currentMatchIndex","nextIndex","keepEditorSelection","startContainer","endContainer","hasNext","hasPrev","currentState","singleton","doRevoke","subject","revoke","s","open","dialogApi","selectedText","updateButtonStates","updateSearchState","data","disableAll","disable","toggleNotFoundAlert","isVisible","getDialogSpec","focusButtonIfRequired","reset","doFind","last","initialState","initialData","getPanelItems","error","items","showNoMatchesAlertBanner","details","register$1","showDialog","register","Plugin"],"mappings":"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","x_google_ignoreList":[0]}