{"version":3,"file":"tinymce-nDjp5WLG.js","sources":["../node_modules/.pnpm/tinymce@6.8.6/node_modules/tinymce/tinymce.js"],"sourcesContent":["/**\n * TinyMCE version 6.8.6 (TBD)\n */\n\n(function () {\n    'use strict';\n\n    var typeOf$1 = function (x) {\n      if (x === null) {\n        return 'null';\n      }\n      if (x === undefined) {\n        return 'undefined';\n      }\n      var t = typeof x;\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n        return 'array';\n      }\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n        return 'string';\n      }\n      return t;\n    };\n    var isEquatableType = function (x) {\n      return [\n        'undefined',\n        'boolean',\n        'number',\n        'string',\n        'function',\n        'xml',\n        'null'\n      ].indexOf(x) !== -1;\n    };\n\n    var sort$1 = function (xs, compareFn) {\n      var clone = Array.prototype.slice.call(xs);\n      return clone.sort(compareFn);\n    };\n\n    var contramap = function (eqa, f) {\n      return eq$2(function (x, y) {\n        return eqa.eq(f(x), f(y));\n      });\n    };\n    var eq$2 = function (f) {\n      return { eq: f };\n    };\n    var tripleEq = eq$2(function (x, y) {\n      return x === y;\n    });\n    var eqString = tripleEq;\n    var eqArray = function (eqa) {\n      return eq$2(function (x, y) {\n        if (x.length !== y.length) {\n          return false;\n        }\n        var len = x.length;\n        for (var i = 0; i < len; i++) {\n          if (!eqa.eq(x[i], y[i])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqSortedArray = function (eqa, compareFn) {\n      return contramap(eqArray(eqa), function (xs) {\n        return sort$1(xs, compareFn);\n      });\n    };\n    var eqRecord = function (eqa) {\n      return eq$2(function (x, y) {\n        var kx = Object.keys(x);\n        var ky = Object.keys(y);\n        if (!eqSortedArray(eqString).eq(kx, ky)) {\n          return false;\n        }\n        var len = kx.length;\n        for (var i = 0; i < len; i++) {\n          var q = kx[i];\n          if (!eqa.eq(x[q], y[q])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqAny = eq$2(function (x, y) {\n      if (x === y) {\n        return true;\n      }\n      var tx = typeOf$1(x);\n      var ty = typeOf$1(y);\n      if (tx !== ty) {\n        return false;\n      }\n      if (isEquatableType(tx)) {\n        return x === y;\n      } else if (tx === 'array') {\n        return eqArray(eqAny).eq(x, y);\n      } else if (tx === 'object') {\n        return eqRecord(eqAny).eq(x, y);\n      }\n      return false;\n    });\n\n    const getPrototypeOf$2 = Object.getPrototypeOf;\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$1 = t => a => t === a;\n    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isPlainObject = value => is$4(value, Object);\n    const isArray$1 = isType$1('array');\n    const isNull = eq$1(null);\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$1(undefined);\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n    const isArrayOf = (value, pred) => {\n      if (isArray$1(value)) {\n        for (let i = 0, len = value.length; i < len; ++i) {\n          if (!pred(value[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n\n    const noop = () => {\n    };\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply$1 = f => {\n      return f();\n    };\n    const call = f => {\n      f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const indexOf$1 = (xs, x) => {\n      const r = rawIndexOf(xs, x);\n      return r === -1 ? Optional.none() : Optional.some(r);\n    };\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const map$3 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$e = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition$2 = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$5 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$e(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil$1 = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$2 = (xs, pred) => {\n      return findUntil$1(xs, pred, never);\n    };\n    const findIndex$2 = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray$1(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$3 = (xs, f) => flatten(map$3(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const difference = (a1, a2) => filter$5(a1, x => !contains$2(a2, x));\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const sort = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$b(xs, 0);\n    const last$3 = xs => get$b(xs, xs.length - 1);\n    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n    const unique$1 = (xs, comparator) => {\n      const r = [];\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (!isDuplicated(x)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty$1 = Object.hasOwnProperty;\n    const each$d = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map$2 = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each$d(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each$d(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const bifilter = (obj, pred) => {\n      const t = {};\n      const f = {};\n      internalFilter(obj, pred, objAcc(t), objAcc(f));\n      return {\n        t,\n        f\n      };\n    };\n    const filter$4 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each$d(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$a = (obj, key) => {\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);\n\n    const stringArray = a => {\n      const all = {};\n      each$e(a, key => {\n        all[key] = {};\n      });\n      return keys(all);\n    };\n\n    const isArrayLike = o => o.length !== undefined;\n    const isArray = Array.isArray;\n    const toArray$1 = obj => {\n      if (!isArray(obj)) {\n        const array = [];\n        for (let i = 0, l = obj.length; i < l; i++) {\n          array[i] = obj[i];\n        }\n        return array;\n      } else {\n        return obj;\n      }\n    };\n    const each$c = (o, cb, s) => {\n      if (!o) {\n        return false;\n      }\n      s = s || o;\n      if (isArrayLike(o)) {\n        for (let n = 0, l = o.length; n < l; n++) {\n          if (cb.call(s, o[n], n, o) === false) {\n            return false;\n          }\n        }\n      } else {\n        for (const n in o) {\n          if (has$2(o, n)) {\n            if (cb.call(s, o[n], n, o) === false) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const map$1 = (array, callback) => {\n      const out = [];\n      each$c(array, (item, index) => {\n        out.push(callback(item, index, array));\n      });\n      return out;\n    };\n    const filter$3 = (a, f) => {\n      const o = [];\n      each$c(a, (v, index) => {\n        if (!f || f(v, index, a)) {\n          o.push(v);\n        }\n      });\n      return o;\n    };\n    const indexOf = (a, v) => {\n      if (a) {\n        for (let i = 0, l = a.length; i < l; i++) {\n          if (a[i] === v) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const reduce = (collection, iteratee, accumulator, thisArg) => {\n      let acc = isUndefined(accumulator) ? collection[0] : accumulator;\n      for (let i = 0; i < collection.length; i++) {\n        acc = iteratee.call(thisArg, acc, collection[i], i);\n      }\n      return acc;\n    };\n    const findIndex$1 = (array, predicate, thisArg) => {\n      for (let i = 0, l = array.length; i < l; i++) {\n        if (predicate.call(thisArg, array[i], i, array)) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    const last$2 = collection => collection[collection.length - 1];\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant(isiPad),\n        isiPhone: constant(isiPhone),\n        isTablet: constant(isTablet),\n        isPhone: constant(isPhone),\n        isTouch: constant(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant(iOSwebview),\n        isDesktop: constant(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find$1 = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$3(group(1), group(2));\n    };\n    const detect$5 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$2();\n      }\n      return find$1(versionRegexes, cleanedAgent);\n    };\n    const unknown$2 = () => {\n      return nu$3(0, 0);\n    };\n    const nu$3 = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$3,\n      detect: detect$5,\n      unknown: unknown$2\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$2(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$4 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$2(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$4(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$4(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const removeFromStart = (str, numChars) => {\n      return str.substring(numChars);\n    };\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const removeLeading = (str, prefix) => {\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n    };\n    const contains$1 = (str, substr, start = 0, end) => {\n      const idx = str.indexOf(substr, start);\n      if (idx !== -1) {\n        return isUndefined(end) ? true : idx + substr.length <= end;\n      } else {\n        return false;\n      }\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim$4 = blank(/^\\s+|\\s+$/g);\n    const lTrim = blank(/^\\s+/g);\n    const rTrim = blank(/\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty$3 = s => !isNotEmpty(s);\n    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\n    const toInt = (value, radix = 10) => {\n      const num = parseInt(value, radix);\n      return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains$1(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant(browsers),\n      oses: constant(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$1 = () => {\n      return nu$2({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$2 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$1,\n      nu: nu$2,\n      edge: constant(edge),\n      chromium: constant(chromium),\n      ie: constant(ie),\n      opera: constant(opera),\n      firefox: constant(firefox),\n      safari: constant(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown = () => {\n      return nu$1({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$1 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown,\n      nu: nu$1,\n      windows: constant(windows),\n      ios: constant(ios),\n      android: constant(android),\n      linux: constant(linux),\n      macos: constant(macos),\n      solaris: constant(solaris),\n      freebsd: constant(freebsd),\n      chromeos: constant(chromeos)\n    };\n\n    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$3 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform$4 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n    const detect$2 = () => platform$4();\n\n    const userAgent = navigator.userAgent;\n    const platform$3 = detect$2();\n    const browser$3 = platform$3.browser;\n    const os$1 = platform$3.os;\n    const deviceType = platform$3.deviceType;\n    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\n    const Env = {\n      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n      documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,\n      cacheSuffix: null,\n      container: null,\n      canHaveCSP: !browser$3.isIE(),\n      windowsPhone,\n      browser: {\n        current: browser$3.current,\n        version: browser$3.version,\n        isChromium: browser$3.isChromium,\n        isEdge: browser$3.isEdge,\n        isFirefox: browser$3.isFirefox,\n        isIE: browser$3.isIE,\n        isOpera: browser$3.isOpera,\n        isSafari: browser$3.isSafari\n      },\n      os: {\n        current: os$1.current,\n        version: os$1.version,\n        isAndroid: os$1.isAndroid,\n        isChromeOS: os$1.isChromeOS,\n        isFreeBSD: os$1.isFreeBSD,\n        isiOS: os$1.isiOS,\n        isLinux: os$1.isLinux,\n        isMacOS: os$1.isMacOS,\n        isSolaris: os$1.isSolaris,\n        isWindows: os$1.isWindows\n      },\n      deviceType: {\n        isDesktop: deviceType.isDesktop,\n        isiPad: deviceType.isiPad,\n        isiPhone: deviceType.isiPhone,\n        isPhone: deviceType.isPhone,\n        isTablet: deviceType.isTablet,\n        isTouch: deviceType.isTouch,\n        isWebView: deviceType.isWebView\n      }\n    };\n\n    const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\n    const trim$3 = str => {\n      return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\n    };\n    const is$3 = (obj, type) => {\n      if (!type) {\n        return obj !== undefined;\n      }\n      if (type === 'array' && isArray(obj)) {\n        return true;\n      }\n      return typeof obj === type;\n    };\n    const makeMap$4 = (items, delim, map = {}) => {\n      const resolvedItems = isString(items) ? items.split(delim || ',') : items || [];\n      let i = resolvedItems.length;\n      while (i--) {\n        map[resolvedItems[i]] = {};\n      }\n      return map;\n    };\n    const hasOwnProperty = has$2;\n    const extend$3 = (obj, ...exts) => {\n      for (let i = 0; i < exts.length; i++) {\n        const ext = exts[i];\n        for (const name in ext) {\n          if (has$2(ext, name)) {\n            const value = ext[name];\n            if (value !== undefined) {\n              obj[name] = value;\n            }\n          }\n        }\n      }\n      return obj;\n    };\n    const walk$4 = function (o, f, n, s) {\n      s = s || this;\n      if (o) {\n        if (n) {\n          o = o[n];\n        }\n        each$c(o, (o, i) => {\n          if (f.call(s, o, i, n) === false) {\n            return false;\n          } else {\n            walk$4(o, f, n, s);\n            return true;\n          }\n        });\n      }\n    };\n    const resolve$3 = (n, o = window) => {\n      const path = n.split('.');\n      for (let i = 0, l = path.length; i < l; i++) {\n        o = o[path[i]];\n        if (!o) {\n          break;\n        }\n      }\n      return o;\n    };\n    const explode$3 = (s, d) => {\n      if (isArray$1(s)) {\n        return s;\n      } else if (s === '') {\n        return [];\n      } else {\n        return map$1(s.split(d || ','), trim$3);\n      }\n    };\n    const _addCacheSuffix = url => {\n      const cacheSuffix = Env.cacheSuffix;\n      if (cacheSuffix) {\n        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\n      }\n      return url;\n    };\n    const Tools = {\n      trim: trim$3,\n      isArray: isArray,\n      is: is$3,\n      toArray: toArray$1,\n      makeMap: makeMap$4,\n      each: each$c,\n      map: map$1,\n      grep: filter$3,\n      inArray: indexOf,\n      hasOwn: hasOwnProperty,\n      extend: extend$3,\n      walk: walk$4,\n      resolve: resolve$3,\n      explode: explode$3,\n      _addCacheSuffix\n    };\n\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const path = (parts, scope) => {\n      let o = scope !== undefined && scope !== null ? scope : Global;\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n        o = o[parts[i]];\n      }\n      return o;\n    };\n    const resolve$2 = (p, scope) => {\n      const parts = p.split('.');\n      return path(parts, scope);\n    };\n\n    const unsafe = (name, scope) => {\n      return resolve$2(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n      const actual = unsafe(name, scope);\n      if (actual === undefined || actual === null) {\n        throw new Error(name + ' not available on this browser');\n      }\n      return actual;\n    };\n\n    const getPrototypeOf$1 = Object.getPrototypeOf;\n    const sandHTMLElement = scope => {\n      return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = x => {\n      const scope = resolve$2('ownerDocument.defaultView', x);\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf$1(x).constructor.name));\n    };\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type$1 = element => element.dom.nodeType;\n    const isType = t => element => type$1(element) === t;\n    const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\n    const isHTMLElement$1 = element => isElement$7(element) && isPrototypeOf(element.dom);\n    const isElement$7 = isType(ELEMENT);\n    const isText$b = isType(TEXT);\n    const isDocument$2 = isType(DOCUMENT);\n    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement$7(e) && name(e) === tag;\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$3 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each$d(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const get$9 = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$9(element, key));\n    const has$1 = (element, key) => {\n      const dom = element.dom;\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n    };\n    const remove$a = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const hasNone = element => {\n      const attrs = element.dom.attributes;\n      return attrs === undefined || attrs === null || attrs.length === 0;\n    };\n    const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const read$4 = (element, attr) => {\n      const value = get$9(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$4 = (element, attr, id) => {\n      const old = read$4(element, attr);\n      const nu = old.concat([id]);\n      set$3(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$9 = (element, attr, id) => {\n      const nu = filter$5(read$4(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$3(element, attr, nu.join(' '));\n      } else {\n        remove$a(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$8 = element => read$4(element, 'class');\n    const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n    const remove$8 = (element, clazz) => remove$9(element, 'class', clazz);\n    const toggle$2 = (element, clazz) => {\n      if (contains$2(get$8(element), clazz)) {\n        return remove$8(element, clazz);\n      } else {\n        return add$3(element, clazz);\n      }\n    };\n\n    const add$2 = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$3(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$8(element);\n      if (classList.length === 0) {\n        remove$a(element, 'class');\n      }\n    };\n    const remove$7 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$8(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const toggle$1 = (element, clazz) => {\n      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\n      cleanClass(element);\n      return result;\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$2(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$2(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$2(node);\n    };\n    const fromDom$2 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\n    const SugarElement = {\n      fromHtml: fromHtml$1,\n      fromTag,\n      fromText,\n      fromDom: fromDom$2,\n      fromPoint: fromPoint$2\n    };\n\n    const toArray = (target, f) => {\n      const r = [];\n      const recurse = e => {\n        r.push(e);\n        return f(e);\n      };\n      let cur = f(target);\n      do {\n        cur = cur.bind(recurse);\n      } while (cur.isSome());\n      return r;\n    };\n\n    const is$1 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n\n    const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents$1 = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const siblings = element => {\n      const filterSelf = elements => filter$5(elements, x => !eq(element, x));\n      return parent(element).map(children$1).map(filterSelf).getOr([]);\n    };\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const prevSiblings = element => reverse(toArray(element, prevSibling));\n    const nextSiblings = element => toArray(element, nextSibling);\n    const children$1 = element => map$3(element.dom.childNodes, SugarElement.fromDom);\n    const child$1 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$1(element, 0);\n    const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\n    const childNodesCount = element => element.dom.childNodes.length;\n    const hasChildNodes = element => element.dom.hasChildNodes();\n\n    const getHead = doc => {\n      const b = doc.dom.head;\n      if (b === null || b === undefined) {\n        throw new Error('Head is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const isSupported$1 = constant(supported);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\n    const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isSupported$1() && isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement$7(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText$b(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$4 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$4 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);\n    };\n    const sibling$1 = (scope, predicate) => {\n      const element = scope.dom;\n      if (!element.parentNode) {\n        return Optional.none();\n      }\n      return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n    };\n    const child = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$2(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$2 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, e => is$1(e, selector), isRoot);\n    const descendant$1 = (scope, selector) => one(selector, scope);\n    const closest$3 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$1(element, selector);\n      return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);\n    };\n\n    const closest$2 = target => closest$3(target, '[contenteditable]');\n    const isEditable$2 = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest$2(element).fold(constant(assumeEditable), editable => getRaw$1(editable) === 'true');\n      }\n    };\n    const getRaw$1 = element => element.dom.contentEditable;\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$2 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each$d(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const get$7 = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const getAllRaw = element => {\n      const css = {};\n      const dom = element.dom;\n      if (isSupported(dom)) {\n        for (let i = 0; i < dom.style.length; i++) {\n          const ruleName = dom.style.item(i);\n          css[ruleName] = dom.style[ruleName];\n        }\n      }\n      return css;\n    };\n    const remove$6 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is$2(getOpt(element, 'style').map(trim$4), '')) {\n        remove$a(element, 'style');\n      }\n    };\n    const reflow = e => e.dom.offsetWidth;\n\n    const before$3 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$4 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const wrap$2 = (element, wrapper) => {\n      before$3(element, wrapper);\n      append$1(wrapper, element);\n    };\n\n    const after$3 = (marker, elements) => {\n      each$e(elements, (x, i) => {\n        const e = i === 0 ? marker : elements[i - 1];\n        after$4(e, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$e(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$e(children$1(element), rogue => {\n        remove$5(rogue);\n      });\n    };\n    const remove$5 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n    const unwrap = wrapper => {\n      const children = children$1(wrapper);\n      if (children.length > 0) {\n        after$3(wrapper, children);\n      }\n      remove$5(wrapper);\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children$1(SugarElement.fromDom(div));\n    };\n    const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\n\n    const get$6 = element => element.dom.innerHTML;\n    const set$1 = (element, content) => {\n      const owner = owner$1(element);\n      const docDom = owner.dom;\n      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n      const contentElements = fromHtml(content, docDom);\n      append(fragment, contentElements);\n      empty(element);\n      append$1(element, fragment);\n    };\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$1(container, clone);\n      return get$6(container);\n    };\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle$1 = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle$1(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const r = (left, top) => {\n      const translate = (x, y) => r(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const get$5 = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const to = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollTo(x, y);\n      }\n    };\n    const intoView = (element, alignToTop) => {\n      const isSafari = detect$2().browser.isSafari();\n      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\n        element.dom.scrollIntoViewIfNeeded(false);\n      } else {\n        element.dom.scrollIntoView(alignToTop);\n      }\n    };\n\n    const get$4 = _win => {\n      const win = _win === undefined ? window : _win;\n      if (detect$2().browser.isFirefox()) {\n        return Optional.none();\n      } else {\n        return Optional.from(win.visualViewport);\n      }\n    };\n    const bounds = (x, y, width, height) => ({\n      x,\n      y,\n      width,\n      height,\n      right: x + width,\n      bottom: y + height\n    });\n    const getBounds = _win => {\n      const win = _win === undefined ? window : _win;\n      const doc = win.document;\n      const scroll = get$5(SugarElement.fromDom(doc));\n      return get$4(win).fold(() => {\n        const html = win.document.documentElement;\n        const width = html.clientWidth;\n        const height = html.clientHeight;\n        return bounds(scroll.left, scroll.top, width, height);\n      }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n    };\n\n    const children = (scope, predicate) => filter$5(children$1(scope), predicate);\n    const descendants$1 = (scope, predicate) => {\n      let result = [];\n      each$e(children$1(scope), x => {\n        if (predicate(x)) {\n          result = result.concat([x]);\n        }\n        result = result.concat(descendants$1(x, predicate));\n      });\n      return result;\n    };\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();\n\n    class DomTreeWalker {\n      constructor(startNode, rootNode) {\n        this.node = startNode;\n        this.rootNode = rootNode;\n        this.current = this.current.bind(this);\n        this.next = this.next.bind(this);\n        this.prev = this.prev.bind(this);\n        this.prev2 = this.prev2.bind(this);\n      }\n      current() {\n        return this.node;\n      }\n      next(shallow) {\n        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\n        return this.node;\n      }\n      prev(shallow) {\n        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\n        return this.node;\n      }\n      prev2(shallow) {\n        this.node = this.findPreviousNode(this.node, shallow);\n        return this.node;\n      }\n      findSibling(node, startName, siblingName, shallow) {\n        if (node) {\n          if (!shallow && node[startName]) {\n            return node[startName];\n          }\n          if (node !== this.rootNode) {\n            let sibling = node[siblingName];\n            if (sibling) {\n              return sibling;\n            }\n            for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\n              sibling = parent[siblingName];\n              if (sibling) {\n                return sibling;\n              }\n            }\n          }\n        }\n        return undefined;\n      }\n      findPreviousNode(node, shallow) {\n        if (node) {\n          const sibling = node.previousSibling;\n          if (this.rootNode && sibling === this.rootNode) {\n            return;\n          }\n          if (sibling) {\n            if (!shallow) {\n              for (let child = sibling.lastChild; child; child = child.lastChild) {\n                if (!child.lastChild) {\n                  return child;\n                }\n              }\n            }\n            return sibling;\n          }\n          const parent = node.parentNode;\n          if (parent && parent !== this.rootNode) {\n            return parent;\n          }\n        }\n        return undefined;\n      }\n    }\n\n    const isNodeType = type => {\n      return node => {\n        return !!node && node.nodeType === type;\n      };\n    };\n    const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\n    const isElement$6 = isNodeType(1);\n    const isHTMLElement = node => isElement$6(node) && isHTMLElement$1(SugarElement.fromDom(node));\n    const isSVGElement = node => isElement$6(node) && node.namespaceURI === 'http://www.w3.org/2000/svg';\n    const matchNodeName = name => {\n      const lowerCasedName = name.toLowerCase();\n      return node => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;\n    };\n    const matchNodeNames = names => {\n      const lowerCasedNames = names.map(s => s.toLowerCase());\n      return node => {\n        if (node && node.nodeName) {\n          const nodeName = node.nodeName.toLowerCase();\n          return contains$2(lowerCasedNames, nodeName);\n        }\n        return false;\n      };\n    };\n    const matchStyleValues = (name, values) => {\n      const items = values.toLowerCase().split(' ');\n      return node => {\n        if (isElement$6(node)) {\n          const win = node.ownerDocument.defaultView;\n          if (win) {\n            for (let i = 0; i < items.length; i++) {\n              const computed = win.getComputedStyle(node, null);\n              const cssValue = computed ? computed.getPropertyValue(name) : null;\n              if (cssValue === items[i]) {\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      };\n    };\n    const hasAttribute = attrName => {\n      return node => {\n        return isElement$6(node) && node.hasAttribute(attrName);\n      };\n    };\n    const hasAttributeValue = (attrName, attrValue) => {\n      return node => {\n        return isElement$6(node) && node.getAttribute(attrName) === attrValue;\n      };\n    };\n    const isBogus$2 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\n    const isBogusAll$1 = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\n    const isTable$2 = node => isElement$6(node) && node.tagName === 'TABLE';\n    const hasContentEditableState = value => {\n      return node => {\n        if (isHTMLElement(node)) {\n          if (node.contentEditable === value) {\n            return true;\n          }\n          if (node.getAttribute('data-mce-contenteditable') === value) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const isTextareaOrInput = matchNodeNames([\n      'textarea',\n      'input'\n    ]);\n    const isText$a = isNodeType(3);\n    const isCData = isNodeType(4);\n    const isPi = isNodeType(7);\n    const isComment = isNodeType(8);\n    const isDocument$1 = isNodeType(9);\n    const isDocumentFragment = isNodeType(11);\n    const isBr$6 = matchNodeName('br');\n    const isImg = matchNodeName('img');\n    const isContentEditableTrue$3 = hasContentEditableState('true');\n    const isContentEditableFalse$b = hasContentEditableState('false');\n    const isTableCell$3 = matchNodeNames([\n      'td',\n      'th'\n    ]);\n    const isTableCellOrCaption = matchNodeNames([\n      'td',\n      'th',\n      'caption'\n    ]);\n    const isMedia$2 = matchNodeNames([\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isListItem$2 = matchNodeName('li');\n    const isDetails = matchNodeName('details');\n    const isSummary$1 = matchNodeName('summary');\n\n    const zeroWidth = '\\uFEFF';\n    const nbsp = '\\xA0';\n    const isZwsp$2 = char => char === zeroWidth;\n    const removeZwsp = s => s.replace(/\\uFEFF/g, '');\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api$1 = NodeValue(isText$b, 'text');\n    const get$3 = element => api$1.get(element);\n    const getOption = element => api$1.getOption(element);\n    const set = (element, value) => api$1.set(element, value);\n\n    const tableCells = [\n      'td',\n      'th'\n    ];\n    const tableSections = [\n      'thead',\n      'tbody',\n      'tfoot'\n    ];\n    const textBlocks = [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'p',\n      'div',\n      'address',\n      'pre',\n      'form',\n      'blockquote',\n      'center',\n      'dir',\n      'fieldset',\n      'header',\n      'footer',\n      'article',\n      'section',\n      'hgroup',\n      'aside',\n      'nav',\n      'figure'\n    ];\n    const listItems$1 = [\n      'li',\n      'dd',\n      'dt'\n    ];\n    const lists = [\n      'ul',\n      'ol',\n      'dl'\n    ];\n    const wsElements = [\n      'pre',\n      'script',\n      'textarea',\n      'style'\n    ];\n    const lazyLookup = items => {\n      let lookup;\n      return node => {\n        lookup = lookup ? lookup : mapToObject(items, always);\n        return has$2(lookup, name(node));\n      };\n    };\n    const isTable$1 = node => name(node) === 'table';\n    const isBr$5 = node => isElement$7(node) && name(node) === 'br';\n    const isTextBlock$2 = lazyLookup(textBlocks);\n    const isList = lazyLookup(lists);\n    const isListItem$1 = lazyLookup(listItems$1);\n    const isTableSection = lazyLookup(tableSections);\n    const isTableCell$2 = lazyLookup(tableCells);\n    const isWsPreserveElement = lazyLookup(wsElements);\n\n    const getLastChildren$1 = elm => {\n      const children = [];\n      let rawNode = elm.dom;\n      while (rawNode) {\n        children.push(SugarElement.fromDom(rawNode));\n        rawNode = rawNode.lastChild;\n      }\n      return children;\n    };\n    const removeTrailingBr = elm => {\n      const allBrs = descendants(elm, 'br');\n      const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);\n      if (allBrs.length === brs.length) {\n        each$e(brs, remove$5);\n      }\n    };\n    const createPaddingBr = () => {\n      const br = SugarElement.fromTag('br');\n      set$3(br, 'data-mce-bogus', '1');\n      return br;\n    };\n    const fillWithPaddingBr = elm => {\n      empty(elm);\n      append$1(elm, createPaddingBr());\n    };\n    const trimBlockTrailingBr = (elm, schema) => {\n      lastChild(elm).each(lastChild => {\n        prevSibling(lastChild).each(lastChildPrevSibling => {\n          if (schema.isBlock(name(elm)) && isBr$5(lastChild) && schema.isBlock(name(lastChildPrevSibling))) {\n            remove$5(lastChild);\n          }\n        });\n      });\n    };\n\n    const ZWSP$1 = zeroWidth;\n    const isZwsp$1 = isZwsp$2;\n    const trim$2 = removeZwsp;\n    const insert$5 = editor => editor.insertContent(ZWSP$1, { preserve_zwsp: true });\n\n    const isElement$5 = isElement$6;\n    const isText$9 = isText$a;\n    const isCaretContainerBlock$1 = node => {\n      if (isText$9(node)) {\n        node = node.parentNode;\n      }\n      return isElement$5(node) && node.hasAttribute('data-mce-caret');\n    };\n    const isCaretContainerInline = node => isText$9(node) && isZwsp$1(node.data);\n    const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\n    const hasContent = node => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);\n    const insertInline$1 = (node, before) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const textNode = doc.createTextNode(ZWSP$1);\n      const parentNode = node.parentNode;\n      if (!before) {\n        const sibling = node.nextSibling;\n        if (isText$9(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (startsWithCaretContainer$1(sibling)) {\n            sibling.splitText(1);\n            return sibling;\n          }\n        }\n        if (node.nextSibling) {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);\n        } else {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);\n        }\n      } else {\n        const sibling = node.previousSibling;\n        if (isText$9(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (endsWithCaretContainer$1(sibling)) {\n            return sibling.splitText(sibling.data.length - 1);\n          }\n        }\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);\n      }\n      return textNode;\n    };\n    const isBeforeInline = pos => {\n      const container = pos.container();\n      if (!isText$a(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\n    };\n    const isAfterInline = pos => {\n      const container = pos.container();\n      if (!isText$a(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\n    };\n    const insertBlock = (blockName, node, before) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const blockNode = doc.createElement(blockName);\n      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\n      blockNode.setAttribute('data-mce-bogus', 'all');\n      blockNode.appendChild(createPaddingBr().dom);\n      const parentNode = node.parentNode;\n      if (!before) {\n        if (node.nextSibling) {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);\n        } else {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);\n        }\n      } else {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);\n      }\n      return blockNode;\n    };\n    const startsWithCaretContainer$1 = node => isText$9(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer$1 = node => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const trimBogusBr = elm => {\n      var _a;\n      const brs = elm.getElementsByTagName('br');\n      const lastBr = brs[brs.length - 1];\n      if (isBogus$2(lastBr)) {\n        (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);\n      }\n    };\n    const showCaretContainerBlock = caretContainer => {\n      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\n        trimBogusBr(caretContainer);\n        caretContainer.removeAttribute('data-mce-caret');\n        caretContainer.removeAttribute('data-mce-bogus');\n        caretContainer.removeAttribute('style');\n        caretContainer.removeAttribute('data-mce-style');\n        caretContainer.removeAttribute('_moz_abspos');\n        return caretContainer;\n      }\n      return null;\n    };\n    const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\n\n    const isContentEditableTrue$2 = isContentEditableTrue$3;\n    const isContentEditableFalse$a = isContentEditableFalse$b;\n    const isBr$4 = isBr$6;\n    const isText$8 = isText$a;\n    const isInvalidTextElement = matchNodeNames([\n      'script',\n      'style',\n      'textarea'\n    ]);\n    const isAtomicInline = matchNodeNames([\n      'img',\n      'input',\n      'textarea',\n      'hr',\n      'iframe',\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isTable = matchNodeNames(['table']);\n    const isCaretContainer$1 = isCaretContainer$2;\n    const isCaretCandidate$3 = node => {\n      if (isCaretContainer$1(node)) {\n        return false;\n      }\n      if (isText$8(node)) {\n        return !isInvalidTextElement(node.parentNode);\n      }\n      return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);\n    };\n    const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\n    const isNonUiContentEditableFalse = node => !isUnselectable(node) && isContentEditableFalse$a(node);\n    const isInEditable = (node, root) => {\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        if (isNonUiContentEditableFalse(tempNode)) {\n          return false;\n        }\n        if (isContentEditableTrue$2(tempNode)) {\n          return true;\n        }\n      }\n      return true;\n    };\n    const isAtomicContentEditableFalse = node => {\n      if (!isNonUiContentEditableFalse(node)) {\n        return false;\n      }\n      return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {\n        return result || isContentEditableTrue$2(elm);\n      }, false);\n    };\n    const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\n    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\n\n    const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n    const isWhitespaceText = text => whiteSpaceRegExp.test(text);\n    const isZwsp = text => {\n      for (const c of text) {\n        if (!isZwsp$2(c)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\n    const isNewLineChar = c => c === '\\n' || c === '\\r';\n    const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\n    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {\n      const tabSpace = repeat(' ', tabSpaces);\n      const normalizedText = text.replace(/\\t/g, tabSpace);\n      const result = foldl(normalizedText, (acc, c) => {\n        if (isCollapsibleWhitespace$1(c) || c === nbsp) {\n          if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\n            return {\n              pcIsSpace: false,\n              str: acc.str + nbsp\n            };\n          } else {\n            return {\n              pcIsSpace: true,\n              str: acc.str + ' '\n            };\n          }\n        } else {\n          return {\n            pcIsSpace: isNewLineChar(c),\n            str: acc.str + c\n          };\n        }\n      }, {\n        pcIsSpace: false,\n        str: ''\n      });\n      return result.str;\n    };\n\n    const hasWhitespacePreserveParent = (node, rootNode) => {\n      const rootElement = SugarElement.fromDom(rootNode);\n      const startNode = SugarElement.fromDom(node);\n      return ancestor$2(startNode, 'pre,code', curry(eq, rootElement));\n    };\n    const isWhitespace$1 = (node, rootNode) => {\n      return isText$a(node) && isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode);\n    };\n    const isNamedAnchor = node => {\n      return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\n    };\n    const isContent$1 = (node, rootNode) => {\n      return isCaretCandidate$3(node) && !isWhitespace$1(node, rootNode) || isNamedAnchor(node) || isBookmark(node);\n    };\n    const isBookmark = hasAttribute('data-mce-bookmark');\n    const isBogus$1 = hasAttribute('data-mce-bogus');\n    const isBogusAll = hasAttributeValue('data-mce-bogus', 'all');\n    const hasNonEditableParent = node => parentElement(SugarElement.fromDom(node)).exists(parent => !isEditable$2(parent));\n    const isEmptyNode = (targetNode, skipBogus) => {\n      let brCount = 0;\n      if (isContent$1(targetNode, targetNode)) {\n        return false;\n      } else {\n        let node = targetNode.firstChild;\n        if (!node) {\n          return true;\n        }\n        const walker = new DomTreeWalker(node, targetNode);\n        do {\n          if (skipBogus) {\n            if (isBogusAll(node)) {\n              node = walker.next(true);\n              continue;\n            }\n            if (isBogus$1(node)) {\n              node = walker.next();\n              continue;\n            }\n          }\n          if (isContentEditableTrue$3(node) && hasNonEditableParent(node)) {\n            return false;\n          }\n          if (isBr$6(node)) {\n            brCount++;\n            node = walker.next();\n            continue;\n          }\n          if (isContent$1(node, targetNode)) {\n            return false;\n          }\n          node = walker.next();\n        } while (node);\n        return brCount <= 1;\n      }\n    };\n    const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);\n\n    const isNonHtmlElementRootName = name => name.toLowerCase() === 'svg';\n    const isNonHtmlElementRoot = node => isNonHtmlElementRootName(node.nodeName);\n    const toScopeType = node => (node === null || node === void 0 ? void 0 : node.nodeName) === 'svg' ? 'svg' : 'html';\n    const namespaceElements = ['svg'];\n    const createNamespaceTracker = () => {\n      let scopes = [];\n      const peek = () => scopes[scopes.length - 1];\n      const track = node => {\n        if (isNonHtmlElementRoot(node)) {\n          scopes.push(node);\n        }\n        let currentScope = peek();\n        if (currentScope && !currentScope.contains(node)) {\n          scopes.pop();\n          currentScope = peek();\n        }\n        return toScopeType(currentScope);\n      };\n      const current = () => toScopeType(peek());\n      const reset = () => {\n        scopes = [];\n      };\n      return {\n        track,\n        current,\n        reset\n      };\n    };\n\n    const transparentBlockAttr = 'data-mce-block';\n    const elementNames = map => filter$5(keys(map), key => !/[A-Z]/.test(key));\n    const makeSelectorFromSchemaMap = map => map$3(elementNames(map), name => {\n      return `${ name }:` + map$3(namespaceElements, ns => `not(${ ns } ${ name })`).join(':');\n    }).join(',');\n    const updateTransparent = (blocksSelector, transparent) => {\n      if (isNonNullable(transparent.querySelector(blocksSelector))) {\n        transparent.setAttribute(transparentBlockAttr, 'true');\n        if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {\n          transparent.removeAttribute('data-mce-selected');\n        }\n        return true;\n      } else {\n        transparent.removeAttribute(transparentBlockAttr);\n        return false;\n      }\n    };\n    const updateBlockStateOnChildren = (schema, scope) => {\n      const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());\n      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n      return filter$5(scope.querySelectorAll(transparentSelector), transparent => updateTransparent(blocksSelector, transparent));\n    };\n    const trimEdge = (el, leftSide) => {\n      var _a;\n      const childPropertyName = leftSide ? 'lastChild' : 'firstChild';\n      for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {\n        if (isEmpty$2(SugarElement.fromDom(child))) {\n          (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);\n          return;\n        }\n      }\n    };\n    const split$2 = (parentElm, splitElm) => {\n      const range = document.createRange();\n      const parentNode = parentElm.parentNode;\n      if (parentNode) {\n        range.setStartBefore(parentElm);\n        range.setEndBefore(splitElm);\n        const beforeFragment = range.extractContents();\n        trimEdge(beforeFragment, true);\n        range.setStartAfter(splitElm);\n        range.setEndAfter(parentElm);\n        const afterFragment = range.extractContents();\n        trimEdge(afterFragment, false);\n        if (!isEmpty$2(SugarElement.fromDom(beforeFragment))) {\n          parentNode.insertBefore(beforeFragment, parentElm);\n        }\n        if (!isEmpty$2(SugarElement.fromDom(splitElm))) {\n          parentNode.insertBefore(splitElm, parentElm);\n        }\n        if (!isEmpty$2(SugarElement.fromDom(afterFragment))) {\n          parentNode.insertBefore(afterFragment, parentElm);\n        }\n        parentNode.removeChild(parentElm);\n      }\n    };\n    const splitInvalidChildren = (schema, scope, transparentBlocks) => {\n      const blocksElements = schema.getBlockElements();\n      const rootNode = SugarElement.fromDom(scope);\n      const isBlock = el => name(el) in blocksElements;\n      const isRoot = el => eq(el, rootNode);\n      each$e(fromDom$1(transparentBlocks), transparentBlock => {\n        ancestor$4(transparentBlock, isBlock, isRoot).each(parentBlock => {\n          const invalidChildren = children(transparentBlock, el => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));\n          if (invalidChildren.length > 0) {\n            const stateScope = parentElement(parentBlock);\n            each$e(invalidChildren, child => {\n              ancestor$4(child, isBlock, isRoot).each(parentBlock => {\n                split$2(parentBlock.dom, child.dom);\n              });\n            });\n            stateScope.each(scope => updateBlockStateOnChildren(schema, scope.dom));\n          }\n        });\n      });\n    };\n    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {\n      each$e([\n        ...transparentBlocks,\n        ...isTransparentBlock(schema, scope) ? [scope] : []\n      ], block => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), elm => {\n        if (isTransparentInline(schema, elm.dom)) {\n          unwrap(elm);\n        }\n      }));\n    };\n    const updateChildren = (schema, scope) => {\n      const transparentBlocks = updateBlockStateOnChildren(schema, scope);\n      splitInvalidChildren(schema, scope, transparentBlocks);\n      unwrapInvalidChildren(schema, scope, transparentBlocks);\n    };\n    const updateElement = (schema, target) => {\n      if (isTransparentElement(schema, target)) {\n        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n        updateTransparent(blocksSelector, target);\n      }\n    };\n    const updateCaret = (schema, root, caretParent) => {\n      const isRoot = el => eq(el, SugarElement.fromDom(root));\n      const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);\n      get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), scope => updateChildren(schema, scope.dom));\n    };\n    const hasBlockAttr = el => el.hasAttribute(transparentBlockAttr);\n    const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);\n    const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);\n    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);\n    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);\n    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));\n\n    const browser$2 = detect$2().browser;\n    const firstElement = nodes => find$2(nodes, isElement$7);\n    const getTableCaptionDeltaY = elm => {\n      if (browser$2.isFirefox() && name(elm) === 'table') {\n        return firstElement(children$1(elm)).filter(elm => {\n          return name(elm) === 'caption';\n        }).bind(caption => {\n          return firstElement(nextSiblings(caption)).map(body => {\n            const bodyTop = body.dom.offsetTop;\n            const captionTop = caption.dom.offsetTop;\n            const captionHeight = caption.dom.offsetHeight;\n            return bodyTop <= captionTop ? -captionHeight : 0;\n          });\n        }).getOr(0);\n      } else {\n        return 0;\n      }\n    };\n    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\n    const getPos = (body, elm, rootElm) => {\n      let x = 0, y = 0;\n      const doc = body.ownerDocument;\n      rootElm = rootElm ? rootElm : body;\n      if (elm) {\n        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\n          const pos = elm.getBoundingClientRect();\n          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\n          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\n          return {\n            x,\n            y\n          };\n        }\n        let offsetParent = elm;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          const castOffsetParent = offsetParent;\n          x += castOffsetParent.offsetLeft || 0;\n          y += castOffsetParent.offsetTop || 0;\n          offsetParent = castOffsetParent.offsetParent;\n        }\n        offsetParent = elm.parentNode;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          x -= offsetParent.scrollLeft || 0;\n          y -= offsetParent.scrollTop || 0;\n          offsetParent = offsetParent.parentNode;\n        }\n        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\n      }\n      return {\n        x,\n        y\n      };\n    };\n\n    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {\n      let idCount = 0;\n      const loadedStates = {};\n      const edos = SugarElement.fromDom(documentOrShadowRoot);\n      const doc = documentOrOwner(edos);\n      const _setReferrerPolicy = referrerPolicy => {\n        settings.referrerPolicy = referrerPolicy;\n      };\n      const _setContentCssCors = contentCssCors => {\n        settings.contentCssCors = contentCssCors;\n      };\n      const addStyle = element => {\n        append$1(getStyleContainer(edos), element);\n      };\n      const removeStyle = id => {\n        const styleContainer = getStyleContainer(edos);\n        descendant$1(styleContainer, '#' + id).each(remove$5);\n      };\n      const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\n        id: 'mce-u' + idCount++,\n        passed: [],\n        failed: [],\n        count: 0\n      }));\n      const load = url => new Promise((success, failure) => {\n        let link;\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        const state = getOrCreateState(urlWithSuffix);\n        loadedStates[urlWithSuffix] = state;\n        state.count++;\n        const resolve = (callbacks, status) => {\n          each$e(callbacks, call);\n          state.status = status;\n          state.passed = [];\n          state.failed = [];\n          if (link) {\n            link.onload = null;\n            link.onerror = null;\n            link = null;\n          }\n        };\n        const passed = () => resolve(state.passed, 2);\n        const failed = () => resolve(state.failed, 3);\n        if (success) {\n          state.passed.push(success);\n        }\n        if (failure) {\n          state.failed.push(failure);\n        }\n        if (state.status === 1) {\n          return;\n        }\n        if (state.status === 2) {\n          passed();\n          return;\n        }\n        if (state.status === 3) {\n          failed();\n          return;\n        }\n        state.status = 1;\n        const linkElem = SugarElement.fromTag('link', doc.dom);\n        setAll$1(linkElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        if (settings.contentCssCors) {\n          set$3(linkElem, 'crossOrigin', 'anonymous');\n        }\n        if (settings.referrerPolicy) {\n          set$3(linkElem, 'referrerpolicy', settings.referrerPolicy);\n        }\n        link = linkElem.dom;\n        link.onload = passed;\n        link.onerror = failed;\n        addStyle(linkElem);\n        set$3(linkElem, 'href', urlWithSuffix);\n      });\n      const loadRawCss = (key, css) => {\n        const state = getOrCreateState(key);\n        loadedStates[key] = state;\n        state.count++;\n        const styleElem = SugarElement.fromTag('style', doc.dom);\n        setAll$1(styleElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        styleElem.dom.innerHTML = css;\n        addStyle(styleElem);\n      };\n      const loadAll = urls => {\n        const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\n        return loadedUrls.then(results => {\n          const parts = partition$2(results, r => r.status === 'fulfilled');\n          if (parts.fail.length > 0) {\n            return Promise.reject(map$3(parts.fail, result => result.reason));\n          } else {\n            return map$3(parts.pass, result => result.value);\n          }\n        });\n      };\n      const unload = url => {\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        get$a(loadedStates, urlWithSuffix).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[urlWithSuffix];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadRawCss = key => {\n        get$a(loadedStates, key).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[key];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadAll = urls => {\n        each$e(urls, url => {\n          unload(url);\n        });\n      };\n      return {\n        load,\n        loadRawCss,\n        loadAll,\n        unload,\n        unloadRawCss,\n        unloadAll,\n        _setReferrerPolicy,\n        _setContentCssCors\n      };\n    };\n\n    const create$d = () => {\n      const map = new WeakMap();\n      const forElement = (referenceElement, settings) => {\n        const root = getRootNode(referenceElement);\n        const rootDom = root.dom;\n        return Optional.from(map.get(rootDom)).getOrThunk(() => {\n          const sl = StyleSheetLoader(rootDom, settings);\n          map.set(rootDom, sl);\n          return sl;\n        });\n      };\n      return { forElement };\n    };\n    const instance = create$d();\n\n    const isSpan = node => node.nodeName.toLowerCase() === 'span';\n    const isInlineContent = (node, root, schema) => isNonNullable(node) && (isContent$1(node, root) || schema.isInline(node.nodeName.toLowerCase()));\n    const surroundedByInlineContent = (node, root, schema) => {\n      const prev = new DomTreeWalker(node, root).prev(false);\n      const next = new DomTreeWalker(node, root).next(false);\n      const prevIsInline = isUndefined(prev) || isInlineContent(prev, root, schema);\n      const nextIsInline = isUndefined(next) || isInlineContent(next, root, schema);\n      return prevIsInline && nextIsInline;\n    };\n    const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\n    const isKeepTextNode = (node, root, schema) => isText$a(node) && node.data.length > 0 && surroundedByInlineContent(node, root, schema);\n    const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\n    const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\n    const trimNode = (dom, node, schema, root) => {\n      var _a;\n      const rootNode = root || node;\n      if (isElement$6(node) && isBookmarkNode$2(node)) {\n        return node;\n      }\n      const children = node.childNodes;\n      for (let i = children.length - 1; i >= 0; i--) {\n        trimNode(dom, children[i], schema, rootNode);\n      }\n      if (isElement$6(node)) {\n        const currentChildren = node.childNodes;\n        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);\n        }\n      }\n      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode, schema)) {\n        dom.remove(node);\n      }\n      return node;\n    };\n\n    const makeMap$3 = Tools.makeMap;\n    const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const rawCharsRegExp = /[<>&\\\"\\']/g;\n    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\n    const asciiMap = {\n      128: '\\u20AC',\n      130: '\\u201A',\n      131: '\\u0192',\n      132: '\\u201E',\n      133: '\\u2026',\n      134: '\\u2020',\n      135: '\\u2021',\n      136: '\\u02c6',\n      137: '\\u2030',\n      138: '\\u0160',\n      139: '\\u2039',\n      140: '\\u0152',\n      142: '\\u017d',\n      145: '\\u2018',\n      146: '\\u2019',\n      147: '\\u201C',\n      148: '\\u201D',\n      149: '\\u2022',\n      150: '\\u2013',\n      151: '\\u2014',\n      152: '\\u02DC',\n      153: '\\u2122',\n      154: '\\u0161',\n      155: '\\u203A',\n      156: '\\u0153',\n      158: '\\u017e',\n      159: '\\u0178'\n    };\n    const baseEntities = {\n      '\"': '&quot;',\n      '\\'': '&#39;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '&': '&amp;',\n      '`': '&#96;'\n    };\n    const reverseEntities = {\n      '&lt;': '<',\n      '&gt;': '>',\n      '&amp;': '&',\n      '&quot;': '\"',\n      '&apos;': `'`\n    };\n    const nativeDecode = text => {\n      const elm = SugarElement.fromTag('div').dom;\n      elm.innerHTML = text;\n      return elm.textContent || elm.innerText || text;\n    };\n    const buildEntitiesLookup = (items, radix) => {\n      const lookup = {};\n      if (items) {\n        const itemList = items.split(',');\n        radix = radix || 10;\n        for (let i = 0; i < itemList.length; i += 2) {\n          const chr = String.fromCharCode(parseInt(itemList[i], radix));\n          if (!baseEntities[chr]) {\n            const entity = '&' + itemList[i + 1] + ';';\n            lookup[chr] = entity;\n            lookup[entity] = chr;\n          }\n        }\n        return lookup;\n      } else {\n        return undefined;\n      }\n    };\n    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      if (chr.length > 1) {\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n      }\n      return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\n    });\n    const encodeNamed = (text, attr, entities) => {\n      const resolveEntities = entities || namedEntities;\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        return baseEntities[chr] || resolveEntities[chr] || chr;\n      });\n    };\n    const getEncodeFunc = (name, entities) => {\n      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\n      const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        if (baseEntities[chr] !== undefined) {\n          return baseEntities[chr];\n        }\n        if (entitiesMap[chr] !== undefined) {\n          return entitiesMap[chr];\n        }\n        if (chr.length > 1) {\n          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n        }\n        return '&#' + chr.charCodeAt(0) + ';';\n      });\n      const encodeCustomNamed = (text, attr) => {\n        return encodeNamed(text, attr, entitiesMap);\n      };\n      const nameMap = makeMap$3(name.replace(/\\+/g, ','));\n      if (nameMap.named && nameMap.numeric) {\n        return encodeNamedAndNumeric;\n      }\n      if (nameMap.named) {\n        if (entities) {\n          return encodeCustomNamed;\n        }\n        return encodeNamed;\n      }\n      if (nameMap.numeric) {\n        return encodeNumeric;\n      }\n      return encodeRaw;\n    };\n    const decode = text => text.replace(entityRegExp, (all, numeric) => {\n      if (numeric) {\n        if (numeric.charAt(0).toLowerCase() === 'x') {\n          numeric = parseInt(numeric.substr(1), 16);\n        } else {\n          numeric = parseInt(numeric, 10);\n        }\n        if (numeric > 65535) {\n          numeric -= 65536;\n          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\n        }\n        return asciiMap[numeric] || String.fromCharCode(numeric);\n      }\n      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n    });\n    const Entities = {\n      encodeRaw,\n      encodeAllRaw,\n      encodeNumeric,\n      encodeNamed,\n      getEncodeFunc,\n      decode\n    };\n\n    const split$1 = (items, delim) => {\n      items = Tools.trim(items);\n      return items ? items.split(delim || ' ') : [];\n    };\n    const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\n\n    const parseCustomElementsRules = value => {\n      const customElementRegExp = /^(~)?(.+)$/;\n      return bind$3(split$1(value, ','), rule => {\n        const matches = customElementRegExp.exec(rule);\n        if (matches) {\n          const inline = matches[1] === '~';\n          const cloneName = inline ? 'span' : 'div';\n          const name = matches[2];\n          return [{\n              inline,\n              cloneName,\n              name\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const getElementSetsAsStrings = type => {\n      let globalAttributes, blockContent;\n      let phrasingContent;\n      globalAttributes = 'id accesskey class dir lang style tabindex title role';\n      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\n      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\n      if (type !== 'html4') {\n        const transparentContent = 'a ins del canvas map';\n        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';\n        blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;\n        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen svg';\n      }\n      if (type !== 'html5-strict') {\n        globalAttributes += ' xml:lang';\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        phrasingContent = [\n          phrasingContent,\n          html4PhrasingContent\n        ].join(' ');\n        const html4BlockContent = 'center dir isindex noframes';\n        blockContent = [\n          blockContent,\n          html4BlockContent\n        ].join(' ');\n      }\n      const flowContent = [\n        blockContent,\n        phrasingContent\n      ].join(' ');\n      return {\n        globalAttributes,\n        blockContent,\n        phrasingContent,\n        flowContent\n      };\n    };\n\n    const makeSchema = type => {\n      const {globalAttributes, phrasingContent, flowContent} = getElementSetsAsStrings(type);\n      const schema = {};\n      const addElement = (name, attributes, children) => {\n        schema[name] = {\n          attributes: mapToObject(attributes, constant({})),\n          attributesOrder: attributes,\n          children: mapToObject(children, constant({}))\n        };\n      };\n      const add = (name, attributes = '', children = '') => {\n        const childNames = split$1(children);\n        const names = split$1(name);\n        let ni = names.length;\n        const allAttributes = split$1([\n          globalAttributes,\n          attributes\n        ].join(' '));\n        while (ni--) {\n          addElement(names[ni], allAttributes.slice(), childNames);\n        }\n      };\n      const addAttrs = (name, attributes) => {\n        const names = split$1(name);\n        const attrs = split$1(attributes);\n        let ni = names.length;\n        while (ni--) {\n          const schemaItem = schema[names[ni]];\n          for (let i = 0, l = attrs.length; i < l; i++) {\n            schemaItem.attributes[attrs[i]] = {};\n            schemaItem.attributesOrder.push(attrs[i]);\n          }\n        }\n      };\n      if (type !== 'html5-strict') {\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        each$e(split$1(html4PhrasingContent), name => {\n          add(name, '', phrasingContent);\n        });\n        const html4BlockContent = 'center dir isindex noframes';\n        each$e(split$1(html4BlockContent), name => {\n          add(name, '', flowContent);\n        });\n      }\n      add('html', 'manifest', 'head body');\n      add('head', '', 'base command link meta noscript script style title');\n      add('title hr noscript br');\n      add('base', 'href target');\n      add('link', 'href rel media hreflang type sizes hreflang');\n      add('meta', 'name http-equiv content charset');\n      add('style', 'media type scoped');\n      add('script', 'src async defer type charset');\n      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\n      add('dd div', '', flowContent);\n      add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);\n      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\n      add('blockquote', 'cite', flowContent);\n      add('ol', 'reversed start type', 'li');\n      add('ul', '', 'li');\n      add('li', 'value', flowContent);\n      add('dl', '', 'dt dd');\n      add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);\n      add('q', 'cite', phrasingContent);\n      add('ins del', 'cite datetime', flowContent);\n      add('img', 'src sizes srcset alt usemap ismap width height');\n      add('iframe', 'src name width height', flowContent);\n      add('embed', 'src type width height');\n      add('object', 'data type typemustmatch name usemap form width height', [\n        flowContent,\n        'param'\n      ].join(' '));\n      add('param', 'name value');\n      add('map', 'name', [\n        flowContent,\n        'area'\n      ].join(' '));\n      add('area', 'alt coords shape href target rel media hreflang type');\n      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\n      add('colgroup', 'span', 'col');\n      add('col', 'span');\n      add('tbody thead tfoot', '', 'tr');\n      add('tr', '', 'td th');\n      add('td', 'colspan rowspan headers', flowContent);\n      add('th', 'colspan rowspan headers scope abbr', flowContent);\n      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\n      add('fieldset', 'disabled form name', [\n        flowContent,\n        'legend'\n      ].join(' '));\n      add('label', 'form for', phrasingContent);\n      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\n      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\n      add('select', 'disabled form multiple name required size', 'option optgroup');\n      add('optgroup', 'disabled label', 'option');\n      add('option', 'disabled label selected value');\n      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\n      add('menu', 'type label', [\n        flowContent,\n        'li'\n      ].join(' '));\n      add('noscript', '', flowContent);\n      if (type !== 'html4') {\n        add('wbr');\n        add('ruby', '', [\n          phrasingContent,\n          'rt rp'\n        ].join(' '));\n        add('figcaption', '', flowContent);\n        add('mark rt rp bdi', '', phrasingContent);\n        add('summary', '', [\n          phrasingContent,\n          'h1 h2 h3 h4 h5 h6'\n        ].join(' '));\n        add('canvas', 'width height', flowContent);\n        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('picture', '', 'img source');\n        add('source', 'src srcset type media sizes');\n        add('track', 'kind src srclang label default');\n        add('datalist', '', [\n          phrasingContent,\n          'option'\n        ].join(' '));\n        add('article section nav aside main header footer', '', flowContent);\n        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\n        add('figure', '', [\n          flowContent,\n          'figcaption'\n        ].join(' '));\n        add('time', 'datetime', phrasingContent);\n        add('dialog', 'open', flowContent);\n        add('command', 'type label icon disabled checked radiogroup command');\n        add('output', 'for form name', phrasingContent);\n        add('progress', 'value max', phrasingContent);\n        add('meter', 'value min max low high optimum', phrasingContent);\n        add('details', 'open', [\n          flowContent,\n          'summary'\n        ].join(' '));\n        add('keygen', 'autofocus challenge disabled form keytype name');\n        addElement('svg', 'id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform'.split(' '), []);\n      }\n      if (type !== 'html5-strict') {\n        addAttrs('script', 'language xml:space');\n        addAttrs('style', 'xml:space');\n        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\n        addAttrs('embed', 'align name hspace vspace');\n        addAttrs('param', 'valuetype type');\n        addAttrs('a', 'charset name rev shape coords');\n        addAttrs('br', 'clear');\n        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\n        addAttrs('img', 'name longdesc align border hspace vspace');\n        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\n        addAttrs('font basefont', 'size color face');\n        addAttrs('input', 'usemap align');\n        addAttrs('select');\n        addAttrs('textarea');\n        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\n        addAttrs('ul', 'type compact');\n        addAttrs('li', 'type');\n        addAttrs('ol dl menu dir', 'compact');\n        addAttrs('pre', 'width xml:space');\n        addAttrs('hr', 'align noshade size width');\n        addAttrs('isindex', 'prompt');\n        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\n        addAttrs('col', 'width align char charoff valign');\n        addAttrs('colgroup', 'width align char charoff valign');\n        addAttrs('thead', 'align char charoff valign');\n        addAttrs('tr', 'align char charoff valign bgcolor');\n        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\n        addAttrs('form', 'accept');\n        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\n        addAttrs('tfoot', 'align char charoff valign');\n        addAttrs('tbody', 'align char charoff valign');\n        addAttrs('area', 'nohref');\n        addAttrs('body', 'background bgcolor text link vlink alink');\n      }\n      if (type !== 'html4') {\n        addAttrs('input button select textarea', 'autofocus');\n        addAttrs('input textarea', 'placeholder');\n        addAttrs('a', 'download');\n        addAttrs('link script img', 'crossorigin');\n        addAttrs('img', 'loading');\n        addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading');\n      }\n      if (type !== 'html4') {\n        each$e([\n          schema.video,\n          schema.audio\n        ], item => {\n          delete item.children.audio;\n          delete item.children.video;\n        });\n      }\n      each$e(split$1('a form meter progress dfn'), name => {\n        if (schema[name]) {\n          delete schema[name].children[name];\n        }\n      });\n      delete schema.caption.children.table;\n      delete schema.script;\n      return schema;\n    };\n\n    const prefixToOperation = prefix => prefix === '-' ? 'remove' : 'add';\n    const parseValidChildrenRules = value => {\n      const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\n      return bind$3(split$1(value, ','), rule => {\n        const matches = childRuleRegExp.exec(rule);\n        if (matches) {\n          const prefix = matches[1];\n          const operation = prefix ? prefixToOperation(prefix) : 'replace';\n          const name = matches[2];\n          const validChildren = split$1(matches[3], '|');\n          return [{\n              operation,\n              name,\n              validChildren\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {\n      const attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/;\n      const hasPatternsRegExp = /[*?+]/;\n      const {attributes, attributesOrder} = targetElement;\n      return each$e(split$1(attrData, '|'), rule => {\n        const matches = attrRuleRegExp.exec(rule);\n        if (matches) {\n          const attr = {};\n          const attrType = matches[1];\n          const attrName = matches[2].replace(/[\\\\:]:/g, ':');\n          const attrPrefix = matches[3];\n          const value = matches[4];\n          if (attrType === '!') {\n            targetElement.attributesRequired = targetElement.attributesRequired || [];\n            targetElement.attributesRequired.push(attrName);\n            attr.required = true;\n          }\n          if (attrType === '-') {\n            delete attributes[attrName];\n            attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);\n            return;\n          }\n          if (attrPrefix) {\n            if (attrPrefix === '=') {\n              targetElement.attributesDefault = targetElement.attributesDefault || [];\n              targetElement.attributesDefault.push({\n                name: attrName,\n                value\n              });\n              attr.defaultValue = value;\n            } else if (attrPrefix === '~') {\n              targetElement.attributesForced = targetElement.attributesForced || [];\n              targetElement.attributesForced.push({\n                name: attrName,\n                value\n              });\n              attr.forcedValue = value;\n            } else if (attrPrefix === '<') {\n              attr.validValues = Tools.makeMap(value, '?');\n            }\n          }\n          if (hasPatternsRegExp.test(attrName)) {\n            const attrPattern = attr;\n            targetElement.attributePatterns = targetElement.attributePatterns || [];\n            attrPattern.pattern = patternToRegExp(attrName);\n            targetElement.attributePatterns.push(attrPattern);\n          } else {\n            if (!attributes[attrName]) {\n              attributesOrder.push(attrName);\n            }\n            attributes[attrName] = attr;\n          }\n        }\n      });\n    };\n    const cloneAttributesInto = (from, to) => {\n      each$d(from.attributes, (value, key) => {\n        to.attributes[key] = value;\n      });\n      to.attributesOrder.push(...from.attributesOrder);\n    };\n    const parseValidElementsRules = (globalElement, validElements) => {\n      const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/;\n      return bind$3(split$1(validElements, ','), rule => {\n        const matches = elementRuleRegExp.exec(rule);\n        if (matches) {\n          const prefix = matches[1];\n          const elementName = matches[2];\n          const outputName = matches[3];\n          const attrsPrefix = matches[4];\n          const attrData = matches[5];\n          const element = {\n            attributes: {},\n            attributesOrder: []\n          };\n          globalElement.each(el => cloneAttributesInto(el, element));\n          if (prefix === '#') {\n            element.paddEmpty = true;\n          } else if (prefix === '-') {\n            element.removeEmpty = true;\n          }\n          if (attrsPrefix === '!') {\n            element.removeEmptyAttrs = true;\n          }\n          if (attrData) {\n            parseValidElementsAttrDataIntoElement(attrData, element);\n          }\n          if (outputName) {\n            element.outputName = elementName;\n          }\n          if (elementName === '@') {\n            if (globalElement.isNone()) {\n              globalElement = Optional.some(element);\n            } else {\n              return [];\n            }\n          }\n          return [outputName ? {\n              name: elementName,\n              element,\n              aliasName: outputName\n            } : {\n              name: elementName,\n              element\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const mapCache = {};\n    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode;\n    const createMap = (defaultValue, extendWith = {}) => {\n      const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\n      return extend$2(value, extendWith);\n    };\n    const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());\n    const compileElementMap = (value, mode) => {\n      if (value) {\n        const styles = {};\n        if (isString(value)) {\n          value = { '*': value };\n        }\n        each$b(value, (value, key) => {\n          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\n        });\n        return styles;\n      } else {\n        return undefined;\n      }\n    };\n    const Schema = (settings = {}) => {\n      var _a;\n      const elements = {};\n      const children = {};\n      let patternElements = [];\n      const customElementsMap = {};\n      const specialElements = {};\n      const createLookupTable = (option, defaultValue, extendWith) => {\n        const value = settings[option];\n        if (!value) {\n          let newValue = mapCache[option];\n          if (!newValue) {\n            newValue = createMap(defaultValue, extendWith);\n            mapCache[option] = newValue;\n          }\n          return newValue;\n        } else {\n          return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\n        }\n      };\n      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\n      const schemaItems = makeSchema(schemaType);\n      if (settings.verify_html === false) {\n        settings.valid_elements = '*[*]';\n      }\n      const validStyles = compileElementMap(settings.valid_styles);\n      const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\n      const validClasses = compileElementMap(settings.valid_classes, 'map');\n      const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\n      const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\n      const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\n      const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\n      const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\n      const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre svg', voidElementsMap);\n      const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\n      const headings = 'h1 h2 h3 h4 h5 h6';\n      const textBlockElementsMap = createLookupTable('text_block_elements', headings + ' p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\n      const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary html body multicol listing', textBlockElementsMap);\n      const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');\n      const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');\n      const wrapBlockElementsMap = createLookupTable('wrap_block_elements', 'pre ' + headings);\n      each$b('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\n        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\n      });\n      const addValidElements = validElements => {\n        const globalElement = Optional.from(elements['@']);\n        const hasPatternsRegExp = /[*?+]/;\n        each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({name, element, aliasName}) => {\n          if (aliasName) {\n            elements[aliasName] = element;\n          }\n          if (hasPatternsRegExp.test(name)) {\n            const patternElement = element;\n            patternElement.pattern = patternToRegExp(name);\n            patternElements.push(patternElement);\n          } else {\n            elements[name] = element;\n          }\n        });\n      };\n      const setValidElements = validElements => {\n        patternElements = [];\n        each$e(keys(elements), name => {\n          delete elements[name];\n        });\n        addValidElements(validElements);\n      };\n      const addCustomElements = customElements => {\n        delete mapCache.text_block_elements;\n        delete mapCache.block_elements;\n        each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({inline, name, cloneName}) => {\n          children[name] = children[cloneName];\n          customElementsMap[name] = cloneName;\n          nonEmptyElementsMap[name.toUpperCase()] = {};\n          nonEmptyElementsMap[name] = {};\n          if (!inline) {\n            blockElementsMap[name.toUpperCase()] = {};\n            blockElementsMap[name] = {};\n          }\n          if (!elements[name]) {\n            let customRule = elements[cloneName];\n            customRule = extend$2({}, customRule);\n            delete customRule.removeEmptyAttrs;\n            delete customRule.removeEmpty;\n            elements[name] = customRule;\n          }\n          each$d(children, (element, elmName) => {\n            if (element[cloneName]) {\n              children[elmName] = element = extend$2({}, children[elmName]);\n              element[name] = element[cloneName];\n            }\n          });\n        });\n      };\n      const addValidChildren = validChildren => {\n        each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({operation, name, validChildren}) => {\n          const parent = operation === 'replace' ? { '#comment': {} } : children[name];\n          each$e(validChildren, child => {\n            if (operation === 'remove') {\n              delete parent[child];\n            } else {\n              parent[child] = {};\n            }\n          });\n          children[name] = parent;\n        });\n      };\n      const getElementRule = name => {\n        const element = elements[name];\n        if (element) {\n          return element;\n        }\n        let i = patternElements.length;\n        while (i--) {\n          const patternElement = patternElements[i];\n          if (patternElement.pattern.test(name)) {\n            return patternElement;\n          }\n        }\n        return undefined;\n      };\n      if (!settings.valid_elements) {\n        each$b(schemaItems, (element, name) => {\n          elements[name] = {\n            attributes: element.attributes,\n            attributesOrder: element.attributesOrder\n          };\n          children[name] = element.children;\n        });\n        each$b(split$1('strong/b em/i'), item => {\n          const items = split$1(item, '/');\n          elements[items[1]].outputName = items[0];\n        });\n        each$b(textInlineElementsMap, (_val, name) => {\n          if (elements[name]) {\n            if (settings.padd_empty_block_inline_children) {\n              elements[name].paddInEmptyBlock = true;\n            }\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$b(split$1('ol ul blockquote a table tbody'), name => {\n          if (elements[name]) {\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), name => {\n          if (elements[name]) {\n            elements[name].paddEmpty = true;\n          }\n        });\n        each$b(split$1('span'), name => {\n          elements[name].removeEmptyAttrs = true;\n        });\n      } else {\n        setValidElements(settings.valid_elements);\n        each$b(schemaItems, (element, name) => {\n          children[name] = element.children;\n        });\n      }\n      delete elements.svg;\n      addCustomElements(settings.custom_elements);\n      addValidChildren(settings.valid_children);\n      addValidElements(settings.extended_valid_elements);\n      addValidChildren('+ol[ul|ol],+ul[ul|ol]');\n      each$b({\n        dd: 'dl',\n        dt: 'dl',\n        li: 'ul ol',\n        td: 'tr',\n        th: 'tr',\n        tr: 'tbody thead tfoot',\n        tbody: 'table',\n        thead: 'table',\n        tfoot: 'table',\n        legend: 'fieldset',\n        area: 'map',\n        param: 'video audio object'\n      }, (parents, item) => {\n        if (elements[item]) {\n          elements[item].parentsRequired = split$1(parents);\n        }\n      });\n      if (settings.invalid_elements) {\n        each$b(explode$2(settings.invalid_elements), item => {\n          if (elements[item]) {\n            delete elements[item];\n          }\n        });\n      }\n      if (!getElementRule('span')) {\n        addValidElements('span[!data-mce-type|*]');\n      }\n      const getValidStyles = constant(validStyles);\n      const getInvalidStyles = constant(invalidStyles);\n      const getValidClasses = constant(validClasses);\n      const getBoolAttrs = constant(boolAttrMap);\n      const getBlockElements = constant(blockElementsMap);\n      const getTextBlockElements = constant(textBlockElementsMap);\n      const getTextInlineElements = constant(textInlineElementsMap);\n      const getVoidElements = constant(Object.seal(voidElementsMap));\n      const getSelfClosingElements = constant(selfClosingElementsMap);\n      const getNonEmptyElements = constant(nonEmptyElementsMap);\n      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\n      const getWhitespaceElements = constant(whitespaceElementsMap);\n      const getTransparentElements = constant(transparentElementsMap);\n      const getWrapBlockElements = constant(wrapBlockElementsMap);\n      const getSpecialElements = constant(Object.seal(specialElements));\n      const isValidChild = (name, child) => {\n        const parent = children[name.toLowerCase()];\n        return !!(parent && parent[child.toLowerCase()]);\n      };\n      const isValid = (name, attr) => {\n        const rule = getElementRule(name);\n        if (rule) {\n          if (attr) {\n            if (rule.attributes[attr]) {\n              return true;\n            }\n            const attrPatterns = rule.attributePatterns;\n            if (attrPatterns) {\n              let i = attrPatterns.length;\n              while (i--) {\n                if (attrPatterns[i].pattern.test(attr)) {\n                  return true;\n                }\n              }\n            }\n          } else {\n            return true;\n          }\n        }\n        return false;\n      };\n      const isBlock = name => has$2(getBlockElements(), name);\n      const isInline = name => !startsWith(name, '#') && isValid(name) && !isBlock(name);\n      const isWrapper = name => has$2(getWrapBlockElements(), name) || isInline(name);\n      const getCustomElements = constant(customElementsMap);\n      return {\n        type: schemaType,\n        children,\n        elements,\n        getValidStyles,\n        getValidClasses,\n        getBlockElements,\n        getInvalidStyles,\n        getVoidElements,\n        getTextBlockElements,\n        getTextInlineElements,\n        getBoolAttrs,\n        getElementRule,\n        getSelfClosingElements,\n        getNonEmptyElements,\n        getMoveCaretBeforeOnEnterElements,\n        getWhitespaceElements,\n        getTransparentElements,\n        getSpecialElements,\n        isValidChild,\n        isValid,\n        isBlock,\n        isInline,\n        isWrapper,\n        getCustomElements,\n        addValidElements,\n        setValidElements,\n        addCustomElements,\n        addValidChildren\n      };\n    };\n\n    const hexColour = value => ({ value: normalizeHex(value) });\n    const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();\n    const toHex = component => {\n      const hex = component.toString(16);\n      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n    };\n    const fromRgba = rgbaColour => {\n      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n      return hexColour(value);\n    };\n\n    const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*$/i;\n    const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)\\s*$/i;\n    const rgbaColour = (red, green, blue, alpha) => ({\n      red,\n      green,\n      blue,\n      alpha\n    });\n    const fromStringValues = (red, green, blue, alpha) => {\n      const r = parseInt(red, 10);\n      const g = parseInt(green, 10);\n      const b = parseInt(blue, 10);\n      const a = parseFloat(alpha);\n      return rgbaColour(r, g, b, a);\n    };\n    const fromString = rgbaString => {\n      if (rgbaString === 'transparent') {\n        return Optional.some(rgbaColour(0, 0, 0, 0));\n      }\n      const rgbMatch = rgbRegex.exec(rgbaString);\n      if (rgbMatch !== null) {\n        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n      }\n      const rgbaMatch = rgbaRegex.exec(rgbaString);\n      if (rgbaMatch !== null) {\n        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n      }\n      return Optional.none();\n    };\n    const toString = rgba => `rgba(${ rgba.red },${ rgba.green },${ rgba.blue },${ rgba.alpha })`;\n\n    const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\n\n    const Styles = (settings = {}, schema) => {\n      const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\n      const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\n      const trimRightRegExp = /\\s+$/;\n      const encodingLookup = {};\n      let validStyles;\n      let invalidStyles;\n      const invisibleChar = zeroWidth;\n      if (schema) {\n        validStyles = schema.getValidStyles();\n        invalidStyles = schema.getInvalidStyles();\n      }\n      const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\n      for (let i = 0; i < encodingItems.length; i++) {\n        encodingLookup[encodingItems[i]] = invisibleChar + i;\n        encodingLookup[invisibleChar + i] = encodingItems[i];\n      }\n      const self = {\n        parse: css => {\n          const styles = {};\n          let isEncoded = false;\n          const urlConverter = settings.url_converter;\n          const urlConverterScope = settings.url_converter_scope || self;\n          const compress = (prefix, suffix, noJoin) => {\n            const top = styles[prefix + '-top' + suffix];\n            if (!top) {\n              return;\n            }\n            const right = styles[prefix + '-right' + suffix];\n            if (!right) {\n              return;\n            }\n            const bottom = styles[prefix + '-bottom' + suffix];\n            if (!bottom) {\n              return;\n            }\n            const left = styles[prefix + '-left' + suffix];\n            if (!left) {\n              return;\n            }\n            const box = [\n              top,\n              right,\n              bottom,\n              left\n            ];\n            let i = box.length - 1;\n            while (i--) {\n              if (box[i] !== box[i + 1]) {\n                break;\n              }\n            }\n            if (i > -1 && noJoin) {\n              return;\n            }\n            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\n            delete styles[prefix + '-top' + suffix];\n            delete styles[prefix + '-right' + suffix];\n            delete styles[prefix + '-bottom' + suffix];\n            delete styles[prefix + '-left' + suffix];\n          };\n          const canCompress = key => {\n            const value = styles[key];\n            if (!value) {\n              return;\n            }\n            const values = value.indexOf(',') > -1 ? [value] : value.split(' ');\n            let i = values.length;\n            while (i--) {\n              if (values[i] !== values[0]) {\n                return false;\n              }\n            }\n            styles[key] = values[0];\n            return true;\n          };\n          const compress2 = (target, a, b, c) => {\n            if (!canCompress(a)) {\n              return;\n            }\n            if (!canCompress(b)) {\n              return;\n            }\n            if (!canCompress(c)) {\n              return;\n            }\n            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\n            delete styles[a];\n            delete styles[b];\n            delete styles[c];\n          };\n          const encode = str => {\n            isEncoded = true;\n            return encodingLookup[str];\n          };\n          const decode = (str, keepSlashes) => {\n            if (isEncoded) {\n              str = str.replace(/\\uFEFF[0-9]/g, str => {\n                return encodingLookup[str];\n              });\n            }\n            if (!keepSlashes) {\n              str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\n            }\n            return str;\n          };\n          const decodeSingleHexSequence = escSeq => {\n            return String.fromCharCode(parseInt(escSeq.slice(1), 16));\n          };\n          const decodeHexSequences = value => {\n            return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\n          };\n          const processUrl = (match, url, url2, url3, str, str2) => {\n            str = str || str2;\n            if (str) {\n              str = decode(str);\n              return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\n            }\n            url = decode(url || url2 || url3 || '');\n            if (!settings.allow_script_urls) {\n              const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\n              if (/(java|vb)script:/i.test(scriptUrl)) {\n                return '';\n              }\n              if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n                return '';\n              }\n            }\n            if (urlConverter) {\n              url = urlConverter.call(urlConverterScope, url, 'style');\n            }\n            return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\n          };\n          if (css) {\n            css = css.replace(/[\\u0000-\\u001F]/g, '');\n            css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\n              return str.replace(/[;:]/g, encode);\n            });\n            let matches;\n            while (matches = styleRegExp.exec(css)) {\n              styleRegExp.lastIndex = matches.index + matches[0].length;\n              let name = matches[1].replace(trimRightRegExp, '').toLowerCase();\n              let value = matches[2].replace(trimRightRegExp, '');\n              if (name && value) {\n                name = decodeHexSequences(name);\n                value = decodeHexSequences(value);\n                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\n                  continue;\n                }\n                if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n                  continue;\n                }\n                if (name === 'font-weight' && value === '700') {\n                  value = 'bold';\n                } else if (name === 'color' || name === 'background-color') {\n                  value = value.toLowerCase();\n                }\n                if (isString(settings.force_hex_color) && settings.force_hex_color !== 'off') {\n                  fromString(value).each(rgba => {\n                    if (settings.force_hex_color === 'always' || rgba.alpha === 1) {\n                      value = rgbaToHexString(toString(rgba));\n                    }\n                  });\n                }\n                value = value.replace(urlOrStrRegExp, processUrl);\n                styles[name] = isEncoded ? decode(value, true) : value;\n              }\n            }\n            compress('border', '', true);\n            compress('border', '-width');\n            compress('border', '-color');\n            compress('border', '-style');\n            compress('padding', '');\n            compress('margin', '');\n            compress2('border', 'border-width', 'border-style', 'border-color');\n            if (styles.border === 'medium none') {\n              delete styles.border;\n            }\n            if (styles['border-image'] === 'none') {\n              delete styles['border-image'];\n            }\n          }\n          return styles;\n        },\n        serialize: (styles, elementName) => {\n          let css = '';\n          const serializeStyles = (elemName, validStyleList) => {\n            const styleList = validStyleList[elemName];\n            if (styleList) {\n              for (let i = 0, l = styleList.length; i < l; i++) {\n                const name = styleList[i];\n                const value = styles[name];\n                if (value) {\n                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n                }\n              }\n            }\n          };\n          const isValid = (name, elemName) => {\n            if (!invalidStyles || !elemName) {\n              return true;\n            }\n            let styleMap = invalidStyles['*'];\n            if (styleMap && styleMap[name]) {\n              return false;\n            }\n            styleMap = invalidStyles[elemName];\n            return !(styleMap && styleMap[name]);\n          };\n          if (elementName && validStyles) {\n            serializeStyles('*', validStyles);\n            serializeStyles(elementName, validStyles);\n          } else {\n            each$d(styles, (value, name) => {\n              if (value && isValid(name, elementName)) {\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n              }\n            });\n          }\n          return css;\n        }\n      };\n      return self;\n    };\n\n    const deprecated = {\n      keyLocation: true,\n      layerX: true,\n      layerY: true,\n      returnValue: true,\n      webkitMovementX: true,\n      webkitMovementY: true,\n      keyIdentifier: true,\n      mozPressure: true\n    };\n    const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\n    const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\n    const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\n    const clone$3 = (originalEvent, data) => {\n      const event = data !== null && data !== void 0 ? data : {};\n      for (const name in originalEvent) {\n        if (!has$2(deprecated, name)) {\n          event[name] = originalEvent[name];\n        }\n      }\n      if (isNonNullable(originalEvent.composedPath)) {\n        event.composedPath = () => originalEvent.composedPath();\n      }\n      if (isNonNullable(originalEvent.getModifierState)) {\n        event.getModifierState = keyArg => originalEvent.getModifierState(keyArg);\n      }\n      if (isNonNullable(originalEvent.getTargetRanges)) {\n        event.getTargetRanges = () => originalEvent.getTargetRanges();\n      }\n      return event;\n    };\n    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\n      var _a;\n      const event = clone$3(originalEvent, data);\n      event.type = type;\n      if (isNullable(event.target)) {\n        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\n      }\n      if (needsNormalizing(originalEvent)) {\n        event.preventDefault = () => {\n          event.defaultPrevented = true;\n          event.isDefaultPrevented = always;\n          if (isFunction(originalEvent.preventDefault)) {\n            originalEvent.preventDefault();\n          }\n        };\n        event.stopPropagation = () => {\n          event.cancelBubble = true;\n          event.isPropagationStopped = always;\n          if (isFunction(originalEvent.stopPropagation)) {\n            originalEvent.stopPropagation();\n          }\n        };\n        event.stopImmediatePropagation = () => {\n          event.isImmediatePropagationStopped = always;\n          event.stopPropagation();\n        };\n        if (!hasIsDefaultPrevented(event)) {\n          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\n          event.isPropagationStopped = event.cancelBubble === true ? always : never;\n          event.isImmediatePropagationStopped = never;\n        }\n      }\n      return event;\n    };\n\n    const eventExpandoPrefix = 'mce-data-';\n    const mouseEventRe = /^(?:mouse|contextmenu)|click/;\n    const addEvent = (target, name, callback, capture) => {\n      target.addEventListener(name, callback, capture || false);\n    };\n    const removeEvent = (target, name, callback, capture) => {\n      target.removeEventListener(name, callback, capture || false);\n    };\n    const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\n    const fix = (originalEvent, data) => {\n      const event = normalize$3(originalEvent.type, originalEvent, document, data);\n      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\n        const eventDoc = event.target.ownerDocument || document;\n        const doc = eventDoc.documentElement;\n        const body = eventDoc.body;\n        const mouseEvent = event;\n        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n      }\n      return event;\n    };\n    const bindOnReady = (win, callback, eventUtils) => {\n      const doc = win.document, event = { type: 'ready' };\n      if (eventUtils.domLoaded) {\n        callback(event);\n        return;\n      }\n      const isDocReady = () => {\n        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\n      };\n      const readyHandler = () => {\n        removeEvent(win, 'DOMContentLoaded', readyHandler);\n        removeEvent(win, 'load', readyHandler);\n        if (!eventUtils.domLoaded) {\n          eventUtils.domLoaded = true;\n          callback(event);\n        }\n        win = null;\n      };\n      if (isDocReady()) {\n        readyHandler();\n      } else {\n        addEvent(win, 'DOMContentLoaded', readyHandler);\n      }\n      if (!eventUtils.domLoaded) {\n        addEvent(win, 'load', readyHandler);\n      }\n    };\n    class EventUtils {\n      constructor() {\n        this.domLoaded = false;\n        this.events = {};\n        this.count = 1;\n        this.expando = eventExpandoPrefix + (+new Date()).toString(32);\n        this.hasFocusIn = 'onfocusin' in document.documentElement;\n        this.count = 1;\n      }\n      bind(target, names, callback, scope) {\n        const self = this;\n        let callbackList;\n        const win = window;\n        const defaultNativeHandler = evt => {\n          self.executeHandlers(fix(evt || win.event), id);\n        };\n        if (!target || isText$a(target) || isComment(target)) {\n          return callback;\n        }\n        let id;\n        if (!target[self.expando]) {\n          id = self.count++;\n          target[self.expando] = id;\n          self.events[id] = {};\n        } else {\n          id = target[self.expando];\n        }\n        scope = scope || target;\n        const namesList = names.split(' ');\n        let i = namesList.length;\n        while (i--) {\n          let name = namesList[i];\n          let nativeHandler = defaultNativeHandler;\n          let capture = false;\n          let fakeName = false;\n          if (name === 'DOMContentLoaded') {\n            name = 'ready';\n          }\n          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\n            callback.call(scope, fix({ type: name }));\n            continue;\n          }\n          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\n            capture = true;\n            fakeName = name === 'focusin' ? 'focus' : 'blur';\n            nativeHandler = evt => {\n              const event = fix(evt || win.event);\n              event.type = event.type === 'focus' ? 'focusin' : 'focusout';\n              self.executeHandlers(event, id);\n            };\n          }\n          callbackList = self.events[id][name];\n          if (!callbackList) {\n            self.events[id][name] = callbackList = [{\n                func: callback,\n                scope\n              }];\n            callbackList.fakeName = fakeName;\n            callbackList.capture = capture;\n            callbackList.nativeHandler = nativeHandler;\n            if (name === 'ready') {\n              bindOnReady(target, nativeHandler, self);\n            } else {\n              addEvent(target, fakeName || name, nativeHandler, capture);\n            }\n          } else {\n            if (name === 'ready' && self.domLoaded) {\n              callback(fix({ type: name }));\n            } else {\n              callbackList.push({\n                func: callback,\n                scope\n              });\n            }\n          }\n        }\n        target = callbackList = null;\n        return callback;\n      }\n      unbind(target, names, callback) {\n        if (!target || isText$a(target) || isComment(target)) {\n          return this;\n        }\n        const id = target[this.expando];\n        if (id) {\n          let eventMap = this.events[id];\n          if (names) {\n            const namesList = names.split(' ');\n            let i = namesList.length;\n            while (i--) {\n              const name = namesList[i];\n              const callbackList = eventMap[name];\n              if (callbackList) {\n                if (callback) {\n                  let ci = callbackList.length;\n                  while (ci--) {\n                    if (callbackList[ci].func === callback) {\n                      const nativeHandler = callbackList.nativeHandler;\n                      const fakeName = callbackList.fakeName, capture = callbackList.capture;\n                      const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n                      newCallbackList.nativeHandler = nativeHandler;\n                      newCallbackList.fakeName = fakeName;\n                      newCallbackList.capture = capture;\n                      eventMap[name] = newCallbackList;\n                    }\n                  }\n                }\n                if (!callback || callbackList.length === 0) {\n                  delete eventMap[name];\n                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n                }\n              }\n            }\n          } else {\n            each$d(eventMap, (callbackList, name) => {\n              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n            });\n            eventMap = {};\n          }\n          for (const name in eventMap) {\n            if (has$2(eventMap, name)) {\n              return this;\n            }\n          }\n          delete this.events[id];\n          try {\n            delete target[this.expando];\n          } catch (ex) {\n            target[this.expando] = null;\n          }\n        }\n        return this;\n      }\n      fire(target, name, args) {\n        return this.dispatch(target, name, args);\n      }\n      dispatch(target, name, args) {\n        if (!target || isText$a(target) || isComment(target)) {\n          return this;\n        }\n        const event = fix({\n          type: name,\n          target\n        }, args);\n        do {\n          const id = target[this.expando];\n          if (id) {\n            this.executeHandlers(event, id);\n          }\n          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n        } while (target && !event.isPropagationStopped());\n        return this;\n      }\n      clean(target) {\n        if (!target || isText$a(target) || isComment(target)) {\n          return this;\n        }\n        if (target[this.expando]) {\n          this.unbind(target);\n        }\n        if (!target.getElementsByTagName) {\n          target = target.document;\n        }\n        if (target && target.getElementsByTagName) {\n          this.unbind(target);\n          const children = target.getElementsByTagName('*');\n          let i = children.length;\n          while (i--) {\n            target = children[i];\n            if (target[this.expando]) {\n              this.unbind(target);\n            }\n          }\n        }\n        return this;\n      }\n      destroy() {\n        this.events = {};\n      }\n      cancel(e) {\n        if (e) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }\n        return false;\n      }\n      executeHandlers(evt, id) {\n        const container = this.events[id];\n        const callbackList = container && container[evt.type];\n        if (callbackList) {\n          for (let i = 0, l = callbackList.length; i < l; i++) {\n            const callback = callbackList[i];\n            if (callback && callback.func.call(callback.scope, evt) === false) {\n              evt.preventDefault();\n            }\n            if (evt.isImmediatePropagationStopped()) {\n              return;\n            }\n          }\n        }\n      }\n    }\n    EventUtils.Event = new EventUtils();\n\n    const each$a = Tools.each;\n    const grep = Tools.grep;\n    const internalStyleName = 'data-mce-style';\n    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\n    const legacySetAttribute = (elm, name, value) => {\n      if (isNullable(value) || value === '') {\n        remove$a(elm, name);\n      } else {\n        set$3(elm, name, value);\n      }\n    };\n    const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\n    const findNodeIndex = (node, normalized) => {\n      let idx = 0;\n      if (node) {\n        for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {\n          const nodeType = tempNode.nodeType;\n          if (normalized && isText$a(tempNode)) {\n            if (nodeType === lastNodeType || !tempNode.data.length) {\n              continue;\n            }\n          }\n          idx++;\n          lastNodeType = nodeType;\n        }\n      }\n      return idx;\n    };\n    const updateInternalStyleAttr = (styles, elm) => {\n      const rawValue = get$9(elm, 'style');\n      const value = styles.serialize(styles.parse(rawValue), name(elm));\n      legacySetAttribute(elm, internalStyleName, value);\n    };\n    const convertStyleToString = (cssValue, cssName) => {\n      if (isNumber(cssValue)) {\n        return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\n      } else {\n        return cssValue;\n      }\n    };\n    const applyStyle$1 = ($elm, cssName, cssValue) => {\n      const normalizedName = camelCaseToHyphens(cssName);\n      if (isNullable(cssValue) || cssValue === '') {\n        remove$6($elm, normalizedName);\n      } else {\n        set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\n      }\n    };\n    const setupAttrHooks = (styles, settings, getContext) => {\n      const keepValues = settings.keep_values;\n      const keepUrlHook = {\n        set: (elm, value, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          if (isFunction(settings.url_converter) && isNonNullable(value)) {\n            value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);\n          }\n          const internalName = 'data-mce-' + name;\n          legacySetAttribute(sugarElm, internalName, value);\n          legacySetAttribute(sugarElm, name, value);\n        },\n        get: (elm, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\n        }\n      };\n      const attrHooks = {\n        style: {\n          set: (elm, value) => {\n            const sugarElm = SugarElement.fromDom(elm);\n            if (keepValues) {\n              legacySetAttribute(sugarElm, internalStyleName, value);\n            }\n            remove$a(sugarElm, 'style');\n            if (isString(value)) {\n              setAll(sugarElm, styles.parse(value));\n            }\n          },\n          get: elm => {\n            const sugarElm = SugarElement.fromDom(elm);\n            const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\n            return styles.serialize(styles.parse(value), name(sugarElm));\n          }\n        }\n      };\n      if (keepValues) {\n        attrHooks.href = attrHooks.src = keepUrlHook;\n      }\n      return attrHooks;\n    };\n    const DOMUtils = (doc, settings = {}) => {\n      const addedStyles = {};\n      const win = window;\n      const files = {};\n      let counter = 0;\n      const stdMode = true;\n      const boxModel = true;\n      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\n        contentCssCors: settings.contentCssCors,\n        referrerPolicy: settings.referrerPolicy\n      });\n      const boundEvents = [];\n      const schema = settings.schema ? settings.schema : Schema({});\n      const styles = Styles({\n        url_converter: settings.url_converter,\n        url_converter_scope: settings.url_converter_scope,\n        force_hex_color: settings.force_hex_color\n      }, settings.schema);\n      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\n      const blockElementsMap = schema.getBlockElements();\n      const isBlock = node => {\n        if (isString(node)) {\n          return has$2(blockElementsMap, node);\n        } else {\n          return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));\n        }\n      };\n      const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\n      const _get = elm => {\n        const value = get(elm);\n        return isNonNullable(value) ? SugarElement.fromDom(value) : null;\n      };\n      const getAttrib = (elm, name, defaultVal = '') => {\n        let value;\n        const $elm = _get(elm);\n        if (isNonNullable($elm) && isElement$7($elm)) {\n          const hook = attrHooks[name];\n          if (hook && hook.get) {\n            value = hook.get($elm.dom, name);\n          } else {\n            value = get$9($elm, name);\n          }\n        }\n        return isNonNullable(value) ? value : defaultVal;\n      };\n      const getAttribs = elm => {\n        const node = get(elm);\n        return isNullable(node) ? [] : node.attributes;\n      };\n      const setAttrib = (elm, name, value) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const val = value === '' ? null : value;\n            const originalValue = get$9($elm, name);\n            const hook = attrHooks[name];\n            if (hook && hook.set) {\n              hook.set($elm.dom, val, name);\n            } else {\n              legacySetAttribute($elm, name, val);\n            }\n            if (originalValue !== val && settings.onSetAttrib) {\n              settings.onSetAttrib({\n                attrElm: $elm.dom,\n                attrName: name,\n                attrValue: val\n              });\n            }\n          }\n        });\n      };\n      const clone = (node, deep) => {\n        return node.cloneNode(deep);\n      };\n      const getRoot = () => settings.root_element || doc.body;\n      const getViewPort = argWin => {\n        const vp = getBounds(argWin);\n        return {\n          x: vp.x,\n          y: vp.y,\n          w: vp.width,\n          h: vp.height\n        };\n      };\n      const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\n      const setStyle = (elm, name, value) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          applyStyle$1($elm, name, value);\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const setStyles = (elm, stylesArg) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          each$d(stylesArg, (v, n) => {\n            applyStyle$1($elm, n, v);\n          });\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const getStyle = (elm, name, computed) => {\n        const $elm = get(elm);\n        if (isNullable($elm) || !isHTMLElement($elm) && !isSVGElement($elm)) {\n          return undefined;\n        }\n        if (computed) {\n          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\n        } else {\n          name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\n          if (name === 'float') {\n            name = 'cssFloat';\n          }\n          return $elm.style ? $elm.style[name] : undefined;\n        }\n      };\n      const getSize = elm => {\n        const $elm = get(elm);\n        if (!$elm) {\n          return {\n            w: 0,\n            h: 0\n          };\n        }\n        let w = getStyle($elm, 'width');\n        let h = getStyle($elm, 'height');\n        if (!w || w.indexOf('px') === -1) {\n          w = '0';\n        }\n        if (!h || h.indexOf('px') === -1) {\n          h = '0';\n        }\n        return {\n          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\n          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\n        };\n      };\n      const getRect = elm => {\n        const $elm = get(elm);\n        const pos = getPos$1($elm);\n        const size = getSize($elm);\n        return {\n          x: pos.x,\n          y: pos.y,\n          w: size.w,\n          h: size.h\n        };\n      };\n      const is = (elm, selector) => {\n        if (!elm) {\n          return false;\n        }\n        const elms = isArray$1(elm) ? elm : [elm];\n        return exists(elms, e => {\n          return is$1(SugarElement.fromDom(e), selector);\n        });\n      };\n      const getParents = (elm, selector, root, collect) => {\n        const result = [];\n        let node = get(elm);\n        collect = collect === undefined;\n        const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\n        if (isString(selector)) {\n          if (selector === '*') {\n            selector = isElement$6;\n          } else {\n            const selectorVal = selector;\n            selector = node => is(node, selectorVal);\n          }\n        }\n        while (node) {\n          if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\n            break;\n          }\n          if (!selector || selector(node)) {\n            if (collect) {\n              result.push(node);\n            } else {\n              return [node];\n            }\n          }\n          node = node.parentNode;\n        }\n        return collect ? result : null;\n      };\n      const getParent = (node, selector, root) => {\n        const parents = getParents(node, selector, root, false);\n        return parents && parents.length > 0 ? parents[0] : null;\n      };\n      const _findSib = (node, selector, name) => {\n        let func = selector;\n        if (node) {\n          if (isString(selector)) {\n            func = node => {\n              return is(node, selector);\n            };\n          }\n          for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {\n            if (isFunction(func) && func(tempNode)) {\n              return tempNode;\n            }\n          }\n        }\n        return null;\n      };\n      const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\n      const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\n      const isParentNode = node => isFunction(node.querySelectorAll);\n      const select = (selector, scope) => {\n        var _a, _b;\n        const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\n        return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];\n      };\n      const run = function (elm, func, scope) {\n        const context = scope !== null && scope !== void 0 ? scope : this;\n        if (isArray$1(elm)) {\n          const result = [];\n          each$a(elm, (e, i) => {\n            const node = get(e);\n            if (node) {\n              result.push(func.call(context, node, i));\n            }\n          });\n          return result;\n        } else {\n          const node = get(elm);\n          return !node ? false : func.call(context, node);\n        }\n      };\n      const setAttribs = (elm, attrs) => {\n        run(elm, $elm => {\n          each$d(attrs, (value, name) => {\n            setAttrib($elm, name, value);\n          });\n        });\n      };\n      const setHTML = (elm, html) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          set$1($elm, html);\n        });\n      };\n      const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\n        const newElm = isString(name) ? doc.createElement(name) : name;\n        if (isNonNullable(attrs)) {\n          setAttribs(newElm, attrs);\n        }\n        if (html) {\n          if (!isString(html) && html.nodeType) {\n            newElm.appendChild(html);\n          } else if (isString(html)) {\n            setHTML(newElm, html);\n          }\n        }\n        return !create ? parentElm.appendChild(newElm) : newElm;\n      });\n      const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\n      const decode = Entities.decode;\n      const encode = Entities.encodeAllRaw;\n      const createHTML = (name, attrs, html = '') => {\n        let outHtml = '<' + name;\n        for (const key in attrs) {\n          if (hasNonNullableKey(attrs, key)) {\n            outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\n          }\n        }\n        if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\n          return outHtml + ' />';\n        } else {\n          return outHtml + '>' + html + '</' + name + '>';\n        }\n      };\n      const createFragment = html => {\n        const container = doc.createElement('div');\n        const frag = doc.createDocumentFragment();\n        frag.appendChild(container);\n        if (html) {\n          container.innerHTML = html;\n        }\n        let node;\n        while (node = container.firstChild) {\n          frag.appendChild(node);\n        }\n        frag.removeChild(container);\n        return frag;\n      };\n      const remove = (node, keepChildren) => {\n        return run(node, n => {\n          const $node = SugarElement.fromDom(n);\n          if (keepChildren) {\n            each$e(children$1($node), child => {\n              if (isText$b(child) && child.dom.length === 0) {\n                remove$5(child);\n              } else {\n                before$3($node, child);\n              }\n            });\n          }\n          remove$5($node);\n          return $node.dom;\n        });\n      };\n      const removeAllAttribs = e => run(e, e => {\n        const attrs = e.attributes;\n        for (let i = attrs.length - 1; i >= 0; i--) {\n          e.removeAttributeNode(attrs.item(i));\n        }\n      });\n      const parseStyle = cssText => styles.parse(cssText);\n      const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\n      const addStyle = cssText => {\n        if (self !== DOMUtils.DOM && doc === document) {\n          if (addedStyles[cssText]) {\n            return;\n          }\n          addedStyles[cssText] = true;\n        }\n        let styleElm = doc.getElementById('mceDefaultStyles');\n        if (!styleElm) {\n          styleElm = doc.createElement('style');\n          styleElm.id = 'mceDefaultStyles';\n          styleElm.type = 'text/css';\n          const head = doc.head;\n          if (head.firstChild) {\n            head.insertBefore(styleElm, head.firstChild);\n          } else {\n            head.appendChild(styleElm);\n          }\n        }\n        if (styleElm.styleSheet) {\n          styleElm.styleSheet.cssText += cssText;\n        } else {\n          styleElm.appendChild(doc.createTextNode(cssText));\n        }\n      };\n      const loadCSS = urls => {\n        if (!urls) {\n          urls = '';\n        }\n        each$e(urls.split(','), url => {\n          files[url] = true;\n          styleSheetLoader.load(url).catch(noop);\n        });\n      };\n      const toggleClass = (elm, cls, state) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const classes = cls.split(' ');\n            each$e(classes, c => {\n              if (isNonNullable(state)) {\n                const fn = state ? add$2 : remove$7;\n                fn($elm, c);\n              } else {\n                toggle$1($elm, c);\n              }\n            });\n          }\n        });\n      };\n      const addClass = (elm, cls) => {\n        toggleClass(elm, cls, true);\n      };\n      const removeClass = (elm, cls) => {\n        toggleClass(elm, cls, false);\n      };\n      const hasClass = (elm, cls) => {\n        const $elm = _get(elm);\n        const classes = cls.split(' ');\n        return isNonNullable($elm) && forall(classes, c => has($elm, c));\n      };\n      const show = elm => {\n        run(elm, e => remove$6(SugarElement.fromDom(e), 'display'));\n      };\n      const hide = elm => {\n        run(elm, e => set$2(SugarElement.fromDom(e), 'display', 'none'));\n      };\n      const isHidden = elm => {\n        const $elm = _get(elm);\n        return isNonNullable($elm) && is$2(getRaw($elm, 'display'), 'none');\n      };\n      const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\n      const getOuterHTML = elm => {\n        const $elm = _get(elm);\n        if (isNonNullable($elm)) {\n          return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\n        } else {\n          return '';\n        }\n      };\n      const setOuterHTML = (elm, html) => {\n        run(elm, $elm => {\n          if (isElement$6($elm)) {\n            $elm.outerHTML = html;\n          }\n        });\n      };\n      const insertAfter = (node, reference) => {\n        const referenceNode = get(reference);\n        return run(node, node => {\n          const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;\n          const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;\n          if (parent) {\n            if (nextSibling) {\n              parent.insertBefore(node, nextSibling);\n            } else {\n              parent.appendChild(node);\n            }\n          }\n          return node;\n        });\n      };\n      const replace = (newElm, oldElm, keepChildren) => run(oldElm, elm => {\n        var _a;\n        const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;\n        if (keepChildren) {\n          each$a(grep(elm.childNodes), node => {\n            replacee.appendChild(node);\n          });\n        }\n        (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);\n        return elm;\n      });\n      const rename = (elm, name) => {\n        if (elm.nodeName !== name.toUpperCase()) {\n          const newElm = create(name);\n          each$a(getAttribs(elm), attrNode => {\n            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\n          });\n          replace(newElm, elm, true);\n          return newElm;\n        } else {\n          return elm;\n        }\n      };\n      const findCommonAncestor = (a, b) => {\n        let ps = a;\n        while (ps) {\n          let pe = b;\n          while (pe && ps !== pe) {\n            pe = pe.parentNode;\n          }\n          if (ps === pe) {\n            break;\n          }\n          ps = ps.parentNode;\n        }\n        if (!ps && a.ownerDocument) {\n          return a.ownerDocument.documentElement;\n        } else {\n          return ps;\n        }\n      };\n      const isNonEmptyElement = node => {\n        if (isElement$6(node)) {\n          const isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');\n          if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {\n            return true;\n          }\n        }\n        return false;\n      };\n      const isEmpty = (node, elements, options) => {\n        let brCount = 0;\n        if (isNonEmptyElement(node)) {\n          return false;\n        }\n        const firstChild = node.firstChild;\n        if (firstChild) {\n          const walker = new DomTreeWalker(firstChild, node);\n          const whitespaceElements = schema ? schema.getWhitespaceElements() : {};\n          const nonEmptyElements = elements || (schema ? schema.getNonEmptyElements() : null);\n          let tempNode = firstChild;\n          do {\n            if (isElement$6(tempNode)) {\n              const bogusVal = tempNode.getAttribute('data-mce-bogus');\n              if (bogusVal) {\n                tempNode = walker.next(bogusVal === 'all');\n                continue;\n              }\n              const name = tempNode.nodeName.toLowerCase();\n              if (nonEmptyElements && nonEmptyElements[name]) {\n                if (name === 'br') {\n                  brCount++;\n                  tempNode = walker.next();\n                  continue;\n                }\n                return false;\n              }\n              if (isNonEmptyElement(tempNode)) {\n                return false;\n              }\n            }\n            if (isComment(tempNode)) {\n              return false;\n            }\n            if (isText$a(tempNode) && !isWhitespaceText(tempNode.data) && (!(options === null || options === void 0 ? void 0 : options.includeZwsp) || !isZwsp(tempNode.data))) {\n              return false;\n            }\n            if (isText$a(tempNode) && tempNode.parentNode && whitespaceElements[tempNode.parentNode.nodeName] && isWhitespaceText(tempNode.data)) {\n              return false;\n            }\n            tempNode = walker.next();\n          } while (tempNode);\n        }\n        return brCount <= 1;\n      };\n      const createRng = () => doc.createRange();\n      const split = (parentElm, splitElm, replacementElm) => {\n        let range = createRng();\n        let beforeFragment;\n        let afterFragment;\n        if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {\n          const parentNode = parentElm.parentNode;\n          range.setStart(parentNode, findNodeIndex(parentElm));\n          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\n          beforeFragment = range.extractContents();\n          range = createRng();\n          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\n          range.setEnd(parentNode, findNodeIndex(parentElm) + 1);\n          afterFragment = range.extractContents();\n          parentNode.insertBefore(trimNode(self, beforeFragment, schema), parentElm);\n          if (replacementElm) {\n            parentNode.insertBefore(replacementElm, parentElm);\n          } else {\n            parentNode.insertBefore(splitElm, parentElm);\n          }\n          parentNode.insertBefore(trimNode(self, afterFragment, schema), parentElm);\n          remove(parentElm);\n          return replacementElm || splitElm;\n        } else {\n          return undefined;\n        }\n      };\n      const bind = (target, name, func, scope) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = bind(target[i], name, func, scope);\n          }\n          return rv;\n        } else {\n          if (settings.collect && (target === doc || target === win)) {\n            boundEvents.push([\n              target,\n              name,\n              func,\n              scope\n            ]);\n          }\n          return events.bind(target, name, func, scope || self);\n        }\n      };\n      const unbind = (target, name, func) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = unbind(target[i], name, func);\n          }\n          return rv;\n        } else {\n          if (boundEvents.length > 0 && (target === doc || target === win)) {\n            let i = boundEvents.length;\n            while (i--) {\n              const [boundTarget, boundName, boundFunc] = boundEvents[i];\n              if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {\n                events.unbind(boundTarget, boundName, boundFunc);\n              }\n            }\n          }\n          return events.unbind(target, name, func);\n        }\n      };\n      const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\n      const fire = (target, name, evt) => events.dispatch(target, name, evt);\n      const getContentEditable = node => {\n        if (node && isHTMLElement(node)) {\n          const contentEditable = node.getAttribute('data-mce-contenteditable');\n          if (contentEditable && contentEditable !== 'inherit') {\n            return contentEditable;\n          }\n          return node.contentEditable !== 'inherit' ? node.contentEditable : null;\n        } else {\n          return null;\n        }\n      };\n      const getContentEditableParent = node => {\n        const root = getRoot();\n        let state = null;\n        for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n          state = getContentEditable(tempNode);\n          if (state !== null) {\n            break;\n          }\n        }\n        return state;\n      };\n      const isEditable = node => {\n        if (isNonNullable(node)) {\n          const scope = isElement$6(node) ? node : node.parentElement;\n          return isNonNullable(scope) && isHTMLElement(scope) && isEditable$2(SugarElement.fromDom(scope));\n        } else {\n          return false;\n        }\n      };\n      const destroy = () => {\n        if (boundEvents.length > 0) {\n          let i = boundEvents.length;\n          while (i--) {\n            const [boundTarget, boundName, boundFunc] = boundEvents[i];\n            events.unbind(boundTarget, boundName, boundFunc);\n          }\n        }\n        each$d(files, (_, url) => {\n          styleSheetLoader.unload(url);\n          delete files[url];\n        });\n      };\n      const isChildOf = (node, parent) => {\n        return node === parent || parent.contains(node);\n      };\n      const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\n      const self = {\n        doc,\n        settings,\n        win,\n        files,\n        stdMode,\n        boxModel,\n        styleSheetLoader,\n        boundEvents,\n        styles,\n        schema,\n        events,\n        isBlock: isBlock,\n        root: null,\n        clone,\n        getRoot,\n        getViewPort,\n        getRect,\n        getSize,\n        getParent,\n        getParents: getParents,\n        get,\n        getNext,\n        getPrev,\n        select,\n        is,\n        add,\n        create,\n        createHTML,\n        createFragment,\n        remove,\n        setStyle,\n        getStyle: getStyle,\n        setStyles,\n        removeAllAttribs,\n        setAttrib,\n        setAttribs,\n        getAttrib,\n        getPos: getPos$1,\n        parseStyle,\n        serializeStyle,\n        addStyle,\n        loadCSS,\n        addClass,\n        removeClass,\n        hasClass,\n        toggleClass,\n        show,\n        hide,\n        isHidden,\n        uniqueId,\n        setHTML,\n        getOuterHTML,\n        setOuterHTML,\n        decode,\n        encode,\n        insertAfter,\n        replace,\n        rename,\n        findCommonAncestor,\n        run,\n        getAttribs,\n        isEmpty,\n        createRng,\n        nodeIndex: findNodeIndex,\n        split,\n        bind: bind,\n        unbind: unbind,\n        fire,\n        dispatch,\n        getContentEditable,\n        getContentEditableParent,\n        isEditable,\n        destroy,\n        isChildOf,\n        dumpRng\n      };\n      const attrHooks = setupAttrHooks(styles, settings, constant(self));\n      return self;\n    };\n    DOMUtils.DOM = DOMUtils(document);\n    DOMUtils.nodeIndex = findNodeIndex;\n\n    const DOM$b = DOMUtils.DOM;\n    const QUEUED = 0;\n    const LOADING = 1;\n    const LOADED = 2;\n    const FAILED = 3;\n    class ScriptLoader {\n      constructor(settings = {}) {\n        this.states = {};\n        this.queue = [];\n        this.scriptLoadedCallbacks = {};\n        this.queueLoadedCallbacks = [];\n        this.loading = false;\n        this.settings = settings;\n      }\n      _setReferrerPolicy(referrerPolicy) {\n        this.settings.referrerPolicy = referrerPolicy;\n      }\n      loadScript(url) {\n        return new Promise((resolve, reject) => {\n          const dom = DOM$b;\n          let elm;\n          const cleanup = () => {\n            dom.remove(id);\n            if (elm) {\n              elm.onerror = elm.onload = elm = null;\n            }\n          };\n          const done = () => {\n            cleanup();\n            resolve();\n          };\n          const error = () => {\n            cleanup();\n            reject('Failed to load script: ' + url);\n          };\n          const id = dom.uniqueId();\n          elm = document.createElement('script');\n          elm.id = id;\n          elm.type = 'text/javascript';\n          elm.src = Tools._addCacheSuffix(url);\n          if (this.settings.referrerPolicy) {\n            dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\n          }\n          elm.onload = done;\n          elm.onerror = error;\n          (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\n        });\n      }\n      isDone(url) {\n        return this.states[url] === LOADED;\n      }\n      markDone(url) {\n        this.states[url] = LOADED;\n      }\n      add(url) {\n        const self = this;\n        self.queue.push(url);\n        const state = self.states[url];\n        if (state === undefined) {\n          self.states[url] = QUEUED;\n        }\n        return new Promise((resolve, reject) => {\n          if (!self.scriptLoadedCallbacks[url]) {\n            self.scriptLoadedCallbacks[url] = [];\n          }\n          self.scriptLoadedCallbacks[url].push({\n            resolve,\n            reject\n          });\n        });\n      }\n      load(url) {\n        return this.add(url);\n      }\n      remove(url) {\n        delete this.states[url];\n        delete this.scriptLoadedCallbacks[url];\n      }\n      loadQueue() {\n        const queue = this.queue;\n        this.queue = [];\n        return this.loadScripts(queue);\n      }\n      loadScripts(scripts) {\n        const self = this;\n        const execCallbacks = (name, url) => {\n          get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\n            each$e(callbacks, callback => callback[name](url));\n          });\n          delete self.scriptLoadedCallbacks[url];\n        };\n        const processResults = results => {\n          const failures = filter$5(results, result => result.status === 'rejected');\n          if (failures.length > 0) {\n            return Promise.reject(bind$3(failures, ({reason}) => isArray$1(reason) ? reason : [reason]));\n          } else {\n            return Promise.resolve();\n          }\n        };\n        const load = urls => Promise.allSettled(map$3(urls, url => {\n          if (self.states[url] === LOADED) {\n            execCallbacks('resolve', url);\n            return Promise.resolve();\n          } else if (self.states[url] === FAILED) {\n            execCallbacks('reject', url);\n            return Promise.reject(url);\n          } else {\n            self.states[url] = LOADING;\n            return self.loadScript(url).then(() => {\n              self.states[url] = LOADED;\n              execCallbacks('resolve', url);\n              const queue = self.queue;\n              if (queue.length > 0) {\n                self.queue = [];\n                return load(queue).then(processResults);\n              } else {\n                return Promise.resolve();\n              }\n            }, () => {\n              self.states[url] = FAILED;\n              execCallbacks('reject', url);\n              return Promise.reject(url);\n            });\n          }\n        }));\n        const processQueue = urls => {\n          self.loading = true;\n          return load(urls).then(results => {\n            self.loading = false;\n            const nextQueuedItem = self.queueLoadedCallbacks.shift();\n            Optional.from(nextQueuedItem).each(call);\n            return processResults(results);\n          });\n        };\n        const uniqueScripts = stringArray(scripts);\n        if (self.loading) {\n          return new Promise((resolve, reject) => {\n            self.queueLoadedCallbacks.push(() => {\n              processQueue(uniqueScripts).then(resolve, reject);\n            });\n          });\n        } else {\n          return processQueue(uniqueScripts);\n        }\n      }\n    }\n    ScriptLoader.ScriptLoader = new ScriptLoader();\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const isDuplicated = (items, item) => {\n      const firstIndex = items.indexOf(item);\n      return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;\n    };\n    const isRaw = str => isObject(str) && has$2(str, 'raw');\n    const isTokenised = str => isArray$1(str) && str.length > 1;\n    const data = {};\n    const currentCode = Cell('en');\n    const getLanguageData = () => get$a(data, currentCode.get());\n    const getData$1 = () => map$2(data, value => ({ ...value }));\n    const setCode = newCode => {\n      if (newCode) {\n        currentCode.set(newCode);\n      }\n    };\n    const getCode = () => currentCode.get();\n    const add$1 = (code, items) => {\n      let langData = data[code];\n      if (!langData) {\n        data[code] = langData = {};\n      }\n      const lcNames = map$3(keys(items), name => name.toLowerCase());\n      each$d(items, (translation, name) => {\n        const lcName = name.toLowerCase();\n        if (lcName !== name && isDuplicated(lcNames, lcName)) {\n          if (!has$2(items, lcName)) {\n            langData[lcName] = translation;\n          }\n          langData[name] = translation;\n        } else {\n          langData[lcName] = translation;\n        }\n      });\n    };\n    const translate = text => {\n      const langData = getLanguageData().getOr({});\n      const toString = obj => {\n        if (isFunction(obj)) {\n          return Object.prototype.toString.call(obj);\n        }\n        return !isEmpty(obj) ? '' + obj : '';\n      };\n      const isEmpty = text => text === '' || text === null || text === undefined;\n      const getLangData = text => {\n        const textStr = toString(text);\n        return has$2(langData, textStr) ? toString(langData[textStr]) : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);\n      };\n      const removeContext = str => str.replace(/{context:\\w+}$/, '');\n      if (isEmpty(text)) {\n        return '';\n      }\n      if (isRaw(text)) {\n        return toString(text.raw);\n      }\n      if (isTokenised(text)) {\n        const values = text.slice(1);\n        const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\n        return removeContext(substitued);\n      }\n      return removeContext(getLangData(text));\n    };\n    const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\n    const hasCode = code => has$2(data, code);\n    const I18n = {\n      getData: getData$1,\n      setCode,\n      getCode,\n      add: add$1,\n      translate,\n      isRtl: isRtl$1,\n      hasCode\n    };\n\n    const AddOnManager = () => {\n      const items = [];\n      const urls = {};\n      const lookup = {};\n      const _listeners = [];\n      const runListeners = (name, state) => {\n        const matchedListeners = filter$5(_listeners, listener => listener.name === name && listener.state === state);\n        each$e(matchedListeners, listener => listener.resolve());\n      };\n      const isLoaded = name => has$2(urls, name);\n      const isAdded = name => has$2(lookup, name);\n      const get = name => {\n        if (lookup[name]) {\n          return lookup[name].instance;\n        }\n        return undefined;\n      };\n      const loadLanguagePack = (name, languages) => {\n        const language = I18n.getCode();\n        const wrappedLanguages = ',' + (languages || '') + ',';\n        if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\n          return;\n        }\n        ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\n      };\n      const requireLangPack = (name, languages) => {\n        if (AddOnManager.languageLoad !== false) {\n          if (isLoaded(name)) {\n            loadLanguagePack(name, languages);\n          } else {\n            waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\n          }\n        }\n      };\n      const add = (id, addOn) => {\n        items.push(addOn);\n        lookup[id] = { instance: addOn };\n        runListeners(id, 'added');\n        return addOn;\n      };\n      const remove = name => {\n        delete urls[name];\n        delete lookup[name];\n      };\n      const createUrl = (baseUrl, dep) => {\n        if (isString(dep)) {\n          return isString(baseUrl) ? {\n            prefix: '',\n            resource: dep,\n            suffix: ''\n          } : {\n            prefix: baseUrl.prefix,\n            resource: dep,\n            suffix: baseUrl.suffix\n          };\n        } else {\n          return dep;\n        }\n      };\n      const load = (name, addOnUrl) => {\n        if (urls[name]) {\n          return Promise.resolve();\n        }\n        let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\n          urlString = AddOnManager.baseURL + '/' + urlString;\n        }\n        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\n        const done = () => {\n          runListeners(name, 'loaded');\n          return Promise.resolve();\n        };\n        if (lookup[name]) {\n          return done();\n        } else {\n          return ScriptLoader.ScriptLoader.add(urlString).then(done);\n        }\n      };\n      const waitFor = (name, state = 'added') => {\n        if (state === 'added' && isAdded(name)) {\n          return Promise.resolve();\n        } else if (state === 'loaded' && isLoaded(name)) {\n          return Promise.resolve();\n        } else {\n          return new Promise(resolve => {\n            _listeners.push({\n              name,\n              state,\n              resolve\n            });\n          });\n        }\n      };\n      return {\n        items,\n        urls,\n        lookup,\n        get,\n        requireLangPack,\n        add,\n        remove,\n        createUrl,\n        load,\n        waitFor\n      };\n    };\n    AddOnManager.languageLoad = true;\n    AddOnManager.baseURL = '';\n    AddOnManager.PluginManager = AddOnManager();\n    AddOnManager.ThemeManager = AddOnManager();\n    AddOnManager.ModelManager = AddOnManager();\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const repeatable = delay => {\n      const intervalId = Cell(Optional.none());\n      const revoke = () => intervalId.get().each(id => clearInterval(id));\n      const clear = () => {\n        revoke();\n        intervalId.set(Optional.none());\n      };\n      const isSet = () => intervalId.get().isSome();\n      const get = () => intervalId.get();\n      const set = functionToRepeat => {\n        revoke();\n        intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value$2 = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const first$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        if (isNull(timer)) {\n          timer = setTimeout(() => {\n            timer = null;\n            fn.apply(null, args);\n          }, rate);\n        }\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n    const last$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const annotation = constant('mce-annotation');\n    const dataAnnotation = constant('data-mce-annotation');\n    const dataAnnotationId = constant('data-mce-annotation-uid');\n    const dataAnnotationActive = constant('data-mce-annotation-active');\n    const dataAnnotationClasses = constant('data-mce-annotation-classes');\n    const dataAnnotationAttributes = constant('data-mce-annotation-attrs');\n\n    const isRoot$1 = root => node => eq(node, root);\n    const identify = (editor, annotationName) => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const root = SugarElement.fromDom(editor.getBody());\n      const selector = annotationName.fold(() => '.' + annotation(), an => `[${ dataAnnotation() }=\"${ an }\"]`);\n      const newStart = child$1(start, rng.startOffset).getOr(start);\n      const closest = closest$3(newStart, selector, isRoot$1(root));\n      return closest.bind(c => getOpt(c, `${ dataAnnotationId() }`).bind(uid => getOpt(c, `${ dataAnnotation() }`).map(name => {\n        const elements = findMarkers(editor, uid);\n        return {\n          uid,\n          name,\n          elements\n        };\n      })));\n    };\n    const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\n    const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$2(elem, '[data-mce-bogus=\"all\"]', isRoot$1(root));\n    const findMarkers = (editor, uid) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const descendants$1 = descendants(body, `[${ dataAnnotationId() }=\"${ uid }\"]`);\n      return filter$5(descendants$1, descendant => !isBogusElement(descendant, body));\n    };\n    const findAll = (editor, name) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const markers = descendants(body, `[${ dataAnnotation() }=\"${ name }\"]`);\n      const directory = {};\n      each$e(markers, m => {\n        if (!isBogusElement(m, body)) {\n          const uid = get$9(m, dataAnnotationId());\n          const nodesAlready = get$a(directory, uid).getOr([]);\n          directory[uid] = nodesAlready.concat([m]);\n        }\n      });\n      return directory;\n    };\n\n    const setup$y = (editor, registry) => {\n      const changeCallbacks = Cell({});\n      const initData = () => ({\n        listeners: [],\n        previous: value$2()\n      });\n      const withCallbacks = (name, f) => {\n        updateCallbacks(name, data => {\n          f(data);\n          return data;\n        });\n      };\n      const updateCallbacks = (name, f) => {\n        const callbackMap = changeCallbacks.get();\n        const data = get$a(callbackMap, name).getOrThunk(initData);\n        const outputData = f(data);\n        callbackMap[name] = outputData;\n        changeCallbacks.set(callbackMap);\n      };\n      const fireCallbacks = (name, uid, elements) => {\n        withCallbacks(name, data => {\n          each$e(data.listeners, f => f(true, name, {\n            uid,\n            nodes: map$3(elements, elem => elem.dom)\n          }));\n        });\n      };\n      const fireNoAnnotation = name => {\n        withCallbacks(name, data => {\n          each$e(data.listeners, f => f(false, name));\n        });\n      };\n      const toggleActiveAttr = (uid, state) => {\n        each$e(findMarkers(editor, uid), elem => {\n          if (state) {\n            set$3(elem, dataAnnotationActive(), 'true');\n          } else {\n            remove$a(elem, dataAnnotationActive());\n          }\n        });\n      };\n      const onNodeChange = last$1(() => {\n        const annotations = sort(registry.getNames());\n        each$e(annotations, name => {\n          updateCallbacks(name, data => {\n            const prev = data.previous.get();\n            identify(editor, Optional.some(name)).fold(() => {\n              prev.each(uid => {\n                fireNoAnnotation(name);\n                data.previous.clear();\n                toggleActiveAttr(uid, false);\n              });\n            }, ({uid, name, elements}) => {\n              if (!is$2(prev, uid)) {\n                prev.each(uid => toggleActiveAttr(uid, false));\n                fireCallbacks(name, uid, elements);\n                data.previous.set(uid);\n                toggleActiveAttr(uid, true);\n              }\n            });\n            return {\n              previous: data.previous,\n              listeners: data.listeners\n            };\n          });\n        });\n      }, 30);\n      editor.on('remove', () => {\n        onNodeChange.cancel();\n      });\n      editor.on('NodeChange', () => {\n        onNodeChange.throttle();\n      });\n      const addListener = (name, f) => {\n        updateCallbacks(name, data => ({\n          previous: data.previous,\n          listeners: data.listeners.concat([f])\n        }));\n      };\n      return { addListener };\n    };\n\n    const setup$x = (editor, registry) => {\n      const dataAnnotation$1 = dataAnnotation();\n      const identifyParserNode = node => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);\n      const removeDirectAnnotation = node => {\n        var _a, _b;\n        node.attr(dataAnnotationId(), null);\n        node.attr(dataAnnotation(), null);\n        node.attr(dataAnnotationActive(), null);\n        const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map(names => names.split(',')).getOr([]);\n        const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map(names => names.split(',')).getOr([]);\n        each$e(customAttrNames, name => node.attr(name, null));\n        const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];\n        const newClassList = difference(classList, [annotation()].concat(customClasses));\n        node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);\n        node.attr(dataAnnotationClasses(), null);\n        node.attr(dataAnnotationAttributes(), null);\n      };\n      editor.serializer.addTempAttr(dataAnnotationActive());\n      editor.serializer.addAttributeFilter(dataAnnotation$1, nodes => {\n        for (const node of nodes) {\n          identifyParserNode(node).each(settings => {\n            if (settings.persistent === false) {\n              if (node.name === 'span') {\n                node.unwrap();\n              } else {\n                removeDirectAnnotation(node);\n              }\n            }\n          });\n        }\n      });\n    };\n\n    const create$c = () => {\n      const annotations = {};\n      const register = (name, settings) => {\n        annotations[name] = {\n          name,\n          settings\n        };\n      };\n      const lookup = name => get$a(annotations, name).map(a => a.settings);\n      const getNames = () => keys(annotations);\n      return {\n        register,\n        lookup,\n        getNames\n      };\n    };\n\n    let unique = 0;\n    const generate$1 = prefix => {\n      const date = new Date();\n      const time = date.getTime();\n      const random = Math.floor(Math.random() * 1000000000);\n      unique++;\n      return prefix + '_' + random + unique + String(time);\n    };\n\n    const add = (element, classes) => {\n      each$e(classes, x => {\n        add$2(element, x);\n      });\n    };\n    const remove$4 = (element, classes) => {\n      each$e(classes, x => {\n        remove$7(element, x);\n      });\n    };\n\n    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow$1 = original => clone$2(original, false);\n    const deep$1 = original => clone$2(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$4(original);\n      setAll$1(nu, attributes);\n      return nu;\n    };\n    const mutate = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after$4(original, nu);\n      const children = children$1(original);\n      append(nu, children);\n      remove$5(original);\n      return nu;\n    };\n\n    const TextWalker = (startNode, rootNode, isBoundary = never) => {\n      const walker = new DomTreeWalker(startNode, rootNode);\n      const walk = direction => {\n        let next;\n        do {\n          next = walker[direction]();\n        } while (next && !isText$a(next) && !isBoundary(next));\n        return Optional.from(next).filter(isText$a);\n      };\n      return {\n        current: () => Optional.from(walker.current()).filter(isText$a),\n        next: () => walk('next'),\n        prev: () => walk('prev'),\n        prev2: () => walk('prev2')\n      };\n    };\n\n    const TextSeeker = (dom, isBoundary) => {\n      const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);\n      const walk = (node, offset, walker, process) => {\n        if (isText$a(node)) {\n          const newOffset = process(node, offset, node.data);\n          if (newOffset !== -1) {\n            return Optional.some({\n              container: node,\n              offset: newOffset\n            });\n          }\n        }\n        return walker().bind(next => walk(next.container, next.offset, walker, process));\n      };\n      const backwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n        return walk(node, offset, () => walker.prev().map(prev => ({\n          container: prev,\n          offset: prev.length\n        })), process).getOrNull();\n      };\n      const forwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n        return walk(node, offset, () => walker.next().map(next => ({\n          container: next,\n          offset: 0\n        })), process).getOrNull();\n      };\n      return {\n        backwards,\n        forwards\n      };\n    };\n\n    const round$2 = Math.round;\n    const clone$1 = rect => {\n      if (!rect) {\n        return {\n          left: 0,\n          top: 0,\n          bottom: 0,\n          right: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      return {\n        left: round$2(rect.left),\n        top: round$2(rect.top),\n        bottom: round$2(rect.bottom),\n        right: round$2(rect.right),\n        width: round$2(rect.width),\n        height: round$2(rect.height)\n      };\n    };\n    const collapse = (rect, toStart) => {\n      rect = clone$1(rect);\n      if (toStart) {\n        rect.right = rect.left;\n      } else {\n        rect.left = rect.left + rect.width;\n        rect.right = rect.left;\n      }\n      rect.width = 0;\n      return rect;\n    };\n    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\n    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\n    const isAbove$1 = (rect1, rect2) => {\n      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\n      if (rect1.bottom - halfHeight < rect2.top) {\n        return true;\n      }\n      if (rect1.top > rect2.bottom) {\n        return false;\n      }\n      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\n    };\n    const isBelow$1 = (rect1, rect2) => {\n      if (rect1.top > rect2.bottom) {\n        return true;\n      }\n      if (rect1.bottom < rect2.top) {\n        return false;\n      }\n      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\n    };\n    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n    const boundingClientRectFromRects = rects => {\n      return foldl(rects, (acc, rect) => {\n        return acc.fold(() => Optional.some(rect), prevRect => {\n          const left = Math.min(rect.left, prevRect.left);\n          const top = Math.min(rect.top, prevRect.top);\n          const right = Math.max(rect.right, prevRect.right);\n          const bottom = Math.max(rect.bottom, prevRect.bottom);\n          return Optional.some({\n            top,\n            right,\n            bottom,\n            left,\n            width: right - left,\n            height: bottom - top\n          });\n        });\n      }, Optional.none());\n    };\n    const distanceToRectEdgeFromXY = (rect, x, y) => {\n      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\n      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\n      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\n    };\n    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\n\n    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\n\n    const getSelectedNode = range => {\n      const startContainer = range.startContainer, startOffset = range.startOffset;\n      if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\n        return startContainer.childNodes[startOffset];\n      }\n      return null;\n    };\n    const getNode$1 = (container, offset) => {\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const childNodes = container.childNodes;\n        const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\n        return childNodes[safeOffset];\n      } else {\n        return container;\n      }\n    };\n    const getNodeUnsafe = (container, offset) => {\n      if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\n        return undefined;\n      } else {\n        return getNode$1(container, offset);\n      }\n    };\n\n    const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\n    const isExtendingChar = ch => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n\n    const or = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (args[i](x)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const and = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (!args[i](x)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    };\n\n    const isElement$4 = isElement$6;\n    const isCaretCandidate$2 = isCaretCandidate$3;\n    const isBlock$2 = matchStyleValues('display', 'block table');\n    const isFloated = matchStyleValues('float', 'left right');\n    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\n    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\n    const isText$7 = isText$a;\n    const isBr$3 = isBr$6;\n    const nodeIndex$1 = DOMUtils.nodeIndex;\n    const resolveIndex$1 = getNodeUnsafe;\n    const createRange$1 = doc => doc ? doc.createRange() : DOMUtils.DOM.createRng();\n    const isWhiteSpace$1 = chr => isString(chr) && /[\\r\\n\\t ]/.test(chr);\n    const isRange = rng => !!rng.setStart && !!rng.setEnd;\n    const isHiddenWhiteSpaceRange = range => {\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$a(container)) {\n        const text = container.data;\n        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const getBrClientRect = brNode => {\n      const doc = brNode.ownerDocument;\n      const rng = createRange$1(doc);\n      const nbsp$1 = doc.createTextNode(nbsp);\n      const parentNode = brNode.parentNode;\n      parentNode.insertBefore(nbsp$1, brNode);\n      rng.setStart(nbsp$1, 0);\n      rng.setEnd(nbsp$1, 1);\n      const clientRect = clone$1(rng.getBoundingClientRect());\n      parentNode.removeChild(nbsp$1);\n      return clientRect;\n    };\n    const getBoundingClientRectWebKitText = rng => {\n      const sc = rng.startContainer;\n      const ec = rng.endContainer;\n      const so = rng.startOffset;\n      const eo = rng.endOffset;\n      if (sc === ec && isText$a(ec) && so === 0 && eo === 1) {\n        const newRng = rng.cloneRange();\n        newRng.setEndAfter(ec);\n        return getBoundingClientRect$1(newRng);\n      } else {\n        return null;\n      }\n    };\n    const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\n    const getBoundingClientRect$1 = item => {\n      var _a;\n      let clientRect;\n      const clientRects = item.getClientRects();\n      if (clientRects.length > 0) {\n        clientRect = clone$1(clientRects[0]);\n      } else {\n        clientRect = clone$1(item.getBoundingClientRect());\n      }\n      if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {\n        return getBrClientRect(item);\n      }\n      if (isZeroRect(clientRect) && isRange(item)) {\n        return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;\n      }\n      return clientRect;\n    };\n    const collapseAndInflateWidth = (clientRect, toStart) => {\n      const newClientRect = collapse(clientRect, toStart);\n      newClientRect.width = 1;\n      newClientRect.right = newClientRect.left + 1;\n      return newClientRect;\n    };\n    const getCaretPositionClientRects = caretPosition => {\n      const clientRects = [];\n      const addUniqueAndValidRect = clientRect => {\n        if (clientRect.height === 0) {\n          return;\n        }\n        if (clientRects.length > 0) {\n          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\n            return;\n          }\n        }\n        clientRects.push(clientRect);\n      };\n      const addCharacterOffset = (container, offset) => {\n        const range = createRange$1(container.ownerDocument);\n        if (offset < container.data.length) {\n          if (isExtendingChar(container.data[offset])) {\n            return;\n          }\n          if (isExtendingChar(container.data[offset - 1])) {\n            range.setStart(container, offset);\n            range.setEnd(container, offset + 1);\n            if (!isHiddenWhiteSpaceRange(range)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n              return;\n            }\n          }\n        }\n        if (offset > 0) {\n          range.setStart(container, offset - 1);\n          range.setEnd(container, offset);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n          }\n        }\n        if (offset < container.data.length) {\n          range.setStart(container, offset);\n          range.setEnd(container, offset + 1);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\n          }\n        }\n      };\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (isText$7(container)) {\n        addCharacterOffset(container, offset);\n        return clientRects;\n      }\n      if (isElement$4(container)) {\n        if (caretPosition.isAtEnd()) {\n          const node = resolveIndex$1(container, offset);\n          if (isText$7(node)) {\n            addCharacterOffset(node, node.data.length);\n          }\n          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n          }\n        } else {\n          const node = resolveIndex$1(container, offset);\n          if (isText$7(node)) {\n            addCharacterOffset(node, 0);\n          }\n          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n            return clientRects;\n          }\n          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\n          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {\n            if (isBlock$2(beforeNode) || isBlock$2(node) || !isValidElementCaretCandidate(node)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\n            }\n          }\n          if (isValidElementCaretCandidate(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\n          }\n        }\n      }\n      return clientRects;\n    };\n    const CaretPosition = (container, offset, clientRects) => {\n      const isAtStart = () => {\n        if (isText$7(container)) {\n          return offset === 0;\n        }\n        return offset === 0;\n      };\n      const isAtEnd = () => {\n        if (isText$7(container)) {\n          return offset >= container.data.length;\n        }\n        return offset >= container.childNodes.length;\n      };\n      const toRange = () => {\n        const range = createRange$1(container.ownerDocument);\n        range.setStart(container, offset);\n        range.setEnd(container, offset);\n        return range;\n      };\n      const getClientRects = () => {\n        if (!clientRects) {\n          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\n        }\n        return clientRects;\n      };\n      const isVisible = () => getClientRects().length > 0;\n      const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\n      const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\n      return {\n        container: constant(container),\n        offset: constant(offset),\n        toRange,\n        getClientRects,\n        isVisible,\n        isAtStart,\n        isAtEnd,\n        isEqual,\n        getNode\n      };\n    };\n    CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\n    CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\n    CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\n    CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\n    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);\n    CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\n    CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\n    CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\n    CaretPosition.isTextPosition = pos => pos ? isText$a(pos.container()) : false;\n    CaretPosition.isElementPosition = pos => !CaretPosition.isTextPosition(pos);\n\n    const trimEmptyTextNode$1 = (dom, node) => {\n      if (isText$a(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const insertNode = (dom, rng, node) => {\n      rng.insertNode(node);\n      trimEmptyTextNode$1(dom, node.previousSibling);\n      trimEmptyTextNode$1(dom, node.nextSibling);\n    };\n    const insertFragment = (dom, rng, frag) => {\n      const firstChild = Optional.from(frag.firstChild);\n      const lastChild = Optional.from(frag.lastChild);\n      rng.insertNode(frag);\n      firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\n      lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\n    };\n    const rangeInsertNode = (dom, rng, node) => {\n      if (isDocumentFragment(node)) {\n        insertFragment(dom, rng, node);\n      } else {\n        insertNode(dom, rng, node);\n      }\n    };\n\n    const isText$6 = isText$a;\n    const isBogus = isBogus$2;\n    const nodeIndex = DOMUtils.nodeIndex;\n    const normalizedParent = node => {\n      const parentNode = node.parentNode;\n      if (isBogus(parentNode)) {\n        return normalizedParent(parentNode);\n      }\n      return parentNode;\n    };\n    const getChildNodes = node => {\n      if (!node) {\n        return [];\n      }\n      return reduce(node.childNodes, (result, node) => {\n        if (isBogus(node) && node.nodeName !== 'BR') {\n          result = result.concat(getChildNodes(node));\n        } else {\n          result.push(node);\n        }\n        return result;\n      }, []);\n    };\n    const normalizedTextOffset = (node, offset) => {\n      let tempNode = node;\n      while (tempNode = tempNode.previousSibling) {\n        if (!isText$6(tempNode)) {\n          break;\n        }\n        offset += tempNode.data.length;\n      }\n      return offset;\n    };\n    const equal = a => b => a === b;\n    const normalizedNodeIndex = node => {\n      let nodes, index;\n      nodes = getChildNodes(normalizedParent(node));\n      index = findIndex$1(nodes, equal(node), node);\n      nodes = nodes.slice(0, index + 1);\n      const numTextFragments = reduce(nodes, (result, node, i) => {\n        if (isText$6(node) && isText$6(nodes[i - 1])) {\n          result++;\n        }\n        return result;\n      }, 0);\n      nodes = filter$3(nodes, matchNodeNames([node.nodeName]));\n      index = findIndex$1(nodes, equal(node), node);\n      return index - numTextFragments;\n    };\n    const createPathItem = node => {\n      const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();\n      return name + '[' + normalizedNodeIndex(node) + ']';\n    };\n    const parentsUntil$1 = (root, node, predicate) => {\n      const parents = [];\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        if (predicate && predicate(tempNode)) {\n          break;\n        }\n        parents.push(tempNode);\n      }\n      return parents;\n    };\n    const create$b = (root, caretPosition) => {\n      let path = [];\n      let container = caretPosition.container();\n      let offset = caretPosition.offset();\n      let outputOffset;\n      if (isText$6(container)) {\n        outputOffset = normalizedTextOffset(container, offset);\n      } else {\n        const childNodes = container.childNodes;\n        if (offset >= childNodes.length) {\n          outputOffset = 'after';\n          offset = childNodes.length - 1;\n        } else {\n          outputOffset = 'before';\n        }\n        container = childNodes[offset];\n      }\n      path.push(createPathItem(container));\n      let parents = parentsUntil$1(root, container);\n      parents = filter$3(parents, not(isBogus$2));\n      path = path.concat(map$1(parents, node => {\n        return createPathItem(node);\n      }));\n      return path.reverse().join('/') + ',' + outputOffset;\n    };\n    const resolvePathItem = (node, name, index) => {\n      let nodes = getChildNodes(node);\n      nodes = filter$3(nodes, (node, index) => {\n        return !isText$6(node) || !isText$6(nodes[index - 1]);\n      });\n      nodes = filter$3(nodes, matchNodeNames([name]));\n      return nodes[index];\n    };\n    const findTextPosition = (container, offset) => {\n      let node = container;\n      let targetOffset = 0;\n      while (isText$6(node)) {\n        const dataLen = node.data.length;\n        if (offset >= targetOffset && offset <= targetOffset + dataLen) {\n          container = node;\n          offset = offset - targetOffset;\n          break;\n        }\n        if (!isText$6(node.nextSibling)) {\n          container = node;\n          offset = dataLen;\n          break;\n        }\n        targetOffset += dataLen;\n        node = node.nextSibling;\n      }\n      if (isText$6(container) && offset > container.data.length) {\n        offset = container.data.length;\n      }\n      return CaretPosition(container, offset);\n    };\n    const resolve$1 = (root, path) => {\n      if (!path) {\n        return null;\n      }\n      const parts = path.split(',');\n      const paths = parts[0].split('/');\n      const offset = parts.length > 1 ? parts[1] : 'before';\n      const container = reduce(paths, (result, value) => {\n        const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\n        if (!match) {\n          return null;\n        }\n        if (match[1] === 'text()') {\n          match[1] = '#text';\n        }\n        return resolvePathItem(result, match[1], parseInt(match[2], 10));\n      }, root);\n      if (!container) {\n        return null;\n      }\n      if (!isText$6(container) && container.parentNode) {\n        let nodeOffset;\n        if (offset === 'after') {\n          nodeOffset = nodeIndex(container) + 1;\n        } else {\n          nodeOffset = nodeIndex(container);\n        }\n        return CaretPosition(container.parentNode, nodeOffset);\n      }\n      return findTextPosition(container, parseInt(offset, 10));\n    };\n\n    const isContentEditableFalse$9 = isContentEditableFalse$b;\n    const getNormalizedTextOffset$1 = (trim, container, offset) => {\n      let trimmedOffset = trim(container.data.slice(0, offset)).length;\n      for (let node = container.previousSibling; node && isText$a(node); node = node.previousSibling) {\n        trimmedOffset += trim(node.data).length;\n      }\n      return trimmedOffset;\n    };\n    const getPoint = (dom, trim, normalized, rng, start) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      const point = [];\n      const root = dom.getRoot();\n      if (isText$a(container)) {\n        point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);\n      } else {\n        let after = 0;\n        const childNodes = container.childNodes;\n        if (offset >= childNodes.length && childNodes.length) {\n          after = 1;\n          offset = Math.max(0, childNodes.length - 1);\n        }\n        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n      }\n      for (let node = container; node && node !== root; node = node.parentNode) {\n        point.push(dom.nodeIndex(node, normalized));\n      }\n      return point;\n    };\n    const getLocation = (trim, selection, normalized, rng) => {\n      const dom = selection.dom;\n      const start = getPoint(dom, trim, normalized, rng, true);\n      const forward = selection.isForward();\n      const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};\n      if (!selection.isCollapsed()) {\n        const end = getPoint(dom, trim, normalized, rng, false);\n        return {\n          start,\n          end,\n          forward,\n          ...fakeCaret\n        };\n      } else {\n        return {\n          start,\n          forward,\n          ...fakeCaret\n        };\n      }\n    };\n    const findIndex = (dom, name, element) => {\n      let count = 0;\n      Tools.each(dom.select(name), node => {\n        if (node.getAttribute('data-mce-bogus') === 'all') {\n          return;\n        } else if (node === element) {\n          return false;\n        } else {\n          count++;\n          return;\n        }\n      });\n      return count;\n    };\n    const moveEndPoint$1 = (rng, start) => {\n      let container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      if (isElement$6(container) && container.nodeName === 'TR') {\n        const childNodes = container.childNodes;\n        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n        if (container) {\n          offset = start ? 0 : container.childNodes.length;\n          if (start) {\n            rng.setStart(container, offset);\n          } else {\n            rng.setEnd(container, offset);\n          }\n        }\n      }\n    };\n    const normalizeTableCellSelection = rng => {\n      moveEndPoint$1(rng, true);\n      moveEndPoint$1(rng, false);\n      return rng;\n    };\n    const findSibling = (node, offset) => {\n      if (isElement$6(node)) {\n        node = getNode$1(node, offset);\n        if (isContentEditableFalse$9(node)) {\n          return node;\n        }\n      }\n      if (isCaretContainer$2(node)) {\n        if (isText$a(node) && isCaretContainerBlock$1(node)) {\n          node = node.parentNode;\n        }\n        let sibling = node.previousSibling;\n        if (isContentEditableFalse$9(sibling)) {\n          return sibling;\n        }\n        sibling = node.nextSibling;\n        if (isContentEditableFalse$9(sibling)) {\n          return sibling;\n        }\n      }\n      return undefined;\n    };\n    const findAdjacentContentEditableFalseElm = rng => {\n      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\n    };\n    const getOffsetBookmark = (trim, normalized, selection) => {\n      const element = selection.getNode();\n      const rng = selection.getRng();\n      if (element.nodeName === 'IMG' || isContentEditableFalse$9(element)) {\n        const name = element.nodeName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, element)\n        };\n      }\n      const sibling = findAdjacentContentEditableFalseElm(rng);\n      if (sibling) {\n        const name = sibling.tagName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, sibling)\n        };\n      }\n      return getLocation(trim, selection, normalized, rng);\n    };\n    const getCaretBookmark = selection => {\n      const rng = selection.getRng();\n      return {\n        start: create$b(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\n        end: create$b(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),\n        forward: selection.isForward()\n      };\n    };\n    const getRangeBookmark = selection => {\n      return {\n        rng: selection.getRng(),\n        forward: selection.isForward()\n      };\n    };\n    const createBookmarkSpan = (dom, id, filled) => {\n      const args = {\n        'data-mce-type': 'bookmark',\n        id,\n        'style': 'overflow:hidden;line-height:0px'\n      };\n      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\n    };\n    const getPersistentBookmark = (selection, filled) => {\n      const dom = selection.dom;\n      let rng = selection.getRng();\n      const id = dom.uniqueId();\n      const collapsed = selection.isCollapsed();\n      const element = selection.getNode();\n      const name = element.nodeName;\n      const forward = selection.isForward();\n      if (name === 'IMG') {\n        return {\n          name,\n          index: findIndex(dom, name, element)\n        };\n      }\n      const rng2 = normalizeTableCellSelection(rng.cloneRange());\n      if (!collapsed) {\n        rng2.collapse(false);\n        const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\n        rangeInsertNode(dom, rng2, endBookmarkNode);\n      }\n      rng = normalizeTableCellSelection(rng);\n      rng.collapse(true);\n      const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\n      rangeInsertNode(dom, rng, startBookmarkNode);\n      selection.moveToBookmark({\n        id,\n        keep: true,\n        forward\n      });\n      return {\n        id,\n        forward\n      };\n    };\n    const getBookmark$2 = (selection, type, normalized = false) => {\n      if (type === 2) {\n        return getOffsetBookmark(trim$2, normalized, selection);\n      } else if (type === 3) {\n        return getCaretBookmark(selection);\n      } else if (type) {\n        return getRangeBookmark(selection);\n      } else {\n        return getPersistentBookmark(selection, false);\n      }\n    };\n    const getUndoBookmark = curry(getOffsetBookmark, identity, true);\n\n    const value$1 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply$1,\n        orThunk: apply$1,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n    const Result = {\n      value: value$1,\n      error,\n      fromOption\n    };\n\n    const generate = cases => {\n      if (!isArray$1(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$e(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray$1(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate };\n\n    Adt.generate([\n      {\n        bothErrors: [\n          'error1',\n          'error2'\n        ]\n      },\n      {\n        firstError: [\n          'error1',\n          'value2'\n        ]\n      },\n      {\n        secondError: [\n          'value1',\n          'error2'\n        ]\n      },\n      {\n        bothValues: [\n          'value1',\n          'value2'\n        ]\n      }\n    ]);\n    const partition$1 = results => {\n      const errors = [];\n      const values = [];\n      each$e(results, result => {\n        result.fold(err => {\n          errors.push(err);\n        }, value => {\n          values.push(value);\n        });\n      });\n      return {\n        errors,\n        values\n      };\n    };\n\n    const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\n    const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\n    const normalizePattern = pattern => {\n      const err = message => Result.error({\n        message,\n        pattern\n      });\n      const formatOrCmd = (name, onFormat, onCommand) => {\n        if (pattern.format !== undefined) {\n          let formats;\n          if (isArray$1(pattern.format)) {\n            if (!forall(pattern.format, isString)) {\n              return err(name + ' pattern has non-string items in the `format` array');\n            }\n            formats = pattern.format;\n          } else if (isString(pattern.format)) {\n            formats = [pattern.format];\n          } else {\n            return err(name + ' pattern has non-string `format` parameter');\n          }\n          return Result.value(onFormat(formats));\n        } else if (pattern.cmd !== undefined) {\n          if (!isString(pattern.cmd)) {\n            return err(name + ' pattern has non-string `cmd` parameter');\n          }\n          return Result.value(onCommand(pattern.cmd, pattern.value));\n        } else {\n          return err(name + ' pattern is missing both `format` and `cmd` parameters');\n        }\n      };\n      if (!isObject(pattern)) {\n        return err('Raw pattern is not an object');\n      }\n      if (!isString(pattern.start)) {\n        return err('Raw pattern is missing `start` parameter');\n      }\n      if (pattern.end !== undefined) {\n        if (!isString(pattern.end)) {\n          return err('Inline pattern has non-string `end` parameter');\n        }\n        if (pattern.start.length === 0 && pattern.end.length === 0) {\n          return err('Inline pattern has empty `start` and `end` parameters');\n        }\n        let start = pattern.start;\n        let end = pattern.end;\n        if (end.length === 0) {\n          end = start;\n          start = '';\n        }\n        return formatOrCmd('Inline', format => ({\n          type: 'inline-format',\n          start,\n          end,\n          format\n        }), (cmd, value) => ({\n          type: 'inline-command',\n          start,\n          end,\n          cmd,\n          value\n        }));\n      } else if (pattern.replacement !== undefined) {\n        if (!isString(pattern.replacement)) {\n          return err('Replacement pattern has non-string `replacement` parameter');\n        }\n        if (pattern.start.length === 0) {\n          return err('Replacement pattern has empty `start` parameter');\n        }\n        return Result.value({\n          type: 'inline-command',\n          start: '',\n          end: pattern.start,\n          cmd: 'mceInsertContent',\n          value: pattern.replacement\n        });\n      } else {\n        if (pattern.start.length === 0) {\n          return err('Block pattern has empty `start` parameter');\n        }\n        return formatOrCmd('Block', formats => ({\n          type: 'block-format',\n          start: pattern.start,\n          format: formats[0]\n        }), (command, commandValue) => ({\n          type: 'block-command',\n          start: pattern.start,\n          cmd: command,\n          value: commandValue\n        }));\n      }\n    };\n    const getBlockPatterns = patterns => filter$5(patterns, isBlockPattern);\n    const getInlinePatterns = patterns => filter$5(patterns, isInlinePattern);\n    const createPatternSet = (patterns, dynamicPatternsLookup) => ({\n      inlinePatterns: getInlinePatterns(patterns),\n      blockPatterns: getBlockPatterns(patterns),\n      dynamicPatternsLookup\n    });\n    const fromRawPatterns = patterns => {\n      const normalized = partition$1(map$3(patterns, normalizePattern));\n      each$e(normalized.errors, err => console.error(err.message, err.pattern));\n      return normalized.values;\n    };\n    const fromRawPatternsLookup = lookupFn => {\n      return ctx => {\n        const rawPatterns = lookupFn(ctx);\n        return fromRawPatterns(rawPatterns);\n      };\n    };\n\n    const deviceDetection$1 = detect$2().deviceType;\n    const isTouch = deviceDetection$1.isTouch();\n    const DOM$a = DOMUtils.DOM;\n    const getHash = value => {\n      const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\n      return foldl(items, (output, item) => {\n        const arr = item.split('=');\n        const key = arr[0];\n        const val = arr.length > 1 ? arr[1] : key;\n        output[trim$4(key)] = trim$4(val);\n        return output;\n      }, {});\n    };\n    const isRegExp = x => is$4(x, RegExp);\n    const option = name => editor => editor.options.get(name);\n    const stringOrObjectProcessor = value => isString(value) || isObject(value);\n    const bodyOptionProcessor = (editor, defaultValue = '') => value => {\n      const valid = isString(value);\n      if (valid) {\n        if (value.indexOf('=') !== -1) {\n          const bodyObj = getHash(value);\n          return {\n            value: get$a(bodyObj, editor.id).getOr(defaultValue),\n            valid\n          };\n        } else {\n          return {\n            value,\n            valid\n          };\n        }\n      } else {\n        return {\n          valid: false,\n          message: 'Must be a string.'\n        };\n      }\n    };\n    const register$7 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('id', {\n        processor: 'string',\n        default: editor.id\n      });\n      registerOption('selector', { processor: 'string' });\n      registerOption('target', { processor: 'object' });\n      registerOption('suffix', { processor: 'string' });\n      registerOption('cache_suffix', { processor: 'string' });\n      registerOption('base_url', { processor: 'string' });\n      registerOption('referrer_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('language_load', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('iframe_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('doctype', {\n        processor: 'string',\n        default: '<!DOCTYPE html>'\n      });\n      registerOption('document_base_url', {\n        processor: 'string',\n        default: editor.documentBaseUrl\n      });\n      registerOption('body_id', {\n        processor: bodyOptionProcessor(editor, 'tinymce'),\n        default: 'tinymce'\n      });\n      registerOption('body_class', {\n        processor: bodyOptionProcessor(editor),\n        default: ''\n      });\n      registerOption('content_security_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('br_in_pre', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('forced_root_block', {\n        processor: value => {\n          const valid = isString(value) && isNotEmpty(value);\n          if (valid) {\n            return {\n              value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a non-empty string.'\n            };\n          }\n        },\n        default: 'p'\n      });\n      registerOption('forced_root_block_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('newline_behavior', {\n        processor: value => {\n          const valid = contains$2([\n            'block',\n            'linebreak',\n            'invert',\n            'default'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: block, linebreak, invert or default.'\n          };\n        },\n        default: 'default'\n      });\n      registerOption('br_newline_selector', {\n        processor: 'string',\n        default: '.mce-toc h2,figcaption,caption'\n      });\n      registerOption('no_newline_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('keep_styles', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('end_container_on_empty_block', {\n        processor: value => {\n          if (isBoolean(value)) {\n            return {\n              valid: true,\n              value\n            };\n          } else if (isString(value)) {\n            return {\n              valid: true,\n              value\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: 'blockquote'\n      });\n      registerOption('font_size_style_values', {\n        processor: 'string',\n        default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\n      });\n      registerOption('font_size_legacy_values', {\n        processor: 'string',\n        default: 'xx-small,small,medium,large,x-large,xx-large,300%'\n      });\n      registerOption('font_size_classes', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('automatic_uploads', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('images_reuse_filename', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_replace_blob_uris', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('icons', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('icons_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_base_path', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_credentials', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_upload_handler', { processor: 'function' });\n      registerOption('language', {\n        processor: 'string',\n        default: 'en'\n      });\n      registerOption('language_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('entity_encoding', {\n        processor: 'string',\n        default: 'named'\n      });\n      registerOption('indent', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('indent_before', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_after', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_use_margin', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('indentation', {\n        processor: 'string',\n        default: '40px'\n      });\n      registerOption('content_css', {\n        processor: value => {\n          const valid = value === false || isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            if (isString(value)) {\n              return {\n                value: map$3(value.split(','), trim$4),\n                valid\n              };\n            } else if (isArray$1(value)) {\n              return {\n                value,\n                valid\n              };\n            } else if (value === false) {\n              return {\n                value: [],\n                valid\n              };\n            } else {\n              return {\n                value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false, a string or an array of strings.'\n            };\n          }\n        },\n        default: isInline$1(editor) ? [] : ['default']\n      });\n      registerOption('content_style', { processor: 'string' });\n      registerOption('content_css_cors', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('font_css', {\n        processor: value => {\n          const valid = isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$4);\n            return {\n              value: newValue,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a string or an array of strings.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('inline_boundaries', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline_boundaries_selector', {\n        processor: 'string',\n        default: 'a[href],code,span.mce-annotation'\n      });\n      registerOption('object_resizing', {\n        processor: value => {\n          const valid = isBoolean(value) || isString(value);\n          if (valid) {\n            if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\n              return {\n                value: '',\n                valid\n              };\n            } else {\n              return {\n                value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: !isTouch\n      });\n      registerOption('resize_img_proportional', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('event_root', { processor: 'object' });\n      registerOption('service_message', { processor: 'string' });\n      registerOption('theme', {\n        processor: value => value === false || isString(value) || isFunction(value),\n        default: 'silver'\n      });\n      registerOption('theme_url', { processor: 'string' });\n      registerOption('formats', { processor: 'object' });\n      registerOption('format_empty_lines', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('format_noneditable_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('preview_styles', {\n        processor: value => {\n          const valid = value === false || isString(value);\n          if (valid) {\n            return {\n              value: value === false ? '' : value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false or a string'\n            };\n          }\n        },\n        default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\n      });\n      registerOption('custom_ui_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('hidden_input', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('submit_patch', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('encoding', { processor: 'string' });\n      registerOption('add_form_submit_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('add_unload_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_undo_redo_levels', {\n        processor: 'number',\n        default: 0\n      });\n      registerOption('disable_nodechange', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('readonly', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('editable_root', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('plugins', {\n        processor: 'string[]',\n        default: []\n      });\n      registerOption('external_plugins', { processor: 'object' });\n      registerOption('forced_plugins', { processor: 'string[]' });\n      registerOption('model', {\n        processor: 'string',\n        default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\n      });\n      registerOption('model_url', { processor: 'string' });\n      registerOption('block_unsupported_drop', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual_table_class', {\n        processor: 'string',\n        default: 'mce-item-table'\n      });\n      registerOption('visual_anchor_class', {\n        processor: 'string',\n        default: 'mce-item-anchor'\n      });\n      registerOption('iframe_aria_text', {\n        processor: 'string',\n        default: 'Rich Text Area. Press ALT-0 for help.'\n      });\n      registerOption('setup', { processor: 'function' });\n      registerOption('init_instance_callback', { processor: 'function' });\n      registerOption('url_converter', {\n        processor: 'function',\n        default: editor.convertURL\n      });\n      registerOption('url_converter_scope', {\n        processor: 'object',\n        default: editor\n      });\n      registerOption('urlconverter_callback', { processor: 'function' });\n      registerOption('allow_conditional_comments', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_html_data_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_svg_data_urls', { processor: 'boolean' });\n      registerOption('allow_html_in_named_anchor', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_script_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_unsafe_link_target', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('convert_fonts_to_spans', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('fix_list_elements', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('preserve_cdata', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('remove_trailing_brs', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('pad_empty_with_br', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('inline_styles', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('element_format', {\n        processor: 'string',\n        default: 'html'\n      });\n      registerOption('entities', { processor: 'string' });\n      registerOption('schema', {\n        processor: 'string',\n        default: 'html5'\n      });\n      registerOption('convert_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('relative_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('remove_script_host', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_elements', { processor: 'string' });\n      registerOption('extended_valid_elements', { processor: 'string' });\n      registerOption('invalid_elements', { processor: 'string' });\n      registerOption('invalid_styles', { processor: stringOrObjectProcessor });\n      registerOption('valid_children', { processor: 'string' });\n      registerOption('valid_classes', { processor: stringOrObjectProcessor });\n      registerOption('valid_elements', { processor: 'string' });\n      registerOption('valid_styles', { processor: stringOrObjectProcessor });\n      registerOption('verify_html', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('auto_focus', { processor: value => isString(value) || value === true });\n      registerOption('browser_spellcheck', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('protect', { processor: 'array' });\n      registerOption('images_file_types', {\n        processor: 'string',\n        default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\n      });\n      registerOption('deprecation_warnings', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('a11y_advanced_options', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('api_key', { processor: 'string' });\n      registerOption('paste_block_drop', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_data_images', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_preprocess', { processor: 'function' });\n      registerOption('paste_postprocess', { processor: 'function' });\n      registerOption('paste_webkit_styles', {\n        processor: 'string',\n        default: 'none'\n      });\n      registerOption('paste_remove_styles_if_webkit', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_merge_formats', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('smart_paste', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_as_text', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_tab_spaces', {\n        processor: 'number',\n        default: 4\n      });\n      registerOption('text_patterns', {\n        processor: value => {\n          if (isArrayOf(value, isObject) || value === false) {\n            const patterns = value === false ? [] : value;\n            return {\n              value: fromRawPatterns(patterns),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be an array of objects or false.'\n            };\n          }\n        },\n        default: [\n          {\n            start: '*',\n            end: '*',\n            format: 'italic'\n          },\n          {\n            start: '**',\n            end: '**',\n            format: 'bold'\n          },\n          {\n            start: '#',\n            format: 'h1'\n          },\n          {\n            start: '##',\n            format: 'h2'\n          },\n          {\n            start: '###',\n            format: 'h3'\n          },\n          {\n            start: '####',\n            format: 'h4'\n          },\n          {\n            start: '#####',\n            format: 'h5'\n          },\n          {\n            start: '######',\n            format: 'h6'\n          },\n          {\n            start: '1. ',\n            cmd: 'InsertOrderedList'\n          },\n          {\n            start: '* ',\n            cmd: 'InsertUnorderedList'\n          },\n          {\n            start: '- ',\n            cmd: 'InsertUnorderedList'\n          }\n        ]\n      });\n      registerOption('text_patterns_lookup', {\n        processor: value => {\n          if (isFunction(value)) {\n            return {\n              value: fromRawPatternsLookup(value),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a single function'\n            };\n          }\n        },\n        default: _ctx => []\n      });\n      registerOption('noneditable_class', {\n        processor: 'string',\n        default: 'mceNonEditable'\n      });\n      registerOption('editable_class', {\n        processor: 'string',\n        default: 'mceEditable'\n      });\n      registerOption('noneditable_regexp', {\n        processor: value => {\n          if (isArrayOf(value, isRegExp)) {\n            return {\n              value,\n              valid: true\n            };\n          } else if (isRegExp(value)) {\n            return {\n              value: [value],\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a RegExp or an array of RegExp.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('table_tab_navigation', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('highlight_on_focus', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('xss_sanitization', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('details_initial_state', {\n        processor: value => {\n          const valid = contains$2([\n            'inherited',\n            'collapsed',\n            'expanded'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: inherited, collapsed, or expanded.'\n          };\n        },\n        default: 'inherited'\n      });\n      registerOption('details_serialized_state', {\n        processor: value => {\n          const valid = contains$2([\n            'inherited',\n            'collapsed',\n            'expanded'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: inherited, collapsed, or expanded.'\n          };\n        },\n        default: 'inherited'\n      });\n      registerOption('init_content_sync', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('newdocument_content', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('force_hex_color', {\n        processor: value => {\n          const options = [\n            'always',\n            'rgb_only',\n            'off'\n          ];\n          const valid = contains$2(options, value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: `Must be one of: ${ options.join(', ') }.`\n          };\n        },\n        default: 'off'\n      });\n      registerOption('sandbox_iframes', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('convert_unsafe_embeds', {\n        processor: 'boolean',\n        default: false\n      });\n      editor.on('ScriptsLoaded', () => {\n        registerOption('directionality', {\n          processor: 'string',\n          default: I18n.isRtl() ? 'rtl' : undefined\n        });\n        registerOption('placeholder', {\n          processor: 'string',\n          default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\n        });\n      });\n    };\n    const getIframeAttrs = option('iframe_attrs');\n    const getDocType = option('doctype');\n    const getDocumentBaseUrl = option('document_base_url');\n    const getBodyId = option('body_id');\n    const getBodyClass = option('body_class');\n    const getContentSecurityPolicy = option('content_security_policy');\n    const shouldPutBrInPre$1 = option('br_in_pre');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n    const getNewlineBehavior = option('newline_behavior');\n    const getBrNewLineSelector = option('br_newline_selector');\n    const getNoNewLineSelector = option('no_newline_selector');\n    const shouldKeepStyles = option('keep_styles');\n    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\n    const isAutomaticUploadsEnabled = option('automatic_uploads');\n    const shouldReuseFileName = option('images_reuse_filename');\n    const shouldReplaceBlobUris = option('images_replace_blob_uris');\n    const getIconPackName = option('icons');\n    const getIconsUrl = option('icons_url');\n    const getImageUploadUrl = option('images_upload_url');\n    const getImageUploadBasePath = option('images_upload_base_path');\n    const getImagesUploadCredentials = option('images_upload_credentials');\n    const getImagesUploadHandler = option('images_upload_handler');\n    const shouldUseContentCssCors = option('content_css_cors');\n    const getReferrerPolicy = option('referrer_policy');\n    const getLanguageCode = option('language');\n    const getLanguageUrl = option('language_url');\n    const shouldIndentUseMargin = option('indent_use_margin');\n    const getIndentation = option('indentation');\n    const getContentCss = option('content_css');\n    const getContentStyle = option('content_style');\n    const getFontCss = option('font_css');\n    const getDirectionality = option('directionality');\n    const getInlineBoundarySelector = option('inline_boundaries_selector');\n    const getObjectResizing = option('object_resizing');\n    const getResizeImgProportional = option('resize_img_proportional');\n    const getPlaceholder = option('placeholder');\n    const getEventRoot = option('event_root');\n    const getServiceMessage = option('service_message');\n    const getTheme = option('theme');\n    const getThemeUrl = option('theme_url');\n    const getModel = option('model');\n    const getModelUrl = option('model_url');\n    const isInlineBoundariesEnabled = option('inline_boundaries');\n    const getFormats = option('formats');\n    const getPreviewStyles = option('preview_styles');\n    const canFormatEmptyLines = option('format_empty_lines');\n    const getFormatNoneditableSelector = option('format_noneditable_selector');\n    const getCustomUiSelector = option('custom_ui_selector');\n    const isInline$1 = option('inline');\n    const hasHiddenInput = option('hidden_input');\n    const shouldPatchSubmit = option('submit_patch');\n    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\n    const shouldAddUnloadTrigger = option('add_unload_trigger');\n    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\n    const shouldDisableNodeChange = option('disable_nodechange');\n    const isReadOnly$1 = option('readonly');\n    const hasEditableRoot$1 = option('editable_root');\n    const hasContentCssCors = option('content_css_cors');\n    const getPlugins = option('plugins');\n    const getExternalPlugins$1 = option('external_plugins');\n    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\n    const isVisualAidsEnabled = option('visual');\n    const getVisualAidsTableClass = option('visual_table_class');\n    const getVisualAidsAnchorClass = option('visual_anchor_class');\n    const getIframeAriaText = option('iframe_aria_text');\n    const getSetupCallback = option('setup');\n    const getInitInstanceCallback = option('init_instance_callback');\n    const getUrlConverterCallback = option('urlconverter_callback');\n    const getAutoFocus = option('auto_focus');\n    const shouldBrowserSpellcheck = option('browser_spellcheck');\n    const getProtect = option('protect');\n    const shouldPasteBlockDrop = option('paste_block_drop');\n    const shouldPasteDataImages = option('paste_data_images');\n    const getPastePreProcess = option('paste_preprocess');\n    const getPastePostProcess = option('paste_postprocess');\n    const getNewDocumentContent = option('newdocument_content');\n    const getPasteWebkitStyles = option('paste_webkit_styles');\n    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\n    const shouldPasteMergeFormats = option('paste_merge_formats');\n    const isSmartPasteEnabled = option('smart_paste');\n    const isPasteAsTextEnabled = option('paste_as_text');\n    const getPasteTabSpaces = option('paste_tab_spaces');\n    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\n    const getTextPatterns = option('text_patterns');\n    const getTextPatternsLookup = option('text_patterns_lookup');\n    const getNonEditableClass = option('noneditable_class');\n    const getEditableClass = option('editable_class');\n    const getNonEditableRegExps = option('noneditable_regexp');\n    const shouldPreserveCData = option('preserve_cdata');\n    const shouldHighlightOnFocus = option('highlight_on_focus');\n    const shouldSanitizeXss = option('xss_sanitization');\n    const shouldUseDocumentWrite = option('init_content_sync');\n    const hasTextPatternsLookup = editor => editor.options.isSet('text_patterns_lookup');\n    const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\n    const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\n    const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\n    const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\n    const hasTableTabNavigation = option('table_tab_navigation');\n    const getDetailsInitialState = option('details_initial_state');\n    const getDetailsSerializedState = option('details_serialized_state');\n    const shouldForceHexColor = option('force_hex_color');\n    const shouldSandboxIframes = option('sandbox_iframes');\n\n    const isElement$3 = isElement$6;\n    const isText$5 = isText$a;\n    const removeNode$1 = node => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n    };\n    const trimCount = text => {\n      const trimmedText = trim$2(text);\n      return {\n        count: text.length - trimmedText.length,\n        text: trimmedText\n      };\n    };\n    const deleteZwspChars = caretContainer => {\n      let idx;\n      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\n        caretContainer.deleteData(idx, 1);\n      }\n    };\n    const removeUnchanged = (caretContainer, pos) => {\n      remove$3(caretContainer);\n      return pos;\n    };\n    const removeTextAndReposition = (caretContainer, pos) => {\n      const before = trimCount(caretContainer.data.substr(0, pos.offset()));\n      const after = trimCount(caretContainer.data.substr(pos.offset()));\n      const text = before.text + after.text;\n      if (text.length > 0) {\n        deleteZwspChars(caretContainer);\n        return CaretPosition(caretContainer, pos.offset() - before.count);\n      } else {\n        return pos;\n      }\n    };\n    const removeElementAndReposition = (caretContainer, pos) => {\n      const parentNode = pos.container();\n      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\n        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\n      }).getOr(pos);\n      remove$3(caretContainer);\n      return newPosition;\n    };\n    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\n    const remove$3 = caretContainerNode => {\n      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\n        if (hasContent(caretContainerNode)) {\n          caretContainerNode.removeAttribute('data-mce-caret');\n        } else {\n          removeNode$1(caretContainerNode);\n        }\n      }\n      if (isText$5(caretContainerNode)) {\n        deleteZwspChars(caretContainerNode);\n        if (caretContainerNode.data.length === 0) {\n          removeNode$1(caretContainerNode);\n        }\n      }\n    };\n\n    const isContentEditableFalse$8 = isContentEditableFalse$b;\n    const isMedia$1 = isMedia$2;\n    const isTableCell$1 = isTableCell$3;\n    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\n    const getAbsoluteClientRect = (root, element, before) => {\n      const clientRect = collapse(element.getBoundingClientRect(), before);\n      let scrollX;\n      let scrollY;\n      if (root.tagName === 'BODY') {\n        const docElm = root.ownerDocument.documentElement;\n        scrollX = root.scrollLeft || docElm.scrollLeft;\n        scrollY = root.scrollTop || docElm.scrollTop;\n      } else {\n        const rootRect = root.getBoundingClientRect();\n        scrollX = root.scrollLeft - rootRect.left;\n        scrollY = root.scrollTop - rootRect.top;\n      }\n      clientRect.left += scrollX;\n      clientRect.right += scrollX;\n      clientRect.top += scrollY;\n      clientRect.bottom += scrollY;\n      clientRect.width = 1;\n      let margin = element.offsetWidth - element.clientWidth;\n      if (margin > 0) {\n        if (before) {\n          margin *= -1;\n        }\n        clientRect.left += margin;\n        clientRect.right += margin;\n      }\n      return clientRect;\n    };\n    const trimInlineCaretContainers = root => {\n      var _a, _b;\n      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\n      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\n        const node = fakeCaretTargetNodes[i].dom;\n        let sibling = node.previousSibling;\n        if (endsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);\n          } else {\n            sibling.deleteData(data.length - 1, 1);\n          }\n        }\n        sibling = node.nextSibling;\n        if (startsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);\n          } else {\n            sibling.deleteData(0, 1);\n          }\n        }\n      }\n    };\n    const FakeCaret = (editor, root, isBlock, hasFocus) => {\n      const lastVisualCaret = value$2();\n      let cursorInterval;\n      let caretContainerNode;\n      const caretBlock = getForcedRootBlock(editor);\n      const dom = editor.dom;\n      const show = (before, element) => {\n        let rng;\n        hide();\n        if (isTableCell$1(element)) {\n          return null;\n        }\n        if (isBlock(element)) {\n          const caretContainer = insertBlock(caretBlock, element, before);\n          const clientRect = getAbsoluteClientRect(root, element, before);\n          dom.setStyle(caretContainer, 'top', clientRect.top);\n          caretContainerNode = caretContainer;\n          const caret = dom.create('div', {\n            'class': 'mce-visual-caret',\n            'data-mce-bogus': 'all'\n          });\n          dom.setStyles(caret, { ...clientRect });\n          dom.add(root, caret);\n          lastVisualCaret.set({\n            caret,\n            element,\n            before\n          });\n          if (before) {\n            dom.addClass(caret, 'mce-visual-caret-before');\n          }\n          startBlink();\n          rng = element.ownerDocument.createRange();\n          rng.setStart(caretContainer, 0);\n          rng.setEnd(caretContainer, 0);\n        } else {\n          caretContainerNode = insertInline$1(element, before);\n          rng = element.ownerDocument.createRange();\n          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\n            rng.setStart(caretContainerNode, 0);\n            rng.setEnd(caretContainerNode, 0);\n          } else {\n            rng.setStart(caretContainerNode, 1);\n            rng.setEnd(caretContainerNode, 1);\n          }\n          return rng;\n        }\n        return rng;\n      };\n      const hide = () => {\n        trimInlineCaretContainers(root);\n        if (caretContainerNode) {\n          remove$3(caretContainerNode);\n          caretContainerNode = null;\n        }\n        lastVisualCaret.on(caretState => {\n          dom.remove(caretState.caret);\n          lastVisualCaret.clear();\n        });\n        if (cursorInterval) {\n          clearInterval(cursorInterval);\n          cursorInterval = undefined;\n        }\n      };\n      const startBlink = () => {\n        cursorInterval = setInterval(() => {\n          lastVisualCaret.on(caretState => {\n            if (hasFocus()) {\n              dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\n            } else {\n              dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\n            }\n          });\n        }, 500);\n      };\n      const reposition = () => {\n        lastVisualCaret.on(caretState => {\n          const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\n          dom.setStyles(caretState.caret, { ...clientRect });\n        });\n      };\n      const destroy = () => clearInterval(cursorInterval);\n      const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\n      return {\n        show,\n        hide,\n        getCss,\n        reposition,\n        destroy\n      };\n    };\n    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\n    const isInlineFakeCaretTarget = node => isContentEditableFalse$8(node) || isMedia$1(node);\n    const isFakeCaretTarget = node => {\n      const isTarget = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();\n      return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2);\n    };\n\n    const isContentEditableTrue$1 = isContentEditableTrue$3;\n    const isContentEditableFalse$7 = isContentEditableFalse$b;\n    const isMedia = isMedia$2;\n    const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');\n    const isCaretContainer = isCaretContainer$2;\n    const isCaretContainerBlock = isCaretContainerBlock$1;\n    const isElement$2 = isElement$6;\n    const isText$4 = isText$a;\n    const isCaretCandidate$1 = isCaretCandidate$3;\n    const isForwards = direction => direction > 0;\n    const isBackwards = direction => direction < 0;\n    const skipCaretContainers = (walk, shallow) => {\n      let node;\n      while (node = walk(shallow)) {\n        if (!isCaretContainerBlock(node)) {\n          return node;\n        }\n      }\n      return null;\n    };\n    const findNode = (node, direction, predicateFn, rootNode, shallow) => {\n      const walker = new DomTreeWalker(node, rootNode);\n      const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);\n      let tempNode;\n      if (isBackwards(direction)) {\n        if (isCefOrCaretContainer) {\n          tempNode = skipCaretContainers(walker.prev.bind(walker), true);\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n        while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow)) {\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      if (isForwards(direction)) {\n        if (isCefOrCaretContainer) {\n          tempNode = skipCaretContainers(walker.next.bind(walker), true);\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n        while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow)) {\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const getEditingHost = (node, rootNode) => {\n      const isCETrue = node => isContentEditableTrue$1(node.dom);\n      const isRoot = node => node.dom === rootNode;\n      return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\n    };\n    const getParentBlock$3 = (node, rootNode) => {\n      while (node && node !== rootNode) {\n        if (isBlockLike(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\n    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\n      if (!caretPosition) {\n        return Optional.none();\n      }\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (!isElement$2(container)) {\n        return Optional.none();\n      }\n      return Optional.from(container.childNodes[offset + relativeOffset]);\n    };\n    const beforeAfter = (before, node) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const range = doc.createRange();\n      if (before) {\n        range.setStartBefore(node);\n        range.setEndBefore(node);\n      } else {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n      return range;\n    };\n    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\n    const lean = (left, root, node) => {\n      const siblingName = left ? 'previousSibling' : 'nextSibling';\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        let sibling = tempNode[siblingName];\n        if (sibling && isCaretContainer(sibling)) {\n          sibling = sibling[siblingName];\n        }\n        if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {\n          if (isNodesInSameBlock(root, sibling, tempNode)) {\n            return sibling;\n          }\n          break;\n        }\n        if (isCaretCandidate$1(sibling)) {\n          break;\n        }\n        tempNode = tempNode.parentNode;\n      }\n      return null;\n    };\n    const before$2 = curry(beforeAfter, true);\n    const after$2 = curry(beforeAfter, false);\n    const normalizeRange = (direction, root, range) => {\n      let node;\n      const leanLeft = curry(lean, true, root);\n      const leanRight = curry(lean, false, root);\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isCaretContainerBlock$1(container)) {\n        const block = isText$4(container) ? container.parentNode : container;\n        const location = block.getAttribute('data-mce-caret');\n        if (location === 'before') {\n          node = block.nextSibling;\n          if (isFakeCaretTarget(node)) {\n            return before$2(node);\n          }\n        }\n        if (location === 'after') {\n          node = block.previousSibling;\n          if (isFakeCaretTarget(node)) {\n            return after$2(node);\n          }\n        }\n      }\n      if (!range.collapsed) {\n        return range;\n      }\n      if (isText$a(container)) {\n        if (isCaretContainer(container)) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (startsWithCaretContainer$1(container) && offset <= 1) {\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          return range;\n        }\n        if (offset === container.data.length) {\n          node = leanRight(container);\n          if (node) {\n            return before$2(node);\n          }\n          return range;\n        }\n        if (offset === 0) {\n          node = leanLeft(container);\n          if (node) {\n            return after$2(node);\n          }\n          return range;\n        }\n      }\n      return range;\n    };\n    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);\n    const getNormalizedRangeEndPoint = (direction, root, range) => {\n      const normalizedRange = normalizeRange(direction, root, range);\n      return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);\n    };\n    const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\n    const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\n    const getVisualCaretPosition = (walkFn, caretPosition) => {\n      let pos = caretPosition;\n      while (pos = walkFn(pos)) {\n        if (pos.isVisible()) {\n          return pos;\n        }\n      }\n      return pos;\n    };\n    const isMoveInsideSameBlock = (from, to) => {\n      const inSameBlock = isInSameBlock(from, to);\n      if (!inSameBlock && isBr$6(from.getNode())) {\n        return true;\n      }\n      return inSameBlock;\n    };\n\n    var HDirection;\n    (function (HDirection) {\n      HDirection[HDirection['Backwards'] = -1] = 'Backwards';\n      HDirection[HDirection['Forwards'] = 1] = 'Forwards';\n    }(HDirection || (HDirection = {})));\n    const isContentEditableFalse$6 = isContentEditableFalse$b;\n    const isText$3 = isText$a;\n    const isElement$1 = isElement$6;\n    const isBr$2 = isBr$6;\n    const isCaretCandidate = isCaretCandidate$3;\n    const isAtomic = isAtomic$1;\n    const isEditableCaretCandidate = isEditableCaretCandidate$1;\n    const getParents$3 = (node, root) => {\n      const parents = [];\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        parents.push(tempNode);\n        tempNode = tempNode.parentNode;\n      }\n      return parents;\n    };\n    const nodeAtIndex = (container, offset) => {\n      if (container.hasChildNodes() && offset < container.childNodes.length) {\n        return container.childNodes[offset];\n      }\n      return null;\n    };\n    const getCaretCandidatePosition = (direction, node) => {\n      if (isForwards(direction)) {\n        if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {\n          return CaretPosition.before(node);\n        }\n        if (isText$3(node)) {\n          return CaretPosition(node, 0);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {\n          return CaretPosition.after(node);\n        }\n        if (isText$3(node)) {\n          return CaretPosition(node, node.data.length);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isBr$2(node)) {\n          return CaretPosition.before(node);\n        }\n        return CaretPosition.after(node);\n      }\n      return CaretPosition.before(node);\n    };\n    const moveForwardFromBr = (root, nextNode) => {\n      const nextSibling = nextNode.nextSibling;\n      if (nextSibling && isCaretCandidate(nextSibling)) {\n        if (isText$3(nextSibling)) {\n          return CaretPosition(nextSibling, 0);\n        } else {\n          return CaretPosition.before(nextSibling);\n        }\n      } else {\n        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\n      }\n    };\n    const findCaretPosition$1 = (direction, startPos, root) => {\n      let node;\n      let nextNode;\n      let innerNode;\n      let caretPosition;\n      if (!isElement$1(root) || !startPos) {\n        return null;\n      }\n      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\n        caretPosition = CaretPosition.after(root.lastChild);\n        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\n          return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\n        }\n      } else {\n        caretPosition = startPos;\n      }\n      const container = caretPosition.container();\n      let offset = caretPosition.offset();\n      if (isText$3(container)) {\n        if (isBackwards(direction) && offset > 0) {\n          return CaretPosition(container, --offset);\n        }\n        if (isForwards(direction) && offset < container.length) {\n          return CaretPosition(container, ++offset);\n        }\n        node = container;\n      } else {\n        if (isBackwards(direction) && offset > 0) {\n          nextNode = nodeAtIndex(container, offset - 1);\n          if (isCaretCandidate(nextNode)) {\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$3(innerNode)) {\n                  return CaretPosition(innerNode, innerNode.data.length);\n                }\n                return CaretPosition.after(innerNode);\n              }\n            }\n            if (isText$3(nextNode)) {\n              return CaretPosition(nextNode, nextNode.data.length);\n            }\n            return CaretPosition.before(nextNode);\n          }\n        }\n        if (isForwards(direction) && offset < container.childNodes.length) {\n          nextNode = nodeAtIndex(container, offset);\n          if (isCaretCandidate(nextNode)) {\n            if (isBr$2(nextNode)) {\n              return moveForwardFromBr(root, nextNode);\n            }\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$3(innerNode)) {\n                  return CaretPosition(innerNode, 0);\n                }\n                return CaretPosition.before(innerNode);\n              }\n            }\n            if (isText$3(nextNode)) {\n              return CaretPosition(nextNode, 0);\n            }\n            return CaretPosition.after(nextNode);\n          }\n        }\n        node = nextNode ? nextNode : caretPosition.getNode();\n      }\n      if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {\n        node = findNode(node, direction, always, root, true);\n        if (isEditableCaretCandidate(node, root)) {\n          return getCaretCandidatePosition(direction, node);\n        }\n      }\n      nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;\n      const rootContentEditableFalseElm = last$2(filter$5(getParents$3(container, root), isContentEditableFalse$6));\n      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\n        if (isForwards(direction)) {\n          caretPosition = CaretPosition.after(rootContentEditableFalseElm);\n        } else {\n          caretPosition = CaretPosition.before(rootContentEditableFalseElm);\n        }\n        return caretPosition;\n      }\n      if (nextNode) {\n        return getCaretCandidatePosition(direction, nextNode);\n      }\n      return null;\n    };\n    const CaretWalker = root => ({\n      next: caretPosition => {\n        return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\n      },\n      prev: caretPosition => {\n        return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\n      }\n    });\n\n    const walkToPositionIn = (forward, root, start) => {\n      const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\n      return fromPosition(forward, root, position);\n    };\n    const afterElement = node => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);\n    const isBeforeOrStart = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        return position.offset() === 0;\n      } else {\n        return isCaretCandidate$3(position.getNode());\n      }\n    };\n    const isAfterOrEnd = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        const container = position.container();\n        return position.offset() === container.data.length;\n      } else {\n        return isCaretCandidate$3(position.getNode(true));\n      }\n    };\n    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\n    const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());\n    const shouldSkipPosition = (forward, from, to) => {\n      if (forward) {\n        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\n      } else {\n        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\n      }\n    };\n    const fromPosition = (forward, root, pos) => {\n      const walker = CaretWalker(root);\n      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\n    };\n    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\n      if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\n        return fromPosition(forward, root, to);\n      } else {\n        return Optional.some(to);\n      }\n    });\n    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\n    const positionIn = (forward, element) => {\n      const startNode = forward ? element.firstChild : element.lastChild;\n      if (isText$a(startNode)) {\n        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\n      } else if (startNode) {\n        if (isCaretCandidate$3(startNode)) {\n          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\n        } else {\n          return walkToPositionIn(forward, element, startNode);\n        }\n      } else {\n        return Optional.none();\n      }\n    };\n    const nextPosition = curry(fromPosition, true);\n    const prevPosition = curry(fromPosition, false);\n    const firstPositionIn = curry(positionIn, true);\n    const lastPositionIn = curry(positionIn, false);\n\n    const CARET_ID = '_mce_caret';\n    const isCaretNode = node => isElement$6(node) && node.id === CARET_ID;\n    const getParentCaretContainer = (body, node) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== body) {\n        if (isCaretNode(currentNode)) {\n          return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return null;\n    };\n\n    const isStringPathBookmark = bookmark => isString(bookmark.start);\n    const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\n    const isIdBookmark = bookmark => has$2(bookmark, 'id');\n    const isIndexBookmark = bookmark => has$2(bookmark, 'name');\n    const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\n\n    const isForwardBookmark = bookmark => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;\n    const addBogus = (dom, node) => {\n      if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\n        node.innerHTML = '<br data-mce-bogus=\"1\" />';\n      }\n      return node;\n    };\n    const resolveCaretPositionBookmark = (dom, bookmark) => {\n      const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));\n      const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));\n      return lift2(startPos, endPos, (start, end) => {\n        const range = dom.createRng();\n        range.setStart(start.container(), start.offset());\n        range.setEnd(end.container(), end.offset());\n        return {\n          range,\n          forward: isForwardBookmark(bookmark)\n        };\n      });\n    };\n    const insertZwsp = (node, rng) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const textNode = doc.createTextNode(ZWSP$1);\n      node.appendChild(textNode);\n      rng.setStart(textNode, 0);\n      rng.setEnd(textNode, 0);\n    };\n    const isEmpty$1 = node => !node.hasChildNodes();\n    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      return true;\n    });\n    const padEmptyCaretContainer = (root, node, rng) => {\n      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\n        insertZwsp(node, rng);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const setEndPoint = (dom, start, bookmark, rng) => {\n      const point = bookmark[start ? 'start' : 'end'];\n      const root = dom.getRoot();\n      if (point) {\n        let node = root;\n        let offset = point[0];\n        for (let i = point.length - 1; node && i >= 1; i--) {\n          const children = node.childNodes;\n          if (padEmptyCaretContainer(root, node, rng)) {\n            return true;\n          }\n          if (point[i] > children.length - 1) {\n            if (padEmptyCaretContainer(root, node, rng)) {\n              return true;\n            }\n            return tryFindRangePosition(node, rng);\n          }\n          node = children[point[i]];\n        }\n        if (isText$a(node)) {\n          offset = Math.min(point[0], node.data.length);\n        }\n        if (isElement$6(node)) {\n          offset = Math.min(point[0], node.childNodes.length);\n        }\n        if (start) {\n          rng.setStart(node, offset);\n        } else {\n          rng.setEnd(node, offset);\n        }\n      }\n      return true;\n    };\n    const isValidTextNode = node => isText$a(node) && node.data.length > 0;\n    const restoreEndPoint = (dom, suffix, bookmark) => {\n      const marker = dom.get(bookmark.id + '_' + suffix);\n      const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;\n      const keep = bookmark.keep;\n      if (marker && markerParent) {\n        let container;\n        let offset;\n        if (suffix === 'start') {\n          if (!keep) {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              container = marker.firstChild;\n              offset = 1;\n            } else if (isValidTextNode(marker.nextSibling)) {\n              container = marker.nextSibling;\n              offset = 0;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              container = marker.previousSibling;\n              offset = marker.previousSibling.data.length;\n            } else {\n              container = markerParent;\n              offset = dom.nodeIndex(marker) + 1;\n            }\n          }\n        } else {\n          if (!keep) {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              container = marker.firstChild;\n              offset = 1;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              container = marker.previousSibling;\n              offset = marker.previousSibling.data.length;\n            } else {\n              container = markerParent;\n              offset = dom.nodeIndex(marker);\n            }\n          }\n        }\n        if (!keep) {\n          const prev = marker.previousSibling;\n          const next = marker.nextSibling;\n          Tools.each(Tools.grep(marker.childNodes), node => {\n            if (isText$a(node)) {\n              node.data = node.data.replace(/\\uFEFF/g, '');\n            }\n          });\n          let otherMarker;\n          while (otherMarker = dom.get(bookmark.id + '_' + suffix)) {\n            dom.remove(otherMarker, true);\n          }\n          if (isText$a(next) && isText$a(prev) && !Env.browser.isOpera()) {\n            const idx = prev.data.length;\n            prev.appendData(next.data);\n            dom.remove(next);\n            container = prev;\n            offset = idx;\n          }\n        }\n        return Optional.some(CaretPosition(container, offset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolvePaths = (dom, bookmark) => {\n      const range = dom.createRng();\n      if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {\n        return Optional.some({\n          range,\n          forward: isForwardBookmark(bookmark)\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolveId = (dom, bookmark) => {\n      const startPos = restoreEndPoint(dom, 'start', bookmark);\n      const endPos = restoreEndPoint(dom, 'end', bookmark);\n      return lift2(startPos, endPos.or(startPos), (spos, epos) => {\n        const range = dom.createRng();\n        range.setStart(addBogus(dom, spos.container()), spos.offset());\n        range.setEnd(addBogus(dom, epos.container()), epos.offset());\n        return {\n          range,\n          forward: isForwardBookmark(bookmark)\n        };\n      });\n    };\n    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\n      const range = dom.createRng();\n      range.selectNode(elm);\n      return {\n        range,\n        forward: true\n      };\n    });\n    const resolve = (selection, bookmark) => {\n      const dom = selection.dom;\n      if (bookmark) {\n        if (isPathBookmark(bookmark)) {\n          return resolvePaths(dom, bookmark);\n        } else if (isStringPathBookmark(bookmark)) {\n          return resolveCaretPositionBookmark(dom, bookmark);\n        } else if (isIdBookmark(bookmark)) {\n          return resolveId(dom, bookmark);\n        } else if (isIndexBookmark(bookmark)) {\n          return resolveIndex(dom, bookmark);\n        } else if (isRangeBookmark(bookmark)) {\n          return Optional.some({\n            range: bookmark.rng,\n            forward: isForwardBookmark(bookmark)\n          });\n        }\n      }\n      return Optional.none();\n    };\n\n    const getBookmark$1 = (selection, type, normalized) => {\n      return getBookmark$2(selection, type, normalized);\n    };\n    const moveToBookmark = (selection, bookmark) => {\n      resolve(selection, bookmark).each(({range, forward}) => {\n        selection.setRng(range, forward);\n      });\n    };\n    const isBookmarkNode$1 = node => {\n      return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\n    };\n\n    const is = expected => actual => expected === actual;\n    const isNbsp = is(nbsp);\n    const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n    const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);\n\n    const getRanges$1 = selection => {\n      const ranges = [];\n      if (selection) {\n        for (let i = 0; i < selection.rangeCount; i++) {\n          ranges.push(selection.getRangeAt(i));\n        }\n      }\n      return ranges;\n    };\n    const getSelectedNodes = ranges => {\n      return bind$3(ranges, range => {\n        const node = getSelectedNode(range);\n        return node ? [SugarElement.fromDom(node)] : [];\n      });\n    };\n    const hasMultipleRanges = selection => {\n      return getRanges$1(selection).length > 1;\n    };\n\n    const getCellsFromRanges = ranges => filter$5(getSelectedNodes(ranges), isTableCell$2);\n    const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\n    const getCellsFromElementOrRanges = (ranges, element) => {\n      const selectedCells = getCellsFromElement(element);\n      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\n    };\n    const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\n    const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);\n\n    const getStartNode = rng => {\n      const sc = rng.startContainer, so = rng.startOffset;\n      if (isText$a(sc)) {\n        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\n      } else {\n        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\n      }\n    };\n    const getEndNode = rng => {\n      const ec = rng.endContainer, eo = rng.endOffset;\n      if (isText$a(ec)) {\n        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\n      } else {\n        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\n      }\n    };\n    const getFirstChildren = node => {\n      return firstChild(node).fold(constant([node]), child => {\n        return [node].concat(getFirstChildren(child));\n      });\n    };\n    const getLastChildren = node => {\n      return lastChild(node).fold(constant([node]), child => {\n        if (name(child) === 'br') {\n          return prevSibling(child).map(sibling => {\n            return [node].concat(getLastChildren(sibling));\n          }).getOr([]);\n        } else {\n          return [node].concat(getLastChildren(child));\n        }\n      });\n    };\n    const hasAllContentsSelected = (elm, rng) => {\n      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\n        const start = find$2(getFirstChildren(elm), curry(eq, startNode));\n        const end = find$2(getLastChildren(elm), curry(eq, endNode));\n        return start.isSome() && end.isSome();\n      }).getOr(false);\n    };\n    const moveEndPoint = (dom, rng, node, start) => {\n      const root = node;\n      const walker = new DomTreeWalker(node, root);\n      const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2([\n        'td',\n        'th',\n        'table'\n      ], name.toLowerCase()));\n      let currentNode = node;\n      do {\n        if (isText$a(currentNode) && Tools.trim(currentNode.data).length !== 0) {\n          if (start) {\n            rng.setStart(currentNode, 0);\n          } else {\n            rng.setEnd(currentNode, currentNode.data.length);\n          }\n          return;\n        }\n        if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {\n          if (start) {\n            rng.setStartBefore(currentNode);\n          } else {\n            if (currentNode.nodeName === 'BR') {\n              rng.setEndBefore(currentNode);\n            } else {\n              rng.setEndAfter(currentNode);\n            }\n          }\n          return;\n        }\n      } while (currentNode = start ? walker.next() : walker.prev());\n      if (root.nodeName === 'BODY') {\n        if (start) {\n          rng.setStart(root, 0);\n        } else {\n          rng.setEnd(root, root.childNodes.length);\n        }\n      }\n    };\n    const hasAnyRanges = editor => {\n      const sel = editor.selection.getSel();\n      return isNonNullable(sel) && sel.rangeCount > 0;\n    };\n    const runOnRanges = (editor, executor) => {\n      const fakeSelectionNodes = getCellsFromEditor(editor);\n      if (fakeSelectionNodes.length > 0) {\n        each$e(fakeSelectionNodes, elem => {\n          const node = elem.dom;\n          const fakeNodeRng = editor.dom.createRng();\n          fakeNodeRng.setStartBefore(node);\n          fakeNodeRng.setEndAfter(node);\n          executor(fakeNodeRng, true);\n        });\n      } else {\n        executor(editor.selection.getRng(), false);\n      }\n    };\n    const preserve = (selection, fillBookmark, executor) => {\n      const bookmark = getPersistentBookmark(selection, fillBookmark);\n      executor(bookmark);\n      selection.moveToBookmark(bookmark);\n    };\n\n    const isNode = node => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);\n    const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n    const isElementDirectlySelected = (dom, node) => {\n      if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {\n        const selectedAttr = dom.getAttrib(node, 'data-mce-selected');\n        const value = parseInt(selectedAttr, 10);\n        return !isNaN(value) && value > 0;\n      } else {\n        return false;\n      }\n    };\n    const preserveSelection = (editor, action, shouldMoveStart) => {\n      const {selection, dom} = editor;\n      const selectedNodeBeforeAction = selection.getNode();\n      const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);\n      preserve(selection, true, () => {\n        action();\n      });\n      const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);\n      if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {\n        editor.selection.select(selectedNodeBeforeAction);\n      } else if (shouldMoveStart(selection.getStart())) {\n        moveStartToNearestText(dom, selection);\n      }\n    };\n    const moveStartToNearestText = (dom, selection) => {\n      var _a, _b;\n      const rng = selection.getRng();\n      const {startContainer, startOffset} = rng;\n      const selectedNode = selection.getNode();\n      if (isElementDirectlySelected(dom, selectedNode)) {\n        return;\n      }\n      if (isElement$6(startContainer)) {\n        const nodes = startContainer.childNodes;\n        const root = dom.getRoot();\n        let walker;\n        if (startOffset < nodes.length) {\n          const startNode = nodes[startOffset];\n          walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);\n        } else {\n          const startNode = nodes[nodes.length - 1];\n          walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);\n          walker.next(true);\n        }\n        for (let node = walker.current(); node; node = walker.next()) {\n          if (dom.getContentEditable(node) === 'false') {\n            return;\n          } else if (isText$a(node) && !isWhiteSpaceNode$1(node)) {\n            rng.setStart(node, 0);\n            selection.setRng(rng);\n            return;\n          }\n        }\n      }\n    };\n    const getNonWhiteSpaceSibling = (node, next, inc) => {\n      if (node) {\n        const nextName = next ? 'nextSibling' : 'previousSibling';\n        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\n          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\n            return node;\n          }\n        }\n      }\n      return undefined;\n    };\n    const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);\n    const isValid = (ed, parent, child) => {\n      return ed.schema.isValidChild(parent, child);\n    };\n    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {\n      if (isNonNullable(node) && isText$a(node)) {\n        const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\n        return isWhitespaceText(data);\n      } else {\n        return false;\n      }\n    };\n    const isEmptyTextNode$1 = node => {\n      return isNonNullable(node) && isText$a(node) && node.length === 0;\n    };\n    const isWrapNoneditableTarget = (editor, node) => {\n      const baseDataSelector = '[data-mce-cef-wrappable]';\n      const formatNoneditableSelector = getFormatNoneditableSelector(editor);\n      const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${ baseDataSelector },${ formatNoneditableSelector }`;\n      return is$1(SugarElement.fromDom(node), selector);\n    };\n    const isWrappableNoneditable = (editor, node) => {\n      const dom = editor.dom;\n      return isElementNode$1(node) && dom.getContentEditable(node) === 'false' && isWrapNoneditableTarget(editor, node) && dom.select('[contenteditable=\"true\"]', node).length === 0;\n    };\n    const replaceVars = (value, vars) => {\n      if (isFunction(value)) {\n        return value(vars);\n      } else if (isNonNullable(vars)) {\n        value = value.replace(/%(\\w+)/g, (str, name) => {\n          return vars[name] || str;\n        });\n      }\n      return value;\n    };\n    const isEq$5 = (str1, str2) => {\n      str1 = str1 || '';\n      str2 = str2 || '';\n      str1 = '' + (str1.nodeName || str1);\n      str2 = '' + (str2.nodeName || str2);\n      return str1.toLowerCase() === str2.toLowerCase();\n    };\n    const normalizeStyleValue = (value, name) => {\n      if (isNullable(value)) {\n        return null;\n      } else {\n        let strValue = String(value);\n        if (name === 'color' || name === 'backgroundColor') {\n          strValue = rgbaToHexString(strValue);\n        }\n        if (name === 'fontWeight' && value === 700) {\n          strValue = 'bold';\n        }\n        if (name === 'fontFamily') {\n          strValue = strValue.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\n        }\n        return strValue;\n      }\n    };\n    const getStyle = (dom, node, name) => {\n      const style = dom.getStyle(node, name);\n      return normalizeStyleValue(style, name);\n    };\n    const getTextDecoration = (dom, node) => {\n      let decoration;\n      dom.getParent(node, n => {\n        if (isElement$6(n)) {\n          decoration = dom.getStyle(n, 'text-decoration');\n          return !!decoration && decoration !== 'none';\n        } else {\n          return false;\n        }\n      });\n      return decoration;\n    };\n    const getParents$2 = (dom, node, selector) => {\n      return dom.getParents(node, selector, dom.getRoot());\n    };\n    const isFormatPredicate = (editor, formatName, predicate) => {\n      const formats = editor.formatter.get(formatName);\n      return isNonNullable(formats) && exists(formats, predicate);\n    };\n    const isVariableFormatName = (editor, formatName) => {\n      const hasVariableValues = format => {\n        const isVariableValue = val => isFunction(val) || val.length > 1 && val.charAt(0) === '%';\n        return exists([\n          'styles',\n          'attributes'\n        ], key => get$a(format, key).exists(field => {\n          const fieldValues = isArray$1(field) ? field : values(field);\n          return exists(fieldValues, isVariableValue);\n        }));\n      };\n      return isFormatPredicate(editor, formatName, hasVariableValues);\n    };\n    const areSimilarFormats = (editor, formatName, otherFormatName) => {\n      const validKeys = [\n        'inline',\n        'block',\n        'selector',\n        'attributes',\n        'styles',\n        'classes'\n      ];\n      const filterObj = format => filter$4(format, (_, key) => exists(validKeys, validKey => validKey === key));\n      return isFormatPredicate(editor, formatName, fmt1 => {\n        const filteredFmt1 = filterObj(fmt1);\n        return isFormatPredicate(editor, otherFormatName, fmt2 => {\n          const filteredFmt2 = filterObj(fmt2);\n          return equal$1(filteredFmt1, filteredFmt2);\n        });\n      });\n    };\n    const isBlockFormat = format => hasNonNullableKey(format, 'block');\n    const isWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper === true;\n    const isNonWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper !== true;\n    const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\n    const isInlineFormat = format => hasNonNullableKey(format, 'inline');\n    const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\n    const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\n    const getEmptyCaretContainers = node => {\n      const nodes = [];\n      let tempNode = node;\n      while (tempNode) {\n        if (isText$a(tempNode) && tempNode.data !== ZWSP$1 || tempNode.childNodes.length > 1) {\n          return [];\n        }\n        if (isElement$6(tempNode)) {\n          nodes.push(tempNode);\n        }\n        tempNode = tempNode.firstChild;\n      }\n      return nodes;\n    };\n    const isCaretContainerEmpty = node => {\n      return getEmptyCaretContainers(node).length > 0;\n    };\n    const isEmptyCaretFormatElement = element => {\n      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\n    };\n\n    const isBookmarkNode = isBookmarkNode$1;\n    const getParents$1 = getParents$2;\n    const isWhiteSpaceNode = isWhiteSpaceNode$1;\n    const isTextBlock = isTextBlock$1;\n    const isBogusBr = node => {\n      return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\n    };\n    const findParentContentEditable = (dom, node) => {\n      let parent = node;\n      while (parent) {\n        if (isElement$6(parent) && dom.getContentEditable(parent)) {\n          return dom.getContentEditable(parent) === 'false' ? parent : node;\n        }\n        parent = parent.parentNode;\n      }\n      return node;\n    };\n    const walkText = (start, node, offset, predicate) => {\n      const str = node.data;\n      if (start) {\n        for (let i = offset; i > 0; i--) {\n          if (predicate(str.charAt(i - 1))) {\n            return i;\n          }\n        }\n      } else {\n        for (let i = offset; i < str.length; i++) {\n          if (predicate(str.charAt(i))) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\n    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\n    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\n      let lastTextNode;\n      const rootNode = dom.getParent(container, dom.isBlock) || body;\n      const walk = (container, offset, pred) => {\n        const textSeeker = TextSeeker(dom);\n        const walker = start ? textSeeker.backwards : textSeeker.forwards;\n        return Optional.from(walker(container, offset, (text, textOffset) => {\n          if (isBookmarkNode(text.parentNode)) {\n            return -1;\n          } else {\n            lastTextNode = text;\n            return pred(start, text, textOffset);\n          }\n        }, rootNode));\n      };\n      const spaceResult = walk(container, offset, findSpace);\n      return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\n        container: lastTextNode,\n        offset: start ? 0 : lastTextNode.length\n      }) : Optional.none());\n    };\n    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\n      const sibling = container[siblingName];\n      if (isText$a(container) && isEmpty$3(container.data) && sibling) {\n        container = sibling;\n      }\n      const parents = getParents$1(dom, container);\n      for (let i = 0; i < parents.length; i++) {\n        for (let y = 0; y < formatList.length; y++) {\n          const curFormat = formatList[y];\n          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\n            continue;\n          }\n          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\n            return parents[i];\n          }\n        }\n      }\n      return container;\n    };\n    const findBlockEndPoint = (dom, formatList, container, siblingName) => {\n      var _a;\n      let node = container;\n      const root = dom.getRoot();\n      const format = formatList[0];\n      if (isBlockFormat(format)) {\n        node = format.wrapper ? null : dom.getParent(container, format.block, root);\n      }\n      if (!node) {\n        const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH,SUMMARY')) !== null && _a !== void 0 ? _a : root;\n        node = dom.getParent(isText$a(container) ? container.parentNode : container, node => node !== root && isTextBlock(dom.schema, node), scopeRoot);\n      }\n      if (node && isBlockFormat(format) && format.wrapper) {\n        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\n      }\n      if (!node) {\n        node = container;\n        while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {\n          node = node[siblingName];\n          if (isEq$5(node, 'br')) {\n            break;\n          }\n        }\n      }\n      return node || container;\n    };\n    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\n      const parent = container.parentNode;\n      if (isNonNullable(container[siblingName])) {\n        return false;\n      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\n        return true;\n      } else {\n        return isAtBlockBoundary$1(dom, root, parent, siblingName);\n      }\n    };\n    const findParentContainer = (dom, formatList, container, offset, start) => {\n      let parent = container;\n      const siblingName = start ? 'previousSibling' : 'nextSibling';\n      const root = dom.getRoot();\n      if (isText$a(container) && !isWhiteSpaceNode(container)) {\n        if (start ? offset > 0 : offset < container.data.length) {\n          return container;\n        }\n      }\n      while (parent) {\n        if (!formatList[0].block_expand && dom.isBlock(parent)) {\n          return parent;\n        }\n        for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n          const allowSpaces = isText$a(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\n          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\n            return parent;\n          }\n        }\n        if (parent === root || parent.parentNode === root) {\n          container = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return container;\n    };\n    const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\n    const expandRng = (dom, rng, formatList, includeTrailingSpace = false) => {\n      let {startContainer, startOffset, endContainer, endOffset} = rng;\n      const format = formatList[0];\n      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\n        startContainer = getNode$1(startContainer, startOffset);\n        if (isText$a(startContainer)) {\n          startOffset = 0;\n        }\n      }\n      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\n        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\n        if (isText$a(endContainer)) {\n          endOffset = endContainer.data.length;\n        }\n      }\n      startContainer = findParentContentEditable(dom, startContainer);\n      endContainer = findParentContentEditable(dom, endContainer);\n      if (isSelfOrParentBookmark(startContainer)) {\n        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n        if (rng.collapsed) {\n          startContainer = startContainer.previousSibling || startContainer;\n        } else {\n          startContainer = startContainer.nextSibling || startContainer;\n        }\n        if (isText$a(startContainer)) {\n          startOffset = rng.collapsed ? startContainer.length : 0;\n        }\n      }\n      if (isSelfOrParentBookmark(endContainer)) {\n        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n        if (rng.collapsed) {\n          endContainer = endContainer.nextSibling || endContainer;\n        } else {\n          endContainer = endContainer.previousSibling || endContainer;\n        }\n        if (isText$a(endContainer)) {\n          endOffset = rng.collapsed ? 0 : endContainer.length;\n        }\n      }\n      if (rng.collapsed) {\n        const startPoint = findWordEndPoint(dom, dom.getRoot(), startContainer, startOffset, true, includeTrailingSpace);\n        startPoint.each(({container, offset}) => {\n          startContainer = container;\n          startOffset = offset;\n        });\n        const endPoint = findWordEndPoint(dom, dom.getRoot(), endContainer, endOffset, false, includeTrailingSpace);\n        endPoint.each(({container, offset}) => {\n          endContainer = container;\n          endOffset = offset;\n        });\n      }\n      if (isInlineFormat(format) || format.block_expand) {\n        if (!isInlineFormat(format) || (!isText$a(startContainer) || startOffset === 0)) {\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n        }\n        if (!isInlineFormat(format) || (!isText$a(endContainer) || endOffset === endContainer.data.length)) {\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n        }\n      }\n      if (shouldExpandToSelector(format)) {\n        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\n        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\n      }\n      if (isBlockFormat(format) || isSelectorFormat(format)) {\n        startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');\n        endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');\n        if (isBlockFormat(format)) {\n          if (!dom.isBlock(startContainer)) {\n            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n          }\n          if (!dom.isBlock(endContainer)) {\n            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n          }\n        }\n      }\n      if (isElement$6(startContainer) && startContainer.parentNode) {\n        startOffset = dom.nodeIndex(startContainer);\n        startContainer = startContainer.parentNode;\n      }\n      if (isElement$6(endContainer) && endContainer.parentNode) {\n        endOffset = dom.nodeIndex(endContainer) + 1;\n        endContainer = endContainer.parentNode;\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const walk$3 = (dom, rng, callback) => {\n      var _a;\n      const startOffset = rng.startOffset;\n      const startContainer = getNode$1(rng.startContainer, startOffset);\n      const endOffset = rng.endOffset;\n      const endContainer = getNode$1(rng.endContainer, endOffset - 1);\n      const exclude = nodes => {\n        const firstNode = nodes[0];\n        if (isText$a(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\n          nodes.splice(0, 1);\n        }\n        const lastNode = nodes[nodes.length - 1];\n        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$a(lastNode)) {\n          nodes.splice(nodes.length - 1, 1);\n        }\n        return nodes;\n      };\n      const collectSiblings = (node, name, endNode) => {\n        const siblings = [];\n        for (; node && node !== endNode; node = node[name]) {\n          siblings.push(node);\n        }\n        return siblings;\n      };\n      const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\n      const walkBoundary = (startNode, endNode, next) => {\n        const siblingName = next ? 'nextSibling' : 'previousSibling';\n        for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\n          parent = node.parentNode;\n          const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\n          if (siblings.length) {\n            if (!next) {\n              siblings.reverse();\n            }\n            callback(exclude(siblings));\n          }\n        }\n      };\n      if (startContainer === endContainer) {\n        return callback(exclude([startContainer]));\n      }\n      const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      if (dom.isChildOf(startContainer, endContainer)) {\n        return walkBoundary(startContainer, ancestor, true);\n      }\n      if (dom.isChildOf(endContainer, startContainer)) {\n        return walkBoundary(endContainer, ancestor);\n      }\n      const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\n      const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\n      walkBoundary(startContainer, startPoint, true);\n      const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\n      if (siblings.length) {\n        callback(exclude(siblings));\n      }\n      walkBoundary(endContainer, endPoint);\n    };\n\n    const validBlocks = [\n      'pre[class*=language-][contenteditable=\"false\"]',\n      'figure.image',\n      'div[data-ephox-embed-iri]',\n      'div.tiny-pageembed',\n      'div.mce-toc',\n      'div[data-mce-toc]'\n    ];\n    const isZeroWidth = elem => isText$b(elem) && get$3(elem) === ZWSP$1;\n    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\n      if (nodeName === 'br' || isZeroWidth(elem)) {\n        return 'valid';\n      } else if (isAnnotation(elem)) {\n        return 'existing';\n      } else if (isCaretNode(elem.dom)) {\n        return 'caret';\n      } else if (exists(validBlocks, selector => is$1(elem, selector))) {\n        return 'valid-block';\n      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\n        return 'invalid-child';\n      } else {\n        return 'valid';\n      }\n    });\n\n    const applyWordGrab = (editor, rng) => {\n      const r = expandRng(editor.dom, rng, [{ inline: 'span' }]);\n      rng.setStart(r.startContainer, r.startOffset);\n      rng.setEnd(r.endContainer, r.endOffset);\n      editor.selection.setRng(rng);\n    };\n    const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {\n      const {uid = masterUId, ...otherData} = data;\n      add$2(elem, annotation());\n      set$3(elem, `${ dataAnnotationId() }`, uid);\n      set$3(elem, `${ dataAnnotation() }`, annotationName);\n      const {attributes = {}, classes = []} = decorate(uid, otherData);\n      setAll$1(elem, attributes);\n      add(elem, classes);\n      if (directAnnotation) {\n        if (classes.length > 0) {\n          set$3(elem, `${ dataAnnotationClasses() }`, classes.join(','));\n        }\n        const attributeNames = keys(attributes);\n        if (attributeNames.length > 0) {\n          set$3(elem, `${ dataAnnotationAttributes() }`, attributeNames.join(','));\n        }\n      }\n    };\n    const removeDirectAnnotation = elem => {\n      remove$7(elem, annotation());\n      remove$a(elem, `${ dataAnnotationId() }`);\n      remove$a(elem, `${ dataAnnotation() }`);\n      remove$a(elem, `${ dataAnnotationActive() }`);\n      const customAttrNames = getOpt(elem, `${ dataAnnotationAttributes() }`).map(names => names.split(',')).getOr([]);\n      const customClasses = getOpt(elem, `${ dataAnnotationClasses() }`).map(names => names.split(',')).getOr([]);\n      each$e(customAttrNames, name => remove$a(elem, name));\n      remove$4(elem, customClasses);\n      remove$a(elem, `${ dataAnnotationClasses() }`);\n      remove$a(elem, `${ dataAnnotationAttributes() }`);\n    };\n    const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {\n      const master = SugarElement.fromTag('span', eDoc);\n      applyAnnotation(master, uid, data, annotationName, decorate, false);\n      return master;\n    };\n    const annotate = (editor, rng, uid, annotationName, decorate, data) => {\n      const newWrappers = [];\n      const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);\n      const wrapper = value$2();\n      const finishWrapper = () => {\n        wrapper.clear();\n      };\n      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\n        const nu = shallow$1(master);\n        newWrappers.push(nu);\n        wrapper.set(nu);\n        return nu;\n      });\n      const processElements = elems => {\n        each$e(elems, processElement);\n      };\n      const processElement = elem => {\n        const ctx = context(editor, elem, 'span', name(elem));\n        switch (ctx) {\n        case 'invalid-child': {\n            finishWrapper();\n            const children = children$1(elem);\n            processElements(children);\n            finishWrapper();\n            break;\n          }\n        case 'valid-block': {\n            finishWrapper();\n            applyAnnotation(elem, uid, data, annotationName, decorate, true);\n            break;\n          }\n        case 'valid': {\n            const w = getOrOpenWrapper();\n            wrap$2(elem, w);\n            break;\n          }\n        }\n      };\n      const processNodes = nodes => {\n        const elems = map$3(nodes, SugarElement.fromDom);\n        processElements(elems);\n      };\n      walk$3(editor.dom, rng, nodes => {\n        finishWrapper();\n        processNodes(nodes);\n      });\n      return newWrappers;\n    };\n    const annotateWithBookmark = (editor, name, settings, data) => {\n      editor.undoManager.transact(() => {\n        const selection = editor.selection;\n        const initialRng = selection.getRng();\n        const hasFakeSelection = getCellsFromEditor(editor).length > 0;\n        const masterUid = generate$1('mce-annotation');\n        if (initialRng.collapsed && !hasFakeSelection) {\n          applyWordGrab(editor, initialRng);\n        }\n        if (selection.getRng().collapsed && !hasFakeSelection) {\n          const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);\n          set$1(wrapper, nbsp);\n          selection.getRng().insertNode(wrapper.dom);\n          selection.select(wrapper.dom);\n        } else {\n          preserve(selection, false, () => {\n            runOnRanges(editor, selectionRng => {\n              annotate(editor, selectionRng, masterUid, name, settings.decorate, data);\n            });\n          });\n        }\n      });\n    };\n\n    const Annotator = editor => {\n      const registry = create$c();\n      setup$x(editor, registry);\n      const changes = setup$y(editor, registry);\n      const isSpan = isTag('span');\n      const removeAnnotations = elements => {\n        each$e(elements, element => {\n          if (isSpan(element)) {\n            unwrap(element);\n          } else {\n            removeDirectAnnotation(element);\n          }\n        });\n      };\n      return {\n        register: (name, settings) => {\n          registry.register(name, settings);\n        },\n        annotate: (name, data) => {\n          registry.lookup(name).each(settings => {\n            annotateWithBookmark(editor, name, settings, data);\n          });\n        },\n        annotationChanged: (name, callback) => {\n          changes.addListener(name, callback);\n        },\n        remove: name => {\n          identify(editor, Optional.some(name)).each(({elements}) => {\n            const bookmark = editor.selection.getBookmark();\n            removeAnnotations(elements);\n            editor.selection.moveToBookmark(bookmark);\n          });\n        },\n        removeAll: name => {\n          const bookmark = editor.selection.getBookmark();\n          each$d(findAll(editor, name), (elements, _) => {\n            removeAnnotations(elements);\n          });\n          editor.selection.moveToBookmark(bookmark);\n        },\n        getAll: name => {\n          const directory = findAll(editor, name);\n          return map$2(directory, elems => map$3(elems, elem => elem.dom));\n        }\n      };\n    };\n\n    const BookmarkManager = selection => {\n      return {\n        getBookmark: curry(getBookmark$1, selection),\n        moveToBookmark: curry(moveToBookmark, selection)\n      };\n    };\n    BookmarkManager.isBookmarkNode = isBookmarkNode$1;\n\n    const isXYWithinRange = (clientX, clientY, range) => {\n      if (range.collapsed) {\n        return false;\n      } else {\n        return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\n      }\n    };\n\n    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\n    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\n    const fireRemove = editor => {\n      editor.dispatch('remove');\n    };\n    const fireDetach = editor => {\n      editor.dispatch('detach');\n    };\n    const fireSwitchMode = (editor, mode) => {\n      editor.dispatch('SwitchMode', { mode });\n    };\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResizeStart', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const fireObjectResized = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResized', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const firePreInit = editor => {\n      editor.dispatch('PreInit');\n    };\n    const firePostRender = editor => {\n      editor.dispatch('PostRender');\n    };\n    const fireInit = editor => {\n      editor.dispatch('Init');\n    };\n    const firePlaceholderToggle = (editor, state) => {\n      editor.dispatch('PlaceholderToggle', { state });\n    };\n    const fireError = (editor, errorType, error) => {\n      editor.dispatch(errorType, error);\n    };\n    const fireFormatApply = (editor, format, node, vars) => {\n      editor.dispatch('FormatApply', {\n        format,\n        node,\n        vars\n      });\n    };\n    const fireFormatRemove = (editor, format, node, vars) => {\n      editor.dispatch('FormatRemove', {\n        format,\n        node,\n        vars\n      });\n    };\n    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\n    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\n    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\n    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\n    const fireAutocompleterStart = (editor, args) => {\n      editor.dispatch('AutocompleterStart', args);\n    };\n    const fireAutocompleterUpdate = (editor, args) => {\n      editor.dispatch('AutocompleterUpdate', args);\n    };\n    const fireAutocompleterEnd = editor => {\n      editor.dispatch('AutocompleterEnd');\n    };\n    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\n      content: html,\n      internal\n    });\n    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\n      node,\n      internal\n    });\n    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });\n    const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', { state });\n\n    const VK = {\n      BACKSPACE: 8,\n      DELETE: 46,\n      DOWN: 40,\n      ENTER: 13,\n      ESC: 27,\n      LEFT: 37,\n      RIGHT: 39,\n      SPACEBAR: 32,\n      TAB: 9,\n      UP: 38,\n      PAGE_UP: 33,\n      PAGE_DOWN: 34,\n      END: 35,\n      HOME: 36,\n      modifierPressed: e => {\n        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\n      },\n      metaKeyPressed: e => {\n        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n      }\n    };\n\n    const elementSelectionAttr = 'data-mce-selected';\n    const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';\n    const abs = Math.abs;\n    const round$1 = Math.round;\n    const resizeHandles = {\n      nw: [\n        0,\n        0,\n        -1,\n        -1\n      ],\n      ne: [\n        1,\n        0,\n        1,\n        -1\n      ],\n      se: [\n        1,\n        1,\n        1,\n        1\n      ],\n      sw: [\n        0,\n        1,\n        -1,\n        1\n      ]\n    };\n    const isTouchEvent = evt => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;\n    const ControlSelection = (selection, editor) => {\n      const dom = editor.dom;\n      const editableDoc = editor.getDoc();\n      const rootDocument = document;\n      const rootElement = editor.getBody();\n      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\n      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n      let width;\n      let height;\n      let startScrollWidth;\n      let startScrollHeight;\n      const isImage = elm => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));\n      const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\n      const isEventOnImageOutsideRange = (evt, range) => {\n        if (isTouchEvent(evt)) {\n          const touch = evt.touches[0];\n          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\n        } else {\n          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\n        }\n      };\n      const contextMenuSelectImage = evt => {\n        const target = evt.target;\n        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\n          editor.selection.select(target);\n        }\n      };\n      const getResizeTargets = elm => {\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return [\n            elm,\n            elm.firstElementChild\n          ];\n        } else if (dom.is(elm, 'figure.image')) {\n          return [elm.querySelector('img')];\n        } else {\n          return [elm];\n        }\n      };\n      const isResizable = elm => {\n        const selector = getObjectResizing(editor);\n        if (!selector) {\n          return false;\n        }\n        if (elm.getAttribute('data-mce-resize') === 'false') {\n          return false;\n        }\n        if (elm === editor.getBody()) {\n          return false;\n        }\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\n        } else {\n          return is$1(SugarElement.fromDom(elm), selector);\n        }\n      };\n      const createGhostElement = elm => {\n        if (isMedia(elm)) {\n          return dom.create('img', { src: Env.transparentSrc });\n        } else {\n          return elm.cloneNode(true);\n        }\n      };\n      const setSizeProp = (element, name, value) => {\n        if (isNonNullable(value)) {\n          const targets = getResizeTargets(element);\n          each$e(targets, target => {\n            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\n              dom.setStyle(target, name, value);\n            } else {\n              dom.setAttrib(target, name, '' + value);\n            }\n          });\n        }\n      };\n      const setGhostElmSize = (ghostElm, width, height) => {\n        setSizeProp(ghostElm, 'width', width);\n        setSizeProp(ghostElm, 'height', height);\n      };\n      const resizeGhostElement = e => {\n        let deltaX, deltaY, proportional;\n        let resizeHelperX, resizeHelperY;\n        deltaX = e.screenX - startX;\n        deltaY = e.screenY - startY;\n        width = deltaX * selectedHandle[2] + startW;\n        height = deltaY * selectedHandle[3] + startH;\n        width = width < 5 ? 5 : width;\n        height = height < 5 ? 5 : height;\n        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\n          proportional = !VK.modifierPressed(e);\n        } else {\n          proportional = VK.modifierPressed(e);\n        }\n        if (proportional) {\n          if (abs(deltaX) > abs(deltaY)) {\n            height = round$1(width * ratio);\n            width = round$1(height / ratio);\n          } else {\n            width = round$1(height / ratio);\n            height = round$1(width * ratio);\n          }\n        }\n        setGhostElmSize(selectedElmGhost, width, height);\n        resizeHelperX = selectedHandle.startPos.x + deltaX;\n        resizeHelperY = selectedHandle.startPos.y + deltaY;\n        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\n        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\n        dom.setStyles(resizeHelper, {\n          left: resizeHelperX,\n          top: resizeHelperY,\n          display: 'block'\n        });\n        resizeHelper.innerHTML = width + ' &times; ' + height;\n        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\n          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\n        }\n        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\n          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\n        }\n        deltaX = rootElement.scrollWidth - startScrollWidth;\n        deltaY = rootElement.scrollHeight - startScrollHeight;\n        if (deltaX + deltaY !== 0) {\n          dom.setStyles(resizeHelper, {\n            left: resizeHelperX - deltaX,\n            top: resizeHelperY - deltaY\n          });\n        }\n        if (!resizeStarted) {\n          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\n          resizeStarted = true;\n        }\n      };\n      const endGhostResize = () => {\n        const wasResizeStarted = resizeStarted;\n        resizeStarted = false;\n        if (wasResizeStarted) {\n          setSizeProp(selectedElm, 'width', width);\n          setSizeProp(selectedElm, 'height', height);\n        }\n        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\n        dom.unbind(editableDoc, 'mouseup', endGhostResize);\n        if (rootDocument !== editableDoc) {\n          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\n          dom.unbind(rootDocument, 'mouseup', endGhostResize);\n        }\n        dom.remove(selectedElmGhost);\n        dom.remove(resizeHelper);\n        dom.remove(resizeBackdrop);\n        showResizeRect(selectedElm);\n        if (wasResizeStarted) {\n          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\n          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\n        }\n        editor.nodeChanged();\n      };\n      const showResizeRect = targetElm => {\n        unbindResizeHandleEvents();\n        const position = dom.getPos(targetElm, rootElement);\n        const selectedElmX = position.x;\n        const selectedElmY = position.y;\n        const rect = targetElm.getBoundingClientRect();\n        const targetWidth = rect.width || rect.right - rect.left;\n        const targetHeight = rect.height || rect.bottom - rect.top;\n        if (selectedElm !== targetElm) {\n          hideResizeRect();\n          selectedElm = targetElm;\n          width = height = 0;\n        }\n        const e = editor.dispatch('ObjectSelected', { target: targetElm });\n        if (isResizable(targetElm) && !e.isDefaultPrevented()) {\n          each$d(resizeHandles, (handle, name) => {\n            const startDrag = e => {\n              const target = getResizeTargets(selectedElm)[0];\n              startX = e.screenX;\n              startY = e.screenY;\n              startW = target.clientWidth;\n              startH = target.clientHeight;\n              ratio = startH / startW;\n              selectedHandle = handle;\n              selectedHandle.name = name;\n              selectedHandle.startPos = {\n                x: targetWidth * handle[0] + selectedElmX,\n                y: targetHeight * handle[1] + selectedElmY\n              };\n              startScrollWidth = rootElement.scrollWidth;\n              startScrollHeight = rootElement.scrollHeight;\n              resizeBackdrop = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-backdrop',\n                'data-mce-bogus': 'all'\n              });\n              dom.setStyles(resizeBackdrop, {\n                position: 'fixed',\n                left: '0',\n                top: '0',\n                width: '100%',\n                height: '100%'\n              });\n              selectedElmGhost = createGhostElement(selectedElm);\n              dom.addClass(selectedElmGhost, 'mce-clonedresizable');\n              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\n              selectedElmGhost.contentEditable = 'false';\n              dom.setStyles(selectedElmGhost, {\n                left: selectedElmX,\n                top: selectedElmY,\n                margin: 0\n              });\n              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\n              selectedElmGhost.removeAttribute(elementSelectionAttr);\n              rootElement.appendChild(selectedElmGhost);\n              dom.bind(editableDoc, 'mousemove', resizeGhostElement);\n              dom.bind(editableDoc, 'mouseup', endGhostResize);\n              if (rootDocument !== editableDoc) {\n                dom.bind(rootDocument, 'mousemove', resizeGhostElement);\n                dom.bind(rootDocument, 'mouseup', endGhostResize);\n              }\n              resizeHelper = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-helper',\n                'data-mce-bogus': 'all'\n              }, startW + ' &times; ' + startH);\n            };\n            let handleElm = dom.get('mceResizeHandle' + name);\n            if (handleElm) {\n              dom.remove(handleElm);\n            }\n            handleElm = dom.add(rootElement, 'div', {\n              'id': 'mceResizeHandle' + name,\n              'data-mce-bogus': 'all',\n              'class': 'mce-resizehandle',\n              'unselectable': true,\n              'style': 'cursor:' + name + '-resize; margin:0; padding:0'\n            });\n            dom.bind(handleElm, 'mousedown', e => {\n              e.stopImmediatePropagation();\n              e.preventDefault();\n              startDrag(e);\n            });\n            handle.elm = handleElm;\n            dom.setStyles(handleElm, {\n              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\n              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\n            });\n          });\n        } else {\n          hideResizeRect(false);\n        }\n      };\n      const throttledShowResizeRect = first$1(showResizeRect, 0);\n      const hideResizeRect = (removeSelected = true) => {\n        throttledShowResizeRect.cancel();\n        unbindResizeHandleEvents();\n        if (selectedElm && removeSelected) {\n          selectedElm.removeAttribute(elementSelectionAttr);\n        }\n        each$d(resizeHandles, (value, name) => {\n          const handleElm = dom.get('mceResizeHandle' + name);\n          if (handleElm) {\n            dom.unbind(handleElm);\n            dom.remove(handleElm);\n          }\n        });\n      };\n      const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);\n      const updateResizeRect = e => {\n        if (resizeStarted || editor.removed || editor.composing) {\n          return;\n        }\n        const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();\n        const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map(e => e.dom).filter(e => dom.isEditable(e.parentElement) || e.nodeName === 'IMG' && dom.isEditable(e)).getOrUndefined();\n        const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';\n        each$e(dom.select(`img[${ elementSelectionAttr }],hr[${ elementSelectionAttr }]`), img => {\n          img.removeAttribute(elementSelectionAttr);\n        });\n        if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {\n          disableGeckoResize();\n          const startElm = selection.getStart(true);\n          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\n            dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);\n            throttledShowResizeRect.throttle(controlElm);\n            return;\n          }\n        }\n        hideResizeRect();\n      };\n      const unbindResizeHandleEvents = () => {\n        each$d(resizeHandles, handle => {\n          if (handle.elm) {\n            dom.unbind(handle.elm);\n            delete handle.elm;\n          }\n        });\n      };\n      const disableGeckoResize = () => {\n        try {\n          editor.getDoc().execCommand('enableObjectResizing', false, 'false');\n        } catch (ex) {\n        }\n      };\n      editor.on('init', () => {\n        disableGeckoResize();\n        editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);\n        editor.on('keyup compositionend', e => {\n          if (selectedElm && selectedElm.nodeName === 'TABLE') {\n            updateResizeRect(e);\n          }\n        });\n        editor.on('hide blur', hideResizeRect);\n        editor.on('contextmenu longpress', contextMenuSelectImage, true);\n      });\n      editor.on('remove', unbindResizeHandleEvents);\n      const destroy = () => {\n        throttledShowResizeRect.cancel();\n        selectedElm = selectedElmGhost = resizeBackdrop = null;\n      };\n      return {\n        isResizable,\n        showResizeRect,\n        hideResizeRect,\n        updateResizeRect,\n        destroy\n      };\n    };\n\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n\n    const adt$3 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n      } else {\n        return fromRange(win, adt$3.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    adt$3.ltr;\n    adt$3.rtl;\n\n    const create$a = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$a };\n\n    const caretPositionFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n        if (pos.offsetNode === null) {\n          return Optional.none();\n        }\n        const r = doc.dom.createRange();\n        r.setStart(pos.offsetNode, pos.offset);\n        r.collapse();\n        return Optional.some(r);\n      });\n    };\n    const caretRangeFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n    };\n    const availableSearch = (() => {\n      if (document.caretPositionFromPoint) {\n        return caretPositionFromPoint;\n      } else if (document.caretRangeFromPoint) {\n        return caretRangeFromPoint;\n      } else {\n        return Optional.none;\n      }\n    })();\n    const fromPoint$1 = (win, x, y) => {\n      const doc = SugarElement.fromDom(win.document);\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n    };\n\n    const adt$2 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$2 = situ => situ.fold(identity, identity, identity);\n    const before$1 = adt$2.before;\n    const on = adt$2.on;\n    const after$1 = adt$2.after;\n    const Situ = {\n      before: before$1,\n      on,\n      after: after$1,\n      cata,\n      getStart: getStart$2\n    };\n\n    const adt$1 = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart$1 = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt$1.domRange;\n    const relative = adt$1.relative;\n    const exact = adt$1.exact;\n    const getWin = selection => {\n      const start = getStart$1(selection);\n      return defaultView(start);\n    };\n    const range = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range\n    };\n\n    const beforeSpecial = (element, offset) => {\n      const name$1 = name(element);\n      if ('input' === name$1) {\n        return Situ.after(element);\n      } else if (!contains$2([\n          'br',\n          'img'\n        ], name$1)) {\n        return Situ.on(element, offset);\n      } else {\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\n      }\n    };\n    const preprocessRelative = (startSitu, finishSitu) => {\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      return SimSelection.relative(start, finish);\n    };\n    const preprocessExact = (start, soffset, finish, foffset) => {\n      const startSitu = beforeSpecial(start, soffset);\n      const finishSitu = beforeSpecial(finish, foffset);\n      return SimSelection.relative(startSitu, finishSitu);\n    };\n    const preprocess = selection => selection.match({\n      domRange: rng => {\n        const start = SugarElement.fromDom(rng.startContainer);\n        const finish = SugarElement.fromDom(rng.endContainer);\n        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\n      },\n      relative: preprocessRelative,\n      exact: preprocessExact\n    });\n\n    const fromElements = (elements, scope) => {\n      const doc = scope || document;\n      const fragment = doc.createDocumentFragment();\n      each$e(elements, element => {\n        fragment.appendChild(element.dom);\n      });\n      return SugarElement.fromDom(fragment);\n    };\n\n    const toNative = selection => {\n      const win = SimSelection.getWin(selection).dom;\n      const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\n      const filtered = preprocess(selection);\n      return diagnose(win, filtered).match({\n        ltr: getDomRange,\n        rtl: getDomRange\n      });\n    };\n    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\n\n    const fromPoint = (clientX, clientY, doc) => {\n      const win = defaultView(SugarElement.fromDom(doc));\n      return getAtPoint(win.dom, clientX, clientY).map(simRange => {\n        const rng = doc.createRange();\n        rng.setStart(simRange.start.dom, simRange.soffset);\n        rng.setEnd(simRange.finish.dom, simRange.foffset);\n        return rng;\n      }).getOrUndefined();\n    };\n\n    const isEq$4 = (rng1, rng2) => {\n      return isNonNullable(rng1) && isNonNullable(rng2) && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);\n    };\n\n    const findParent = (node, rootNode, predicate) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== rootNode) {\n        if (predicate(currentNode)) {\n          return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return null;\n    };\n    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\n    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => node.nodeName === name);\n    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);\n    const hasBrBeforeAfter = (dom, node, left) => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());\n        let currentNode;\n        while (currentNode = walker[left ? 'prev' : 'next']()) {\n          if (isBr$6(currentNode)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const isPrevNode = (node, name) => {\n      var _a;\n      return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name;\n    };\n    const hasContentEditableFalseParent = (root, node) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== root) {\n        if (isContentEditableFalse$b(currentNode)) {\n          return true;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return false;\n    };\n    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\n      const body = dom.getRoot();\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      const parentNode = startNode.parentNode;\n      let lastInlineElement;\n      let node;\n      if (!parentNode) {\n        return Optional.none();\n      }\n      const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;\n      if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n        return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));\n      }\n      const walker = new DomTreeWalker(startNode, parentBlockContainer);\n      while (node = walker[left ? 'prev' : 'next']()) {\n        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\n          return Optional.none();\n        }\n        if (isText$a(node) && node.data.length > 0) {\n          if (!hasParentWithName(node, body, 'A')) {\n            return Optional.some(CaretPosition(node, left ? node.data.length : 0));\n          }\n          return Optional.none();\n        }\n        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n          return Optional.none();\n        }\n        lastInlineElement = node;\n      }\n      if (isComment(lastInlineElement)) {\n        return Optional.none();\n      }\n      if (collapsed && lastInlineElement) {\n        return Optional.some(CaretPosition(lastInlineElement, 0));\n      }\n      return Optional.none();\n    };\n    const normalizeEndPoint = (dom, collapsed, start, rng) => {\n      const body = dom.getRoot();\n      let node;\n      let normalized = false;\n      let container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      let directionLeft = start;\n      if (isCaretContainer$2(container)) {\n        return Optional.none();\n      }\n      if (isElement$6(container) && offset > container.childNodes.length - 1) {\n        directionLeft = false;\n      }\n      if (isDocument$1(container)) {\n        container = body;\n        offset = 0;\n      }\n      if (container === body) {\n        if (directionLeft) {\n          node = container.childNodes[offset > 0 ? offset - 1 : 0];\n          if (node) {\n            if (isCaretContainer$2(node)) {\n              return Optional.none();\n            }\n            if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {\n              return Optional.none();\n            }\n          }\n        }\n        if (container.hasChildNodes()) {\n          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n          container = container.childNodes[offset];\n          offset = isText$a(container) && isAfterNode ? container.data.length : 0;\n          if (!collapsed && container === body.lastChild && isTable$2(container)) {\n            return Optional.none();\n          }\n          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {\n            return Optional.none();\n          }\n          if (isDetails(container)) {\n            return Optional.none();\n          }\n          if (container.hasChildNodes() && !isTable$2(container)) {\n            node = container;\n            const walker = new DomTreeWalker(container, body);\n            do {\n              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {\n                normalized = false;\n                break;\n              }\n              if (isText$a(node) && node.data.length > 0) {\n                offset = directionLeft ? 0 : node.data.length;\n                container = node;\n                normalized = true;\n                break;\n              }\n              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {\n                offset = dom.nodeIndex(node);\n                container = node.parentNode;\n                if (!directionLeft) {\n                  offset++;\n                }\n                normalized = true;\n                break;\n              }\n            } while (node = directionLeft ? walker.next() : walker.prev());\n          }\n        }\n      }\n      if (collapsed) {\n        if (isText$a(container) && offset === 0) {\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\n            container = pos.container();\n            offset = pos.offset();\n            normalized = true;\n          });\n        }\n        if (isElement$6(container)) {\n          node = container.childNodes[offset];\n          if (!node) {\n            node = container.childNodes[offset - 1];\n          }\n          if (node && isBr$6(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\n            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\n              container = pos.container();\n              offset = pos.offset();\n              normalized = true;\n            });\n          }\n        }\n      }\n      if (directionLeft && !collapsed && isText$a(container) && offset === container.data.length) {\n        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\n          container = pos.container();\n          offset = pos.offset();\n          normalized = true;\n        });\n      }\n      return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();\n    };\n    const normalize$2 = (dom, rng) => {\n      const collapsed = rng.collapsed, normRng = rng.cloneRange();\n      const startPos = CaretPosition.fromRangeStart(rng);\n      normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\n        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\n          normRng.setStart(pos.container(), pos.offset());\n        }\n      });\n      if (!collapsed) {\n        normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\n          normRng.setEnd(pos.container(), pos.offset());\n        });\n      }\n      if (collapsed) {\n        normRng.collapse(true);\n      }\n      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\n    };\n\n    const splitText = (node, offset) => {\n      return node.splitText(offset);\n    };\n    const split = rng => {\n      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;\n      if (startContainer === endContainer && isText$a(startContainer)) {\n        if (startOffset > 0 && startOffset < startContainer.data.length) {\n          endContainer = splitText(startContainer, startOffset);\n          startContainer = endContainer.previousSibling;\n          if (endOffset > startOffset) {\n            endOffset = endOffset - startOffset;\n            const newContainer = splitText(endContainer, endOffset).previousSibling;\n            startContainer = endContainer = newContainer;\n            endOffset = newContainer.data.length;\n            startOffset = 0;\n          } else {\n            endOffset = 0;\n          }\n        }\n      } else {\n        if (isText$a(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {\n          startContainer = splitText(startContainer, startOffset);\n          startOffset = 0;\n        }\n        if (isText$a(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {\n          const newContainer = splitText(endContainer, endOffset).previousSibling;\n          endContainer = newContainer;\n          endOffset = newContainer.data.length;\n        }\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const RangeUtils = dom => {\n      const walk = (rng, callback) => {\n        return walk$3(dom, rng, callback);\n      };\n      const split$1 = split;\n      const normalize = rng => {\n        return normalize$2(dom, rng).fold(never, normalizedRng => {\n          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\n          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\n          return true;\n        });\n      };\n      const expand = (rng, options = { type: 'word' }) => {\n        if (options.type === 'word') {\n          const rangeLike = expandRng(dom, rng, [{ inline: 'span' }]);\n          const newRange = dom.createRng();\n          newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);\n          newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);\n          return newRange;\n        }\n        return rng;\n      };\n      return {\n        walk,\n        split: split$1,\n        expand,\n        normalize\n      };\n    };\n    RangeUtils.compareRanges = isEq$4;\n    RangeUtils.getCaretRangeFromPoint = fromPoint;\n    RangeUtils.getSelectedNode = getSelectedNode;\n    RangeUtils.getNode = getNode$1;\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$7(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$7(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const api = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$2 = element => api.get(element);\n\n    const getDocument = () => SugarElement.fromDom(document);\n\n    const walkUp = (navigation, doc) => {\n      const frame = navigation.view(doc);\n      return frame.fold(constant([]), f => {\n        const parent = navigation.owner(f);\n        const rest = walkUp(navigation, parent);\n        return [f].concat(rest);\n      });\n    };\n    const pathTo = (element, navigation) => {\n      const d = navigation.owner(element);\n      return walkUp(navigation, d);\n    };\n\n    const view = doc => {\n      var _a;\n      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n      return element.map(SugarElement.fromDom);\n    };\n    const owner = element => documentOrOwner(element);\n\n    var Navigation = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        view: view,\n        owner: owner\n    });\n\n    const find = element => {\n      const doc = getDocument();\n      const scroll = get$5(doc);\n      const frames = pathTo(element, Navigation);\n      const offset = viewport(element);\n      const r = foldr(frames, (b, a) => {\n        const loc = viewport(a);\n        return {\n          left: b.left + loc.left,\n          top: b.top + loc.top\n        };\n      }, {\n        left: 0,\n        top: 0\n      });\n      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n    };\n\n    const excludeFromDescend = element => name(element) === 'textarea';\n    const fireScrollIntoViewEvent = (editor, data) => {\n      const scrollEvent = editor.dispatch('ScrollIntoView', data);\n      return scrollEvent.isDefaultPrevented();\n    };\n    const fireAfterScrollIntoViewEvent = (editor, data) => {\n      editor.dispatch('AfterScrollIntoView', data);\n    };\n    const descend = (element, offset) => {\n      const children = children$1(element);\n      if (children.length === 0 || excludeFromDescend(element)) {\n        return {\n          element,\n          offset\n        };\n      } else if (offset < children.length && !excludeFromDescend(children[offset])) {\n        return {\n          element: children[offset],\n          offset: 0\n        };\n      } else {\n        const last = children[children.length - 1];\n        if (excludeFromDescend(last)) {\n          return {\n            element,\n            offset\n          };\n        } else {\n          if (name(last) === 'img') {\n            return {\n              element: last,\n              offset: 1\n            };\n          } else if (isText$b(last)) {\n            return {\n              element: last,\n              offset: get$3(last).length\n            };\n          } else {\n            return {\n              element: last,\n              offset: children$1(last).length\n            };\n          }\n        }\n      }\n    };\n    const markerInfo = (element, cleanupFun) => {\n      const pos = absolute(element);\n      const height = get$2(element);\n      return {\n        element,\n        bottom: pos.top + height,\n        height,\n        pos,\n        cleanup: cleanupFun\n      };\n    };\n    const createMarker$1 = (element, offset) => {\n      const startPoint = descend(element, offset);\n      const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\n      before$3(startPoint.element, span);\n      return markerInfo(span, () => remove$5(span));\n    };\n    const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\n    const withMarker = (editor, f, rng, alignToTop) => {\n      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\n    };\n    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\n      const data = {\n        elm: marker.element.dom,\n        alignToTop\n      };\n      if (fireScrollIntoViewEvent(editor, data)) {\n        return;\n      }\n      const scrollTop = get$5(doc).top;\n      f(editor, doc, scrollTop, marker, alignToTop);\n      fireAfterScrollIntoViewEvent(editor, data);\n    };\n    const applyWithMarker = (editor, f, rng, alignToTop) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const doc = SugarElement.fromDom(editor.getDoc());\n      reflow(body);\n      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n      withScrollEvents(editor, doc, f, marker, alignToTop);\n      marker.cleanup();\n    };\n    const withElement = (editor, element, f, alignToTop) => {\n      const doc = SugarElement.fromDom(editor.getDoc());\n      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\n    };\n    const preserveWith = (editor, f, rng) => {\n      const startElement = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endElement = rng.endContainer;\n      const endOffset = rng.endOffset;\n      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\n      const newRng = editor.dom.createRng();\n      newRng.setStart(startElement, startOffset);\n      newRng.setEnd(endElement, endOffset);\n      editor.selection.setRng(rng);\n    };\n    const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {\n      const pos = marker.pos;\n      if (alignToTop) {\n        to(pos.left, pos.top, doc);\n      } else {\n        const y = pos.top - viewHeight + marker.height;\n        to(-editor.getBody().getBoundingClientRect().left, y, doc);\n      }\n    };\n    const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {\n      const viewportBottom = viewHeight + scrollTop;\n      const markerTop = marker.pos.top;\n      const markerBottom = marker.bottom;\n      const largerThanViewport = markerBottom - markerTop >= viewHeight;\n      if (markerTop < scrollTop) {\n        scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);\n      } else if (markerTop > viewportBottom) {\n        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\n        scrollToMarker(editor, marker, viewHeight, align, doc);\n      } else if (markerBottom > viewportBottom && !largerThanViewport) {\n        scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);\n      }\n    };\n    const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {\n      const viewHeight = defaultView(doc).dom.innerHeight;\n      intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);\n    };\n    const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {\n      const frameViewHeight = defaultView(doc).dom.innerHeight;\n      intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);\n      const op = find(marker.element);\n      const viewportBounds = getBounds(window);\n      if (op.top < viewportBounds.y) {\n        intoView(marker.element, alignToTop !== false);\n      } else if (op.top > viewportBounds.bottom) {\n        intoView(marker.element, alignToTop === true);\n      }\n    };\n    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\n    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\n    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\n    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\n    const scrollElementIntoView = (editor, element, alignToTop) => {\n      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\n      scroller(editor, element, alignToTop);\n    };\n    const scrollRangeIntoView = (editor, rng, alignToTop) => {\n      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\n      scroller(editor, rng, alignToTop);\n    };\n\n    const focus$1 = (element, preventScroll = false) => element.dom.focus({ preventScroll });\n    const hasFocus$1 = element => {\n      const root = getRootNode(element).dom;\n      return element.dom === root.activeElement;\n    };\n    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n\n    const clamp$1 = (offset, element) => {\n      const max = isText$b(element) ? get$3(element).length : children$1(element).length + 1;\n      if (offset > max) {\n        return max;\n      } else if (offset < 0) {\n        return 0;\n      }\n      return offset;\n    };\n    const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\n    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\n    const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\n    const shouldStore = editor => editor.inline || Env.browser.isFirefox();\n    const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n    const readRange = win => {\n      const selection = win.getSelection();\n      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\n      return rng.map(nativeRangeToSelectionRange);\n    };\n    const getBookmark = root => {\n      const win = defaultView(root);\n      return readRange(win.dom).filter(isRngInRoot(root));\n    };\n    const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\n    const bookmarkToNativeRng = bookmark => {\n      const rng = document.createRange();\n      try {\n        rng.setStart(bookmark.start.dom, bookmark.soffset);\n        rng.setEnd(bookmark.finish.dom, bookmark.foffset);\n        return Optional.some(rng);\n      } catch (_) {\n        return Optional.none();\n      }\n    };\n    const store = editor => {\n      const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();\n      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\n    };\n    const getRng = editor => {\n      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\n      return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\n    };\n    const restore = editor => {\n      getRng(editor).each(rng => editor.selection.setRng(rng));\n    };\n\n    const isEditorUIElement$1 = elm => {\n      const className = elm.className.toString();\n      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\n    };\n    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };\n\n    const wrappedSetTimeout = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setTimeout(callback, time);\n    };\n    const wrappedSetInterval = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setInterval(callback, time);\n    };\n    const Delay = {\n      setEditorTimeout: (editor, callback, time) => {\n        return wrappedSetTimeout(() => {\n          if (!editor.removed) {\n            callback();\n          }\n        }, time);\n      },\n      setEditorInterval: (editor, callback, time) => {\n        const timer = wrappedSetInterval(() => {\n          if (!editor.removed) {\n            callback();\n          } else {\n            clearInterval(timer);\n          }\n        }, time);\n        return timer;\n      }\n    };\n\n    const isManualNodeChange = e => {\n      return e.type === 'nodechange' && e.selectionChange;\n    };\n    const registerPageMouseUp = (editor, throttledStore) => {\n      const mouseUpPage = () => {\n        throttledStore.throttle();\n      };\n      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\n      editor.on('remove', () => {\n        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\n      });\n    };\n    const registerMouseUp = (editor, throttledStore) => {\n      editor.on('mouseup touchend', _e => {\n        throttledStore.throttle();\n      });\n    };\n    const registerEditorEvents = (editor, throttledStore) => {\n      registerMouseUp(editor, throttledStore);\n      editor.on('keyup NodeChange AfterSetSelectionRange', e => {\n        if (!isManualNodeChange(e)) {\n          store(editor);\n        }\n      });\n    };\n    const register$6 = editor => {\n      const throttledStore = first$1(() => {\n        store(editor);\n      }, 0);\n      editor.on('init', () => {\n        if (editor.inline) {\n          registerPageMouseUp(editor, throttledStore);\n        }\n        registerEditorEvents(editor, throttledStore);\n      });\n      editor.on('remove', () => {\n        throttledStore.cancel();\n      });\n    };\n\n    let documentFocusInHandler;\n    const DOM$9 = DOMUtils.DOM;\n    const isEditorUIElement = elm => {\n      return isElement$6(elm) && FocusManager.isEditorUIElement(elm);\n    };\n    const isEditorContentAreaElement = elm => {\n      const classList = elm.classList;\n      if (classList !== undefined) {\n        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\n      } else {\n        return false;\n      }\n    };\n    const isUIElement = (editor, elm) => {\n      const customSelector = getCustomUiSelector(editor);\n      const parent = DOM$9.getParent(elm, elm => {\n        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\n      });\n      return parent !== null;\n    };\n    const getActiveElement = editor => {\n      try {\n        const root = getRootNode(SugarElement.fromDom(editor.getElement()));\n        return active$1(root).fold(() => document.body, x => x.dom);\n      } catch (ex) {\n        return document.body;\n      }\n    };\n    const registerEvents$1 = (editorManager, e) => {\n      const editor = e.editor;\n      register$6(editor);\n      const toggleContentAreaOnFocus = (editor, fn) => {\n        if (shouldHighlightOnFocus(editor) && editor.inline !== true) {\n          const contentArea = SugarElement.fromDom(editor.getContainer());\n          fn(contentArea, 'tox-edit-focus');\n        }\n      };\n      editor.on('focusin', () => {\n        const focusedEditor = editorManager.focusedEditor;\n        if (isEditorContentAreaElement(getActiveElement(editor))) {\n          toggleContentAreaOnFocus(editor, add$2);\n        }\n        if (focusedEditor !== editor) {\n          if (focusedEditor) {\n            focusedEditor.dispatch('blur', { focusedEditor: editor });\n          }\n          editorManager.setActive(editor);\n          editorManager.focusedEditor = editor;\n          editor.dispatch('focus', { blurredEditor: focusedEditor });\n          editor.focus(true);\n        }\n      });\n      editor.on('focusout', () => {\n        Delay.setEditorTimeout(editor, () => {\n          const focusedEditor = editorManager.focusedEditor;\n          if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {\n            toggleContentAreaOnFocus(editor, remove$7);\n          }\n          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\n            editor.dispatch('blur', { focusedEditor: null });\n            editorManager.focusedEditor = null;\n          }\n        });\n      });\n      if (!documentFocusInHandler) {\n        documentFocusInHandler = e => {\n          const activeEditor = editorManager.activeEditor;\n          if (activeEditor) {\n            getOriginalEventTarget(e).each(target => {\n              const elem = target;\n              if (elem.ownerDocument === document) {\n                if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {\n                  activeEditor.dispatch('blur', { focusedEditor: null });\n                  editorManager.focusedEditor = null;\n                }\n              }\n            });\n          }\n        };\n        DOM$9.bind(document, 'focusin', documentFocusInHandler);\n      }\n    };\n    const unregisterDocumentEvents = (editorManager, e) => {\n      if (editorManager.focusedEditor === e.editor) {\n        editorManager.focusedEditor = null;\n      }\n      if (!editorManager.activeEditor && documentFocusInHandler) {\n        DOM$9.unbind(document, 'focusin', documentFocusInHandler);\n        documentFocusInHandler = null;\n      }\n    };\n    const setup$w = editorManager => {\n      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\n      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\n    };\n\n    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\n    const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\n    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\n      if (isTableSection(node)) {\n        return Optional.some(node);\n      } else if (!contains(root, node)) {\n        return Optional.some(root);\n      } else {\n        return Optional.none();\n      }\n    });\n    const normalizeSelection = (editor, rng) => {\n      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\n        return firstPositionIn(elm.dom);\n      }).fold(() => {\n        editor.selection.normalize();\n      }, caretPos => editor.selection.setRng(caretPos.toRange()));\n    };\n    const focusBody = body => {\n      if (body.setActive) {\n        try {\n          body.setActive();\n        } catch (ex) {\n          body.focus();\n        }\n      } else {\n        body.focus();\n      }\n    };\n    const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\n    const hasIframeFocus = editor => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\n    const hasInlineFocus = editor => {\n      const rawBody = editor.getBody();\n      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\n    };\n    const hasUiFocus = editor => {\n      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n      return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\n    };\n    const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\n    const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\n    const focusEditor = editor => {\n      const selection = editor.selection;\n      const body = editor.getBody();\n      let rng = selection.getRng();\n      editor.quirks.refreshContentEditable();\n      if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n        getRng(editor).each(bookmarkRng => {\n          editor.selection.setRng(bookmarkRng);\n          rng = bookmarkRng;\n        });\n      }\n      const contentEditableHost = getContentEditableHost(editor, selection.getNode());\n      if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {\n        focusBody(contentEditableHost);\n        normalizeSelection(editor, rng);\n        activateEditor(editor);\n        return;\n      }\n      if (!editor.inline) {\n        if (!Env.browser.isOpera()) {\n          focusBody(body);\n        }\n        editor.getWin().focus();\n      }\n      if (Env.browser.isFirefox() || editor.inline) {\n        focusBody(body);\n        normalizeSelection(editor, rng);\n      }\n      activateEditor(editor);\n    };\n    const activateEditor = editor => editor.editorManager.setActive(editor);\n    const focus = (editor, skipFocus) => {\n      if (editor.removed) {\n        return;\n      }\n      if (skipFocus) {\n        activateEditor(editor);\n      } else {\n        focusEditor(editor);\n      }\n    };\n\n    const isEditableRange = (dom, rng) => {\n      if (rng.collapsed) {\n        return dom.isEditable(rng.startContainer);\n      } else {\n        return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);\n      }\n    };\n\n    const getEndpointElement = (root, rng, start, real, resolve) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      const offset = start ? rng.startOffset : rng.endOffset;\n      return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\n    };\n    const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\n    const getEnd$1 = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\n    const skipEmptyTextNodes = (node, forwards) => {\n      const orig = node;\n      while (node && isText$a(node) && node.length === 0) {\n        node = forwards ? node.nextSibling : node.previousSibling;\n      }\n      return node || orig;\n    };\n    const getNode = (root, rng) => {\n      if (!rng) {\n        return root;\n      }\n      let startContainer = rng.startContainer;\n      let endContainer = rng.endContainer;\n      const startOffset = rng.startOffset;\n      const endOffset = rng.endOffset;\n      let node = rng.commonAncestorContainer;\n      if (!rng.collapsed) {\n        if (startContainer === endContainer) {\n          if (endOffset - startOffset < 2) {\n            if (startContainer.hasChildNodes()) {\n              node = startContainer.childNodes[startOffset];\n            }\n          }\n        }\n        if (isText$a(startContainer) && isText$a(endContainer)) {\n          if (startContainer.length === startOffset) {\n            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n          } else {\n            startContainer = startContainer.parentNode;\n          }\n          if (endOffset === 0) {\n            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n          } else {\n            endContainer = endContainer.parentNode;\n          }\n          if (startContainer && startContainer === endContainer) {\n            node = startContainer;\n          }\n        }\n      }\n      const elm = isText$a(node) ? node.parentNode : node;\n      return isHTMLElement(elm) ? elm : root;\n    };\n    const getSelectedBlocks = (dom, rng, startElm, endElm) => {\n      const selectedBlocks = [];\n      const root = dom.getRoot();\n      const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\n      const end = dom.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom.isBlock);\n      if (start && start !== root) {\n        selectedBlocks.push(start);\n      }\n      if (start && end && start !== end) {\n        let node;\n        const walker = new DomTreeWalker(start, root);\n        while ((node = walker.next()) && node !== end) {\n          if (dom.isBlock(node)) {\n            selectedBlocks.push(node);\n          }\n        }\n      }\n      if (end && start !== end && end !== root) {\n        selectedBlocks.push(end);\n      }\n      return selectedBlocks;\n    };\n    const select = (dom, node, content) => Optional.from(node).bind(node => Optional.from(node.parentNode).map(parent => {\n      const idx = dom.nodeIndex(node);\n      const rng = dom.createRng();\n      rng.setStart(parent, idx);\n      rng.setEnd(parent, idx + 1);\n      if (content) {\n        moveEndPoint(dom, rng, node, true);\n        moveEndPoint(dom, rng, node, false);\n      }\n      return rng;\n    }));\n\n    const processRanges = (editor, ranges) => map$3(ranges, range => {\n      const evt = editor.dispatch('GetSelectionRange', { range });\n      return evt.range !== range ? evt.range : range;\n    });\n\n    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children$1(element).length, v => v.length);\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n    const isContentEditableFalse$5 = elem => isHTMLElement$1(elem) && get$9(elem, 'contenteditable') === 'false';\n    const elementsWithCursorPosition = [\n      'img',\n      'br'\n    ];\n    const isCursorPosition = elem => {\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$5(elem);\n    };\n\n    const first = element => descendant$2(element, isCursorPosition);\n    const last = element => descendantRtl(element, isCursorPosition);\n    const descendantRtl = (scope, predicate) => {\n      const descend = element => {\n        const children = children$1(element);\n        for (let i = children.length - 1; i >= 0; i--) {\n          const child = children[i];\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(child);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope);\n    };\n\n    const autocompleteSelector = '[data-mce-autocompleter]';\n    const create$9 = (editor, range) => {\n      if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {\n        const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter=\"1\" data-mce-bogus=\"1\"></span>', editor.getDoc());\n        append$1(wrapper, SugarElement.fromDom(range.extractContents()));\n        range.insertNode(wrapper.dom);\n        parent(wrapper).each(elm => elm.dom.normalize());\n        last(wrapper).map(last => {\n          editor.selection.setCursorLocation(last.dom, getEnd(last));\n        });\n      }\n    };\n    const detect$1 = elm => closest$3(elm, autocompleteSelector);\n    const findIn = elm => descendant$1(elm, autocompleteSelector);\n    const remove$2 = (editor, elm) => findIn(elm).each(wrapper => {\n      const bookmark = editor.selection.getBookmark();\n      unwrap(wrapper);\n      editor.selection.moveToBookmark(bookmark);\n    });\n\n    const typeLookup = {\n      '#text': 3,\n      '#comment': 8,\n      '#cdata': 4,\n      '#pi': 7,\n      '#doctype': 10,\n      '#document-fragment': 11\n    };\n    const walk$2 = (node, root, prev) => {\n      const startName = prev ? 'lastChild' : 'firstChild';\n      const siblingName = prev ? 'prev' : 'next';\n      if (node[startName]) {\n        return node[startName];\n      }\n      if (node !== root) {\n        let sibling = node[siblingName];\n        if (sibling) {\n          return sibling;\n        }\n        for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\n          sibling = parent[siblingName];\n          if (sibling) {\n            return sibling;\n          }\n        }\n      }\n      return undefined;\n    };\n    const isEmptyTextNode = node => {\n      var _a;\n      const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n      if (!isWhitespaceText(text)) {\n        return false;\n      }\n      const parentNode = node.parent;\n      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {\n        return false;\n      }\n      return true;\n    };\n    const isNonEmptyElement = node => {\n      const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\n      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\n    };\n    class AstNode {\n      static create(name, attrs) {\n        const node = new AstNode(name, typeLookup[name] || 1);\n        if (attrs) {\n          each$d(attrs, (value, attrName) => {\n            node.attr(attrName, value);\n          });\n        }\n        return node;\n      }\n      constructor(name, type) {\n        this.name = name;\n        this.type = type;\n        if (type === 1) {\n          this.attributes = [];\n          this.attributes.map = {};\n        }\n      }\n      replace(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        self.insert(node, self);\n        self.remove();\n        return self;\n      }\n      attr(name, value) {\n        const self = this;\n        if (!isString(name)) {\n          if (isNonNullable(name)) {\n            each$d(name, (value, key) => {\n              self.attr(key, value);\n            });\n          }\n          return self;\n        }\n        const attrs = self.attributes;\n        if (attrs) {\n          if (value !== undefined) {\n            if (value === null) {\n              if (name in attrs.map) {\n                delete attrs.map[name];\n                let i = attrs.length;\n                while (i--) {\n                  if (attrs[i].name === name) {\n                    attrs.splice(i, 1);\n                    return self;\n                  }\n                }\n              }\n              return self;\n            }\n            if (name in attrs.map) {\n              let i = attrs.length;\n              while (i--) {\n                if (attrs[i].name === name) {\n                  attrs[i].value = value;\n                  break;\n                }\n              }\n            } else {\n              attrs.push({\n                name,\n                value\n              });\n            }\n            attrs.map[name] = value;\n            return self;\n          }\n          return attrs.map[name];\n        }\n        return undefined;\n      }\n      clone() {\n        const self = this;\n        const clone = new AstNode(self.name, self.type);\n        const selfAttrs = self.attributes;\n        if (selfAttrs) {\n          const cloneAttrs = [];\n          cloneAttrs.map = {};\n          for (let i = 0, l = selfAttrs.length; i < l; i++) {\n            const selfAttr = selfAttrs[i];\n            if (selfAttr.name !== 'id') {\n              cloneAttrs[cloneAttrs.length] = {\n                name: selfAttr.name,\n                value: selfAttr.value\n              };\n              cloneAttrs.map[selfAttr.name] = selfAttr.value;\n            }\n          }\n          clone.attributes = cloneAttrs;\n        }\n        clone.value = self.value;\n        return clone;\n      }\n      wrap(wrapper) {\n        const self = this;\n        if (self.parent) {\n          self.parent.insert(wrapper, self);\n          wrapper.append(self);\n        }\n        return self;\n      }\n      unwrap() {\n        const self = this;\n        for (let node = self.firstChild; node;) {\n          const next = node.next;\n          self.insert(node, self, true);\n          node = next;\n        }\n        self.remove();\n      }\n      remove() {\n        const self = this, parent = self.parent, next = self.next, prev = self.prev;\n        if (parent) {\n          if (parent.firstChild === self) {\n            parent.firstChild = next;\n            if (next) {\n              next.prev = null;\n            }\n          } else if (prev) {\n            prev.next = next;\n          }\n          if (parent.lastChild === self) {\n            parent.lastChild = prev;\n            if (prev) {\n              prev.next = null;\n            }\n          } else if (next) {\n            next.prev = prev;\n          }\n          self.parent = self.next = self.prev = null;\n        }\n        return self;\n      }\n      append(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        const last = self.lastChild;\n        if (last) {\n          last.next = node;\n          node.prev = last;\n          self.lastChild = node;\n        } else {\n          self.lastChild = self.firstChild = node;\n        }\n        node.parent = self;\n        return node;\n      }\n      insert(node, refNode, before) {\n        if (node.parent) {\n          node.remove();\n        }\n        const parent = refNode.parent || this;\n        if (before) {\n          if (refNode === parent.firstChild) {\n            parent.firstChild = node;\n          } else if (refNode.prev) {\n            refNode.prev.next = node;\n          }\n          node.prev = refNode.prev;\n          node.next = refNode;\n          refNode.prev = node;\n        } else {\n          if (refNode === parent.lastChild) {\n            parent.lastChild = node;\n          } else if (refNode.next) {\n            refNode.next.prev = node;\n          }\n          node.next = refNode.next;\n          node.prev = refNode;\n          refNode.next = node;\n        }\n        node.parent = parent;\n        return node;\n      }\n      getAll(name) {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\n          if (node.name === name) {\n            collection.push(node);\n          }\n        }\n        return collection;\n      }\n      children() {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = node.next) {\n          collection.push(node);\n        }\n        return collection;\n      }\n      empty() {\n        const self = this;\n        if (self.firstChild) {\n          const nodes = [];\n          for (let node = self.firstChild; node; node = walk$2(node, self)) {\n            nodes.push(node);\n          }\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n          }\n        }\n        self.firstChild = self.lastChild = null;\n        return self;\n      }\n      isEmpty(elements, whitespace = {}, predicate) {\n        var _a;\n        const self = this;\n        let node = self.firstChild;\n        if (isNonEmptyElement(self)) {\n          return false;\n        }\n        if (node) {\n          do {\n            if (node.type === 1) {\n              if (node.attr('data-mce-bogus')) {\n                continue;\n              }\n              if (elements[node.name]) {\n                return false;\n              }\n              if (isNonEmptyElement(node)) {\n                return false;\n              }\n            }\n            if (node.type === 8) {\n              return false;\n            }\n            if (node.type === 3 && !isEmptyTextNode(node)) {\n              return false;\n            }\n            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {\n              return false;\n            }\n            if (predicate && predicate(node)) {\n              return false;\n            }\n          } while (node = walk$2(node, self));\n        }\n        return true;\n      }\n      walk(prev) {\n        return walk$2(this, null, prev);\n      }\n    }\n\n    const unescapedTextParents = Tools.makeMap('NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT', ' ');\n    const containsZwsp = node => isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);\n    const getTemporaryNodeSelector = tempAttrs => `${ tempAttrs.length === 0 ? '' : `${ map$3(tempAttrs, attr => `[${ attr }]`).join(',') },` }[data-mce-bogus=\"all\"]`;\n    const getTemporaryNodes = (tempAttrs, body) => body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));\n    const createZwspCommentWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, node => containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\n    const createUnescapedZwspTextWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_TEXT, node => {\n      if (containsZwsp(node)) {\n        const parent = node.parentNode;\n        return parent && has$2(unescapedTextParents, parent.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n      } else {\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    const hasZwspComment = body => createZwspCommentWalker(body).nextNode() !== null;\n    const hasUnescapedZwspText = body => createUnescapedZwspTextWalker(body).nextNode() !== null;\n    const hasTemporaryNode = (tempAttrs, body) => body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;\n    const trimTemporaryNodes = (tempAttrs, body) => {\n      each$e(getTemporaryNodes(tempAttrs, body), elm => {\n        const element = SugarElement.fromDom(elm);\n        if (get$9(element, 'data-mce-bogus') === 'all') {\n          remove$5(element);\n        } else {\n          each$e(tempAttrs, attr => {\n            if (has$1(element, attr)) {\n              remove$a(element, attr);\n            }\n          });\n        }\n      });\n    };\n    const emptyAllNodeValuesInWalker = walker => {\n      let curr = walker.nextNode();\n      while (curr !== null) {\n        curr.nodeValue = null;\n        curr = walker.nextNode();\n      }\n    };\n    const emptyZwspComments = compose(emptyAllNodeValuesInWalker, createZwspCommentWalker);\n    const emptyUnescapedZwspTexts = compose(emptyAllNodeValuesInWalker, createUnescapedZwspTextWalker);\n    const trim$1 = (body, tempAttrs) => {\n      const conditionalTrims = [\n        {\n          condition: curry(hasTemporaryNode, tempAttrs),\n          action: curry(trimTemporaryNodes, tempAttrs)\n        },\n        {\n          condition: hasZwspComment,\n          action: emptyZwspComments\n        },\n        {\n          condition: hasUnescapedZwspText,\n          action: emptyUnescapedZwspTexts\n        }\n      ];\n      let trimmed = body;\n      let cloned = false;\n      each$e(conditionalTrims, ({condition, action}) => {\n        if (condition(trimmed)) {\n          if (!cloned) {\n            trimmed = body.cloneNode(true);\n            cloned = true;\n          }\n          action(trimmed);\n        }\n      });\n      return trimmed;\n    };\n\n    const cleanupBogusElements = parent => {\n      const bogusElements = descendants(parent, '[data-mce-bogus]');\n      each$e(bogusElements, elem => {\n        const bogusValue = get$9(elem, 'data-mce-bogus');\n        if (bogusValue === 'all') {\n          remove$5(elem);\n        } else if (isBr$5(elem)) {\n          before$3(elem, SugarElement.fromText(zeroWidth));\n          remove$5(elem);\n        } else {\n          unwrap(elem);\n        }\n      });\n    };\n    const cleanupInputNames = parent => {\n      const inputs = descendants(parent, 'input');\n      each$e(inputs, input => {\n        remove$a(input, 'name');\n      });\n    };\n\n    const trimEmptyContents = (editor, html) => {\n      const blockName = getForcedRootBlock(editor);\n      const emptyRegExp = new RegExp(`^(<${ blockName }[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${ blockName }>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\n      return html.replace(emptyRegExp, '');\n    };\n    const getPlainTextContent = (editor, body) => {\n      const doc = editor.getDoc();\n      const dos = getRootNode(SugarElement.fromDom(editor.getBody()));\n      const offscreenDiv = SugarElement.fromTag('div', doc);\n      set$3(offscreenDiv, 'data-mce-bogus', 'all');\n      setAll(offscreenDiv, {\n        position: 'fixed',\n        left: '-9999999px',\n        top: '0'\n      });\n      set$1(offscreenDiv, body.innerHTML);\n      cleanupBogusElements(offscreenDiv);\n      cleanupInputNames(offscreenDiv);\n      const root = getContentContainer(dos);\n      append$1(root, offscreenDiv);\n      const content = trim$2(offscreenDiv.dom.innerText);\n      remove$5(offscreenDiv);\n      return content;\n    };\n    const getContentFromBody = (editor, args, body) => {\n      let content;\n      if (args.format === 'raw') {\n        content = Tools.trim(trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));\n      } else if (args.format === 'text') {\n        content = getPlainTextContent(editor, body);\n      } else if (args.format === 'tree') {\n        content = editor.serializer.serialize(body, args);\n      } else {\n        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\n      }\n      const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\n      return shouldTrim && isString(content) ? Tools.trim(content) : content;\n    };\n    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\n\n    const makeMap$1 = Tools.makeMap;\n    const Writer = settings => {\n      const html = [];\n      settings = settings || {};\n      const indent = settings.indent;\n      const indentBefore = makeMap$1(settings.indent_before || '');\n      const indentAfter = makeMap$1(settings.indent_after || '');\n      const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\n      const htmlOutput = settings.element_format !== 'xhtml';\n      return {\n        start: (name, attrs, empty) => {\n          if (indent && indentBefore[name] && html.length > 0) {\n            const value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n          html.push('<', name);\n          if (attrs) {\n            for (let i = 0, l = attrs.length; i < l; i++) {\n              const attr = attrs[i];\n              html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\n            }\n          }\n          if (!empty || htmlOutput) {\n            html[html.length] = '>';\n          } else {\n            html[html.length] = ' />';\n          }\n          if (empty && indent && indentAfter[name] && html.length > 0) {\n            const value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        end: name => {\n          let value;\n          html.push('</', name, '>');\n          if (indent && indentAfter[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        text: (text, raw) => {\n          if (text.length > 0) {\n            html[html.length] = raw ? text : encode(text);\n          }\n        },\n        cdata: text => {\n          html.push('<![CDATA[', text, ']]>');\n        },\n        comment: text => {\n          html.push('<!--', text, '-->');\n        },\n        pi: (name, text) => {\n          if (text) {\n            html.push('<?', name, ' ', encode(text), '?>');\n          } else {\n            html.push('<?', name, '?>');\n          }\n          if (indent) {\n            html.push('\\n');\n          }\n        },\n        doctype: text => {\n          html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\n        },\n        reset: () => {\n          html.length = 0;\n        },\n        getContent: () => {\n          return html.join('').replace(/\\n$/, '');\n        }\n      };\n    };\n\n    const HtmlSerializer = (settings = {}, schema = Schema()) => {\n      const writer = Writer(settings);\n      settings.validate = 'validate' in settings ? settings.validate : true;\n      const serialize = node => {\n        const validate = settings.validate;\n        const handlers = {\n          3: node => {\n            var _a;\n            writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);\n          },\n          8: node => {\n            var _a;\n            writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          7: node => {\n            writer.pi(node.name, node.value);\n          },\n          10: node => {\n            var _a;\n            writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          4: node => {\n            var _a;\n            writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          11: node => {\n            let tempNode = node;\n            if (tempNode = tempNode.firstChild) {\n              do {\n                walk(tempNode);\n              } while (tempNode = tempNode.next);\n            }\n          }\n        };\n        writer.reset();\n        const walk = node => {\n          var _a;\n          const handler = handlers[node.type];\n          if (!handler) {\n            const name = node.name;\n            const isEmpty = name in schema.getVoidElements();\n            let attrs = node.attributes;\n            if (validate && attrs && attrs.length > 1) {\n              const sortedAttrs = [];\n              sortedAttrs.map = {};\n              const elementRule = schema.getElementRule(node.name);\n              if (elementRule) {\n                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n                  const attrName = elementRule.attributesOrder[i];\n                  if (attrName in attrs.map) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                for (let i = 0, l = attrs.length; i < l; i++) {\n                  const attrName = attrs[i].name;\n                  if (!(attrName in sortedAttrs.map)) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                attrs = sortedAttrs;\n              }\n            }\n            writer.start(name, attrs, isEmpty);\n            if (isNonHtmlElementRootName(name)) {\n              if (isString(node.value)) {\n                writer.text(node.value, true);\n              }\n              writer.end(name);\n            } else {\n              if (!isEmpty) {\n                let child = node.firstChild;\n                if (child) {\n                  if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\\n') {\n                    writer.text('\\n', true);\n                  }\n                  do {\n                    walk(child);\n                  } while (child = child.next);\n                }\n                writer.end(name);\n              }\n            }\n          } else {\n            handler(node);\n          }\n        };\n        if (node.type === 1 && !settings.inner) {\n          walk(node);\n        } else if (node.type === 3) {\n          handlers[3](node);\n        } else {\n          handlers[11](node);\n        }\n        return writer.getContent();\n      };\n      return { serialize };\n    };\n\n    const nonInheritableStyles = new Set();\n    (() => {\n      const nonInheritableStylesArr = [\n        'margin',\n        'margin-left',\n        'margin-right',\n        'margin-top',\n        'margin-bottom',\n        'padding',\n        'padding-left',\n        'padding-right',\n        'padding-top',\n        'padding-bottom',\n        'border',\n        'border-width',\n        'border-style',\n        'border-color',\n        'background',\n        'background-attachment',\n        'background-clip',\n        'background-color',\n        'background-image',\n        'background-origin',\n        'background-position',\n        'background-repeat',\n        'background-size',\n        'float',\n        'position',\n        'left',\n        'right',\n        'top',\n        'bottom',\n        'z-index',\n        'display',\n        'transform',\n        'width',\n        'max-width',\n        'min-width',\n        'height',\n        'max-height',\n        'min-height',\n        'overflow',\n        'overflow-x',\n        'overflow-y',\n        'text-overflow',\n        'vertical-align',\n        'transition',\n        'transition-delay',\n        'transition-duration',\n        'transition-property',\n        'transition-timing-function'\n      ];\n      each$e(nonInheritableStylesArr, style => {\n        nonInheritableStyles.add(style);\n      });\n    })();\n    const shorthandStyleProps = [\n      'font',\n      'text-decoration',\n      'text-emphasis'\n    ];\n    const getStyleProps = (dom, node) => keys(dom.parseStyle(dom.getAttrib(node, 'style')));\n    const isNonInheritableStyle = style => nonInheritableStyles.has(style);\n    const hasInheritableStyles = (dom, node) => forall(getStyleProps(dom, node), style => !isNonInheritableStyle(style));\n    const getLonghandStyleProps = styles => filter$5(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\n    const hasStyleConflict = (dom, node, parentNode) => {\n      const nodeStyleProps = getStyleProps(dom, node);\n      const parentNodeStyleProps = getStyleProps(dom, parentNode);\n      const valueMismatch = prop => {\n        var _a, _b;\n        const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\n        const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\n        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\n      };\n      return exists(nodeStyleProps, nodeStyleProp => {\n        const propExists = props => exists(props, prop => prop === nodeStyleProp);\n        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\n          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\n          return exists(longhandProps, valueMismatch);\n        } else {\n          return valueMismatch(nodeStyleProp);\n        }\n      });\n    };\n\n    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$a).exists(text => {\n      const delta = forward ? 0 : -1;\n      return predicate(text.data.charAt(pos.offset() + delta));\n    });\n    const isBeforeSpace = curry(isChar, true, isWhiteSpace);\n    const isAfterSpace = curry(isChar, false, isWhiteSpace);\n    const isEmptyText = pos => {\n      const container = pos.container();\n      return isText$a(container) && (container.data.length === 0 || isZwsp$1(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\n    };\n    const matchesElementPosition = (before, predicate) => pos => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();\n    const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\n    const isCefNode = node => isContentEditableFalse$b(node) && !isBogusAll$1(node);\n    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\n    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\n    const isBeforeMedia = matchesElementPosition(true, isMedia$2);\n    const isAfterMedia = matchesElementPosition(false, isMedia$2);\n    const isBeforeTable = matchesElementPosition(true, isTable$2);\n    const isAfterTable = matchesElementPosition(false, isTable$2);\n    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\n    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\n\n    const dropLast = xs => xs.slice(0, -1);\n    const parentsUntil = (start, root, predicate) => {\n      if (contains(root, start)) {\n        return dropLast(parents$1(start, elm => {\n          return predicate(elm) || eq(elm, root);\n        }));\n      } else {\n        return [];\n      }\n    };\n    const parents = (start, root) => parentsUntil(start, root, never);\n    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\n\n    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\n    const isBlock$1 = schema => el => schema.isBlock(name(el));\n    const getClosestBlock$1 = (root, pos, schema) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$1(schema));\n    const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos, schema).fold(() => !isInSameBlock(newPos, pos, root.dom), fromBlock => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\n    const isAtBlockBoundary = (forward, root, pos, schema) => getClosestBlock$1(root, pos, schema).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => !isInSameBlock(newPos, pos, root.dom)), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\n    const isAtStartOfBlock = curry(isAtBlockBoundary, false);\n    const isAtEndOfBlock = curry(isAtBlockBoundary, true);\n    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\n    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\n\n    const isBr$1 = pos => getElementFromPosition(pos).exists(isBr$5);\n    const findBr = (forward, root, pos, schema) => {\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n      const scope = head(parentBlocks).getOr(root);\n      return fromPosition(forward, scope.dom, pos).filter(isBr$1);\n    };\n    const isBeforeBr$1 = (root, pos, schema) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos, schema).isSome();\n    const isAfterBr = (root, pos, schema) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos, schema).isSome();\n    const findPreviousBr = curry(findBr, false);\n    const findNextBr = curry(findBr, true);\n\n    const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\n    const getClosestBlock = (root, pos, schema) => {\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n      return head(parentBlocks).getOr(root);\n    };\n    const hasSpaceBefore = (root, pos, schema) => {\n      if (isInMiddleOfText(pos)) {\n        return isAfterSpace(pos);\n      } else {\n        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isAfterSpace);\n      }\n    };\n    const hasSpaceAfter = (root, pos, schema) => {\n      if (isInMiddleOfText(pos)) {\n        return isBeforeSpace(pos);\n      } else {\n        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isBeforeSpace);\n      }\n    };\n    const isPreValue = value => contains$2([\n      'pre',\n      'pre-wrap'\n    ], value);\n    const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\n    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\n    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\n    const isAtLineBoundary = (root, pos, schema) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos, schema) || isAtEndOfBlock(root, pos, schema) || isAfterBr(root, pos, schema) || isBeforeBr$1(root, pos, schema);\n    const isCefBlock = node => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);\n    const isSiblingCefBlock = (root, direction) => container => {\n      return isCefBlock(new DomTreeWalker(container, root)[direction]());\n    };\n    const isBeforeCefBlock = (root, pos) => {\n      const nextPos = nextPosition(root.dom, pos).getOr(pos);\n      const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');\n      return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));\n    };\n    const isAfterCefBlock = (root, pos) => {\n      const prevPos = prevPosition(root.dom, pos).getOr(pos);\n      const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');\n      return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));\n    };\n    const needsToHaveNbsp = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtLineBoundary(root, pos, schema) || hasSpaceBefore(root, pos, schema) || hasSpaceAfter(root, pos, schema);\n      }\n    };\n    const needsToBeNbspLeft = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtStartOfBlock(root, pos, schema) || isBeforeBlock(root, pos, schema) || isAfterBr(root, pos, schema) || hasSpaceBefore(root, pos, schema) || isAfterCefBlock(root, pos);\n      }\n    };\n    const leanRight = pos => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$a(container) && offset < container.data.length) {\n        return CaretPosition(container, offset + 1);\n      } else {\n        return pos;\n      }\n    };\n    const needsToBeNbspRight = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtEndOfBlock(root, pos, schema) || isAfterBlock(root, pos, schema) || isBeforeBr$1(root, pos, schema) || hasSpaceAfter(root, pos, schema) || isBeforeCefBlock(root, pos);\n      }\n    };\n    const needsToBeNbsp = (root, pos, schema) => needsToBeNbspLeft(root, pos, schema) || needsToBeNbspRight(root, leanRight(pos), schema);\n    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\n    const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));\n    const hasNbsp = pos => {\n      const container = pos.container();\n      return isText$a(container) && contains$1(container.data, nbsp);\n    };\n    const normalizeNbspMiddle = text => {\n      const chars = text.split('');\n      return map$3(chars, (chr, i) => {\n        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\n          return ' ';\n        } else {\n          return chr;\n        }\n      }).join('');\n    };\n    const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {\n      const text = node.data;\n      const firstPos = CaretPosition(node, 0);\n      if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos, schema)) {\n        node.data = ' ' + text.slice(1);\n        return true;\n      } else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos, schema)) {\n        node.data = nbsp + text.slice(1);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspInMiddleOfTextNode = node => {\n      const text = node.data;\n      const newText = normalizeNbspMiddle(text);\n      if (newText !== text) {\n        node.data = newText;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {\n      const text = node.data;\n      const lastPos = CaretPosition(node, text.length - 1);\n      if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos, schema)) {\n        node.data = text.slice(0, -1) + ' ';\n        return true;\n      } else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos, schema)) {\n        node.data = text.slice(0, -1) + nbsp;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbsps = (root, pos, schema) => {\n      const container = pos.container();\n      if (!isText$a(container)) {\n        return Optional.none();\n      }\n      if (hasNbsp(pos)) {\n        const normalized = normalizeNbspAtStart(root, container, false, schema) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false, schema);\n        return someIf(normalized, pos);\n      } else if (needsToBeNbsp(root, pos, schema)) {\n        const normalized = normalizeNbspAtStart(root, container, true, schema) || normalizeNbspAtEnd(root, container, true, schema);\n        return someIf(normalized, pos);\n      } else {\n        return Optional.none();\n      }\n    };\n    const normalizeNbspsInEditor = editor => {\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng()), editor.schema).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      }\n    };\n\n    const normalize$1 = (node, offset, count, schema) => {\n      if (count === 0) {\n        return;\n      }\n      const elm = SugarElement.fromDom(node);\n      const root = ancestor$4(elm, el => schema.isBlock(name(el))).getOr(elm);\n      const whitespace = node.data.slice(offset, offset + count);\n      const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);\n      const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);\n      node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\n    };\n    const normalizeWhitespaceAfter = (node, offset, schema) => {\n      const content = node.data.slice(offset);\n      const whitespaceCount = content.length - lTrim(content).length;\n      normalize$1(node, offset, whitespaceCount, schema);\n    };\n    const normalizeWhitespaceBefore = (node, offset, schema) => {\n      const content = node.data.slice(0, offset);\n      const whitespaceCount = content.length - rTrim(content).length;\n      normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);\n    };\n    const mergeTextNodes = (prevNode, nextNode, schema, normalizeWhitespace, mergeToPrev = true) => {\n      const whitespaceOffset = rTrim(prevNode.data).length;\n      const newNode = mergeToPrev ? prevNode : nextNode;\n      const removeNode = mergeToPrev ? nextNode : prevNode;\n      if (mergeToPrev) {\n        newNode.appendData(removeNode.data);\n      } else {\n        newNode.insertData(0, removeNode.data);\n      }\n      remove$5(SugarElement.fromDom(removeNode));\n      if (normalizeWhitespace) {\n        normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);\n      }\n      return newNode;\n    };\n\n    const needsReposition = (pos, elm) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\n    };\n    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\n    const beforeOrStartOf = node => isText$a(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\n    const afterOrEndOf = node => isText$a(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\n    const getPreviousSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.previousSibling)) {\n        return Optional.some(afterOrEndOf(elm.previousSibling));\n      } else {\n        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\n      }\n    };\n    const getNextSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.nextSibling)) {\n        return Optional.some(beforeOrStartOf(elm.nextSibling));\n      } else {\n        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\n      }\n    };\n    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\n      return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind(node => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));\n    };\n    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));\n    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\n    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\n    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\n    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\n    const setSelection$1 = (editor, forward, pos) => {\n      pos.fold(() => {\n        editor.focus();\n      }, pos => {\n        editor.selection.setRng(pos.toRange(), forward);\n      });\n    };\n    const eqRawNode = rawNode => elm => elm.dom === rawNode;\n    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\n    const paddEmptyBlock = (elm, preserveEmptyCaret) => {\n      if (isEmpty$2(elm)) {\n        const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\n        if (preserveEmptyCaret) {\n          each$e(children$1(elm), node => {\n            if (!isEmptyCaretFormatElement(node)) {\n              remove$5(node);\n            }\n          });\n        } else {\n          empty(elm);\n        }\n        append$1(elm, br);\n        return Optional.some(CaretPosition.before(br.dom));\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteNormalized = (elm, afterDeletePosOpt, schema, normalizeWhitespace) => {\n      const prevTextOpt = prevSibling(elm).filter(isText$b);\n      const nextTextOpt = nextSibling(elm).filter(isText$b);\n      remove$5(elm);\n      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\n        const prevNode = prev.dom, nextNode = next.dom;\n        const offset = prevNode.data.length;\n        mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);\n        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\n      }).orThunk(() => {\n        if (normalizeWhitespace) {\n          prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema));\n          nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0, schema));\n        }\n        return afterDeletePosOpt;\n      });\n    };\n    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\n    const deleteElement$2 = (editor, forward, elm, moveCaret = true, preserveEmptyCaret = false) => {\n      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\n      const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\n      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, editor.schema, isInlineElement(editor, elm));\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      } else {\n        parentBlock.bind(elm => paddEmptyBlock(elm, preserveEmptyCaret)).fold(() => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, normalizedAfterDeletePos);\n          }\n        }, paddPos => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, Optional.some(paddPos));\n          }\n        });\n      }\n    };\n\n    const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\n    const hasStrongRtl = text => strongRtl.test(text);\n\n    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);\n    const isRtl = element => {\n      var _a;\n      return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : '');\n    };\n    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\n    const findRootInline = (isInlineTarget, rootNode, pos) => {\n      const parents = findInlineParents(isInlineTarget, rootNode, pos);\n      return Optional.from(parents[parents.length - 1]);\n    };\n    const hasSameParentBlock = (rootNode, node1, node2) => {\n      const block1 = getParentBlock$3(node1, rootNode);\n      const block2 = getParentBlock$3(node2, rootNode);\n      return isNonNullable(block1) && block1 === block2;\n    };\n    const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\n    const normalizePosition = (forward, pos) => {\n      const container = pos.container(), offset = pos.offset();\n      if (forward) {\n        if (isCaretContainerInline(container)) {\n          if (isText$a(container.nextSibling)) {\n            return CaretPosition(container.nextSibling, 0);\n          } else {\n            return CaretPosition.after(container);\n          }\n        } else {\n          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\n        }\n      } else {\n        if (isCaretContainerInline(container)) {\n          if (isText$a(container.previousSibling)) {\n            return CaretPosition(container.previousSibling, container.previousSibling.data.length);\n          } else {\n            return CaretPosition.before(container);\n          }\n        } else {\n          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\n        }\n      }\n    };\n    const normalizeForwards = curry(normalizePosition, true);\n    const normalizeBackwards = curry(normalizePosition, false);\n\n    const execCommandIgnoreInputEvents = (editor, command) => {\n      const inputBlocker = e => e.stopImmediatePropagation();\n      editor.on('beforeinput input', inputBlocker, true);\n      editor.getDoc().execCommand(command);\n      editor.off('beforeinput input', inputBlocker);\n    };\n    const execEditorDeleteCommand = editor => {\n      editor.execCommand('delete');\n    };\n    const execNativeDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\n    const execNativeForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\n    const isBeforeRoot = rootNode => elm => is$2(parent(elm), rootNode, eq);\n    const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem$1(element);\n    const getParentBlock$2 = (rootNode, elm) => {\n      if (contains(rootNode, elm)) {\n        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\n      } else {\n        return Optional.none();\n      }\n    };\n    const paddEmptyBody = (editor, moveSelection = true) => {\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('', { no_selection: !moveSelection });\n      }\n    };\n    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      const normalizedFromPos = normalizePosition(false, fromPos);\n      if (forward) {\n        return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\n      } else {\n        return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\n      }\n    }).getOr(true);\n    const freefallRtl = root => {\n      const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\n      return child.bind(freefallRtl).orThunk(() => Optional.some(root));\n    };\n    const deleteRangeContents = (editor, rng, root, moveSelection = true) => {\n      var _a;\n      rng.deleteContents();\n      const lastNode = freefallRtl(root).getOr(root);\n      const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);\n      if (lastBlock.dom === editor.getBody()) {\n        paddEmptyBody(editor, moveSelection);\n      } else if (isEmpty$2(lastBlock)) {\n        fillWithPaddingBr(lastBlock);\n        if (moveSelection) {\n          editor.selection.setCursorLocation(lastBlock.dom, 0);\n        }\n      }\n      if (!eq(root, lastBlock)) {\n        const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);\n        each$e(additionalCleanupNodes.concat(children$1(root)), node => {\n          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) {\n            remove$5(node);\n          }\n        });\n      }\n    };\n\n    const ancestor$1 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();\n    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\n    const descendant = (scope, predicate) => descendant$2(scope, predicate).isSome();\n\n    const isRootFromElement = root => cur => eq(root, cur);\n    const getTableCells = table => descendants(table, 'td,th');\n    const getTable$1 = (node, isRoot) => getClosestTable(SugarElement.fromDom(node), isRoot);\n    const selectionInTableWithNestedTable = details => {\n      return lift2(details.startTable, details.endTable, (startTable, endTable) => {\n        const isStartTableParentOfEndTable = descendant(startTable, t => eq(t, endTable));\n        const isEndTableParentOfStartTable = descendant(endTable, t => eq(t, startTable));\n        return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable ? details : {\n          ...details,\n          startTable: isStartTableParentOfEndTable ? Optional.none() : details.startTable,\n          endTable: isEndTableParentOfStartTable ? Optional.none() : details.endTable,\n          isSameTable: false,\n          isMultiTable: false\n        };\n      }).getOr(details);\n    };\n    const adjustQuirksInDetails = details => {\n      return selectionInTableWithNestedTable(details);\n    };\n    const getTableDetailsFromRange = (rng, isRoot) => {\n      const startTable = getTable$1(rng.startContainer, isRoot);\n      const endTable = getTable$1(rng.endContainer, isRoot);\n      const isStartInTable = startTable.isSome();\n      const isEndInTable = endTable.isSome();\n      const isSameTable = lift2(startTable, endTable, eq).getOr(false);\n      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\n      return adjustQuirksInDetails({\n        startTable,\n        endTable,\n        isStartInTable,\n        isEndInTable,\n        isSameTable,\n        isMultiTable\n      });\n    };\n\n    const tableCellRng = (start, end) => ({\n      start,\n      end\n    });\n    const tableSelection = (rng, table, cells) => ({\n      rng,\n      table,\n      cells\n    });\n    const deleteAction = Adt.generate([\n      {\n        singleCellTable: [\n          'rng',\n          'cell'\n        ]\n      },\n      { fullTable: ['table'] },\n      {\n        partialTable: [\n          'cells',\n          'outsideDetails'\n        ]\n      },\n      {\n        multiTable: [\n          'startTableCells',\n          'endTableCells',\n          'betweenRng'\n        ]\n      }\n    ]);\n    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\n    const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\n    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\n    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\n      const rows = table.dom.rows;\n      return rows.length === 1 && rows[0].cells.length === 1;\n    });\n    const getCellRng = (rng, isRoot) => {\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\n      return lift2(startCell, endCell, tableCellRng);\n    };\n    const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$3(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\n    const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\n    const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\n    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\n      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\n        return Optional.none();\n      } else if (selectionDetails.isSameTable) {\n        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: sameTableSelection,\n          end: sameTableSelection\n        });\n      } else {\n        const startCell = getClosestCell$1(rng.startContainer, isRoot);\n        const endCell = getClosestCell$1(rng.endContainer, isRoot);\n        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: startTableSelection,\n          end: endTableSelection\n        });\n      }\n    };\n    const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\n    const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\n    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\n    const unselectCells = (rng, selectionDetails) => {\n      const {startTable, endTable} = selectionDetails;\n      const otherContentRng = rng.cloneRange();\n      startTable.each(table => otherContentRng.setStartAfter(table.dom));\n      endTable.each(table => otherContentRng.setEndBefore(table.dom));\n      return otherContentRng;\n    };\n    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => start.or(end)).bind(tableSelection => {\n      const {isSameTable} = selectionDetails;\n      const selectedCells = getSelectedCells(tableSelection).getOr([]);\n      if (isSameTable && tableSelection.cells.length === selectedCells.length) {\n        return Optional.some(deleteAction.fullTable(tableSelection.table));\n      } else if (selectedCells.length > 0) {\n        if (isSameTable) {\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\n        } else {\n          const otherContentRng = unselectCells(rng, selectionDetails);\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({\n            ...selectionDetails,\n            rng: otherContentRng\n          })));\n        }\n      } else {\n        return Optional.none();\n      }\n    });\n    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => {\n      const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\n      const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\n      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\n        const otherContentRng = unselectCells(rng, selectionDetails);\n        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getActionFromRange = (root, rng) => {\n      const isRoot = isRootFromElement(root);\n      const optCellRng = getCellRng(rng, isRoot);\n      const selectionDetails = getTableDetailsFromRange(rng, isRoot);\n      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\n        return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\n      } else if (selectionDetails.isMultiTable) {\n        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\n      } else {\n        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\n      }\n    };\n\n    const cleanCells = cells => each$e(cells, cell => {\n      remove$a(cell, 'contenteditable');\n      fillWithPaddingBr(cell);\n    });\n    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\n    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\n      emptyBlock.each(block => {\n        if (startInTable) {\n          remove$5(block);\n        } else {\n          fillWithPaddingBr(block);\n          editor.selection.setCursorLocation(block.dom, 0);\n        }\n      });\n    };\n    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\n      const insideTableRng = rng.cloneRange();\n      if (isFirstCellInSelection) {\n        insideTableRng.setStart(rng.startContainer, rng.startOffset);\n        insideTableRng.setEndAfter(cell.dom.lastChild);\n      } else {\n        insideTableRng.setStartBefore(cell.dom.firstChild);\n        insideTableRng.setEnd(rng.endContainer, rng.endOffset);\n      }\n      deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\n    };\n    const collapseAndRestoreCellSelection = editor => {\n      const selectedCells = getCellsFromEditor(editor);\n      const selectedNode = SugarElement.fromDom(editor.selection.getNode());\n      if (isTableCell$3(selectedNode.dom) && isEmpty$2(selectedNode)) {\n        editor.selection.setCursorLocation(selectedNode.dom, 0);\n      } else {\n        editor.selection.collapse(true);\n      }\n      if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\n        set$3(selectedNode, 'data-mce-selected', '1');\n      }\n    };\n    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\n      const editorRng = editor.selection.getRng();\n      const cellsToClean = outsideDetails.bind(({rng, isStartInTable}) => {\n        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\n        rng.deleteContents();\n        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));\n        const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\n        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\n        if (!isEmpty$2(endPointCell)) {\n          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\n        } else {\n          return Optional.none();\n        }\n      }).getOr(cells);\n      cleanCells(cellsToClean);\n      collapseAndRestoreCellSelection(editor);\n    });\n    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\n      const rng = editor.selection.getRng();\n      const startCell = startTableCells[0];\n      const endCell = endTableCells[endTableCells.length - 1];\n      deleteContentInsideCell(editor, startCell, rng, true);\n      deleteContentInsideCell(editor, endCell, rng, false);\n      const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);\n      const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);\n      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\n      betweenRng.deleteContents();\n      collapseAndRestoreCellSelection(editor);\n    });\n    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {\n      deleteRangeContents(editor, rng, cell, moveSelection);\n    });\n    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\n    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\n    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\n    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\n    const deleteRange$3 = (editor, startElm, selectedCells) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\n    };\n    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);\n    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\n    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\n    const emptyElement = (editor, elm) => Optional.some(() => {\n      fillWithPaddingBr(elm);\n      editor.selection.setCursorLocation(elm.dom, 0);\n    });\n    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\n    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\n    const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\n    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\n    const deleteCaretCells = (editor, forward, rootElm, startElm) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\n    };\n    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\n    };\n    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\n    const isBeforeOrAfterTable = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\n    };\n    const deleteCaret$3 = (editor, forward, startElm) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\n    };\n    const backspaceDelete$a = (editor, forward) => {\n      const startElm = SugarElement.fromDom(editor.selection.getStart(true));\n      const cells = getCellsFromEditor(editor);\n      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells);\n    };\n\n    const getContentEditableRoot$1 = (root, node) => {\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {\n          return tempNode;\n        }\n        tempNode = tempNode.parentNode;\n      }\n      return null;\n    };\n\n    const internalAttributesPrefixes = [\n      'data-ephox-',\n      'data-mce-',\n      'data-alloy-',\n      'data-snooker-',\n      '_'\n    ];\n    const each$9 = Tools.each;\n    const ElementUtils = editor => {\n      const dom = editor.dom;\n      const internalAttributes = new Set(editor.serializer.getTempAttrs());\n      const compare = (node1, node2) => {\n        if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {\n          return false;\n        }\n        const getAttribs = node => {\n          const attribs = {};\n          each$9(dom.getAttribs(node), attr => {\n            const name = attr.nodeName.toLowerCase();\n            if (name !== 'style' && !isAttributeInternal(name)) {\n              attribs[name] = dom.getAttrib(node, name);\n            }\n          });\n          return attribs;\n        };\n        const compareObjects = (obj1, obj2) => {\n          for (const name in obj1) {\n            if (has$2(obj1, name)) {\n              const value = obj2[name];\n              if (isUndefined(value)) {\n                return false;\n              }\n              if (obj1[name] !== value) {\n                return false;\n              }\n              delete obj2[name];\n            }\n          }\n          for (const name in obj2) {\n            if (has$2(obj2, name)) {\n              return false;\n            }\n          }\n          return true;\n        };\n        if (isElement$6(node1) && isElement$6(node2)) {\n          if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n            return false;\n          }\n          if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\n            return false;\n          }\n        }\n        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\n      };\n      const isAttributeInternal = attributeName => exists(internalAttributesPrefixes, value => startsWith(attributeName, value)) || internalAttributes.has(attributeName);\n      return {\n        compare,\n        isAttributeInternal\n      };\n    };\n\n    const isHeading = node => [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6'\n    ].includes(node.name);\n    const isSummary = node => node.name === 'summary';\n\n    const traverse = (root, fn) => {\n      let node = root;\n      while (node = node.walk()) {\n        fn(node);\n      }\n    };\n    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\n      const name = node.name;\n      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\n        const filter = nodeFilters[ni];\n        if (filter.name === name) {\n          const match = matches.nodes[name];\n          if (match) {\n            match.nodes.push(node);\n          } else {\n            matches.nodes[name] = {\n              filter,\n              nodes: [node]\n            };\n          }\n        }\n      }\n      if (node.attributes) {\n        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\n          const filter = attributeFilters[ai];\n          const attrName = filter.name;\n          if (attrName in node.attributes.map) {\n            const match = matches.attributes[attrName];\n            if (match) {\n              match.nodes.push(node);\n            } else {\n              matches.attributes[attrName] = {\n                filter,\n                nodes: [node]\n              };\n            }\n          }\n        }\n      }\n    };\n    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\n      const matches = {\n        nodes: {},\n        attributes: {}\n      };\n      if (node.firstChild) {\n        traverse(node, childNode => {\n          matchNode$1(nodeFilters, attributeFilters, childNode, matches);\n        });\n      }\n      return matches;\n    };\n    const runFilters = (matches, args) => {\n      const run = (matchRecord, filteringAttributes) => {\n        each$d(matchRecord, match => {\n          const nodes = from(match.nodes);\n          each$e(match.filter.callbacks, callback => {\n            for (let i = nodes.length - 1; i >= 0; i--) {\n              const node = nodes[i];\n              const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;\n              if (!valueMatches || isNullable(node.parent)) {\n                nodes.splice(i, 1);\n              }\n            }\n            if (nodes.length > 0) {\n              callback(nodes, match.filter.name, args);\n            }\n          });\n        });\n      };\n      run(matches.nodes, false);\n      run(matches.attributes, true);\n    };\n    const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {\n      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\n      runFilters(matches, args);\n    };\n\n    const paddEmptyNode = (settings, args, isBlock, node) => {\n      const brPreferred = settings.pad_empty_with_br || args.insert;\n      if (brPreferred && isBlock(node)) {\n        const astNode = new AstNode('br', 1);\n        if (args.insert) {\n          astNode.attr('data-mce-bogus', '1');\n        }\n        node.empty().append(astNode);\n      } else {\n        node.empty().append(new AstNode('#text', 3)).value = nbsp;\n      }\n    };\n    const isPaddedWithNbsp = node => {\n      var _a;\n      return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;\n    };\n    const hasOnlyChild = (node, name) => {\n      const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;\n      return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;\n    };\n    const isPadded = (schema, node) => {\n      const rule = schema.getElementRule(node.name);\n      return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;\n    };\n    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\n    const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');\n    const findClosestEditingHost = scope => {\n      let editableNode;\n      for (let node = scope; node; node = node.parent) {\n        const contentEditable = node.attr('contenteditable');\n        if (contentEditable === 'false') {\n          break;\n        } else if (contentEditable === 'true') {\n          editableNode = node;\n        }\n      }\n      return Optional.from(editableNode);\n    };\n\n    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {\n      if (schema.getSpecialElements()[node.name]) {\n        node.empty().remove();\n      } else {\n        const children = node.children();\n        for (const childNode of children) {\n          if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {\n            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\n          }\n        }\n        node.unwrap();\n      }\n    };\n    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {\n      const textBlockElements = schema.getTextBlockElements();\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');\n      const fixed = new Set();\n      const isSplittableElement = node => node !== rootNode && !nonSplittableElements[node.name];\n      for (let ni = 0; ni < nodes.length; ni++) {\n        const node = nodes[ni];\n        let parent;\n        let newParent;\n        let tempNode;\n        if (!node.parent || fixed.has(node)) {\n          continue;\n        }\n        if (textBlockElements[node.name] && node.parent.name === 'li') {\n          let sibling = node.next;\n          while (sibling) {\n            if (textBlockElements[sibling.name]) {\n              sibling.name = 'li';\n              fixed.add(sibling);\n              node.parent.insert(sibling, node.parent);\n            } else {\n              break;\n            }\n            sibling = sibling.next;\n          }\n          node.unwrap();\n          continue;\n        }\n        const parents = [node];\n        for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {\n          parents.push(parent);\n        }\n        if (parent && parents.length > 1) {\n          if (!isInvalid(schema, node, parent)) {\n            parents.reverse();\n            newParent = parents[0].clone();\n            onCreate(newParent);\n            let currentNode = newParent;\n            for (let i = 0; i < parents.length - 1; i++) {\n              if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {\n                tempNode = parents[i].clone();\n                onCreate(tempNode);\n                currentNode.append(tempNode);\n              } else {\n                tempNode = currentNode;\n              }\n              for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\n                const nextNode = childNode.next;\n                tempNode.append(childNode);\n                childNode = nextNode;\n              }\n              currentNode = tempNode;\n            }\n            if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\n              parent.insert(newParent, parents[0], true);\n              parent.insert(node, newParent);\n            } else {\n              parent.insert(node, parents[0], true);\n            }\n            parent = parents[0];\n            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\n              parent.empty().remove();\n            }\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        } else if (node.parent) {\n          if (node.name === 'li') {\n            let sibling = node.prev;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n              sibling.append(node);\n              continue;\n            }\n            sibling = node.next;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {\n              sibling.insert(node, sibling.firstChild, true);\n              continue;\n            }\n            const wrapper = new AstNode('ul', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n            continue;\n          }\n          if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\n            const wrapper = new AstNode('div', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        }\n      }\n    };\n    const hasClosest = (node, parentName) => {\n      let tempNode = node;\n      while (tempNode) {\n        if (tempNode.name === parentName) {\n          return true;\n        }\n        tempNode = tempNode.parent;\n      }\n      return false;\n    };\n    const isInvalid = (schema, node, parent = node.parent) => {\n      if (!parent) {\n        return false;\n      }\n      if (schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\n        return true;\n      }\n      if (node.name === 'a' && hasClosest(parent, 'a')) {\n        return true;\n      }\n      if (isSummary(parent) && isHeading(node)) {\n        return !((parent === null || parent === void 0 ? void 0 : parent.firstChild) === node && (parent === null || parent === void 0 ? void 0 : parent.lastChild) === node);\n      }\n      return false;\n    };\n\n    const createRange = (sc, so, ec, eo) => {\n      const rng = document.createRange();\n      rng.setStart(sc, so);\n      rng.setEnd(ec, eo);\n      return rng;\n    };\n    const normalizeBlockSelectionRange = rng => {\n      const startPos = CaretPosition.fromRangeStart(rng);\n      const endPos = CaretPosition.fromRangeEnd(rng);\n      const rootNode = rng.commonAncestorContainer;\n      return fromPosition(false, rootNode, endPos).map(newEndPos => {\n        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\n          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\n        } else {\n          return rng;\n        }\n      }).getOr(rng);\n    };\n    const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\n\n    const hasOnlyOneChild$1 = node => {\n      return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;\n    };\n    const isPaddingNode = node => {\n      return node.name === 'br' || node.value === nbsp;\n    };\n    const isPaddedEmptyBlock = (schema, node) => {\n      const blockElements = schema.getBlockElements();\n      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\n    };\n    const isEmptyFragmentElement = (schema, node) => {\n      const nonEmptyElements = schema.getNonEmptyElements();\n      return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\n    };\n    const isListFragment = (schema, fragment) => {\n      let firstChild = fragment.firstChild;\n      let lastChild = fragment.lastChild;\n      if (firstChild && firstChild.name === 'meta') {\n        firstChild = firstChild.next;\n      }\n      if (lastChild && lastChild.attr('id') === 'mce_marker') {\n        lastChild = lastChild.prev;\n      }\n      if (isEmptyFragmentElement(schema, lastChild)) {\n        lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;\n      }\n      if (!firstChild || firstChild !== lastChild) {\n        return false;\n      }\n      return firstChild.name === 'ul' || firstChild.name === 'ol';\n    };\n    const cleanupDomFragment = domFragment => {\n      var _a, _b;\n      const firstChild = domFragment.firstChild;\n      const lastChild = domFragment.lastChild;\n      if (firstChild && firstChild.nodeName === 'META') {\n        (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);\n      }\n      if (lastChild && lastChild.id === 'mce_marker') {\n        (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);\n      }\n      return domFragment;\n    };\n    const toDomFragment = (dom, serializer, fragment) => {\n      const html = serializer.serialize(fragment);\n      const domFragment = dom.createFragment(html);\n      return cleanupDomFragment(domFragment);\n    };\n    const listItems = elm => {\n      var _a;\n      return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], child => {\n        return child.nodeName === 'LI';\n      });\n    };\n    const isPadding = node => {\n      return node.data === nbsp || isBr$6(node);\n    };\n    const isListItemPadded = node => {\n      return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);\n    };\n    const isEmptyOrPadded = elm => {\n      return !elm.firstChild || isListItemPadded(elm);\n    };\n    const trimListItems = elms => {\n      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\n    };\n    const getParentLi = (dom, node) => {\n      const parentBlock = dom.getParent(node, dom.isBlock);\n      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\n    };\n    const isParentBlockLi = (dom, node) => {\n      return !!getParentLi(dom, node);\n    };\n    const getSplit = (parentNode, rng) => {\n      const beforeRng = rng.cloneRange();\n      const afterRng = rng.cloneRange();\n      beforeRng.setStartBefore(parentNode);\n      afterRng.setEndAfter(parentNode);\n      return [\n        beforeRng.cloneContents(),\n        afterRng.cloneContents()\n      ];\n    };\n    const findFirstIn = (node, rootNode) => {\n      const caretPos = CaretPosition.before(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.next(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const findLastOf = (node, rootNode) => {\n      const caretPos = CaretPosition.after(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.prev(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const insertMiddle = (target, elms, rootNode, rng) => {\n      const parts = getSplit(target, rng);\n      const parentElm = target.parentNode;\n      if (parentElm) {\n        parentElm.insertBefore(parts[0], target);\n        Tools.each(elms, li => {\n          parentElm.insertBefore(li, target);\n        });\n        parentElm.insertBefore(parts[1], target);\n        parentElm.removeChild(target);\n      }\n      return findLastOf(elms[elms.length - 1], rootNode);\n    };\n    const insertBefore$2 = (target, elms, rootNode) => {\n      const parentElm = target.parentNode;\n      if (parentElm) {\n        Tools.each(elms, elm => {\n          parentElm.insertBefore(elm, target);\n        });\n      }\n      return findFirstIn(target, rootNode);\n    };\n    const insertAfter$2 = (target, elms, rootNode, dom) => {\n      dom.insertAfter(elms.reverse(), target);\n      return findLastOf(elms[0], rootNode);\n    };\n    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\n      const domFragment = toDomFragment(dom, serializer, fragment);\n      const liTarget = getParentLi(dom, rng.startContainer);\n      const liElms = trimListItems(listItems(domFragment.firstChild));\n      const BEGINNING = 1, END = 2;\n      const rootNode = dom.getRoot();\n      const isAt = location => {\n        const caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(dom.getRoot());\n        const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\n        const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();\n        return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;\n      };\n      if (!liTarget) {\n        return null;\n      } else if (isAt(BEGINNING)) {\n        return insertBefore$2(liTarget, liElms, rootNode);\n      } else if (isAt(END)) {\n        return insertAfter$2(liTarget, liElms, rootNode, dom);\n      } else {\n        return insertMiddle(liTarget, liElms, rootNode, rng);\n      }\n    };\n\n    const mergeableWrappedElements = ['pre'];\n    const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {\n      var _a;\n      const firstNode = fragment.firstChild;\n      const lastNode = fragment.lastChild;\n      const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;\n      const isPastingSingleElement = firstNode === last;\n      const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);\n      if (isPastingSingleElement && isWrappedElement) {\n        const isContentEditable = firstNode.attr('contenteditable') !== 'false';\n        const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;\n        const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);\n        return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;\n      } else {\n        return false;\n      }\n    };\n    const isTableCell = isTableCell$3;\n    const isTableCellContentSelected = (dom, rng, cell) => {\n      if (isNonNullable(cell)) {\n        const endCell = dom.getParent(rng.endContainer, isTableCell);\n        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\n      } else {\n        return false;\n      }\n    };\n    const validInsertion = (editor, value, parentNode) => {\n      var _a;\n      if (parentNode.getAttribute('data-mce-bogus') === 'all') {\n        (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);\n      } else {\n        const node = parentNode.firstChild;\n        const node2 = parentNode.lastChild;\n        if (!node || node === node2 && node.nodeName === 'BR') {\n          editor.dom.setHTML(parentNode, value);\n        } else {\n          editor.selection.setContent(value, { no_events: true });\n        }\n      }\n    };\n    const trimBrsFromTableCell = (dom, elm, schema) => {\n      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(el => trimBlockTrailingBr(el, schema));\n    };\n    const reduceInlineTextElements = (editor, merge) => {\n      const textInlineElements = editor.schema.getTextInlineElements();\n      const dom = editor.dom;\n      if (merge) {\n        const root = editor.getBody();\n        const elementUtils = ElementUtils(editor);\n        Tools.each(dom.select('*[data-mce-fragment]'), node => {\n          const isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);\n          if (isInline && hasInheritableStyles(dom, node)) {\n            for (let parentNode = node.parentElement; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentElement) {\n              const styleConflict = hasStyleConflict(dom, node, parentNode);\n              if (styleConflict) {\n                break;\n              }\n              if (elementUtils.compare(parentNode, node)) {\n                dom.remove(node, true);\n                break;\n              }\n            }\n          }\n        });\n      }\n    };\n    const markFragmentElements = fragment => {\n      let node = fragment;\n      while (node = node.walk()) {\n        if (node.type === 1) {\n          node.attr('data-mce-fragment', '1');\n        }\n      }\n    };\n    const unmarkFragmentElements = elm => {\n      Tools.each(elm.getElementsByTagName('*'), elm => {\n        elm.removeAttribute('data-mce-fragment');\n      });\n    };\n    const isPartOfFragment = node => {\n      return !!node.getAttribute('data-mce-fragment');\n    };\n    const canHaveChildren = (editor, node) => {\n      return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];\n    };\n    const moveSelectionToMarker = (editor, marker) => {\n      var _a, _b, _c;\n      let nextRng;\n      const dom = editor.dom;\n      const selection = editor.selection;\n      if (!marker) {\n        return;\n      }\n      selection.scrollIntoView(marker);\n      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\n      if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {\n        dom.remove(marker);\n        selection.select(parentEditableElm);\n        return;\n      }\n      let rng = dom.createRng();\n      const node = marker.previousSibling;\n      if (isText$a(node)) {\n        rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n        const node2 = marker.nextSibling;\n        if (isText$a(node2)) {\n          node.appendData(node2.data);\n          (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);\n        }\n      } else {\n        rng.setStartBefore(marker);\n        rng.setEndBefore(marker);\n      }\n      const findNextCaretRng = rng => {\n        let caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(editor.getBody());\n        caretPos = caretWalker.next(caretPos);\n        return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();\n      };\n      const parentBlock = dom.getParent(marker, dom.isBlock);\n      dom.remove(marker);\n      if (parentBlock && dom.isEmpty(parentBlock)) {\n        const isCell = isTableCell(parentBlock);\n        empty(SugarElement.fromDom(parentBlock));\n        rng.setStart(parentBlock, 0);\n        rng.setEnd(parentBlock, 0);\n        if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\n          rng = nextRng;\n          dom.remove(parentBlock);\n        } else {\n          dom.add(parentBlock, dom.create('br', isCell ? {} : { 'data-mce-bogus': '1' }));\n        }\n      }\n      selection.setRng(rng);\n    };\n    const deleteSelectedContent = editor => {\n      const dom = editor.dom;\n      const rng = normalize(editor.selection.getRng());\n      editor.selection.setRng(rng);\n      const startCell = dom.getParent(rng.startContainer, isTableCell);\n      if (isTableCellContentSelected(dom, rng, startCell)) {\n        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\n      } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$a(rng.startContainer.childNodes[rng.startOffset])) {\n        rng.deleteContents();\n      } else {\n        editor.getDoc().execCommand('Delete', false);\n      }\n    };\n    const findMarkerNode = scope => {\n      for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {\n        if (markerNode.attr('id') === 'mce_marker') {\n          return Optional.some(markerNode);\n        }\n      }\n      return Optional.none();\n    };\n    const notHeadingsInSummary = (dom, node, fragment) => {\n      var _a;\n      return exists(fragment.children(), isHeading) && ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName) === 'SUMMARY';\n    };\n    const insertHtmlAtCaret = (editor, value, details) => {\n      var _a, _b;\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const parser = editor.parser;\n      const merge = details.merge;\n      const serializer = HtmlSerializer({ validate: true }, editor.schema);\n      const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\n      if (!details.preserve_zwsp) {\n        value = trim$2(value);\n      }\n      if (value.indexOf('{$caret}') === -1) {\n        value += '{$caret}';\n      }\n      value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n      let rng = selection.getRng();\n      const caretElement = rng.startContainer;\n      const body = editor.getBody();\n      if (caretElement === body && selection.isCollapsed()) {\n        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\n          rng = dom.createRng();\n          rng.setStart(body.firstChild, 0);\n          rng.setEnd(body.firstChild, 0);\n          selection.setRng(rng);\n        }\n      }\n      if (!selection.isCollapsed()) {\n        deleteSelectedContent(editor);\n      }\n      const parentNode = selection.getNode();\n      const parserArgs = {\n        context: parentNode.nodeName.toLowerCase(),\n        data: details.data,\n        insert: true\n      };\n      const fragment = parser.parse(value, parserArgs);\n      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\n        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\n        if (rng) {\n          selection.setRng(rng);\n        }\n        return value;\n      }\n      if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {\n        (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();\n      }\n      markFragmentElements(fragment);\n      let node = fragment.lastChild;\n      if (node && node.attr('id') === 'mce_marker') {\n        const marker = node;\n        for (node = node.prev; node; node = node.walk(true)) {\n          if (node.type === 3 || !dom.isBlock(node.name)) {\n            if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {\n              node.parent.insert(marker, node, node.name === 'br');\n            }\n            break;\n          }\n        }\n      }\n      editor._selectionOverrides.showBlockCaretContainer(parentNode);\n      if (!parserArgs.invalid && !notHeadingsInSummary(dom, parentNode, fragment)) {\n        value = serializer.serialize(fragment);\n        validInsertion(editor, value, parentNode);\n      } else {\n        editor.selection.setContent(bookmarkHtml);\n        let parentNode = selection.getNode();\n        let tempNode;\n        const rootNode = editor.getBody();\n        if (isDocument$1(parentNode)) {\n          parentNode = tempNode = rootNode;\n        } else {\n          tempNode = parentNode;\n        }\n        while (tempNode && tempNode !== rootNode) {\n          parentNode = tempNode;\n          tempNode = tempNode.parentNode;\n        }\n        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n        const root = parser.parse(value);\n        const markerNode = findMarkerNode(root);\n        const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);\n        markerNode.each(marker => marker.replace(fragment));\n        const toExtract = fragment.children();\n        const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;\n        fragment.unwrap();\n        const invalidChildren = filter$5(toExtract, node => isInvalid(editor.schema, node, parent));\n        cleanInvalidNodes(invalidChildren, editor.schema, editingHost);\n        filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);\n        value = serializer.serialize(root);\n        if (parentNode === rootNode) {\n          dom.setHTML(rootNode, value);\n        } else {\n          dom.setOuterHTML(parentNode, value);\n        }\n      }\n      reduceInlineTextElements(editor, merge);\n      moveSelectionToMarker(editor, dom.get('mce_marker'));\n      unmarkFragmentElements(editor.getBody());\n      trimBrsFromTableCell(dom, selection.getStart(), editor.schema);\n      updateCaret(editor.schema, editor.getBody(), selection.getStart());\n      return value;\n    };\n\n    const isTreeNode = content => content instanceof AstNode;\n\n    const moveSelection = editor => {\n      if (hasFocus(editor)) {\n        firstPositionIn(editor.getBody()).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const setEditorHtml = (editor, html, noSelection) => {\n      editor.dom.setHTML(editor.getBody(), html);\n      if (noSelection !== true) {\n        moveSelection(editor);\n      }\n    };\n    const setContentString = (editor, body, content, args) => {\n      content = trim$2(content);\n      if (content.length === 0 || /^\\s+$/.test(content)) {\n        const padd = '<br data-mce-bogus=\"1\">';\n        if (body.nodeName === 'TABLE') {\n          content = '<tr><td>' + padd + '</td></tr>';\n        } else if (/^(UL|OL)$/.test(body.nodeName)) {\n          content = '<li>' + padd + '</li>';\n        }\n        const forcedRootBlockName = getForcedRootBlock(editor);\n        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n          content = padd;\n          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\n        } else if (!content) {\n          content = padd;\n        }\n        setEditorHtml(editor, content, args.no_selection);\n        return {\n          content,\n          html: content\n        };\n      } else {\n        if (args.format !== 'raw') {\n          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {\n            isRootContent: true,\n            insert: true\n          }));\n        }\n        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\n        setEditorHtml(editor, trimmedHtml, args.no_selection);\n        return {\n          content: trimmedHtml,\n          html: trimmedHtml\n        };\n      }\n    };\n    const setContentTree = (editor, body, content, args) => {\n      filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\n      const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);\n      const trimmedHtml = trim$2(isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html));\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\n      return {\n        content,\n        html: trimmedHtml\n      };\n    };\n    const setContentInternal = (editor, content, args) => {\n      return Optional.from(editor.getBody()).map(body => {\n        if (isTreeNode(content)) {\n          return setContentTree(editor, body, content, args);\n        } else {\n          return setContentString(editor, body, content, args);\n        }\n      }).getOr({\n        content,\n        html: isTreeNode(args.content) ? '' : args.content\n      });\n    };\n\n    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n    const ancestor = (scope, transform, isRoot) => {\n      let element = scope.dom;\n      const stop = ensureIsRoot(isRoot);\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        const transformed = transform(el);\n        if (transformed.isSome()) {\n          return transformed;\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$1 = (scope, transform, isRoot) => {\n      const current = transform(scope);\n      const stop = ensureIsRoot(isRoot);\n      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\n    };\n\n    const isEq$3 = isEq$5;\n    const matchesUnInheritedFormatSelector = (ed, node, name) => {\n      const formatList = ed.formatter.get(name);\n      if (formatList) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const matchParents = (editor, node, name, vars, similar) => {\n      const root = editor.dom.getRoot();\n      if (node === root) {\n        return false;\n      }\n      const matchedNode = editor.dom.getParent(node, elm => {\n        if (matchesUnInheritedFormatSelector(editor, elm, name)) {\n          return true;\n        }\n        return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);\n      });\n      return !!matchNode(editor, matchedNode, name, vars, similar);\n    };\n    const matchName = (dom, node, format) => {\n      if (isInlineFormat(format) && isEq$3(node, format.inline)) {\n        return true;\n      }\n      if (isBlockFormat(format) && isEq$3(node, format.block)) {\n        return true;\n      }\n      if (isSelectorFormat(format)) {\n        return isElement$6(node) && dom.is(node, format.selector);\n      }\n      return false;\n    };\n    const matchItems = (dom, node, format, itemName, similar, vars) => {\n      const items = format[itemName];\n      const matchAttributes = itemName === 'attributes';\n      if (isFunction(format.onmatch)) {\n        return format.onmatch(node, format, itemName);\n      }\n      if (items) {\n        if (!isArrayLike(items)) {\n          for (const key in items) {\n            if (has$2(items, key)) {\n              const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);\n              const expectedValue = replaceVars(items[key], vars);\n              const isEmptyValue = isNullable(value) || isEmpty$3(value);\n              if (isEmptyValue && isNullable(expectedValue)) {\n                continue;\n              }\n              if (similar && isEmptyValue && !format.exact) {\n                return false;\n              }\n              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\n                return false;\n              }\n            }\n          }\n        } else {\n          for (let i = 0; i < items.length; i++) {\n            if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\n              return true;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const matchNode = (ed, node, name, vars, similar) => {\n      const formatList = ed.formatter.get(name);\n      const dom = ed.dom;\n      if (formatList && isElement$6(node)) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\n            const classes = format.classes;\n            if (classes) {\n              for (let x = 0; x < classes.length; x++) {\n                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\n                  return;\n                }\n              }\n            }\n            return format;\n          }\n        }\n      }\n      return undefined;\n    };\n    const match$2 = (editor, name, vars, node, similar) => {\n      if (node) {\n        return matchParents(editor, node, name, vars, similar);\n      }\n      node = editor.selection.getNode();\n      if (matchParents(editor, node, name, vars, similar)) {\n        return true;\n      }\n      const startNode = editor.selection.getStart();\n      if (startNode !== node) {\n        if (matchParents(editor, startNode, name, vars, similar)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const matchAll = (editor, names, vars) => {\n      const matchedFormatNames = [];\n      const checkedMap = {};\n      const startElement = editor.selection.getStart();\n      editor.dom.getParent(startElement, node => {\n        for (let i = 0; i < names.length; i++) {\n          const name = names[i];\n          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\n            checkedMap[name] = true;\n            matchedFormatNames.push(name);\n          }\n        }\n      }, editor.dom.getRoot());\n      return matchedFormatNames;\n    };\n    const closest = (editor, names) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\n      return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$1(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\n    };\n    const canApply = (editor, name) => {\n      const formatList = editor.formatter.get(name);\n      const dom = editor.dom;\n      if (formatList && editor.selection.isEditable()) {\n        const startNode = editor.selection.getStart();\n        const parents = getParents$2(dom, startNode);\n        for (let x = formatList.length - 1; x >= 0; x--) {\n          const format = formatList[x];\n          if (!isSelectorFormat(format)) {\n            return true;\n          }\n          for (let i = parents.length - 1; i >= 0; i--) {\n            if (dom.is(parents[i], format.selector)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\n      const matchSimilar = isVariableFormatName(editor, name);\n      if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\n        return acc.concat([name]);\n      } else {\n        return acc;\n      }\n    }, []);\n\n    const ZWSP = ZWSP$1;\n    const importNode = (ownerDocument, node) => {\n      return ownerDocument.importNode(node, true);\n    };\n    const findFirstTextNode = node => {\n      if (node) {\n        const walker = new DomTreeWalker(node, node);\n        for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {\n          if (isText$a(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const createCaretContainer = fill => {\n      const caretContainer = SugarElement.fromTag('span');\n      setAll$1(caretContainer, {\n        'id': CARET_ID,\n        'data-mce-bogus': '1',\n        'data-mce-type': 'format-caret'\n      });\n      if (fill) {\n        append$1(caretContainer, SugarElement.fromText(ZWSP));\n      }\n      return caretContainer;\n    };\n    const trimZwspFromCaretContainer = caretContainerNode => {\n      const textNode = findFirstTextNode(caretContainerNode);\n      if (textNode && textNode.data.charAt(0) === ZWSP) {\n        textNode.deleteData(0, 1);\n      }\n      return textNode;\n    };\n    const removeCaretContainerNode = (editor, node, moveCaret) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (isCaretContainerEmpty(node)) {\n        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret, true);\n      } else {\n        const rng = selection.getRng();\n        const block = dom.getParent(node, dom.isBlock);\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        const textNode = trimZwspFromCaretContainer(node);\n        dom.remove(node, true);\n        if (startContainer === textNode && startOffset > 0) {\n          rng.setStart(textNode, startOffset - 1);\n        }\n        if (endContainer === textNode && endOffset > 0) {\n          rng.setEnd(textNode, endOffset - 1);\n        }\n        if (block && dom.isEmpty(block)) {\n          fillWithPaddingBr(SugarElement.fromDom(block));\n        }\n        selection.setRng(rng);\n      }\n    };\n    const removeCaretContainer = (editor, node, moveCaret) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (!node) {\n        node = getParentCaretContainer(editor.getBody(), selection.getStart());\n        if (!node) {\n          while (node = dom.get(CARET_ID)) {\n            removeCaretContainerNode(editor, node, moveCaret);\n          }\n        }\n      } else {\n        removeCaretContainerNode(editor, node, moveCaret);\n      }\n    };\n    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\n      var _a, _b;\n      const dom = editor.dom;\n      const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));\n      if (block && dom.isEmpty(block)) {\n        (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);\n      } else {\n        removeTrailingBr(SugarElement.fromDom(formatNode));\n        if (dom.isEmpty(formatNode)) {\n          (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);\n        } else {\n          dom.insertAfter(caretContainer, formatNode);\n        }\n      }\n    };\n    const appendNode = (parentNode, node) => {\n      parentNode.appendChild(node);\n      return node;\n    };\n    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\n      var _a;\n      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\n        return appendNode(parentNode, formatNode.cloneNode(false));\n      }, caretContainer);\n      const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));\n    };\n    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\n      const formatter = editor.formatter;\n      const dom = editor.dom;\n      const validFormats = filter$5(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\n      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\n      const uniqueFormats = filter$5(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\n      if (uniqueFormats.length > 0) {\n        const clonedFormatNode = formatNode.cloneNode(false);\n        dom.add(caretContainer, clonedFormatNode);\n        formatter.remove(name, vars, clonedFormatNode, similar);\n        dom.remove(clonedFormatNode);\n        return Optional.some(clonedFormatNode);\n      } else {\n        return Optional.none();\n      }\n    };\n    const applyCaretFormat = (editor, name, vars) => {\n      let caretContainer;\n      const selection = editor.selection;\n      const formatList = editor.formatter.get(name);\n      if (!formatList) {\n        return;\n      }\n      const selectionRng = selection.getRng();\n      let offset = selectionRng.startOffset;\n      const container = selectionRng.startContainer;\n      const text = container.nodeValue;\n      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\n      const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\n      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\n        const bookmark = selection.getBookmark();\n        selectionRng.collapse(true);\n        let rng = expandRng(editor.dom, selectionRng, formatList);\n        rng = split(rng);\n        editor.formatter.apply(name, vars, rng);\n        selection.moveToBookmark(bookmark);\n      } else {\n        let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;\n        if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {\n          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\n          textNode = caretContainer.firstChild;\n          selectionRng.insertNode(caretContainer);\n          offset = 1;\n          editor.formatter.apply(name, vars, caretContainer);\n        } else {\n          editor.formatter.apply(name, vars, caretContainer);\n        }\n        selection.setCursorLocation(textNode, offset);\n      }\n    };\n    const removeCaretFormat = (editor, name, vars, similar) => {\n      const dom = editor.dom;\n      const selection = editor.selection;\n      let hasContentAfter = false;\n      const formatList = editor.formatter.get(name);\n      if (!formatList) {\n        return;\n      }\n      const rng = selection.getRng();\n      const container = rng.startContainer;\n      const offset = rng.startOffset;\n      let node = container;\n      if (isText$a(container)) {\n        if (offset !== container.data.length) {\n          hasContentAfter = true;\n        }\n        node = node.parentNode;\n      }\n      const parents = [];\n      let formatNode;\n      while (node) {\n        if (matchNode(editor, node, name, vars, similar)) {\n          formatNode = node;\n          break;\n        }\n        if (node.nextSibling) {\n          hasContentAfter = true;\n        }\n        parents.push(node);\n        node = node.parentNode;\n      }\n      if (!formatNode) {\n        return;\n      }\n      if (hasContentAfter) {\n        const bookmark = selection.getBookmark();\n        rng.collapse(true);\n        let expandedRng = expandRng(dom, rng, formatList, true);\n        expandedRng = split(expandedRng);\n        editor.formatter.remove(name, vars, expandedRng, similar);\n        selection.moveToBookmark(bookmark);\n      } else {\n        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\n        const parentsAfter = isNonNullable(caretContainer) ? dom.getParents(formatNode.parentNode, always, caretContainer) : [];\n        const newCaretContainer = createCaretContainer(false).dom;\n        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);\n        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\n        const caretTextNode = insertFormatNodesIntoCaretContainer([\n          ...parents,\n          ...cleanedFormatNode.toArray(),\n          ...parentsAfter\n        ], newCaretContainer);\n        if (caretContainer) {\n          removeCaretContainerNode(editor, caretContainer, isNonNullable(caretContainer));\n        }\n        selection.setCursorLocation(caretTextNode, 1);\n        if (dom.isEmpty(formatNode)) {\n          dom.remove(formatNode);\n        }\n      }\n    };\n    const disableCaretContainer = (editor, keyCode, moveCaret) => {\n      const selection = editor.selection, body = editor.getBody();\n      removeCaretContainer(editor, null, moveCaret);\n      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n      }\n      if (keyCode === 37 || keyCode === 39) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n      }\n    };\n    const endsWithNbsp = element => isText$a(element) && endsWith(element.data, nbsp);\n    const setup$v = editor => {\n      editor.on('mouseup keydown', e => {\n        disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));\n      });\n    };\n    const createCaretFormat = formatNodes => {\n      const caretContainer = createCaretContainer(false);\n      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\n      return {\n        caretContainer,\n        caretPosition: CaretPosition(innerMost, 0)\n      };\n    };\n    const replaceWithCaretFormat = (targetNode, formatNodes) => {\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\n      before$3(SugarElement.fromDom(targetNode), caretContainer);\n      remove$5(SugarElement.fromDom(targetNode));\n      return caretPosition;\n    };\n    const createCaretFormatAtStart$1 = (rng, formatNodes) => {\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\n      rng.insertNode(caretContainer.dom);\n      return caretPosition;\n    };\n    const isFormatElement = (editor, element) => {\n      if (isCaretNode(element.dom)) {\n        return false;\n      }\n      const inlineElements = editor.schema.getTextInlineElements();\n      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);\n    };\n\n    const postProcessHooks = {};\n    const isPre = matchNodeNames(['pre']);\n    const addPostProcessHook = (name, hook) => {\n      const hooks = postProcessHooks[name];\n      if (!hooks) {\n        postProcessHooks[name] = [];\n      }\n      postProcessHooks[name].push(hook);\n    };\n    const postProcess$1 = (name, editor) => {\n      if (has$2(postProcessHooks, name)) {\n        each$e(postProcessHooks[name], hook => {\n          hook(editor);\n        });\n      }\n    };\n    addPostProcessHook('pre', editor => {\n      const rng = editor.selection.getRng();\n      const hasPreSibling = blocks => pre => {\n        const prev = pre.previousSibling;\n        return isPre(prev) && contains$2(blocks, prev);\n      };\n      const joinPre = (pre1, pre2) => {\n        const sPre2 = SugarElement.fromDom(pre2);\n        const doc = documentOrOwner(sPre2).dom;\n        remove$5(sPre2);\n        append(SugarElement.fromDom(pre1), [\n          SugarElement.fromTag('br', doc),\n          SugarElement.fromTag('br', doc),\n          ...children$1(sPre2)\n        ]);\n      };\n      if (!rng.collapsed) {\n        const blocks = editor.selection.getSelectedBlocks();\n        const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));\n        each$e(preBlocks, pre => {\n          joinPre(pre.previousSibling, pre);\n        });\n      }\n    });\n\n    const listItemStyles = [\n      'fontWeight',\n      'fontStyle',\n      'color',\n      'fontSize',\n      'fontFamily'\n    ];\n    const hasListStyles = fmt => isObject(fmt.styles) && exists(keys(fmt.styles), name => contains$2(listItemStyles, name));\n    const findExpandedListItemFormat = formats => find$2(formats, fmt => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));\n    const getExpandedListItemFormat = (formatter, format) => {\n      const formatList = formatter.get(format);\n      return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();\n    };\n    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();\n    const isRngEndAtEndOfElement = (rng, elm) => {\n      return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(pos => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;\n    };\n    const isEditableListItem = dom => elm => isListItem$2(elm) && dom.isEditable(elm);\n    const getFullySelectedBlocks = selection => {\n      const blocks = selection.getSelectedBlocks();\n      const rng = selection.getRng();\n      if (selection.isCollapsed()) {\n        return [];\n      }\n      if (blocks.length === 1) {\n        return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];\n      } else {\n        const first = head(blocks).filter(elm => isRngStartAtStartOfElement(rng, elm)).toArray();\n        const last = last$3(blocks).filter(elm => isRngEndAtEndOfElement(rng, elm)).toArray();\n        const middle = blocks.slice(1, -1);\n        return first.concat(middle).concat(last);\n      }\n    };\n    const getFullySelectedListItems = selection => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));\n    const getPartiallySelectedListItems = selection => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));\n\n    const each$8 = Tools.each;\n    const isElementNode = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n    const findElementSibling = (node, siblingName) => {\n      for (let sibling = node; sibling; sibling = sibling[siblingName]) {\n        if (isText$a(sibling) && isNotEmpty(sibling.data)) {\n          return node;\n        }\n        if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\n          return sibling;\n        }\n      }\n      return node;\n    };\n    const mergeSiblingsNodes = (editor, prev, next) => {\n      const elementUtils = ElementUtils(editor);\n      const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);\n      const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);\n      if (isPrevEditable && isNextEditable) {\n        const prevSibling = findElementSibling(prev, 'previousSibling');\n        const nextSibling = findElementSibling(next, 'nextSibling');\n        if (elementUtils.compare(prevSibling, nextSibling)) {\n          for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {\n            const tmpSibling = sibling;\n            sibling = sibling.nextSibling;\n            prevSibling.appendChild(tmpSibling);\n          }\n          editor.dom.remove(nextSibling);\n          Tools.each(Tools.grep(nextSibling.childNodes), node => {\n            prevSibling.appendChild(node);\n          });\n          return prevSibling;\n        }\n      }\n      return next;\n    };\n    const mergeSiblings = (editor, format, vars, node) => {\n      var _a;\n      if (node && format.merge_siblings !== false) {\n        const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;\n        mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));\n      }\n    };\n    const clearChildStyles = (dom, format, node) => {\n      if (format.clear_child_styles) {\n        const selector = format.links ? '*:not(a)' : '*';\n        each$8(dom.select(selector, node), childNode => {\n          if (isElementNode(childNode) && dom.isEditable(childNode)) {\n            each$8(format.styles, (_value, name) => {\n              dom.setStyle(childNode, name, '');\n            });\n          }\n        });\n      }\n    };\n    const processChildElements = (node, filter, process) => {\n      each$8(node.childNodes, node => {\n        if (isElementNode(node)) {\n          if (filter(node)) {\n            process(node);\n          }\n          if (node.hasChildNodes()) {\n            processChildElements(node, filter, process);\n          }\n        }\n      });\n    };\n    const unwrapEmptySpan = (dom, node) => {\n      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\n        dom.remove(node, true);\n      }\n    };\n    const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\n    const applyStyle = (dom, name, value) => node => {\n      dom.setStyle(node, name, value);\n      if (node.getAttribute('style') === '') {\n        node.removeAttribute('style');\n      }\n      unwrapEmptySpan(dom, node);\n    };\n\n    const removeResult = Adt.generate([\n      { keep: [] },\n      { rename: ['name'] },\n      { removed: [] }\n    ]);\n    const MCE_ATTR_RE = /^(src|href|style)$/;\n    const each$7 = Tools.each;\n    const isEq$2 = isEq$5;\n    const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\n    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\n    const getContainer = (ed, rng, start) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement$6(container)) {\n        const lastIdx = container.childNodes.length - 1;\n        if (!start && offset) {\n          offset--;\n        }\n        container = container.childNodes[offset > lastIdx ? lastIdx : offset];\n      }\n      if (isText$a(container) && start && offset >= container.data.length) {\n        container = new DomTreeWalker(container, ed.getBody()).next() || container;\n      }\n      if (isText$a(container) && !start && offset === 0) {\n        container = new DomTreeWalker(container, ed.getBody()).prev() || container;\n      }\n      return container;\n    };\n    const normalizeTableSelection = (node, start) => {\n      const prop = start ? 'firstChild' : 'lastChild';\n      const childNode = node[prop];\n      if (isTableCellOrRow(node) && childNode) {\n        if (node.nodeName === 'TR') {\n          return childNode[prop] || childNode;\n        } else {\n          return childNode;\n        }\n      }\n      return node;\n    };\n    const wrap$1 = (dom, node, name, attrs) => {\n      var _a;\n      const wrapper = dom.create(name, attrs);\n      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n      return wrapper;\n    };\n    const wrapWithSiblings = (dom, node, next, name, attrs) => {\n      const start = SugarElement.fromDom(node);\n      const wrapper = SugarElement.fromDom(dom.create(name, attrs));\n      const siblings = next ? nextSiblings(start) : prevSiblings(start);\n      append(wrapper, siblings);\n      if (next) {\n        before$3(start, wrapper);\n        prepend(wrapper, start);\n      } else {\n        after$4(start, wrapper);\n        append$1(wrapper, start);\n      }\n      return wrapper.dom;\n    };\n    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\n    const removeNode = (ed, node, format) => {\n      const parentNode = node.parentNode;\n      let rootBlockElm;\n      const dom = ed.dom;\n      const forcedRootBlock = getForcedRootBlock(ed);\n      if (isBlockFormat(format)) {\n        if (parentNode === dom.getRoot()) {\n          if (!format.list_block || !isEq$2(node, format.list_block)) {\n            each$e(from(node.childNodes), node => {\n              if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\n                if (!rootBlockElm) {\n                  rootBlockElm = wrap$1(dom, node, forcedRootBlock);\n                  dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\n                } else {\n                  rootBlockElm.appendChild(node);\n                }\n              } else {\n                rootBlockElm = null;\n              }\n            });\n          }\n        }\n      }\n      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\n        return;\n      }\n      dom.remove(node, true);\n    };\n    const processFormatAttrOrStyle = (name, value, vars) => {\n      if (isNumber(name)) {\n        return {\n          name: value,\n          value: null\n        };\n      } else {\n        return {\n          name,\n          value: replaceVars(value, vars)\n        };\n      }\n    };\n    const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {\n      if (dom.getAttrib(elm, 'style') === '') {\n        elm.removeAttribute('style');\n        elm.removeAttribute('data-mce-style');\n      }\n    };\n    const removeStyles = (dom, elm, format, vars, compareNode) => {\n      let stylesModified = false;\n      each$7(format.styles, (value, name) => {\n        const {\n          name: styleName,\n          value: styleValue\n        } = processFormatAttrOrStyle(name, value, vars);\n        const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);\n        if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {\n          dom.setStyle(elm, styleName, '');\n        }\n        stylesModified = true;\n      });\n      if (stylesModified) {\n        removeEmptyStyleAttributeIfNeeded(dom, elm);\n      }\n    };\n    const removeListStyleFormats = (editor, name, vars) => {\n      if (name === 'removeformat') {\n        each$e(getPartiallySelectedListItems(editor.selection), li => {\n          each$e(listItemStyles, name => editor.dom.setStyle(li, name, ''));\n          removeEmptyStyleAttributeIfNeeded(editor.dom, li);\n        });\n      } else {\n        getExpandedListItemFormat(editor.formatter, name).each(liFmt => {\n          each$e(getPartiallySelectedListItems(editor.selection), li => removeStyles(editor.dom, li, liFmt, vars, null));\n        });\n      }\n    };\n    const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {\n      const dom = ed.dom;\n      const elementUtils = ElementUtils(ed);\n      const schema = ed.schema;\n      if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {\n        removeNode(ed, node, format);\n        return removeResult.removed();\n      }\n      if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {\n        return removeResult.keep();\n      }\n      if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\n        return removeResult.keep();\n      }\n      const elm = node;\n      const preserveAttributes = format.preserve_attributes;\n      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {\n        const attrsToPreserve = filter$5(dom.getAttribs(elm), attr => contains$2(preserveAttributes, attr.name.toLowerCase()));\n        dom.removeAllAttribs(elm);\n        each$e(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\n        if (attrsToPreserve.length > 0) {\n          return removeResult.rename('span');\n        }\n      }\n      if (format.remove !== 'all') {\n        removeStyles(dom, elm, format, vars, compareNode);\n        each$7(format.attributes, (value, name) => {\n          const {\n            name: attrName,\n            value: attrValue\n          } = processFormatAttrOrStyle(name, value, vars);\n          if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {\n            if (attrName === 'class') {\n              const currentValue = dom.getAttrib(elm, attrName);\n              if (currentValue) {\n                let valueOut = '';\n                each$e(currentValue.split(/\\s+/), cls => {\n                  if (/mce\\-\\w+/.test(cls)) {\n                    valueOut += (valueOut ? ' ' : '') + cls;\n                  }\n                });\n                if (valueOut) {\n                  dom.setAttrib(elm, attrName, valueOut);\n                  return;\n                }\n              }\n            }\n            if (MCE_ATTR_RE.test(attrName)) {\n              elm.removeAttribute('data-mce-' + attrName);\n            }\n            if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\n              elm.removeAttribute(attrName);\n              dom.setStyle(elm, 'list-style-type', 'none');\n              return;\n            }\n            if (attrName === 'class') {\n              elm.removeAttribute('className');\n            }\n            elm.removeAttribute(attrName);\n          }\n        });\n        each$7(format.classes, value => {\n          value = replaceVars(value, vars);\n          if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {\n            dom.removeClass(elm, value);\n          }\n        });\n        const attrs = dom.getAttribs(elm);\n        for (let i = 0; i < attrs.length; i++) {\n          const attrName = attrs[i].nodeName;\n          if (!elementUtils.isAttributeInternal(attrName)) {\n            return removeResult.keep();\n          }\n        }\n      }\n      if (format.remove !== 'none') {\n        removeNode(ed, elm, format);\n        return removeResult.removed();\n      }\n      return removeResult.keep();\n    };\n    const findFormatRoot = (editor, container, name, vars, similar) => {\n      let formatRoot;\n      if (container.parentNode) {\n        each$e(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\n          if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {\n            const format = matchNode(editor, parent, name, vars, similar);\n            if (format && format.split !== false) {\n              formatRoot = parent;\n            }\n          }\n        });\n      }\n      return formatRoot;\n    };\n    const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\n      const fragment = editor.dom.createFragment();\n      fragment.appendChild(clone);\n      return editor.dom.rename(clone, newName);\n    }, constant(null));\n    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\n      var _a, _b;\n      let lastClone;\n      let firstClone;\n      const dom = editor.dom;\n      if (formatRoot) {\n        const formatRootParent = formatRoot.parentNode;\n        for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\n          let clone = dom.clone(parent, false);\n          for (let i = 0; i < formatList.length; i++) {\n            clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);\n            if (clone === null) {\n              break;\n            }\n          }\n          if (clone) {\n            if (lastClone) {\n              clone.appendChild(lastClone);\n            }\n            if (!firstClone) {\n              firstClone = clone;\n            }\n            lastClone = clone;\n          }\n        }\n        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\n          container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;\n        }\n        if (lastClone && firstClone) {\n          (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);\n          firstClone.appendChild(target);\n          if (isInlineFormat(format)) {\n            mergeSiblings(editor, format, vars, lastClone);\n          }\n        }\n      }\n      return container;\n    };\n    const removeFormatInternal = (ed, name, vars, node, similar) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const splitToFormatRoot = container => {\n        const formatRoot = findFormatRoot(ed, container, name, vars, similar);\n        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\n      };\n      const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\n      const removeFormatOnNode = node => exists(formatList, fmt => removeNodeFormat(ed, fmt, vars, node, node));\n      const process = node => {\n        const children = from(node.childNodes);\n        const removed = removeFormatOnNode(node);\n        const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\n        const parentNode = node.parentNode;\n        if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n          removeFormatOnNode(parentNode);\n        }\n        if (format.deep) {\n          if (children.length) {\n            for (let i = 0; i < children.length; i++) {\n              process(children[i]);\n            }\n          }\n        }\n        const textDecorations = [\n          'underline',\n          'line-through',\n          'overline'\n        ];\n        each$e(textDecorations, decoration => {\n          if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\n            removeNodeFormat(ed, {\n              deep: false,\n              exact: true,\n              inline: 'span',\n              styles: { textDecoration: decoration }\n            }, undefined, node);\n          }\n        });\n      };\n      const unwrap = start => {\n        const node = dom.get(start ? '_start' : '_end');\n        if (node) {\n          let out = node[start ? 'firstChild' : 'lastChild'];\n          if (isRemoveBookmarkNode(out)) {\n            out = out[start ? 'firstChild' : 'lastChild'];\n          }\n          if (isText$a(out) && out.data.length === 0) {\n            out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n          }\n          dom.remove(node, true);\n          return out;\n        } else {\n          return null;\n        }\n      };\n      const removeRngStyle = rng => {\n        let startContainer;\n        let endContainer;\n        let expandedRng = expandRng(dom, rng, formatList, rng.collapsed);\n        if (format.split) {\n          expandedRng = split(expandedRng);\n          startContainer = getContainer(ed, expandedRng, true);\n          endContainer = getContainer(ed, expandedRng);\n          if (startContainer !== endContainer) {\n            startContainer = normalizeTableSelection(startContainer, true);\n            endContainer = normalizeTableSelection(endContainer, false);\n            if (isChildOfInlineParent(dom, startContainer, endContainer)) {\n              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\n                'id': '_start',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(true);\n              return;\n            }\n            if (isChildOfInlineParent(dom, endContainer, startContainer)) {\n              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\n                'id': '_end',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(false);\n              return;\n            }\n            startContainer = wrap$1(dom, startContainer, 'span', {\n              'id': '_start',\n              'data-mce-type': 'bookmark'\n            });\n            endContainer = wrap$1(dom, endContainer, 'span', {\n              'id': '_end',\n              'data-mce-type': 'bookmark'\n            });\n            const newRng = dom.createRng();\n            newRng.setStartAfter(startContainer);\n            newRng.setEndBefore(endContainer);\n            walk$3(dom, newRng, nodes => {\n              each$e(nodes, n => {\n                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\n                  splitToFormatRoot(n);\n                }\n              });\n            });\n            splitToFormatRoot(startContainer);\n            splitToFormatRoot(endContainer);\n            startContainer = unwrap(true);\n            endContainer = unwrap();\n          } else {\n            startContainer = endContainer = splitToFormatRoot(startContainer);\n          }\n          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n          expandedRng.startOffset = dom.nodeIndex(startContainer);\n          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\n        }\n        walk$3(dom, expandedRng, nodes => {\n          each$e(nodes, process);\n        });\n      };\n      if (node) {\n        if (isNode(node)) {\n          const rng = dom.createRng();\n          rng.setStartBefore(node);\n          rng.setEndAfter(node);\n          removeRngStyle(rng);\n        } else {\n          removeRngStyle(node);\n        }\n        fireFormatRemove(ed, name, node, vars);\n        return;\n      }\n      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n        preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), startNode => isInlineFormat(format) && match$2(ed, name, vars, startNode));\n        ed.nodeChanged();\n      } else {\n        removeCaretFormat(ed, name, vars, similar);\n      }\n      removeListStyleFormats(ed, name, vars);\n      fireFormatRemove(ed, name, node, vars);\n    };\n    const removeFormat$1 = (ed, name, vars, node, similar) => {\n      if (node || ed.selection.isEditable()) {\n        removeFormatInternal(ed, name, vars, node, similar);\n      }\n    };\n    const removeNodeFormat = (editor, format, vars, node, compareNode) => {\n      return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, newName => {\n        editor.dom.rename(node, newName);\n        return true;\n      }, always);\n    };\n\n    const each$6 = Tools.each;\n    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\n      const processTextDecorationsAndColor = n => {\n        if (isHTMLElement(n) && isElement$6(n.parentNode) && dom.isEditable(n)) {\n          const parentTextDecoration = getTextDecoration(dom, n.parentNode);\n          if (dom.getStyle(n, 'color') && parentTextDecoration) {\n            dom.setStyle(n, 'text-decoration', parentTextDecoration);\n          } else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {\n            dom.setStyle(n, 'text-decoration', null);\n          }\n        }\n      };\n      if (format.styles && (format.styles.color || format.styles.textDecoration)) {\n        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\n        processTextDecorationsAndColor(node);\n      }\n    };\n    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\n      if (format.styles && format.styles.backgroundColor) {\n        const hasFontSize = hasStyle(dom, 'fontSize');\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\n      }\n    };\n    const mergeSubSup = (dom, format, vars, node) => {\n      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\n        const hasFontSize = hasStyle(dom, 'fontSize');\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'fontSize', ''));\n        const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), dom.isEditable);\n        dom.remove(inverseTagDescendants, true);\n      }\n    };\n    const mergeWithChildren = (editor, formatList, vars, node) => {\n      each$6(formatList, format => {\n        if (isInlineFormat(format)) {\n          each$6(editor.dom.select(format.inline, node), child => {\n            if (isElementNode(child)) {\n              removeNodeFormat(editor, format, vars, child, format.exact ? child : null);\n            }\n          });\n        }\n        clearChildStyles(editor.dom, format, node);\n      });\n    };\n    const mergeWithParents = (editor, format, name, vars, node) => {\n      const parentNode = node.parentNode;\n      if (matchNode(editor, parentNode, name, vars)) {\n        if (removeNodeFormat(editor, format, vars, node)) {\n          return;\n        }\n      }\n      if (format.merge_with_parents && parentNode) {\n        editor.dom.getParent(parentNode, parent => {\n          if (matchNode(editor, parent, name, vars)) {\n            removeNodeFormat(editor, format, vars, node);\n            return true;\n          } else {\n            return false;\n          }\n        });\n      }\n    };\n\n    const each$5 = Tools.each;\n    const canFormatBR = (editor, format, node, parentName) => {\n      if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {\n        const validBRParentElements = getTextRootBlockElements(editor.schema);\n        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\n        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;\n      } else {\n        return false;\n      }\n    };\n    const applyStyles = (dom, elm, format, vars) => {\n      each$5(format.styles, (value, name) => {\n        dom.setStyle(elm, name, replaceVars(value, vars));\n      });\n      if (format.styles) {\n        const styleVal = dom.getAttrib(elm, 'style');\n        if (styleVal) {\n          dom.setAttrib(elm, 'data-mce-style', styleVal);\n        }\n      }\n    };\n    const applyFormatAction = (ed, name, vars, node) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const isCollapsed = !node && ed.selection.isCollapsed();\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const setElementFormat = (elm, fmt = format) => {\n        if (isFunction(fmt.onformat)) {\n          fmt.onformat(elm, fmt, vars, node);\n        }\n        applyStyles(dom, elm, fmt, vars);\n        each$5(fmt.attributes, (value, name) => {\n          dom.setAttrib(elm, name, replaceVars(value, vars));\n        });\n        each$5(fmt.classes, value => {\n          const newValue = replaceVars(value, vars);\n          if (!dom.hasClass(elm, newValue)) {\n            dom.addClass(elm, newValue);\n          }\n        });\n      };\n      const applyNodeStyle = (formatList, node) => {\n        let found = false;\n        each$5(formatList, format => {\n          if (!isSelectorFormat(format)) {\n            return false;\n          }\n          if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {\n            return true;\n          }\n          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\n            return true;\n          }\n          if (dom.is(node, format.selector) && !isCaretNode(node)) {\n            setElementFormat(node, format);\n            found = true;\n            return false;\n          }\n          return true;\n        });\n        return found;\n      };\n      const createWrapElement = wrapName => {\n        if (isString(wrapName)) {\n          const wrapElm = dom.create(wrapName);\n          setElementFormat(wrapElm);\n          return wrapElm;\n        } else {\n          return null;\n        }\n      };\n      const applyRngStyle = (dom, rng, nodeSpecific) => {\n        const newWrappers = [];\n        let contentEditable = true;\n        const wrapName = format.inline || format.block;\n        const wrapElm = createWrapElement(wrapName);\n        const isMatchingWrappingBlock = node => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);\n        const canRenameBlock = (node, parentName, isEditableDescendant) => {\n          const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node) && isValid(ed, parentName, wrapName);\n          return isEditableDescendant && isValidBlockFormatForNode;\n        };\n        const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {\n          const nodeName = node.nodeName.toLowerCase();\n          const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);\n          const isZwsp = !nodeSpecific && isText$a(node) && isZwsp$1(node.data);\n          const isCaret = isCaretNode(node);\n          const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);\n          return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp && !isCaret && isCorrectFormatForNode;\n        };\n        walk$3(dom, rng, nodes => {\n          let currentWrapElm;\n          const process = node => {\n            let hasContentEditableState = false;\n            let lastContentEditable = contentEditable;\n            let isWrappableNoneditableElm = false;\n            const parentNode = node.parentNode;\n            const parentName = parentNode.nodeName.toLowerCase();\n            const contentEditableValue = dom.getContentEditable(node);\n            if (isNonNullable(contentEditableValue)) {\n              lastContentEditable = contentEditable;\n              contentEditable = contentEditableValue === 'true';\n              hasContentEditableState = true;\n              isWrappableNoneditableElm = isWrappableNoneditable(ed, node);\n            }\n            const isEditableDescendant = contentEditable && !hasContentEditableState;\n            if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {\n              currentWrapElm = null;\n              if (isBlockFormat(format)) {\n                dom.remove(node);\n              }\n              return;\n            }\n            if (isMatchingWrappingBlock(node)) {\n              currentWrapElm = null;\n              return;\n            }\n            if (canRenameBlock(node, parentName, isEditableDescendant)) {\n              const elm = dom.rename(node, wrapName);\n              setElementFormat(elm);\n              newWrappers.push(elm);\n              currentWrapElm = null;\n              return;\n            }\n            if (isSelectorFormat(format)) {\n              let found = applyNodeStyle(formatList, node);\n              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n                found = applyNodeStyle(formatList, parentNode);\n              }\n              if (!isInlineFormat(format) || found) {\n                currentWrapElm = null;\n                return;\n              }\n            }\n            if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {\n              if (!currentWrapElm) {\n                currentWrapElm = dom.clone(wrapElm, false);\n                parentNode.insertBefore(currentWrapElm, node);\n                newWrappers.push(currentWrapElm);\n              }\n              if (isWrappableNoneditableElm && hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm.appendChild(node);\n            } else {\n              currentWrapElm = null;\n              each$e(from(node.childNodes), process);\n              if (hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm = null;\n            }\n          };\n          each$e(nodes, process);\n        });\n        if (format.links === true) {\n          each$e(newWrappers, node => {\n            const process = node => {\n              if (node.nodeName === 'A') {\n                setElementFormat(node, format);\n              }\n              each$e(from(node.childNodes), process);\n            };\n            process(node);\n          });\n        }\n        each$e(newWrappers, node => {\n          const getChildCount = node => {\n            let count = 0;\n            each$e(node.childNodes, node => {\n              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\n                count++;\n              }\n            });\n            return count;\n          };\n          const mergeStyles = node => {\n            const childElement = find$2(node.childNodes, isElementNode$1).filter(child => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));\n            return childElement.map(child => {\n              const clone = dom.clone(child, false);\n              setElementFormat(clone);\n              dom.replace(clone, node, true);\n              dom.remove(child, true);\n              return clone;\n            }).getOr(node);\n          };\n          const childCount = getChildCount(node);\n          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\n            dom.remove(node, true);\n            return;\n          }\n          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\n            if (!format.exact && childCount === 1) {\n              node = mergeStyles(node);\n            }\n            mergeWithChildren(ed, formatList, vars, node);\n            mergeWithParents(ed, format, name, vars, node);\n            mergeBackgroundColorAndFontSize(dom, format, vars, node);\n            mergeTextDecorationsAndColor(dom, format, vars, node);\n            mergeSubSup(dom, format, vars, node);\n            mergeSiblings(ed, format, vars, node);\n          }\n        });\n      };\n      const targetNode = isNode(node) ? node : selection.getNode();\n      if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {\n        node = targetNode;\n        applyNodeStyle(formatList, node);\n        fireFormatApply(ed, name, node, vars);\n        return;\n      }\n      if (format) {\n        if (node) {\n          if (isNode(node)) {\n            if (!applyNodeStyle(formatList, node)) {\n              const rng = dom.createRng();\n              rng.setStartBefore(node);\n              rng.setEndAfter(node);\n              applyRngStyle(dom, expandRng(dom, rng, formatList), true);\n            }\n          } else {\n            applyRngStyle(dom, node, true);\n          }\n        } else {\n          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n            selection.setRng(normalize(selection.getRng()));\n            preserveSelection(ed, () => {\n              runOnRanges(ed, (selectionRng, fake) => {\n                const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);\n                applyRngStyle(dom, expandedRng, false);\n              });\n            }, always);\n            ed.nodeChanged();\n          } else {\n            applyCaretFormat(ed, name, vars);\n          }\n          getExpandedListItemFormat(ed.formatter, name).each(liFmt => {\n            each$e(getFullySelectedListItems(ed.selection), li => applyStyles(dom, li, liFmt, vars));\n          });\n        }\n        postProcess$1(name, ed);\n      }\n      fireFormatApply(ed, name, node, vars);\n    };\n    const applyFormat$1 = (editor, name, vars, node) => {\n      if (node || editor.selection.isEditable()) {\n        applyFormatAction(editor, name, vars, node);\n      }\n    };\n\n    const hasVars = value => has$2(value, 'vars');\n    const setup$u = (registeredFormatListeners, editor) => {\n      registeredFormatListeners.set({});\n      editor.on('NodeChange', e => {\n        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\n      });\n      editor.on('FormatApply FormatRemove', e => {\n        const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\n        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\n      });\n    };\n    const fallbackElement = editor => editor.selection.getStart();\n    const matchingNode = (editor, parents, format, similar, vars) => {\n      const isMatchingNode = node => {\n        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\n        return !isUndefined(matchingFormat);\n      };\n      const isUnableToMatch = node => {\n        if (matchesUnInheritedFormatSelector(editor, node, format)) {\n          return true;\n        } else {\n          if (!similar) {\n            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\n          } else {\n            return false;\n          }\n        }\n      };\n      return findUntil$1(parents, isMatchingNode, isUnableToMatch);\n    };\n    const getParents = (editor, elm) => {\n      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\n      return filter$5(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$2(node));\n    };\n    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\n      const parents = getParents(editor, elm);\n      each$d(registeredCallbacks, (data, format) => {\n        const runIfChanged = spec => {\n          const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\n          const isSet = match.isSome();\n          if (spec.state.get() !== isSet) {\n            spec.state.set(isSet);\n            const node = match.getOr(elm);\n            if (hasVars(spec)) {\n              spec.callback(isSet, {\n                node,\n                format,\n                parents\n              });\n            } else {\n              each$e(spec.callbacks, callback => callback(isSet, {\n                node,\n                format,\n                parents\n              }));\n            }\n          }\n        };\n        each$e([\n          data.withSimilar,\n          data.withoutSimilar\n        ], runIfChanged);\n        each$e(data.withVars, runIfChanged);\n      });\n    };\n    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$e(formats.split(','), format => {\n        const group = get$a(formatChangeItems, format).getOrThunk(() => {\n          const base = {\n            withSimilar: {\n              state: Cell(false),\n              similar: true,\n              callbacks: []\n            },\n            withoutSimilar: {\n              state: Cell(false),\n              similar: false,\n              callbacks: []\n            },\n            withVars: []\n          };\n          formatChangeItems[format] = base;\n          return base;\n        });\n        const getCurrent = () => {\n          const parents = getParents(editor);\n          return matchingNode(editor, parents, format, similar, vars).isSome();\n        };\n        if (isUndefined(vars)) {\n          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\n          toAppendTo.callbacks.push(callback);\n          if (toAppendTo.callbacks.length === 1) {\n            toAppendTo.state.set(getCurrent());\n          }\n        } else {\n          group.withVars.push({\n            state: Cell(getCurrent()),\n            similar,\n            vars,\n            callback\n          });\n        }\n      });\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const removeListeners = (registeredFormatListeners, formats, callback) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$e(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\n        formatChangeItems[format] = {\n          withSimilar: {\n            ...group.withSimilar,\n            callbacks: filter$5(group.withSimilar.callbacks, cb => cb !== callback)\n          },\n          withoutSimilar: {\n            ...group.withoutSimilar,\n            callbacks: filter$5(group.withoutSimilar.callbacks, cb => cb !== callback)\n          },\n          withVars: filter$5(group.withVars, item => item.callback !== callback)\n        };\n      }));\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\n      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };\n    };\n\n    const toggle = (editor, name, vars, node) => {\n      const fmt = editor.formatter.get(name);\n      if (fmt) {\n        if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\n          removeFormat$1(editor, name, vars, node);\n        } else {\n          applyFormat$1(editor, name, vars, node);\n        }\n      }\n    };\n\n    const explode$1 = Tools.explode;\n    const create$8 = () => {\n      const filters = {};\n      const addFilter = (name, callback) => {\n        each$e(explode$1(name), name => {\n          if (!has$2(filters, name)) {\n            filters[name] = {\n              name,\n              callbacks: []\n            };\n          }\n          filters[name].callbacks.push(callback);\n        });\n      };\n      const getFilters = () => values(filters);\n      const removeFilter = (name, callback) => {\n        each$e(explode$1(name), name => {\n          if (has$2(filters, name)) {\n            if (isNonNullable(callback)) {\n              const filter = filters[name];\n              const newCallbacks = filter$5(filter.callbacks, c => c !== callback);\n              if (newCallbacks.length > 0) {\n                filter.callbacks = newCallbacks;\n              } else {\n                delete filters[name];\n              }\n            } else {\n              delete filters[name];\n            }\n          }\n        });\n      };\n      return {\n        addFilter,\n        getFilters,\n        removeFilter\n      };\n    };\n\n    const removeAttrs = (node, names) => {\n      each$e(names, name => {\n        node.attr(name, null);\n      });\n    };\n    const addFontToSpansFilter = (domParser, styles, fontSizes) => {\n      domParser.addNodeFilter('font', nodes => {\n        each$e(nodes, node => {\n          const props = styles.parse(node.attr('style'));\n          const color = node.attr('color');\n          const face = node.attr('face');\n          const size = node.attr('size');\n          if (color) {\n            props.color = color;\n          }\n          if (face) {\n            props['font-family'] = face;\n          }\n          if (size) {\n            toInt(size).each(num => {\n              props['font-size'] = fontSizes[num - 1];\n            });\n          }\n          node.name = 'span';\n          node.attr('style', styles.serialize(props));\n          removeAttrs(node, [\n            'color',\n            'face',\n            'size'\n          ]);\n        });\n      });\n    };\n    const addStrikeFilter = (domParser, schema, styles) => {\n      domParser.addNodeFilter('strike', nodes => {\n        const convertToSTag = schema.type !== 'html4';\n        each$e(nodes, node => {\n          if (convertToSTag) {\n            node.name = 's';\n          } else {\n            const props = styles.parse(node.attr('style'));\n            props['text-decoration'] = 'line-through';\n            node.name = 'span';\n            node.attr('style', styles.serialize(props));\n          }\n        });\n      });\n    };\n    const addFilters = (domParser, settings, schema) => {\n      var _a;\n      const styles = Styles();\n      if (settings.convert_fonts_to_spans) {\n        addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));\n      }\n      addStrikeFilter(domParser, schema, styles);\n    };\n    const register$5 = (domParser, settings, schema) => {\n      if (settings.inline_styles) {\n        addFilters(domParser, settings, schema);\n      }\n    };\n\n    const addNodeFilter = (settings, htmlParser, schema) => {\n      htmlParser.addNodeFilter('br', (nodes, _, args) => {\n        const blockElements = Tools.extend({}, schema.getBlockElements());\n        const nonEmptyElements = schema.getNonEmptyElements();\n        const whitespaceElements = schema.getWhitespaceElements();\n        blockElements.body = 1;\n        const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node);\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          let node = nodes[i];\n          let parent = node.parent;\n          if (parent && isBlock(parent) && node === parent.lastChild) {\n            let prev = node.prev;\n            while (prev) {\n              const prevName = prev.name;\n              if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\n                if (prevName === 'br') {\n                  node = null;\n                }\n                break;\n              }\n              prev = prev.prev;\n            }\n            if (node) {\n              node.remove();\n              if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\n                const elementRule = schema.getElementRule(parent.name);\n                if (elementRule) {\n                  if (elementRule.removeEmpty) {\n                    parent.remove();\n                  } else if (elementRule.paddEmpty) {\n                    paddEmptyNode(settings, args, isBlock, parent);\n                  }\n                }\n              }\n            }\n          } else {\n            let lastParent = node;\n            while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\n              lastParent = parent;\n              if (blockElements[parent.name]) {\n                break;\n              }\n              parent = parent.parent;\n            }\n            if (lastParent === parent) {\n              const textNode = new AstNode('#text', 3);\n              textNode.value = nbsp;\n              node.replace(textNode);\n            }\n          }\n        }\n      });\n    };\n\n    const blobUriToBlob = url => fetch(url).then(res => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({\n      message: `Cannot convert ${ url } to Blob. Resource might not exist or is inaccessible.`,\n      uriType: 'blob'\n    }));\n    const extractBase64Data = data => {\n      const matches = /([a-z0-9+\\/=\\s]+)/i.exec(data);\n      return matches ? matches[1] : '';\n    };\n    const parseDataUri = uri => {\n      const [type, ...rest] = uri.split(',');\n      const data = rest.join(',');\n      const matches = /data:([^/]+\\/[^;]+)(;.+)?/.exec(type);\n      if (matches) {\n        const base64Encoded = matches[2] === ';base64';\n        const extractedData = base64Encoded ? extractBase64Data(data) : decodeURIComponent(data);\n        return Optional.some({\n          type: matches[1],\n          data: extractedData,\n          base64Encoded\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const buildBlob = (type, data, base64Encoded = true) => {\n      let str = data;\n      if (base64Encoded) {\n        try {\n          str = atob(data);\n        } catch (e) {\n          return Optional.none();\n        }\n      }\n      const arr = new Uint8Array(str.length);\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = str.charCodeAt(i);\n      }\n      return Optional.some(new Blob([arr], { type }));\n    };\n    const dataUriToBlob = uri => {\n      return new Promise((resolve, reject) => {\n        parseDataUri(uri).bind(({type, data, base64Encoded}) => buildBlob(type, data, base64Encoded)).fold(() => reject('Invalid data URI'), resolve);\n      });\n    };\n    const uriToBlob = url => {\n      if (startsWith(url, 'blob:')) {\n        return blobUriToBlob(url);\n      } else if (startsWith(url, 'data:')) {\n        return dataUriToBlob(url);\n      } else {\n        return Promise.reject('Unknown URI format');\n      }\n    };\n    const blobToDataUri = blob => {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n        reader.onerror = () => {\n          var _a;\n          reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);\n        };\n        reader.readAsDataURL(blob);\n      });\n    };\n\n    let count$1 = 0;\n    const uniqueId$1 = prefix => {\n      return (prefix || 'blobid') + count$1++;\n    };\n    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {\n      return parseDataUri(dataUri).bind(({data, type, base64Encoded}) => {\n        if (base64Only && !base64Encoded) {\n          return Optional.none();\n        } else {\n          const base64 = base64Encoded ? data : btoa(data);\n          return generateBlobInfo(base64, type);\n        }\n      });\n    };\n    const createBlobInfo$1 = (blobCache, blob, base64) => {\n      const blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {\n      return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map(blob => createBlobInfo$1(blobCache, blob, base64))));\n    };\n    const imageToBlobInfo = (blobCache, imageSrc) => {\n      const invalidDataUri = () => Promise.reject('Invalid data URI');\n      if (startsWith(imageSrc, 'blob:')) {\n        const blobInfo = blobCache.getByUri(imageSrc);\n        if (isNonNullable(blobInfo)) {\n          return Promise.resolve(blobInfo);\n        } else {\n          return uriToBlob(imageSrc).then(blob => {\n            return blobToDataUri(blob).then(dataUri => {\n              return processDataUri(dataUri, false, base64 => {\n                return Optional.some(createBlobInfo$1(blobCache, blob, base64));\n              }).getOrThunk(invalidDataUri);\n            });\n          });\n        }\n      } else if (startsWith(imageSrc, 'data:')) {\n        return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, blobInfo => Promise.resolve(blobInfo));\n      } else {\n        return Promise.reject('Unknown image data format');\n      }\n    };\n\n    const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\n    const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\n    const registerBase64ImageFilter = (parser, settings) => {\n      const {blob_cache: blobCache} = settings;\n      if (blobCache) {\n        const processImage = img => {\n          const inputSrc = img.attr('src');\n          if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {\n            return;\n          }\n          dataUriToBlobInfo(blobCache, inputSrc, true).each(blobInfo => {\n            img.attr('src', blobInfo.blobUri());\n          });\n        };\n        parser.addAttributeFilter('src', nodes => each$e(nodes, processImage));\n      }\n    };\n    const isMimeType = (mime, type) => startsWith(mime, `${ type }/`);\n    const createSafeEmbed = (mime, src, width, height, sandboxIframes) => {\n      let name;\n      if (isUndefined(mime)) {\n        name = 'iframe';\n      } else if (isMimeType(mime, 'image')) {\n        name = 'img';\n      } else if (isMimeType(mime, 'video')) {\n        name = 'video';\n      } else if (isMimeType(mime, 'audio')) {\n        name = 'audio';\n      } else {\n        name = 'iframe';\n      }\n      const embed = new AstNode(name, 1);\n      embed.attr(name === 'audio' ? { src } : {\n        src,\n        width,\n        height\n      });\n      if (name === 'audio' || name === 'video') {\n        embed.attr('controls', '');\n      }\n      if (name === 'iframe' && sandboxIframes) {\n        embed.attr('sandbox', '');\n      }\n      return embed;\n    };\n    const register$4 = (parser, settings) => {\n      const schema = parser.schema;\n      if (settings.remove_trailing_brs) {\n        addNodeFilter(settings, parser, schema);\n      }\n      parser.addAttributeFilter('href', nodes => {\n        let i = nodes.length;\n        const appendRel = rel => {\n          const parts = rel.split(' ').filter(p => p.length > 0);\n          return parts.concat(['noopener']).sort().join(' ');\n        };\n        const addNoOpener = rel => {\n          const newRel = rel ? Tools.trim(rel) : '';\n          if (!/\\b(noopener)\\b/g.test(newRel)) {\n            return appendRel(newRel);\n          } else {\n            return newRel;\n          }\n        };\n        if (!settings.allow_unsafe_link_target) {\n          while (i--) {\n            const node = nodes[i];\n            if (node.name === 'a' && node.attr('target') === '_blank') {\n              node.attr('rel', addNoOpener(node.attr('rel')));\n            }\n          }\n        }\n      });\n      if (!settings.allow_html_in_named_anchor) {\n        parser.addAttributeFilter('id,name', nodes => {\n          let i = nodes.length, sibling, prevSibling, parent, node;\n          while (i--) {\n            node = nodes[i];\n            if (node.name === 'a' && node.firstChild && !node.attr('href')) {\n              parent = node.parent;\n              sibling = node.lastChild;\n              while (sibling && parent) {\n                prevSibling = sibling.prev;\n                parent.insert(sibling, node);\n                sibling = prevSibling;\n              }\n            }\n          }\n        });\n      }\n      if (settings.fix_list_elements) {\n        parser.addNodeFilter('ul,ol', nodes => {\n          let i = nodes.length, node, parentNode;\n          while (i--) {\n            node = nodes[i];\n            parentNode = node.parent;\n            if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {\n              if (node.prev && node.prev.name === 'li') {\n                node.prev.append(node);\n              } else {\n                const li = new AstNode('li', 1);\n                li.attr('style', 'list-style-type: none');\n                node.wrap(li);\n              }\n            }\n          }\n        });\n      }\n      const validClasses = schema.getValidClasses();\n      if (settings.validate && validClasses) {\n        parser.addAttributeFilter('class', nodes => {\n          var _a;\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';\n            const classList = Tools.explode(clazz, ' ');\n            let classValue = '';\n            for (let ci = 0; ci < classList.length; ci++) {\n              const className = classList[ci];\n              let valid = false;\n              let validClassesMap = validClasses['*'];\n              if (validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              validClassesMap = validClasses[node.name];\n              if (!valid && validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              if (valid) {\n                if (classValue) {\n                  classValue += ' ';\n                }\n                classValue += className;\n              }\n            }\n            if (!classValue.length) {\n              classValue = null;\n            }\n            node.attr('class', classValue);\n          }\n        });\n      }\n      registerBase64ImageFilter(parser, settings);\n      if (settings.convert_unsafe_embeds) {\n        parser.addNodeFilter('object,embed', nodes => each$e(nodes, node => {\n          node.replace(createSafeEmbed(node.attr('type'), node.name === 'object' ? node.attr('data') : node.attr('src'), node.attr('width'), node.attr('height'), settings.sandbox_iframes));\n        }));\n      }\n      if (settings.sandbox_iframes) {\n        parser.addNodeFilter('iframe', nodes => each$e(nodes, node => node.attr('sandbox', '')));\n      }\n    };\n\n    /*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */\n\n    const {\n      entries,\n      setPrototypeOf,\n      isFrozen,\n      getPrototypeOf,\n      getOwnPropertyDescriptor\n    } = Object;\n    let {\n      freeze,\n      seal,\n      create: create$7\n    } = Object; // eslint-disable-line import/no-mutable-exports\n    let {\n      apply,\n      construct\n    } = typeof Reflect !== 'undefined' && Reflect;\n    if (!freeze) {\n      freeze = function freeze(x) {\n        return x;\n      };\n    }\n    if (!seal) {\n      seal = function seal(x) {\n        return x;\n      };\n    }\n    if (!apply) {\n      apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n      };\n    }\n    if (!construct) {\n      construct = function construct(Func, args) {\n        return new Func(...args);\n      };\n    }\n    const arrayForEach = unapply(Array.prototype.forEach);\n    const arrayPop = unapply(Array.prototype.pop);\n    const arrayPush = unapply(Array.prototype.push);\n    const stringToLowerCase = unapply(String.prototype.toLowerCase);\n    const stringToString = unapply(String.prototype.toString);\n    const stringMatch = unapply(String.prototype.match);\n    const stringReplace = unapply(String.prototype.replace);\n    const stringIndexOf = unapply(String.prototype.indexOf);\n    const stringTrim = unapply(String.prototype.trim);\n    const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\n    const regExpTest = unapply(RegExp.prototype.test);\n    const typeErrorCreate = unconstruct(TypeError);\n\n    /**\n     * Creates a new function that calls the given function with a specified thisArg and arguments.\n     *\n     * @param {Function} func - The function to be wrapped and called.\n     * @returns {Function} A new function that calls the given function with a specified thisArg and arguments.\n     */\n    function unapply(func) {\n      return function (thisArg) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n      };\n    }\n\n    /**\n     * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n     *\n     * @param {Function} func - The constructor function to be wrapped and called.\n     * @returns {Function} A new function that constructs an instance of the given constructor function with the provided arguments.\n     */\n    function unconstruct(func) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n      };\n    }\n\n    /**\n     * Add properties to a lookup table\n     *\n     * @param {Object} set - The set to which elements will be added.\n     * @param {Array} array - The array containing elements to be added to the set.\n     * @param {Function} transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n     * @returns {Object} The modified set with added elements.\n     */\n    function addToSet(set, array) {\n      let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n      if (setPrototypeOf) {\n        // Make 'in' and truthy checks like Boolean(set.constructor)\n        // independent of any properties defined on Object.prototype.\n        // Prevent prototype setters from intercepting set as a this value.\n        setPrototypeOf(set, null);\n      }\n      let l = array.length;\n      while (l--) {\n        let element = array[l];\n        if (typeof element === 'string') {\n          const lcElement = transformCaseFunc(element);\n          if (lcElement !== element) {\n            // Config presets (e.g. tags.js, attrs.js) are immutable.\n            if (!isFrozen(array)) {\n              array[l] = lcElement;\n            }\n            element = lcElement;\n          }\n        }\n        set[element] = true;\n      }\n      return set;\n    }\n\n    /**\n     * Clean up an array to harden against CSPP\n     *\n     * @param {Array} array - The array to be cleaned.\n     * @returns {Array} The cleaned version of the array\n     */\n    function cleanArray(array) {\n      for (let index = 0; index < array.length; index++) {\n        const isPropertyExist = objectHasOwnProperty(array, index);\n        if (!isPropertyExist) {\n          array[index] = null;\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Shallow clone an object\n     *\n     * @param {Object} object - The object to be cloned.\n     * @returns {Object} A new object that copies the original.\n     */\n    function clone(object) {\n      const newObject = create$7(null);\n      for (const [property, value] of entries(object)) {\n        const isPropertyExist = objectHasOwnProperty(object, property);\n        if (isPropertyExist) {\n          if (Array.isArray(value)) {\n            newObject[property] = cleanArray(value);\n          } else if (value && typeof value === 'object' && value.constructor === Object) {\n            newObject[property] = clone(value);\n          } else {\n            newObject[property] = value;\n          }\n        }\n      }\n      return newObject;\n    }\n\n    /**\n     * This method automatically checks if the prop is function or getter and behaves accordingly.\n     *\n     * @param {Object} object - The object to look up the getter function in its prototype chain.\n     * @param {String} prop - The property name for which to find the getter function.\n     * @returns {Function} The getter function found in the prototype chain or a fallback function.\n     */\n    function lookupGetter(object, prop) {\n      while (object !== null) {\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n          if (desc.get) {\n            return unapply(desc.get);\n          }\n          if (typeof desc.value === 'function') {\n            return unapply(desc.value);\n          }\n        }\n        object = getPrototypeOf(object);\n      }\n      function fallbackValue() {\n        return null;\n      }\n      return fallbackValue;\n    }\n\n    const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n    // SVG\n    const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n    const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n    // List of SVG elements that are disallowed by default.\n    // We still need to know them so that we can do namespace\n    // checks properly in case one wants to add them to\n    // allow-list.\n    const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n    const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);\n\n    // Similarly to SVG, we want to know all MathML elements,\n    // even those that we disallow by default.\n    const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n    const text = freeze(['#text']);\n\n    const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);\n    const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n    const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n    const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n    // eslint-disable-next-line unicorn/better-regex\n    const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n    const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n    const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n    const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n    const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n    );\n    const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n    const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n    );\n    const DOCTYPE_NAME = seal(/^html$/i);\n    const CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\n\n    var EXPRESSIONS = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      MUSTACHE_EXPR: MUSTACHE_EXPR,\n      ERB_EXPR: ERB_EXPR,\n      TMPLIT_EXPR: TMPLIT_EXPR,\n      DATA_ATTR: DATA_ATTR,\n      ARIA_ATTR: ARIA_ATTR,\n      IS_ALLOWED_URI: IS_ALLOWED_URI,\n      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE: ATTR_WHITESPACE,\n      DOCTYPE_NAME: DOCTYPE_NAME,\n      CUSTOM_ELEMENT: CUSTOM_ELEMENT\n    });\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n    const NODE_TYPE = {\n      element: 1,\n      attribute: 2,\n      text: 3,\n      cdataSection: 4,\n      entityReference: 5,\n      // Deprecated\n      entityNode: 6,\n      // Deprecated\n      progressingInstruction: 7,\n      comment: 8,\n      document: 9,\n      documentType: 10,\n      documentFragment: 11,\n      notation: 12 // Deprecated\n    };\n    const getGlobal = function getGlobal() {\n      return typeof window === 'undefined' ? null : window;\n    };\n\n    /**\n     * Creates a no-op policy for internal use only.\n     * Don't export this function outside this module!\n     * @param {TrustedTypePolicyFactory} trustedTypes The policy factory.\n     * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n     * @return {TrustedTypePolicy} The policy created (or null, if Trusted Types\n     * are not supported or creating the policy failed).\n     */\n    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n        return null;\n      }\n\n      // Allow the callers to control the unique policy name\n      // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n      // Policy creation with duplicate names throws in Trusted Types.\n      let suffix = null;\n      const ATTR_NAME = 'data-tt-policy-suffix';\n      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n      }\n      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n      try {\n        return trustedTypes.createPolicy(policyName, {\n          createHTML(html) {\n            return html;\n          },\n          createScriptURL(scriptUrl) {\n            return scriptUrl;\n          }\n        });\n      } catch (_) {\n        // Policy creation failed (most likely another DOMPurify script has\n        // already run). Skip creating the policy, as this will only cause errors\n        // if TT are enforced.\n        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n        return null;\n      }\n    };\n    function createDOMPurify() {\n      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n      const DOMPurify = root => createDOMPurify(root);\n\n      /**\n       * Version label, exposed for easier checks\n       * if DOMPurify is up to date or not\n       */\n      DOMPurify.version = '3.1.7';\n\n      /**\n       * Array of elements that DOMPurify removed during sanitation.\n       * Empty if nothing was removed.\n       */\n      DOMPurify.removed = [];\n      if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document) {\n        // Not running in a browser, provide a factory function\n        // so that you can pass your own Window\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n      }\n      let {\n        document\n      } = window;\n      const originalDocument = document;\n      const currentScript = originalDocument.currentScript;\n      const {\n        DocumentFragment,\n        HTMLTemplateElement,\n        Node,\n        Element,\n        NodeFilter,\n        NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n        HTMLFormElement,\n        DOMParser,\n        trustedTypes\n      } = window;\n      const ElementPrototype = Element.prototype;\n      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n      const remove = lookupGetter(ElementPrototype, 'remove');\n      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n      // As per issue #47, the web-components registry is inherited by a\n      // new document created via createHTMLDocument. As per the spec\n      // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n      // a new empty registry is used when creating a template contents owner\n      // document, so we use that as our parent document to ensure nothing\n      // is inherited.\n      if (typeof HTMLTemplateElement === 'function') {\n        const template = document.createElement('template');\n        if (template.content && template.content.ownerDocument) {\n          document = template.content.ownerDocument;\n        }\n      }\n      let trustedTypesPolicy;\n      let emptyHTML = '';\n      const {\n        implementation,\n        createNodeIterator,\n        createDocumentFragment,\n        getElementsByTagName\n      } = document;\n      const {\n        importNode\n      } = originalDocument;\n      let hooks = {};\n\n      /**\n       * Expose whether this browser supports running the full DOMPurify.\n       */\n      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n      const {\n        MUSTACHE_EXPR,\n        ERB_EXPR,\n        TMPLIT_EXPR,\n        DATA_ATTR,\n        ARIA_ATTR,\n        IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE,\n        CUSTOM_ELEMENT\n      } = EXPRESSIONS;\n      let {\n        IS_ALLOWED_URI: IS_ALLOWED_URI$1\n      } = EXPRESSIONS;\n\n      /**\n       * We consider the elements and attributes below to be safe. Ideally\n       * don't add any new ones but feel free to remove unwanted ones.\n       */\n\n      /* allowed element names */\n      let ALLOWED_TAGS = null;\n      const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);\n\n      /* Allowed attribute names */\n      let ALLOWED_ATTR = null;\n      const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);\n\n      /*\n       * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.\n       * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n       * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n       * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n       */\n      let CUSTOM_ELEMENT_HANDLING = Object.seal(create$7(null, {\n        tagNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        attributeNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        allowCustomizedBuiltInElements: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: false\n        }\n      }));\n\n      /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n      let FORBID_TAGS = null;\n\n      /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n      let FORBID_ATTR = null;\n\n      /* Decide if ARIA attributes are okay */\n      let ALLOW_ARIA_ATTR = true;\n\n      /* Decide if custom data attributes are okay */\n      let ALLOW_DATA_ATTR = true;\n\n      /* Decide if unknown protocols are okay */\n      let ALLOW_UNKNOWN_PROTOCOLS = false;\n\n      /* Decide if self-closing tags in attributes are allowed.\n       * Usually removed due to a mXSS issue in jQuery 3.0 */\n      let ALLOW_SELF_CLOSE_IN_ATTR = true;\n\n      /* Output should be safe for common template engines.\n       * This means, DOMPurify removes data attributes, mustaches and ERB\n       */\n      let SAFE_FOR_TEMPLATES = false;\n\n      /* Output should be safe even for XML used within HTML and alike.\n       * This means, DOMPurify removes comments when containing risky content.\n       */\n      let SAFE_FOR_XML = true;\n\n      /* Decide if document with <html>... should be returned */\n      let WHOLE_DOCUMENT = false;\n\n      /* Track whether config is already set on this instance of DOMPurify. */\n      let SET_CONFIG = false;\n\n      /* Decide if all elements (e.g. style, script) must be children of\n       * document.body. By default, browsers might move them to document.head */\n      let FORCE_BODY = false;\n\n      /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n       * string (or a TrustedHTML object if Trusted Types are supported).\n       * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n       */\n      let RETURN_DOM = false;\n\n      /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n       * string  (or a TrustedHTML object if Trusted Types are supported) */\n      let RETURN_DOM_FRAGMENT = false;\n\n      /* Try to return a Trusted Type object instead of a string, return a string in\n       * case Trusted Types are not supported  */\n      let RETURN_TRUSTED_TYPE = false;\n\n      /* Output should be free from DOM clobbering attacks?\n       * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n       */\n      let SANITIZE_DOM = true;\n\n      /* Achieve full DOM Clobbering protection by isolating the namespace of named\n       * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n       *\n       * HTML/DOM spec rules that enable DOM Clobbering:\n       *   - Named Access on Window (§7.3.3)\n       *   - DOM Tree Accessors (§3.1.5)\n       *   - Form Element Parent-Child Relations (§4.10.3)\n       *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n       *   - HTMLCollection (§4.2.10.2)\n       *\n       * Namespace isolation is implemented by prefixing `id` and `name` attributes\n       * with a constant string, i.e., `user-content-`\n       */\n      let SANITIZE_NAMED_PROPS = false;\n      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n\n      /* Keep element content when removing element? */\n      let KEEP_CONTENT = true;\n\n      /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n       * of importing it into a new Document and returning a sanitized copy */\n      let IN_PLACE = false;\n\n      /* Allow usage of profiles like html, svg and mathMl */\n      let USE_PROFILES = {};\n\n      /* Tags to ignore content of when KEEP_CONTENT is true */\n      let FORBID_CONTENTS = null;\n      const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n      /* Tags that are safe for data: URIs */\n      let DATA_URI_TAGS = null;\n      const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n      /* Attributes safe for values like \"javascript:\" */\n      let URI_SAFE_ATTRIBUTES = null;\n      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n      /* Document namespace */\n      let NAMESPACE = HTML_NAMESPACE;\n      let IS_EMPTY_INPUT = false;\n\n      /* Allowed XHTML+XML namespaces */\n      let ALLOWED_NAMESPACES = null;\n      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n\n      /* Parsing of strict XHTML documents */\n      let PARSER_MEDIA_TYPE = null;\n      const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n      let transformCaseFunc = null;\n\n      /* Keep a reference to config to pass to hooks */\n      let CONFIG = null;\n\n      /* Ideally, do not touch anything below this line */\n      /* ______________________________________________ */\n\n      const formElement = document.createElement('form');\n      const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n      };\n\n      /**\n       * _parseConfig\n       *\n       * @param  {Object} cfg optional config literal\n       */\n      // eslint-disable-next-line complexity\n      const _parseConfig = function _parseConfig() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (CONFIG && CONFIG === cfg) {\n          return;\n        }\n\n        /* Shield configuration object from tampering */\n        if (!cfg || typeof cfg !== 'object') {\n          cfg = {};\n        }\n\n        /* Shield configuration object from prototype pollution */\n        cfg = clone(cfg);\n        PARSER_MEDIA_TYPE =\n        // eslint-disable-next-line unicorn/prefer-includes\n        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n\n        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n\n        /* Set configuration parameters */\n        ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES),\n        // eslint-disable-line indent\n        cfg.ADD_URI_SAFE_ATTR,\n        // eslint-disable-line indent\n        transformCaseFunc // eslint-disable-line indent\n        ) // eslint-disable-line indent\n        : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS),\n        // eslint-disable-line indent\n        cfg.ADD_DATA_URI_TAGS,\n        // eslint-disable-line indent\n        transformCaseFunc // eslint-disable-line indent\n        ) // eslint-disable-line indent\n        : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n        FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n        USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n        RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n        FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n        IN_PLACE = cfg.IN_PLACE || false; // Default false\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n          RETURN_DOM = true;\n        }\n\n        /* Parse profile info */\n        if (USE_PROFILES) {\n          ALLOWED_TAGS = addToSet({}, text);\n          ALLOWED_ATTR = [];\n          if (USE_PROFILES.html === true) {\n            addToSet(ALLOWED_TAGS, html$1);\n            addToSet(ALLOWED_ATTR, html);\n          }\n          if (USE_PROFILES.svg === true) {\n            addToSet(ALLOWED_TAGS, svg$1);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.svgFilters === true) {\n            addToSet(ALLOWED_TAGS, svgFilters);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.mathMl === true) {\n            addToSet(ALLOWED_TAGS, mathMl$1);\n            addToSet(ALLOWED_ATTR, mathMl);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n        }\n\n        /* Merge configuration parameters */\n        if (cfg.ADD_TAGS) {\n          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n            ALLOWED_TAGS = clone(ALLOWED_TAGS);\n          }\n          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n        }\n        if (cfg.ADD_ATTR) {\n          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n            ALLOWED_ATTR = clone(ALLOWED_ATTR);\n          }\n          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n            FORBID_CONTENTS = clone(FORBID_CONTENTS);\n          }\n          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n\n        /* Add #text in case KEEP_CONTENT is set to true */\n        if (KEEP_CONTENT) {\n          ALLOWED_TAGS['#text'] = true;\n        }\n\n        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n        if (WHOLE_DOCUMENT) {\n          addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n        }\n\n        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n        if (ALLOWED_TAGS.table) {\n          addToSet(ALLOWED_TAGS, ['tbody']);\n          delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n          }\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n          }\n\n          // Overwrite existing TrustedTypes policy.\n          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n\n          // Sign local variables required by `sanitize`.\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        } else {\n          // Uninitialized policy, attempt to initialize the internal dompurify policy.\n          if (trustedTypesPolicy === undefined) {\n            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n          }\n\n          // If creating the internal policy succeeded sign internal variables.\n          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n            emptyHTML = trustedTypesPolicy.createHTML('');\n          }\n        }\n\n        // Prevent further manipulation of configuration.\n        // Not available in IE8, Safari 5, etc.\n        if (freeze) {\n          freeze(cfg);\n        }\n        CONFIG = cfg;\n      };\n      const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n      const HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);\n\n      // Certain elements are allowed in both SVG and HTML\n      // namespace. We need to specify them explicitly\n      // so that they don't get erroneously deleted from\n      // HTML namespace.\n      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n      /* Keep track of all possible SVG and MathML tags\n       * so that we can perform the namespace checks\n       * correctly. */\n      const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);\n      const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);\n\n      /**\n       * @param  {Element} element a DOM element whose namespace is being checked\n       * @returns {boolean} Return false if the element has a\n       *  namespace that a spec-compliant parser would never\n       *  return. Return true otherwise.\n       */\n      const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n\n        // In JSDOM, if we're inside shadow DOM, then parentNode\n        // can be null. We just simulate parent in this case.\n        if (!parent || !parent.tagName) {\n          parent = {\n            namespaceURI: NAMESPACE,\n            tagName: 'template'\n          };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n          // The only way to switch from HTML namespace to SVG\n          // is via <svg>. If it happens via any other tag, then\n          // it should be killed.\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'svg';\n          }\n\n          // The only way to switch from MathML to SVG is via`\n          // svg if parent is either <annotation-xml> or MathML\n          // text integration points.\n          if (parent.namespaceURI === MATHML_NAMESPACE) {\n            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n          }\n\n          // We only allow elements that are defined in SVG\n          // spec. All others are disallowed in SVG namespace.\n          return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n          // The only way to switch from HTML namespace to MathML\n          // is via <math>. If it happens via any other tag, then\n          // it should be killed.\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'math';\n          }\n\n          // The only way to switch from SVG to MathML is via\n          // <math> and HTML integration points\n          if (parent.namespaceURI === SVG_NAMESPACE) {\n            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n          }\n\n          // We only allow elements that are defined in MathML\n          // spec. All others are disallowed in MathML namespace.\n          return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n          // The only way to switch from SVG to HTML is via\n          // HTML integration points, and from MathML to HTML\n          // is via MathML text integration points\n          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n\n          // We disallow tags that are specific for MathML\n          // or SVG and should never appear in HTML namespace\n          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n\n        // For XHTML and XML documents that support custom namespaces\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return true;\n        }\n\n        // The code should never reach this place (this means\n        // that the element somehow got namespace that is not\n        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n        // Return false just in case.\n        return false;\n      };\n\n      /**\n       * _forceRemove\n       *\n       * @param  {Node} node a DOM node\n       */\n      const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, {\n          element: node\n        });\n        try {\n          // eslint-disable-next-line unicorn/prefer-dom-node-remove\n          getParentNode(node).removeChild(node);\n        } catch (_) {\n          remove(node);\n        }\n      };\n\n      /**\n       * _removeAttribute\n       *\n       * @param  {String} name an Attribute name\n       * @param  {Node} node a DOM node\n       */\n      const _removeAttribute = function _removeAttribute(name, node) {\n        try {\n          arrayPush(DOMPurify.removed, {\n            attribute: node.getAttributeNode(name),\n            from: node\n          });\n        } catch (_) {\n          arrayPush(DOMPurify.removed, {\n            attribute: null,\n            from: node\n          });\n        }\n        node.removeAttribute(name);\n\n        // We void attribute values for unremovable \"is\"\" attributes\n        if (name === 'is' && !ALLOWED_ATTR[name]) {\n          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n            try {\n              _forceRemove(node);\n            } catch (_) {}\n          } else {\n            try {\n              node.setAttribute(name, '');\n            } catch (_) {}\n          }\n        }\n      };\n\n      /**\n       * _initDocument\n       *\n       * @param  {String} dirty a string of dirty markup\n       * @return {Document} a DOM, filled with the dirty markup\n       */\n      const _initDocument = function _initDocument(dirty) {\n        /* Create a HTML document */\n        let doc = null;\n        let leadingWhitespace = null;\n        if (FORCE_BODY) {\n          dirty = '<remove></remove>' + dirty;\n        } else {\n          /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n          const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n          leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n          // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n          dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        /*\n         * Use the DOMParser API by default, fallback later if needs be\n         * DOMParser not work for svg when has multiple root element.\n         */\n        if (NAMESPACE === HTML_NAMESPACE) {\n          try {\n            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n          } catch (_) {}\n        }\n\n        /* Use createHTMLDocument in case DOMParser is not available */\n        if (!doc || !doc.documentElement) {\n          doc = implementation.createDocument(NAMESPACE, 'template', null);\n          try {\n            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n          } catch (_) {\n            // Syntax error if dirtyPayload is invalid xml\n          }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n\n        /* Work on whole document or just its body */\n        if (NAMESPACE === HTML_NAMESPACE) {\n          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n      };\n\n      /**\n       * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n       *\n       * @param  {Node} root The root element or node to start traversing on.\n       * @return {NodeIterator} The created NodeIterator\n       */\n      const _createNodeIterator = function _createNodeIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root,\n        // eslint-disable-next-line no-bitwise\n        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n      };\n\n      /**\n       * _isClobbered\n       *\n       * @param  {Node} elm element to check for clobbering attacks\n       * @return {Boolean} true if clobbered, false if safe\n       */\n      const _isClobbered = function _isClobbered(elm) {\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n      };\n\n      /**\n       * Checks whether the given object is a DOM node.\n       *\n       * @param  {Node} object object to check whether it's a DOM node\n       * @return {Boolean} true is object is a DOM node\n       */\n      const _isNode = function _isNode(object) {\n        return typeof Node === 'function' && object instanceof Node;\n      };\n\n      /**\n       * _executeHook\n       * Execute user configurable hooks\n       *\n       * @param  {String} entryPoint  Name of the hook's entry point\n       * @param  {Node} currentNode node to work on with the hook\n       * @param  {Object} data additional hook parameters\n       */\n      const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n        if (!hooks[entryPoint]) {\n          return;\n        }\n        arrayForEach(hooks[entryPoint], hook => {\n          hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n      };\n\n      /**\n       * _sanitizeElements\n       *\n       * @protect nodeName\n       * @protect textContent\n       * @protect removeChild\n       *\n       * @param   {Node} currentNode to check for permission to exist\n       * @return  {Boolean} true if node was killed, false if left alive\n       */\n      const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content = null;\n\n        /* Execute a hook if present */\n        _executeHook('beforeSanitizeElements', currentNode, null);\n\n        /* Check if element is clobbered or can clobber */\n        if (_isClobbered(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Now let's check the element's type and name */\n        const tagName = transformCaseFunc(currentNode.nodeName);\n\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeElement', currentNode, {\n          tagName,\n          allowedTags: ALLOWED_TAGS\n        });\n\n        /* Detect mXSS attempts abusing namespace confusion */\n        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Remove any occurrence of processing instructions */\n        if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Remove any kind of possibly harmful comments */\n        if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Remove element if anything forbids its presence */\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          /* Check if we have a custom element to handle */\n          if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n              return false;\n            }\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n              return false;\n            }\n          }\n\n          /* Keep content except for bad-listed elements */\n          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n            const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n            if (childNodes && parentNode) {\n              const childCount = childNodes.length;\n              for (let i = childCount - 1; i >= 0; --i) {\n                const childClone = cloneNode(childNodes[i], true);\n                childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n                parentNode.insertBefore(childClone, getNextSibling(currentNode));\n              }\n            }\n          }\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Check whether element has a valid namespace */\n        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Make sure that older browsers don't get fallback-tag mXSS */\n        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Sanitize element content to be template-safe */\n        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n          /* Get the element's text content */\n          content = currentNode.textContent;\n          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n            content = stringReplace(content, expr, ' ');\n          });\n          if (currentNode.textContent !== content) {\n            arrayPush(DOMPurify.removed, {\n              element: currentNode.cloneNode()\n            });\n            currentNode.textContent = content;\n          }\n        }\n\n        /* Execute a hook if present */\n        _executeHook('afterSanitizeElements', currentNode, null);\n        return false;\n      };\n\n      /**\n       * _isValidAttribute\n       *\n       * @param  {string} lcTag Lowercase tag name of containing element.\n       * @param  {string} lcName Lowercase attribute name.\n       * @param  {string} value Attribute value.\n       * @return {Boolean} Returns true if `value` is valid, otherwise false.\n       */\n      // eslint-disable-next-line complexity\n      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        /* Make sure attribute cannot clobber */\n        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n          return false;\n        }\n\n        /* Allow valid data-* attributes: At least one character after \"-\"\n            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n            We don't need to check the value; it's always URI safe. */\n        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n          if (\n          // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||\n          // Alternative, second condition checks if it's an `is`-attribute, AND\n          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n          lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {\n            return false;\n          }\n          /* Check value is safe. First, is attr inert? If so, is safe */\n        } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {\n          return false;\n        } else ;\n        return true;\n      };\n\n      /**\n       * _isBasicCustomElement\n       * checks if at least one dash is included in tagName, and it's not the first char\n       * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n       *\n       * @param {string} tagName name of the tag of the node to sanitize\n       * @returns {boolean} Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n       */\n      const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n        return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);\n      };\n\n      /**\n       * _sanitizeAttributes\n       *\n       * @protect attributes\n       * @protect nodeName\n       * @protect removeAttribute\n       * @protect setAttribute\n       *\n       * @param  {Node} currentNode to sanitize\n       */\n      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        /* Execute a hook if present */\n        _executeHook('beforeSanitizeAttributes', currentNode, null);\n        const {\n          attributes\n        } = currentNode;\n\n        /* Check if we have attributes; if not we might have a text node */\n        if (!attributes) {\n          return;\n        }\n        const hookEvent = {\n          attrName: '',\n          attrValue: '',\n          keepAttr: true,\n          allowedAttributes: ALLOWED_ATTR\n        };\n        let l = attributes.length;\n\n        /* Go backwards over all attributes; safely remove bad ones */\n        while (l--) {\n          const attr = attributes[l];\n          const {\n            name,\n            namespaceURI,\n            value: attrValue\n          } = attr;\n          const lcName = transformCaseFunc(name);\n          let value = name === 'value' ? attrValue : stringTrim(attrValue);\n          const initValue = value;\n\n          /* Execute a hook if present */\n          hookEvent.attrName = lcName;\n          hookEvent.attrValue = value;\n          hookEvent.keepAttr = true;\n          hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n          value = hookEvent.attrValue;\n\n          /* Did the hooks approve of the attribute? */\n          if (hookEvent.forceKeepAttr) {\n            continue;\n          }\n\n          /* Did the hooks approve of the attribute? */\n          if (!hookEvent.keepAttr) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n\n          /* Work around a security issue in jQuery 3.0 */\n          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n\n          /* Sanitize attribute content to be template-safe */\n          if (SAFE_FOR_TEMPLATES) {\n            arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n              value = stringReplace(value, expr, ' ');\n            });\n          }\n\n          /* Is `value` valid for this attribute? */\n          const lcTag = transformCaseFunc(currentNode.nodeName);\n          if (!_isValidAttribute(lcTag, lcName, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n\n          /* Full DOM Clobbering protection via namespace isolation,\n           * Prefix id and name attributes with `user-content-`\n           */\n          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n            // Remove the attribute with this value\n            _removeAttribute(name, currentNode);\n\n            // Prefix the value and later re-create the attribute with the sanitized value\n            value = SANITIZE_NAMED_PROPS_PREFIX + value;\n          }\n\n          /* Work around a security issue with comments inside attributes */\n          if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title)/i, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n\n          /* Handle attributes that require Trusted Types */\n          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n            if (namespaceURI) ; else {\n              switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n                case 'TrustedHTML':\n                  {\n                    value = trustedTypesPolicy.createHTML(value);\n                    break;\n                  }\n                case 'TrustedScriptURL':\n                  {\n                    value = trustedTypesPolicy.createScriptURL(value);\n                    break;\n                  }\n              }\n            }\n          }\n\n          /* Handle invalid data-* attribute set by try-catching it */\n          if (value !== initValue) {\n            try {\n              if (namespaceURI) {\n                currentNode.setAttributeNS(namespaceURI, name, value);\n              } else {\n                /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n                currentNode.setAttribute(name, value);\n              }\n              if (_isClobbered(currentNode)) {\n                _forceRemove(currentNode);\n              } else {\n                arrayPop(DOMPurify.removed);\n              }\n            } catch (_) {}\n          }\n        }\n\n        /* Execute a hook if present */\n        _executeHook('afterSanitizeAttributes', currentNode, null);\n      };\n\n      /**\n       * _sanitizeShadowDOM\n       *\n       * @param  {DocumentFragment} fragment to iterate over recursively\n       */\n      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode = null;\n        const shadowIterator = _createNodeIterator(fragment);\n\n        /* Execute a hook if present */\n        _executeHook('beforeSanitizeShadowDOM', fragment, null);\n        while (shadowNode = shadowIterator.nextNode()) {\n          /* Execute a hook if present */\n          _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n          /* Sanitize tags and elements */\n          if (_sanitizeElements(shadowNode)) {\n            continue;\n          }\n\n          /* Deep shadow DOM detected */\n          if (shadowNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(shadowNode.content);\n          }\n\n          /* Check attributes, sanitize if necessary */\n          _sanitizeAttributes(shadowNode);\n        }\n\n        /* Execute a hook if present */\n        _executeHook('afterSanitizeShadowDOM', fragment, null);\n      };\n\n      /**\n       * Sanitize\n       * Public method providing core sanitation functionality\n       *\n       * @param {String|Node} dirty string or DOM node\n       * @param {Object} cfg object\n       */\n      // eslint-disable-next-line complexity\n      DOMPurify.sanitize = function (dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body = null;\n        let importedNode = null;\n        let currentNode = null;\n        let returnNode = null;\n        /* Make sure we have a string to sanitize.\n          DO NOT return early, as this will return the wrong type if\n          the user has requested a DOM object rather than a string */\n        IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n          dirty = '<!-->';\n        }\n\n        /* Stringify, in case dirty is an object */\n        if (typeof dirty !== 'string' && !_isNode(dirty)) {\n          if (typeof dirty.toString === 'function') {\n            dirty = dirty.toString();\n            if (typeof dirty !== 'string') {\n              throw typeErrorCreate('dirty is not a string, aborting');\n            }\n          } else {\n            throw typeErrorCreate('toString is not a function');\n          }\n        }\n\n        /* Return dirty HTML if DOMPurify cannot run */\n        if (!DOMPurify.isSupported) {\n          return dirty;\n        }\n\n        /* Assign config vars */\n        if (!SET_CONFIG) {\n          _parseConfig(cfg);\n        }\n\n        /* Clean up removed elements */\n        DOMPurify.removed = [];\n\n        /* Check if dirty is correctly typed for IN_PLACE */\n        if (typeof dirty === 'string') {\n          IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n          /* Do some early pre-sanitization to avoid unsafe root nodes */\n          if (dirty.nodeName) {\n            const tagName = transformCaseFunc(dirty.nodeName);\n            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n            }\n          }\n        } else if (dirty instanceof Node) {\n          /* If dirty is a DOM element, append to an empty document to avoid\n             elements being stripped by the parser */\n          body = _initDocument('<!---->');\n          importedNode = body.ownerDocument.importNode(dirty, true);\n          if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {\n            /* Node is already a body, use as is */\n            body = importedNode;\n          } else if (importedNode.nodeName === 'HTML') {\n            body = importedNode;\n          } else {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            body.appendChild(importedNode);\n          }\n        } else {\n          /* Exit directly if we have nothing to do */\n          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n          // eslint-disable-next-line unicorn/prefer-includes\n          dirty.indexOf('<') === -1) {\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n          }\n\n          /* Initialize the document to work on */\n          body = _initDocument(dirty);\n\n          /* Check we have a DOM node from the data */\n          if (!body) {\n            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n          }\n        }\n\n        /* Remove first element node (ours) if FORCE_BODY is set */\n        if (body && FORCE_BODY) {\n          _forceRemove(body.firstChild);\n        }\n\n        /* Get node iterator */\n        const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n\n        /* Now start iterating over the created document */\n        while (currentNode = nodeIterator.nextNode()) {\n          /* Sanitize tags and elements */\n          if (_sanitizeElements(currentNode)) {\n            continue;\n          }\n\n          /* Shadow DOM detected, sanitize it */\n          if (currentNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(currentNode.content);\n          }\n\n          /* Check attributes, sanitize if necessary */\n          _sanitizeAttributes(currentNode);\n        }\n\n        /* If we sanitized `dirty` in-place, return it. */\n        if (IN_PLACE) {\n          return dirty;\n        }\n\n        /* Return sanitized string or DOM */\n        if (RETURN_DOM) {\n          if (RETURN_DOM_FRAGMENT) {\n            returnNode = createDocumentFragment.call(body.ownerDocument);\n            while (body.firstChild) {\n              // eslint-disable-next-line unicorn/prefer-dom-node-append\n              returnNode.appendChild(body.firstChild);\n            }\n          } else {\n            returnNode = body;\n          }\n          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n            /*\n              AdoptNode() is not used because internal state is not reset\n              (e.g. the past names map of a HTMLFormElement), this is safe\n              in theory but we would rather not risk another attack vector.\n              The state that is cloned by importNode() is explicitly defined\n              by the specs.\n            */\n            returnNode = importNode.call(originalDocument, returnNode, true);\n          }\n          return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n        /* Serialize doctype if allowed */\n        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n        }\n\n        /* Sanitize final string template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n            serializedHTML = stringReplace(serializedHTML, expr, ' ');\n          });\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n      };\n\n      /**\n       * Public method to set the configuration once\n       * setConfig\n       *\n       * @param {Object} cfg configuration object\n       */\n      DOMPurify.setConfig = function () {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n      };\n\n      /**\n       * Public method to remove the configuration\n       * clearConfig\n       *\n       */\n      DOMPurify.clearConfig = function () {\n        CONFIG = null;\n        SET_CONFIG = false;\n      };\n\n      /**\n       * Public method to check if an attribute value is valid.\n       * Uses last set config, if any. Otherwise, uses config defaults.\n       * isValidAttribute\n       *\n       * @param  {String} tag Tag name of containing element.\n       * @param  {String} attr Attribute name.\n       * @param  {String} value Attribute value.\n       * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n       */\n      DOMPurify.isValidAttribute = function (tag, attr, value) {\n        /* Initialize shared config vars if necessary. */\n        if (!CONFIG) {\n          _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n      };\n\n      /**\n       * AddHook\n       * Public method to add DOMPurify hooks\n       *\n       * @param {String} entryPoint entry point for the hook to add\n       * @param {Function} hookFunction function to execute\n       */\n      DOMPurify.addHook = function (entryPoint, hookFunction) {\n        if (typeof hookFunction !== 'function') {\n          return;\n        }\n        hooks[entryPoint] = hooks[entryPoint] || [];\n        arrayPush(hooks[entryPoint], hookFunction);\n      };\n\n      /**\n       * RemoveHook\n       * Public method to remove a DOMPurify hook at a given entryPoint\n       * (pops it from the stack of hooks if more are present)\n       *\n       * @param {String} entryPoint entry point for the hook to remove\n       * @return {Function} removed(popped) hook\n       */\n      DOMPurify.removeHook = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          return arrayPop(hooks[entryPoint]);\n        }\n      };\n\n      /**\n       * RemoveHooks\n       * Public method to remove all DOMPurify hooks at a given entryPoint\n       *\n       * @param  {String} entryPoint entry point for the hooks to remove\n       */\n      DOMPurify.removeHooks = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          hooks[entryPoint] = [];\n        }\n      };\n\n      /**\n       * RemoveAllHooks\n       * Public method to remove all DOMPurify hooks\n       */\n      DOMPurify.removeAllHooks = function () {\n        hooks = {};\n      };\n      return DOMPurify;\n    }\n    var purify = createDOMPurify();\n\n    const each$4 = Tools.each, trim = Tools.trim;\n    const queryParts = [\n      'source',\n      'protocol',\n      'authority',\n      'userInfo',\n      'user',\n      'password',\n      'host',\n      'port',\n      'relative',\n      'path',\n      'directory',\n      'file',\n      'query',\n      'anchor'\n    ];\n    const DEFAULT_PORTS = {\n      ftp: 21,\n      http: 80,\n      https: 443,\n      mailto: 25\n    };\n    const safeSvgDataUrlElements = [\n      'img',\n      'video'\n    ];\n    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\n      if (isNonNullable(allowSvgDataUrls)) {\n        return !allowSvgDataUrls;\n      } else {\n        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\n      }\n    };\n    const decodeUri = encodedUri => {\n      try {\n        return decodeURIComponent(encodedUri);\n      } catch (ex) {\n        return unescape(encodedUri);\n      }\n    };\n    const isInvalidUri = (settings, uri, tagName) => {\n      const decodedUri = decodeUri(uri).replace(/\\s/g, '');\n      if (settings.allow_script_urls) {\n        return false;\n      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\n        return true;\n      } else if (settings.allow_html_data_urls) {\n        return false;\n      } else if (/^data:image\\//i.test(decodedUri)) {\n        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\n      } else {\n        return /^data:/i.test(decodedUri);\n      }\n    };\n    class URI {\n      static parseDataUri(uri) {\n        let type;\n        const uriComponents = decodeURIComponent(uri).split(',');\n        const matches = /data:([^;]+)/.exec(uriComponents[0]);\n        if (matches) {\n          type = matches[1];\n        }\n        return {\n          type,\n          data: uriComponents[1]\n        };\n      }\n      static isDomSafe(uri, context, options = {}) {\n        if (options.allow_script_urls) {\n          return true;\n        } else {\n          const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\n          return !isInvalidUri(options, decodedUri, context);\n        }\n      }\n      static getDocumentBaseUrl(loc) {\n        var _a;\n        let baseUrl;\n        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\n          baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';\n        } else {\n          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\n        }\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\n          baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(baseUrl)) {\n            baseUrl += '/';\n          }\n        }\n        return baseUrl;\n      }\n      constructor(url, settings = {}) {\n        this.path = '';\n        this.directory = '';\n        url = trim(url);\n        this.settings = settings;\n        const baseUri = settings.base_uri;\n        const self = this;\n        if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n          self.source = url;\n          return;\n        }\n        const isProtocolRelative = url.indexOf('//') === 0;\n        if (url.indexOf('/') === 0 && !isProtocolRelative) {\n          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\n        }\n        if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n          const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;\n          if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {\n            url = '//mce_host' + self.toAbsPath(baseUrl, url);\n          } else {\n            const match = /([^#?]*)([#?]?.*)/.exec(url);\n            if (match) {\n              url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\n            }\n          }\n        }\n        url = url.replace(/@@/g, '(mce_at)');\n        const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n        if (urlMatch) {\n          each$4(queryParts, (v, i) => {\n            let part = urlMatch[i];\n            if (part) {\n              part = part.replace(/\\(mce_at\\)/g, '@@');\n            }\n            self[v] = part;\n          });\n        }\n        if (baseUri) {\n          if (!self.protocol) {\n            self.protocol = baseUri.protocol;\n          }\n          if (!self.userInfo) {\n            self.userInfo = baseUri.userInfo;\n          }\n          if (!self.port && self.host === 'mce_host') {\n            self.port = baseUri.port;\n          }\n          if (!self.host || self.host === 'mce_host') {\n            self.host = baseUri.host;\n          }\n          self.source = '';\n        }\n        if (isProtocolRelative) {\n          self.protocol = '';\n        }\n      }\n      setPath(path) {\n        const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\n        if (pathMatch) {\n          this.path = pathMatch[0];\n          this.directory = pathMatch[1];\n          this.file = pathMatch[2];\n        }\n        this.source = '';\n        this.getURI();\n      }\n      toRelative(uri) {\n        if (uri === './') {\n          return uri;\n        }\n        const relativeUri = new URI(uri, { base_uri: this });\n        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\n          return relativeUri.getURI();\n        }\n        const tu = this.getURI(), uu = relativeUri.getURI();\n        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\n          return tu;\n        }\n        let output = this.toRelPath(this.path, relativeUri.path);\n        if (relativeUri.query) {\n          output += '?' + relativeUri.query;\n        }\n        if (relativeUri.anchor) {\n          output += '#' + relativeUri.anchor;\n        }\n        return output;\n      }\n      toAbsolute(uri, noHost) {\n        const absoluteUri = new URI(uri, { base_uri: this });\n        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\n      }\n      isSameOrigin(uri) {\n        if (this.host == uri.host && this.protocol == uri.protocol) {\n          if (this.port == uri.port) {\n            return true;\n          }\n          const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;\n          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      toRelPath(base, path) {\n        let breakPoint = 0, out = '', i, l;\n        const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\n        const items = path.split('/');\n        if (normalizedBase.length >= items.length) {\n          for (i = 0, l = normalizedBase.length; i < l; i++) {\n            if (i >= items.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (normalizedBase.length < items.length) {\n          for (i = 0, l = items.length; i < l; i++) {\n            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (breakPoint === 1) {\n          return path;\n        }\n        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\n          out += '../';\n        }\n        for (i = breakPoint - 1, l = items.length; i < l; i++) {\n          if (i !== breakPoint - 1) {\n            out += '/' + items[i];\n          } else {\n            out += items[i];\n          }\n        }\n        return out;\n      }\n      toAbsPath(base, path) {\n        let nb = 0;\n        const tr = /\\/$/.test(path) ? '/' : '';\n        const normalizedBase = base.split('/');\n        const normalizedPath = path.split('/');\n        const baseParts = [];\n        each$4(normalizedBase, k => {\n          if (k) {\n            baseParts.push(k);\n          }\n        });\n        const pathParts = [];\n        for (let i = normalizedPath.length - 1; i >= 0; i--) {\n          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\n            continue;\n          }\n          if (normalizedPath[i] === '..') {\n            nb++;\n            continue;\n          }\n          if (nb > 0) {\n            nb--;\n            continue;\n          }\n          pathParts.push(normalizedPath[i]);\n        }\n        const i = baseParts.length - nb;\n        let outPath;\n        if (i <= 0) {\n          outPath = reverse(pathParts).join('/');\n        } else {\n          outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');\n        }\n        if (outPath.indexOf('/') !== 0) {\n          outPath = '/' + outPath;\n        }\n        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\n          outPath += tr;\n        }\n        return outPath;\n      }\n      getURI(noProtoHost = false) {\n        let s;\n        if (!this.source || noProtoHost) {\n          s = '';\n          if (!noProtoHost) {\n            if (this.protocol) {\n              s += this.protocol + '://';\n            } else {\n              s += '//';\n            }\n            if (this.userInfo) {\n              s += this.userInfo + '@';\n            }\n            if (this.host) {\n              s += this.host;\n            }\n            if (this.port) {\n              s += ':' + this.port;\n            }\n          }\n          if (this.path) {\n            s += this.path;\n          }\n          if (this.query) {\n            s += '?' + this.query;\n          }\n          if (this.anchor) {\n            s += '#' + this.anchor;\n          }\n          this.source = s;\n        }\n        return this.source;\n      }\n    }\n\n    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\n    const internalElementAttr = 'data-mce-type';\n    let uid = 0;\n    const processNode = (node, settings, schema, scope, evt) => {\n      var _a, _b, _c, _d;\n      const validate = settings.validate;\n      const specialElements = schema.getSpecialElements();\n      if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {\n        node.nodeValue = ' ' + node.nodeValue;\n      }\n      const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();\n      if (scope !== 'html' && schema.isValid(scope)) {\n        if (isNonNullable(evt)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n        return;\n      }\n      if (node.nodeType !== ELEMENT || lcTagName === 'body') {\n        return;\n      }\n      const element = SugarElement.fromDom(node);\n      const isInternalElement = has$1(element, internalElementAttr);\n      const bogus = get$9(element, 'data-mce-bogus');\n      if (!isInternalElement && isString(bogus)) {\n        if (bogus === 'all') {\n          remove$5(element);\n        } else {\n          unwrap(element);\n        }\n        return;\n      }\n      const rule = schema.getElementRule(lcTagName);\n      if (validate && !rule) {\n        if (has$2(specialElements, lcTagName)) {\n          remove$5(element);\n        } else {\n          unwrap(element);\n        }\n        return;\n      } else {\n        if (isNonNullable(evt)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n      }\n      if (validate && rule && !isInternalElement) {\n        each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], attr => {\n          set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n        });\n        each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], attr => {\n          if (!has$1(element, attr.name)) {\n            set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n          }\n        });\n        if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\n          unwrap(element);\n          return;\n        }\n        if (rule.removeEmptyAttrs && hasNone(element)) {\n          unwrap(element);\n          return;\n        }\n        if (rule.outputName && rule.outputName !== lcTagName) {\n          mutate(element, rule.outputName);\n        }\n      }\n    };\n    const processAttr = (ele, settings, schema, scope, evt) => {\n      const tagName = ele.tagName.toLowerCase();\n      const {attrName, attrValue} = evt;\n      evt.keepAttr = shouldKeepAttribute(settings, schema, scope, tagName, attrName, attrValue);\n      if (evt.keepAttr) {\n        evt.allowedAttributes[attrName] = true;\n        if (isBooleanAttribute(attrName, schema)) {\n          evt.attrValue = attrName;\n        }\n        if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\n          evt.forceKeepAttr = true;\n        }\n      } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {\n        evt.forceKeepAttr = true;\n      }\n    };\n    const shouldKeepAttribute = (settings, schema, scope, tagName, attrName, attrValue) => {\n      if (scope !== 'html' && !isNonHtmlElementRootName(tagName)) {\n        return true;\n      }\n      return !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));\n    };\n    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');\n    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();\n    const filterAttributes = (ele, settings, schema, scope) => {\n      const {attributes} = ele;\n      for (let i = attributes.length - 1; i >= 0; i--) {\n        const attr = attributes[i];\n        const attrName = attr.name;\n        const attrValue = attr.value;\n        if (!shouldKeepAttribute(settings, schema, scope, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {\n          ele.removeAttribute(attrName);\n        } else if (isBooleanAttribute(attrName, schema)) {\n          ele.setAttribute(attrName, attrName);\n        }\n      }\n    };\n    const setupPurify = (settings, schema, namespaceTracker) => {\n      const purify$1 = purify();\n      purify$1.addHook('uponSanitizeElement', (ele, evt) => {\n        processNode(ele, settings, schema, namespaceTracker.track(ele), evt);\n      });\n      purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\n        processAttr(ele, settings, schema, namespaceTracker.current(), evt);\n      });\n      return purify$1;\n    };\n    const getPurifyConfig = (settings, mimeType) => {\n      const basePurifyConfig = {\n        IN_PLACE: true,\n        ALLOW_UNKNOWN_PROTOCOLS: true,\n        ALLOWED_TAGS: [\n          '#comment',\n          '#cdata-section',\n          'body'\n        ],\n        ALLOWED_ATTR: [],\n        SAFE_FOR_XML: false\n      };\n      const config = { ...basePurifyConfig };\n      config.PARSER_MEDIA_TYPE = mimeType;\n      if (settings.allow_script_urls) {\n        config.ALLOWED_URI_REGEXP = /.*/;\n      } else if (settings.allow_html_data_urls) {\n        config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\n      }\n      return config;\n    };\n    const sanitizeNamespaceElement = ele => {\n      const xlinkAttrs = [\n        'type',\n        'href',\n        'role',\n        'arcrole',\n        'title',\n        'show',\n        'actuate',\n        'label',\n        'from',\n        'to'\n      ].map(name => `xlink:${ name }`);\n      const config = {\n        IN_PLACE: true,\n        USE_PROFILES: {\n          html: true,\n          svg: true,\n          svgFilters: true\n        },\n        ALLOWED_ATTR: xlinkAttrs\n      };\n      purify().sanitize(ele, config);\n      return ele.innerHTML;\n    };\n    const getSanitizer = (settings, schema) => {\n      const namespaceTracker = createNamespaceTracker();\n      if (settings.sanitize) {\n        const purify = setupPurify(settings, schema, namespaceTracker);\n        const sanitizeHtmlElement = (body, mimeType) => {\n          purify.sanitize(body, getPurifyConfig(settings, mimeType));\n          purify.removed = [];\n          namespaceTracker.reset();\n        };\n        return {\n          sanitizeHtmlElement,\n          sanitizeNamespaceElement\n        };\n      } else {\n        const sanitizeHtmlElement = (body, _mimeType) => {\n          const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);\n          let node;\n          while (node = nodeIterator.nextNode()) {\n            const currentScope = namespaceTracker.track(node);\n            processNode(node, settings, schema, currentScope);\n            if (isElement$6(node)) {\n              filterAttributes(node, settings, schema, currentScope);\n            }\n          }\n          namespaceTracker.reset();\n        };\n        const sanitizeNamespaceElement = noop;\n        return {\n          sanitizeHtmlElement,\n          sanitizeNamespaceElement\n        };\n      }\n    };\n\n    const makeMap = Tools.makeMap, extend$1 = Tools.extend;\n    const transferChildren = (parent, nativeParent, specialElements, nsSanitizer) => {\n      const parentName = parent.name;\n      const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea' && parentName !== 'noscript';\n      const childNodes = nativeParent.childNodes;\n      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\n        const nativeChild = childNodes[ni];\n        const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\n        if (isElement$6(nativeChild)) {\n          const attributes = nativeChild.attributes;\n          for (let ai = 0, al = attributes.length; ai < al; ai++) {\n            const attr = attributes[ai];\n            child.attr(attr.name, attr.value);\n          }\n          if (isNonHtmlElementRootName(child.name)) {\n            nsSanitizer(nativeChild);\n            child.value = nativeChild.innerHTML;\n          }\n        } else if (isText$a(nativeChild)) {\n          child.value = nativeChild.data;\n          if (isSpecial) {\n            child.raw = true;\n          }\n        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\n          child.value = nativeChild.data;\n        }\n        if (!isNonHtmlElementRootName(child.name)) {\n          transferChildren(child, nativeChild, specialElements, nsSanitizer);\n        }\n        parent.append(child);\n      }\n    };\n    const walkTree = (root, preprocessors, postprocessors) => {\n      const traverseOrder = [];\n      for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {\n        const tempNode = node;\n        each$e(preprocessors, preprocess => preprocess(tempNode));\n        if (isNullable(tempNode.parent) && tempNode !== root) {\n          node = lastNode;\n        } else {\n          traverseOrder.push(tempNode);\n        }\n      }\n      for (let i = traverseOrder.length - 1; i >= 0; i--) {\n        const node = traverseOrder[i];\n        each$e(postprocessors, postprocess => postprocess(node));\n      }\n    };\n    const whitespaceCleaner = (root, schema, settings, args) => {\n      const validate = settings.validate;\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n      const textRootBlockElements = getTextRootBlockElements(schema);\n      const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n      const hasWhitespaceParent = node => {\n        let tempNode = node.parent;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in whitespaceElements) {\n            return true;\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isTextRootBlockEmpty = node => {\n        let tempNode = node;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in textRootBlockElements) {\n            return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node) || isNonHtmlElementRootName(node.name) && node.parent === root;\n      const isAtEdgeOfBlock = (node, start) => {\n        const neighbour = start ? node.prev : node.next;\n        if (isNonNullable(neighbour) || isNullable(node.parent)) {\n          return false;\n        }\n        return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);\n      };\n      const preprocess = node => {\n        var _a;\n        if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n            text = text.replace(allWhiteSpaceRegExp, ' ');\n            if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {\n              text = text.replace(startWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      const postprocess = node => {\n        var _a;\n        if (node.type === 1) {\n          const elementRule = schema.getElementRule(node.name);\n          if (validate && elementRule) {\n            const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\n            if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {\n              paddEmptyNode(settings, args, isBlock, node);\n            } else if (elementRule.removeEmpty && isNodeEmpty) {\n              if (isBlock(node)) {\n                node.remove();\n              } else {\n                node.unwrap();\n              }\n            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\n              paddEmptyNode(settings, args, isBlock, node);\n            }\n          }\n        } else if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n            if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {\n              text = text.replace(endWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      return [\n        preprocess,\n        postprocess\n      ];\n    };\n    const getRootBlockName = (settings, args) => {\n      var _a;\n      const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\n      if (name === false) {\n        return '';\n      } else if (name === true) {\n        return 'p';\n      } else {\n        return name;\n      }\n    };\n    const DomParser = (settings = {}, schema = Schema()) => {\n      const nodeFilterRegistry = create$8();\n      const attributeFilterRegistry = create$8();\n      const defaultedSettings = {\n        validate: true,\n        root_name: 'body',\n        sanitize: true,\n        ...settings\n      };\n      const parser = new DOMParser();\n      const sanitizer = getSanitizer(defaultedSettings, schema);\n      const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {\n        const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\n        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\n        const content = isSpecialRoot ? `<${ rootName }>${ html }</${ rootName }>` : html;\n        const wrappedHtml = format === 'xhtml' ? `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${ content }</body></html>` : `<body>${ content }</body>`;\n        const body = parser.parseFromString(wrappedHtml, mimeType).body;\n        sanitizer.sanitizeHtmlElement(body, mimeType);\n        return isSpecialRoot ? body.firstChild : body;\n      };\n      const addNodeFilter = nodeFilterRegistry.addFilter;\n      const getNodeFilters = nodeFilterRegistry.getFilters;\n      const removeNodeFilter = nodeFilterRegistry.removeFilter;\n      const addAttributeFilter = attributeFilterRegistry.addFilter;\n      const getAttributeFilters = attributeFilterRegistry.getFilters;\n      const removeAttributeFilter = attributeFilterRegistry.removeFilter;\n      const findInvalidChildren = (node, invalidChildren) => {\n        if (isInvalid(schema, node)) {\n          invalidChildren.push(node);\n        }\n      };\n      const isWrappableNode = (blockElements, node) => {\n        const isInternalElement = isString(node.attr(internalElementAttr));\n        const isInlineElement = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node)) && !isNonHtmlElementRootName(node.name);\n        return node.type === 3 || isInlineElement && !isInternalElement;\n      };\n      const addRootBlocks = (rootNode, rootBlockName) => {\n        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n        const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n        const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n        let node = rootNode.firstChild, rootBlockNode = null;\n        const trim = rootBlock => {\n          var _a, _b;\n          if (rootBlock) {\n            node = rootBlock.firstChild;\n            if (node && node.type === 3) {\n              node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');\n            }\n            node = rootBlock.lastChild;\n            if (node && node.type === 3) {\n              node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');\n            }\n          }\n        };\n        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n          return;\n        }\n        while (node) {\n          const next = node.next;\n          if (isWrappableNode(blockElements, node)) {\n            if (!rootBlockNode) {\n              rootBlockNode = new AstNode(rootBlockName, 1);\n              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\n              rootNode.insert(rootBlockNode, node);\n              rootBlockNode.append(node);\n            } else {\n              rootBlockNode.append(node);\n            }\n          } else {\n            trim(rootBlockNode);\n            rootBlockNode = null;\n          }\n          node = next;\n        }\n        trim(rootBlockNode);\n      };\n      const parse = (html, args = {}) => {\n        var _a;\n        const validate = defaultedSettings.validate;\n        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\n        const element = parseAndSanitizeWithContext(html, rootName, args.format);\n        updateChildren(schema, element);\n        const rootNode = new AstNode(rootName, 11);\n        transferChildren(rootNode, element, schema.getSpecialElements(), sanitizer.sanitizeNamespaceElement);\n        element.innerHTML = '';\n        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\n        const invalidChildren = [];\n        const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\n        const matches = {\n          nodes: {},\n          attributes: {}\n        };\n        const matchFinder = node => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);\n        walkTree(rootNode, [\n          whitespacePre,\n          matchFinder\n        ], [\n          whitespacePost,\n          invalidFinder\n        ]);\n        invalidChildren.reverse();\n        if (validate && invalidChildren.length > 0) {\n          if (args.context) {\n            const {\n              pass: topLevelChildren,\n              fail: otherChildren\n            } = partition$2(invalidChildren, child => child.parent === rootNode);\n            cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);\n            args.invalid = topLevelChildren.length > 0;\n          } else {\n            cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);\n          }\n        }\n        const rootBlockName = getRootBlockName(defaultedSettings, args);\n        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\n          addRootBlocks(rootNode, rootBlockName);\n        }\n        if (!args.invalid) {\n          runFilters(matches, args);\n        }\n        return rootNode;\n      };\n      const exports = {\n        schema,\n        addAttributeFilter,\n        getAttributeFilters,\n        removeAttributeFilter,\n        addNodeFilter,\n        getNodeFilters,\n        removeNodeFilter,\n        parse\n      };\n      register$4(exports, defaultedSettings);\n      register$5(exports, defaultedSettings, schema);\n      return exports;\n    };\n\n    const serializeContent = content => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;\n    const withSerializedContent = (content, fireEvent, parserSettings) => {\n      const serializedContent = serializeContent(content);\n      const eventArgs = fireEvent(serializedContent);\n      if (eventArgs.isDefaultPrevented()) {\n        return eventArgs;\n      } else if (isTreeNode(content)) {\n        if (eventArgs.content !== serializedContent) {\n          const rootNode = DomParser({\n            validate: false,\n            forced_root_block: false,\n            ...parserSettings\n          }).parse(eventArgs.content, { context: content.name });\n          return {\n            ...eventArgs,\n            content: rootNode\n          };\n        } else {\n          return {\n            ...eventArgs,\n            content\n          };\n        }\n      } else {\n        return eventArgs;\n      }\n    };\n    const preProcessGetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const eventArgs = fireBeforeGetContent(editor, args);\n        if (eventArgs.isDefaultPrevented()) {\n          return Result.error(fireGetContent(editor, {\n            content: '',\n            ...eventArgs\n          }).content);\n        } else {\n          return Result.value(eventArgs);\n        }\n      }\n    };\n    const postProcessGetContent = (editor, content, args) => {\n      if (args.no_events) {\n        return content;\n      } else {\n        const processedEventArgs = withSerializedContent(content, content => fireGetContent(editor, {\n          ...args,\n          content\n        }), {\n          sanitize: shouldSanitizeXss(editor),\n          sandbox_iframes: shouldSandboxIframes(editor)\n        });\n        return processedEventArgs.content;\n      }\n    };\n    const preProcessSetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {\n          ...args,\n          content\n        }), {\n          sanitize: shouldSanitizeXss(editor),\n          sandbox_iframes: shouldSandboxIframes(editor)\n        });\n        if (processedEventArgs.isDefaultPrevented()) {\n          fireSetContent(editor, processedEventArgs);\n          return Result.error(undefined);\n        } else {\n          return Result.value(processedEventArgs);\n        }\n      }\n    };\n    const postProcessSetContent = (editor, content, args) => {\n      if (!args.no_events) {\n        fireSetContent(editor, {\n          ...args,\n          content\n        });\n      }\n    };\n\n    const tableModel = (element, width, rows) => ({\n      element,\n      width,\n      rows\n    });\n    const tableRow = (element, cells) => ({\n      element,\n      cells\n    });\n    const cellPosition = (x, y) => ({\n      x,\n      y\n    });\n    const getSpan = (td, key) => {\n      return getOpt(td, key).bind(toInt).getOr(1);\n    };\n    const fillout = (table, x, y, tr, td) => {\n      const rowspan = getSpan(td, 'rowspan');\n      const colspan = getSpan(td, 'colspan');\n      const rows = table.rows;\n      for (let y2 = y; y2 < y + rowspan; y2++) {\n        if (!rows[y2]) {\n          rows[y2] = tableRow(deep$1(tr), []);\n        }\n        for (let x2 = x; x2 < x + colspan; x2++) {\n          const cells = rows[y2].cells;\n          cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\n        }\n      }\n    };\n    const cellExists = (table, x, y) => {\n      const rows = table.rows;\n      const cells = rows[y] ? rows[y].cells : [];\n      return !!cells[x];\n    };\n    const skipCellsX = (table, x, y) => {\n      while (cellExists(table, x, y)) {\n        x++;\n      }\n      return x;\n    };\n    const getWidth = rows => {\n      return foldl(rows, (acc, row) => {\n        return row.cells.length > acc ? row.cells.length : acc;\n      }, 0);\n    };\n    const findElementPos = (table, element) => {\n      const rows = table.rows;\n      for (let y = 0; y < rows.length; y++) {\n        const cells = rows[y].cells;\n        for (let x = 0; x < cells.length; x++) {\n          if (eq(cells[x], element)) {\n            return Optional.some(cellPosition(x, y));\n          }\n        }\n      }\n      return Optional.none();\n    };\n    const extractRows = (table, sx, sy, ex, ey) => {\n      const newRows = [];\n      const rows = table.rows;\n      for (let y = sy; y <= ey; y++) {\n        const cells = rows[y].cells;\n        const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\n        newRows.push(tableRow(rows[y].element, slice));\n      }\n      return newRows;\n    };\n    const subTable = (table, startPos, endPos) => {\n      const sx = startPos.x, sy = startPos.y;\n      const ex = endPos.x, ey = endPos.y;\n      const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\n      return tableModel(table.element, getWidth(newRows), newRows);\n    };\n    const createDomTable = (table, rows) => {\n      const tableElement = shallow$1(table.element);\n      const tableBody = SugarElement.fromTag('tbody');\n      append(tableBody, rows);\n      append$1(tableElement, tableBody);\n      return tableElement;\n    };\n    const modelRowsToDomRows = table => {\n      return map$3(table.rows, row => {\n        const cells = map$3(row.cells, cell => {\n          const td = deep$1(cell);\n          remove$a(td, 'colspan');\n          remove$a(td, 'rowspan');\n          return td;\n        });\n        const tr = shallow$1(row.element);\n        append(tr, cells);\n        return tr;\n      });\n    };\n    const fromDom = tableElm => {\n      const table = tableModel(shallow$1(tableElm), 0, []);\n      each$e(descendants(tableElm, 'tr'), (tr, y) => {\n        each$e(descendants(tr, 'td,th'), (td, x) => {\n          fillout(table, skipCellsX(table, x, y), y, tr, td);\n        });\n      });\n      return tableModel(table.element, getWidth(table.rows), table.rows);\n    };\n    const toDom = table => {\n      return createDomTable(table, modelRowsToDomRows(table));\n    };\n    const subsection = (table, startElement, endElement) => {\n      return findElementPos(table, startElement).bind(startPos => {\n        return findElementPos(table, endElement).map(endPos => {\n          return subTable(table, startPos, endPos);\n        });\n      });\n    };\n\n    const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\n    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\n      const listElm = SugarElement.fromTag(name(listCont));\n      const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\n      setAll(listElm, listStyles);\n      return [\n        SugarElement.fromTag('li'),\n        listElm\n      ];\n    }).getOr([]));\n    const wrap = (innerElm, elms) => {\n      const wrapped = foldl(elms, (acc, elm) => {\n        append$1(elm, acc);\n        return elm;\n      }, innerElm);\n      return elms.length > 0 ? fromElements([wrapped]) : wrapped;\n    };\n    const directListWrappers = commonAnchorContainer => {\n      if (isListItem$1(commonAnchorContainer)) {\n        return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [\n          commonAnchorContainer,\n          listElm\n        ]);\n      } else {\n        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\n      }\n    };\n    const getWrapElements = (rootNode, rng, schema) => {\n      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\n      const parents = parentsAndSelf(commonAnchorContainer, rootNode);\n      const wrapElements = filter$5(parents, el => schema.isWrapper(name(el)));\n      const listWrappers = getFullySelectedListWrappers(parents, rng);\n      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\n      return map$3(allWrappers, shallow$1);\n    };\n    const emptyFragment = () => fromElements([]);\n    const getFragmentFromRange = (rootNode, rng, schema) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng, schema));\n    const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));\n    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\n      const firstCell = selectedTableCells[0];\n      const lastCell = selectedTableCells[selectedTableCells.length - 1];\n      const fullTableModel = fromDom(tableElm);\n      return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\n    }).getOrThunk(emptyFragment);\n    const getSelectionFragment = (rootNode, ranges, schema) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0], schema);\n    const read$3 = (rootNode, ranges, schema) => {\n      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\n      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges, schema);\n    };\n\n    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\n    const getInnerText = bin => {\n      return trim$2(bin.innerText);\n    };\n    const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\n    const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\n      var _a;\n      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\n      const body = editor.getBody();\n      const contextNodeName = getContextNodeName(parentBlockOpt);\n      const rangeContentClone = SugarElement.fromDom(rng.cloneContents());\n      cleanupBogusElements(rangeContentClone);\n      cleanupInputNames(rangeContentClone);\n      const bin = editor.dom.add(body, contextNodeName, {\n        'data-mce-bogus': 'all',\n        'style': 'overflow: hidden; opacity: 0;'\n      }, rangeContentClone.dom);\n      const text = getInnerText(bin);\n      const nonRenderedText = trim$2((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');\n      editor.dom.remove(bin);\n      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\n        const parentBlock = parentBlockOpt.getOr(body);\n        const parentBlockText = getInnerText(parentBlock);\n        const textIndex = parentBlockText.indexOf(text);\n        if (textIndex === -1) {\n          return text;\n        } else {\n          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\n          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\n          return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\n        }\n      } else {\n        return text;\n      }\n    }).getOr('');\n    const getSerializedContent = (editor, args) => {\n      const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');\n      const sel = editor.selection.getSel();\n      const ranges = processRanges(editor, getRanges$1(sel));\n      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema).dom : rng.cloneContents();\n      if (fragment) {\n        tmpElm.appendChild(fragment);\n      }\n      return editor.selection.serializer.serialize(tmpElm, args);\n    };\n    const extractSelectedContent = (editor, args) => {\n      if (args.format === 'text') {\n        return getTextContent(editor);\n      } else {\n        const content = getSerializedContent(editor, args);\n        if (args.format === 'tree') {\n          return content;\n        } else {\n          return editor.selection.isCollapsed() ? '' : content;\n        }\n      }\n    };\n    const setupArgs$3 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      selection: true,\n      getInner: true\n    });\n    const getSelectedContentInternal = (editor, format, args = {}) => {\n      const defaultedArgs = setupArgs$3(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = extractSelectedContent(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const KEEP = 0, INSERT = 1, DELETE = 2;\n    const diff = (left, right) => {\n      const size = left.length + right.length + 2;\n      const vDown = new Array(size);\n      const vUp = new Array(size);\n      const snake = (start, end, diag) => {\n        return {\n          start,\n          end,\n          diag\n        };\n      };\n      const buildScript = (start1, end1, start2, end2, script) => {\n        const middle = getMiddleSnake(start1, end1, start2, end2);\n        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\n          let i = start1;\n          let j = start2;\n          while (i < end1 || j < end2) {\n            if (i < end1 && j < end2 && left[i] === right[j]) {\n              script.push([\n                KEEP,\n                left[i]\n              ]);\n              ++i;\n              ++j;\n            } else {\n              if (end1 - start1 > end2 - start2) {\n                script.push([\n                  DELETE,\n                  left[i]\n                ]);\n                ++i;\n              } else {\n                script.push([\n                  INSERT,\n                  right[j]\n                ]);\n                ++j;\n              }\n            }\n          }\n        } else {\n          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\n          for (let i2 = middle.start; i2 < middle.end; ++i2) {\n            script.push([\n              KEEP,\n              left[i2]\n            ]);\n          }\n          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\n        }\n      };\n      const buildSnake = (start, diag, end1, end2) => {\n        let end = start;\n        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\n          ++end;\n        }\n        return snake(start, end, diag);\n      };\n      const getMiddleSnake = (start1, end1, start2, end2) => {\n        const m = end1 - start1;\n        const n = end2 - start2;\n        if (m === 0 || n === 0) {\n          return null;\n        }\n        const delta = m - n;\n        const sum = n + m;\n        const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\n        vDown[1 + offset] = start1;\n        vUp[1 + offset] = end1 + 1;\n        let d, k, i, x, y;\n        for (d = 0; d <= offset; ++d) {\n          for (k = -d; k <= d; k += 2) {\n            i = k + offset;\n            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\n              vDown[i] = vDown[i + 1];\n            } else {\n              vDown[i] = vDown[i - 1] + 1;\n            }\n            x = vDown[i];\n            y = x - start1 + start2 - k;\n            while (x < end1 && y < end2 && left[x] === right[y]) {\n              vDown[i] = ++x;\n              ++y;\n            }\n            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\n              if (vUp[i - delta] <= vDown[i]) {\n                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n          for (k = delta - d; k <= delta + d; k += 2) {\n            i = k + offset - delta;\n            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\n              vUp[i] = vUp[i + 1] - 1;\n            } else {\n              vUp[i] = vUp[i - 1];\n            }\n            x = vUp[i] - 1;\n            y = x - start1 + start2 - k;\n            while (x >= start1 && y >= start2 && left[x] === right[y]) {\n              vUp[i] = x--;\n              y--;\n            }\n            if (delta % 2 === 0 && -d <= k && k <= d) {\n              if (vUp[i] <= vDown[i + delta]) {\n                return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n        }\n        return null;\n      };\n      const script = [];\n      buildScript(0, left.length, 0, right.length, script);\n      return script;\n    };\n\n    const getOuterHtml = elm => {\n      if (isElement$6(elm)) {\n        return elm.outerHTML;\n      } else if (isText$a(elm)) {\n        return Entities.encodeRaw(elm.data, false);\n      } else if (isComment(elm)) {\n        return '<!--' + elm.data + '-->';\n      }\n      return '';\n    };\n    const createFragment = html => {\n      let node;\n      const container = document.createElement('div');\n      const frag = document.createDocumentFragment();\n      if (html) {\n        container.innerHTML = html;\n      }\n      while (node = container.firstChild) {\n        frag.appendChild(node);\n      }\n      return frag;\n    };\n    const insertAt = (elm, html, index) => {\n      const fragment = createFragment(html);\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        elm.insertBefore(fragment, target);\n      } else {\n        elm.appendChild(fragment);\n      }\n    };\n    const removeAt = (elm, index) => {\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        elm.removeChild(target);\n      }\n    };\n    const applyDiff = (diff, elm) => {\n      let index = 0;\n      each$e(diff, action => {\n        if (action[0] === KEEP) {\n          index++;\n        } else if (action[0] === INSERT) {\n          insertAt(elm, action[1], index);\n          index++;\n        } else if (action[0] === DELETE) {\n          removeAt(elm, index);\n        }\n      });\n    };\n    const read$2 = (elm, trimZwsp) => filter$5(map$3(from(elm.childNodes), trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml), item => {\n      return item.length > 0;\n    });\n    const write = (fragments, elm) => {\n      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\n      applyDiff(diff(currentFragments, fragments), elm);\n      return elm;\n    };\n\n    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\n    const hasIframes = body => body.querySelector('iframe') !== null;\n    const createFragmentedLevel = fragments => {\n      return {\n        type: 'fragmented',\n        fragments,\n        content: '',\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createCompleteLevel = content => {\n      return {\n        type: 'complete',\n        fragments: null,\n        content,\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createFromEditor = editor => {\n      const tempAttrs = editor.serializer.getTempAttrs();\n      const body = trim$1(editor.getBody(), tempAttrs);\n      return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$2(body.innerHTML));\n    };\n    const applyToEditor = (editor, level, before) => {\n      const bookmark = before ? level.beforeBookmark : level.bookmark;\n      if (level.type === 'fragmented') {\n        write(level.fragments, editor.getBody());\n      } else {\n        editor.setContent(level.content, {\n          format: 'raw',\n          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\n        });\n      }\n      if (bookmark) {\n        editor.selection.moveToBookmark(bookmark);\n        editor.selection.scrollIntoView();\n      }\n    };\n    const getLevelContent = level => {\n      return level.type === 'fragmented' ? level.fragments.join('') : level.content;\n    };\n    const getCleanLevelContent = level => {\n      const elm = SugarElement.fromTag('body', lazyTempDocument());\n      set$1(elm, getLevelContent(level));\n      each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);\n      return get$6(elm);\n    };\n    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\n    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\n    const isEq$1 = (level1, level2) => {\n      if (!level1 || !level2) {\n        return false;\n      } else if (hasEqualContent(level1, level2)) {\n        return true;\n      } else {\n        return hasEqualCleanedContent(level1, level2);\n      }\n    };\n\n    const isUnlocked = locks => locks.get() === 0;\n\n    const setTyping = (undoManager, typing, locks) => {\n      if (isUnlocked(locks)) {\n        undoManager.typing = typing;\n      }\n    };\n    const endTyping = (undoManager, locks) => {\n      if (undoManager.typing) {\n        setTyping(undoManager, false, locks);\n        undoManager.add();\n      }\n    };\n    const endTypingLevelIgnoreLocks = undoManager => {\n      if (undoManager.typing) {\n        undoManager.typing = false;\n        undoManager.add();\n      }\n    };\n\n    const beforeChange$1 = (editor, locks, beforeBookmark) => {\n      if (isUnlocked(locks)) {\n        beforeBookmark.set(getUndoBookmark(editor.selection));\n      }\n    };\n    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\n      const currentLevel = createFromEditor(editor);\n      const newLevel = Tools.extend(level || {}, currentLevel);\n      if (!isUnlocked(locks) || editor.removed) {\n        return null;\n      }\n      const lastLevel = undoManager.data[index.get()];\n      if (editor.dispatch('BeforeAddUndo', {\n          level: newLevel,\n          lastLevel,\n          originalEvent: event\n        }).isDefaultPrevented()) {\n        return null;\n      }\n      if (lastLevel && isEq$1(lastLevel, newLevel)) {\n        return null;\n      }\n      if (undoManager.data[index.get()]) {\n        beforeBookmark.get().each(bm => {\n          undoManager.data[index.get()].beforeBookmark = bm;\n        });\n      }\n      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\n      if (customUndoRedoLevels) {\n        if (undoManager.data.length > customUndoRedoLevels) {\n          for (let i = 0; i < undoManager.data.length - 1; i++) {\n            undoManager.data[i] = undoManager.data[i + 1];\n          }\n          undoManager.data.length--;\n          index.set(undoManager.data.length);\n        }\n      }\n      newLevel.bookmark = getUndoBookmark(editor.selection);\n      if (index.get() < undoManager.data.length - 1) {\n        undoManager.data.length = index.get() + 1;\n      }\n      undoManager.data.push(newLevel);\n      index.set(undoManager.data.length - 1);\n      const args = {\n        level: newLevel,\n        lastLevel,\n        originalEvent: event\n      };\n      if (index.get() > 0) {\n        editor.setDirty(true);\n        editor.dispatch('AddUndo', args);\n        editor.dispatch('change', args);\n      } else {\n        editor.dispatch('AddUndo', args);\n      }\n      return newLevel;\n    };\n    const clear$1 = (editor, undoManager, index) => {\n      undoManager.data = [];\n      index.set(0);\n      undoManager.typing = false;\n      editor.dispatch('ClearUndos');\n    };\n    const extra$1 = (editor, undoManager, index, callback1, callback2) => {\n      if (undoManager.transact(callback1)) {\n        const bookmark = undoManager.data[index.get()].bookmark;\n        const lastLevel = undoManager.data[index.get() - 1];\n        applyToEditor(editor, lastLevel, true);\n        if (undoManager.transact(callback2)) {\n          undoManager.data[index.get() - 1].beforeBookmark = bookmark;\n        }\n      }\n    };\n    const redo$1 = (editor, index, data) => {\n      let level;\n      if (index.get() < data.length - 1) {\n        index.set(index.get() + 1);\n        level = data[index.get()];\n        applyToEditor(editor, level, false);\n        editor.setDirty(true);\n        editor.dispatch('Redo', { level });\n      }\n      return level;\n    };\n    const undo$1 = (editor, undoManager, locks, index) => {\n      let level;\n      if (undoManager.typing) {\n        undoManager.add();\n        undoManager.typing = false;\n        setTyping(undoManager, false, locks);\n      }\n      if (index.get() > 0) {\n        index.set(index.get() - 1);\n        level = undoManager.data[index.get()];\n        applyToEditor(editor, level, true);\n        editor.setDirty(true);\n        editor.dispatch('Undo', { level });\n      }\n      return level;\n    };\n    const reset$1 = undoManager => {\n      undoManager.clear();\n      undoManager.add();\n    };\n    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\n    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\n    const transact$1 = (undoManager, locks, callback) => {\n      endTyping(undoManager, locks);\n      undoManager.beforeChange();\n      undoManager.ignore(callback);\n      return undoManager.add();\n    };\n    const ignore$1 = (locks, callback) => {\n      try {\n        locks.set(locks.get() + 1);\n        callback();\n      } finally {\n        locks.set(locks.get() - 1);\n      }\n    };\n\n    const addVisualInternal = (editor, elm) => {\n      const dom = editor.dom;\n      const scope = isNonNullable(elm) ? elm : editor.getBody();\n      each$e(dom.select('table,a', scope), matchedElm => {\n        switch (matchedElm.nodeName) {\n        case 'TABLE':\n          const cls = getVisualAidsTableClass(editor);\n          const value = dom.getAttrib(matchedElm, 'border');\n          if ((!value || value === '0') && editor.hasVisual) {\n            dom.addClass(matchedElm, cls);\n          } else {\n            dom.removeClass(matchedElm, cls);\n          }\n          break;\n        case 'A':\n          if (!dom.getAttrib(matchedElm, 'href')) {\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\n            const cls = getVisualAidsAnchorClass(editor);\n            if (value && editor.hasVisual) {\n              dom.addClass(matchedElm, cls);\n            } else {\n              dom.removeClass(matchedElm, cls);\n            }\n          }\n          break;\n        }\n      });\n      editor.dispatch('VisualAid', {\n        element: elm,\n        hasVisual: editor.hasVisual\n      });\n    };\n\n    const makePlainAdaptor = editor => ({\n      init: { bindEvents: noop },\n      undoManager: {\n        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\n        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\n        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\n        redo: (index, data) => redo$1(editor, index, data),\n        clear: (undoManager, index) => clear$1(editor, undoManager, index),\n        reset: undoManager => reset$1(undoManager),\n        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\n        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\n        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\n        ignore: (locks, callback) => ignore$1(locks, callback),\n        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\n      },\n      formatter: {\n        match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\n        matchAll: (names, vars) => matchAll(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\n        canApply: name => canApply(editor, name),\n        closest: names => closest(editor, names),\n        apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\n        remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),\n        toggle: (name, vars, node) => toggle(editor, name, vars, node),\n        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\n      },\n      editor: {\n        getContent: args => getContentInternal(editor, args),\n        setContent: (content, args) => setContentInternal(editor, content, args),\n        insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\n        addVisual: elm => addVisualInternal(editor, elm)\n      },\n      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },\n      autocompleter: {\n        addDecoration: range => create$9(editor, range),\n        removeDecoration: () => remove$2(editor, SugarElement.fromDom(editor.getBody()))\n      },\n      raw: { getModel: () => Optional.none() }\n    });\n    const makeRtcAdaptor = rtcEditor => {\n      const defaultVars = vars => isObject(vars) ? vars : {};\n      const {init, undoManager, formatter, editor, selection, autocompleter, raw} = rtcEditor;\n      return {\n        init: { bindEvents: init.bindEvents },\n        undoManager: {\n          beforeChange: undoManager.beforeChange,\n          add: undoManager.add,\n          undo: undoManager.undo,\n          redo: undoManager.redo,\n          clear: undoManager.clear,\n          reset: undoManager.reset,\n          hasUndo: undoManager.hasUndo,\n          hasRedo: undoManager.hasRedo,\n          transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\n          ignore: (_locks, callback) => undoManager.ignore(callback),\n          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\n        },\n        formatter: {\n          match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\n          matchAll: formatter.matchAll,\n          matchNode: formatter.matchNode,\n          canApply: name => formatter.canApply(name),\n          closest: names => formatter.closest(names),\n          apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\n          remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\n          toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\n          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\n        },\n        editor: {\n          getContent: args => editor.getContent(args),\n          setContent: (content, args) => {\n            return {\n              content: editor.setContent(content, args),\n              html: ''\n            };\n          },\n          insertContent: (content, _details) => {\n            editor.insertContent(content);\n            return '';\n          },\n          addVisual: editor.addVisual\n        },\n        selection: { getContent: (_format, args) => selection.getContent(args) },\n        autocompleter: {\n          addDecoration: autocompleter.addDecoration,\n          removeDecoration: autocompleter.removeDecoration\n        },\n        raw: { getModel: () => Optional.some(raw.getRawModel()) }\n      };\n    };\n    const makeNoopAdaptor = () => {\n      const nul = constant(null);\n      const empty = constant('');\n      return {\n        init: { bindEvents: noop },\n        undoManager: {\n          beforeChange: noop,\n          add: nul,\n          undo: nul,\n          redo: nul,\n          clear: noop,\n          reset: noop,\n          hasUndo: never,\n          hasRedo: never,\n          transact: nul,\n          ignore: noop,\n          extra: noop\n        },\n        formatter: {\n          match: never,\n          matchAll: constant([]),\n          matchNode: constant(undefined),\n          canApply: never,\n          closest: empty,\n          apply: noop,\n          remove: noop,\n          toggle: noop,\n          formatChanged: constant({ unbind: noop })\n        },\n        editor: {\n          getContent: empty,\n          setContent: constant({\n            content: '',\n            html: ''\n          }),\n          insertContent: constant(''),\n          addVisual: noop\n        },\n        selection: { getContent: empty },\n        autocompleter: {\n          addDecoration: noop,\n          removeDecoration: noop\n        },\n        raw: { getModel: constant(Optional.none()) }\n      };\n    };\n    const isRtc = editor => has$2(editor.plugins, 'rtc');\n    const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\n    const setup$t = editor => {\n      const editorCast = editor;\n      return getRtcSetup(editor).fold(() => {\n        editorCast.rtcInstance = makePlainAdaptor(editor);\n        return Optional.none();\n      }, setup => {\n        editorCast.rtcInstance = makeNoopAdaptor();\n        return Optional.some(() => setup().then(rtcEditor => {\n          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\n          return rtcEditor.rtc.isRemote;\n        }));\n      });\n    };\n    const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\n    const getRtcInstanceWithError = editor => {\n      const rtcInstance = editor.rtcInstance;\n      if (!rtcInstance) {\n        throw new Error('Failed to get RTC instance not yet initialized.');\n      } else {\n        return rtcInstance;\n      }\n    };\n    const beforeChange = (editor, locks, beforeBookmark) => {\n      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\n    };\n    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\n    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\n    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\n    const clear = (editor, undoManager, index) => {\n      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\n    };\n    const reset = (editor, undoManager) => {\n      getRtcInstanceWithError(editor).undoManager.reset(undoManager);\n    };\n    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\n    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\n    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\n    const ignore = (editor, locks, callback) => {\n      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\n    };\n    const extra = (editor, undoManager, index, callback1, callback2) => {\n      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\n    };\n    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\n    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\n    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\n    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\n    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\n    const applyFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\n    };\n    const removeFormat = (editor, name, vars, node, similar) => {\n      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\n    };\n    const toggleFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\n    };\n    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\n    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\n    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\n    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\n    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\n    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\n    const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\n    const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);\n    const removeAutocompleterDecoration = editor => getRtcInstanceWithError(editor).autocompleter.removeDecoration();\n\n    const getContent$1 = (editor, args = {}) => {\n      const format = args.format ? args.format : 'html';\n      return getSelectedContent(editor, format, args);\n    };\n\n    const removeEmpty = text => {\n      if (text.dom.length === 0) {\n        remove$5(text);\n        return Optional.none();\n      } else {\n        return Optional.some(text);\n      }\n    };\n    const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\n    const merge$1 = (outer, inner, rng, start, schema) => {\n      const outerElm = outer.dom;\n      const innerElm = inner.dom;\n      const oldLength = start ? outerElm.length : innerElm.length;\n      if (start) {\n        mergeTextNodes(outerElm, innerElm, schema, false, !start);\n        rng.setStart(innerElm, oldLength);\n      } else {\n        mergeTextNodes(innerElm, outerElm, schema, false, !start);\n        rng.setEnd(innerElm, oldLength);\n      }\n    };\n    const normalizeTextIfRequired = (inner, start, schema) => {\n      parent(inner).each(root => {\n        const text = inner.dom;\n        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {\n          normalizeWhitespaceAfter(text, 0, schema);\n        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length), schema)) {\n          normalizeWhitespaceBefore(text, text.length, schema);\n        }\n      });\n    };\n    const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {\n      outerNode.bind(outer => {\n        const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\n        normalizer(outer.dom, start ? outer.dom.length : 0, schema);\n        return innerNode.filter(isText$b).map(inner => merge$1(outer, inner, rng, start, schema));\n      }).orThunk(() => {\n        const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$b);\n        return innerTextNode.map(inner => normalizeTextIfRequired(inner, start, schema));\n      });\n    };\n    const rngSetContent = (rng, fragment, schema) => {\n      const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\n      const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\n      rng.deleteContents();\n      rng.insertNode(fragment);\n      const prevText = firstChild.bind(prevSibling).filter(isText$b).bind(removeEmpty);\n      const nextText = lastChild.bind(nextSibling).filter(isText$b).bind(removeEmpty);\n      mergeAndNormalizeText(prevText, firstChild, rng, true, schema);\n      mergeAndNormalizeText(nextText, lastChild, rng, false, schema);\n      rng.collapse(false);\n    };\n    const setupArgs$2 = (args, content) => ({\n      format: 'html',\n      ...args,\n      set: true,\n      selection: true,\n      content\n    });\n    const cleanContent = (editor, args) => {\n      if (args.format !== 'raw') {\n        const rng = editor.selection.getRng();\n        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\n        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};\n        const node = editor.parser.parse(args.content, {\n          forced_root_block: false,\n          ...contextArgs,\n          ...args\n        });\n        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);\n      } else {\n        return args.content;\n      }\n    };\n    const setContent$1 = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs$2(args, content);\n      preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\n        const cleanedContent = cleanContent(editor, updatedArgs);\n        const rng = editor.selection.getRng();\n        rngSetContent(rng, rng.createContextualFragment(cleanedContent), editor.schema);\n        editor.selection.setRng(rng);\n        scrollRangeIntoView(editor, rng);\n        postProcessSetContent(editor, cleanedContent, updatedArgs);\n      });\n    };\n\n    const deleteFromCallbackMap = (callbackMap, selector, callback) => {\n      if (has$2(callbackMap, selector)) {\n        const newCallbacks = filter$5(callbackMap[selector], cb => cb !== callback);\n        if (newCallbacks.length === 0) {\n          delete callbackMap[selector];\n        } else {\n          callbackMap[selector] = newCallbacks;\n        }\n      }\n    };\n    var SelectorChanged = (dom, editor) => {\n      let selectorChangedData;\n      let currentSelectors;\n      const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\n      const getParents = elem => dom.getParents(elem, undefined, dom.getRoot());\n      const setup = () => {\n        selectorChangedData = {};\n        currentSelectors = {};\n        editor.on('NodeChange', e => {\n          const node = e.element;\n          const parents = getParents(node);\n          const matchedSelectors = {};\n          each$d(selectorChangedData, (callbacks, selector) => {\n            findMatchingNode(selector, parents).each(node => {\n              if (!currentSelectors[selector]) {\n                each$e(callbacks, callback => {\n                  callback(true, {\n                    node,\n                    selector,\n                    parents\n                  });\n                });\n                currentSelectors[selector] = callbacks;\n              }\n              matchedSelectors[selector] = callbacks;\n            });\n          });\n          each$d(currentSelectors, (callbacks, selector) => {\n            if (!matchedSelectors[selector]) {\n              delete currentSelectors[selector];\n              each$e(callbacks, callback => {\n                callback(false, {\n                  node,\n                  selector,\n                  parents\n                });\n              });\n            }\n          });\n        });\n      };\n      return {\n        selectorChangedWithUnbind: (selector, callback) => {\n          if (!selectorChangedData) {\n            setup();\n          }\n          if (!selectorChangedData[selector]) {\n            selectorChangedData[selector] = [];\n          }\n          selectorChangedData[selector].push(callback);\n          findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\n            currentSelectors[selector] = selectorChangedData[selector];\n          });\n          return {\n            unbind: () => {\n              deleteFromCallbackMap(selectorChangedData, selector, callback);\n              deleteFromCallbackMap(currentSelectors, selector, callback);\n            }\n          };\n        }\n      };\n    };\n\n    const isAttachedToDom = node => {\n      return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\n    };\n    const isValidRange = rng => {\n      if (!rng) {\n        return false;\n      } else {\n        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\n      }\n    };\n    const EditorSelection = (dom, win, serializer, editor) => {\n      let selectedRange;\n      let explicitRange;\n      const {selectorChangedWithUnbind} = SelectorChanged(dom, editor);\n      const setCursorLocation = (node, offset) => {\n        const rng = dom.createRng();\n        if (isNonNullable(node) && isNonNullable(offset)) {\n          rng.setStart(node, offset);\n          rng.setEnd(node, offset);\n          setRng(rng);\n          collapse(false);\n        } else {\n          moveEndPoint(dom, rng, editor.getBody(), true);\n          setRng(rng);\n        }\n      };\n      const getContent = args => getContent$1(editor, args);\n      const setContent = (content, args) => setContent$1(editor, content, args);\n      const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\n      const getEnd = real => getEnd$1(editor.getBody(), getRng$1(), real);\n      const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\n      const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\n      const select$1 = (node, content) => {\n        select(dom, node, content).each(setRng);\n        return node;\n      };\n      const isCollapsed = () => {\n        const rng = getRng$1(), sel = getSel();\n        if (!rng || rng.item) {\n          return false;\n        }\n        if (rng.compareEndPoints) {\n          return rng.compareEndPoints('StartToEnd', rng) === 0;\n        }\n        return !sel || rng.collapsed;\n      };\n      const isEditable = () => {\n        const rng = getRng$1();\n        const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected=\"1\"]');\n        if (fakeSelectedElements.length > 0) {\n          return forall(fakeSelectedElements, el => dom.isEditable(el.parentElement));\n        } else {\n          return isEditableRange(dom, rng);\n        }\n      };\n      const collapse = toStart => {\n        const rng = getRng$1();\n        rng.collapse(!!toStart);\n        setRng(rng);\n      };\n      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\n      const getRng$1 = () => {\n        let rng;\n        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\n          try {\n            return sourceRange.compareBoundaryPoints(how, destinationRange);\n          } catch (ex) {\n            return -1;\n          }\n        };\n        const doc = win.document;\n        if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n          const bookmark = getRng(editor);\n          if (bookmark.isSome()) {\n            return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\n          }\n        }\n        try {\n          const selection = getSel();\n          if (selection && !isRestrictedNode(selection.anchorNode)) {\n            if (selection.rangeCount > 0) {\n              rng = selection.getRangeAt(0);\n            } else {\n              rng = doc.createRange();\n            }\n            rng = processRanges(editor, [rng])[0];\n          }\n        } catch (ex) {\n        }\n        if (!rng) {\n          rng = doc.createRange();\n        }\n        if (isDocument$1(rng.startContainer) && rng.collapsed) {\n          const elm = dom.getRoot();\n          rng.setStart(elm, 0);\n          rng.setEnd(elm, 0);\n        }\n        if (selectedRange && explicitRange) {\n          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\n            rng = explicitRange;\n          } else {\n            selectedRange = null;\n            explicitRange = null;\n          }\n        }\n        return rng;\n      };\n      const setRng = (rng, forward) => {\n        if (!isValidRange(rng)) {\n          return;\n        }\n        const sel = getSel();\n        const evt = editor.dispatch('SetSelectionRange', {\n          range: rng,\n          forward\n        });\n        rng = evt.range;\n        if (sel) {\n          explicitRange = rng;\n          try {\n            sel.removeAllRanges();\n            sel.addRange(rng);\n          } catch (ex) {\n          }\n          if (forward === false && sel.extend) {\n            sel.collapse(rng.endContainer, rng.endOffset);\n            sel.extend(rng.startContainer, rng.startOffset);\n          }\n          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n        }\n        if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {\n          if (rng.endOffset - rng.startOffset < 2) {\n            if (rng.startContainer.hasChildNodes()) {\n              const node = rng.startContainer.childNodes[rng.startOffset];\n              if (node && node.nodeName === 'IMG') {\n                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\n                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\n                  sel.setBaseAndExtent(node, 0, node, 1);\n                }\n              }\n            }\n          }\n        }\n        editor.dispatch('AfterSetSelectionRange', {\n          range: rng,\n          forward\n        });\n      };\n      const setNode = elm => {\n        setContent(dom.getOuterHTML(elm));\n        return elm;\n      };\n      const getNode$1 = () => getNode(editor.getBody(), getRng$1());\n      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\n      const isForward = () => {\n        const sel = getSel();\n        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\n          return true;\n        }\n        const anchorRange = dom.createRng();\n        const focusRange = dom.createRng();\n        try {\n          anchorRange.setStart(anchorNode, sel.anchorOffset);\n          anchorRange.collapse(true);\n          focusRange.setStart(focusNode, sel.focusOffset);\n          focusRange.collapse(true);\n        } catch (e) {\n          return true;\n        }\n        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n      };\n      const normalize = () => {\n        const rng = getRng$1();\n        const sel = getSel();\n        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\n          const normRng = normalize$2(dom, rng);\n          normRng.each(normRng => {\n            setRng(normRng, isForward());\n          });\n          return normRng.getOr(rng);\n        }\n        return rng;\n      };\n      const selectorChanged = (selector, callback) => {\n        selectorChangedWithUnbind(selector, callback);\n        return exports;\n      };\n      const getScrollContainer = () => {\n        let scrollContainer;\n        let node = dom.getRoot();\n        while (node && node.nodeName !== 'BODY') {\n          if (node.scrollHeight > node.clientHeight) {\n            scrollContainer = node;\n            break;\n          }\n          node = node.parentNode;\n        }\n        return scrollContainer;\n      };\n      const scrollIntoView = (elm, alignToTop) => {\n        if (isNonNullable(elm)) {\n          scrollElementIntoView(editor, elm, alignToTop);\n        } else {\n          scrollRangeIntoView(editor, getRng$1(), alignToTop);\n        }\n      };\n      const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\n      const getBoundingClientRect = () => {\n        const rng = getRng$1();\n        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\n      };\n      const destroy = () => {\n        win = selectedRange = explicitRange = null;\n        controlSelection.destroy();\n      };\n      const expand = (options = { type: 'word' }) => setRng(RangeUtils(dom).expand(getRng$1(), options));\n      const exports = {\n        dom,\n        win,\n        serializer,\n        editor,\n        expand,\n        collapse,\n        setCursorLocation,\n        getContent,\n        setContent,\n        getBookmark,\n        moveToBookmark,\n        select: select$1,\n        isCollapsed,\n        isEditable,\n        isForward,\n        setNode,\n        getNode: getNode$1,\n        getSel,\n        setRng,\n        getRng: getRng$1,\n        getStart: getStart$1,\n        getEnd,\n        getSelectedBlocks: getSelectedBlocks$1,\n        normalize,\n        selectorChanged,\n        selectorChangedWithUnbind,\n        getScrollContainer,\n        scrollIntoView,\n        placeCaretAt,\n        getBoundingClientRect,\n        destroy\n      };\n      const bookmarkManager = BookmarkManager(exports);\n      const controlSelection = ControlSelection(exports, editor);\n      exports.bookmarkManager = bookmarkManager;\n      exports.controlSelection = controlSelection;\n      return exports;\n    };\n\n    const register$3 = (htmlParser, settings, dom) => {\n      htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          node.attr('tabindex', node.attr('data-mce-tabindex'));\n          node.attr(name, null);\n        }\n      });\n      htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\n        const internalName = 'data-mce-' + name;\n        const urlConverter = settings.url_converter;\n        const urlConverterScope = settings.url_converter_scope;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(internalName);\n          if (value !== undefined) {\n            node.attr(name, value.length > 0 ? value : null);\n            node.attr(internalName, null);\n          } else {\n            value = node.attr(name);\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n            } else if (urlConverter) {\n              value = urlConverter.call(urlConverterScope, value, name, node.name);\n            }\n            node.attr(name, value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr('class');\n          if (value) {\n            value = value.replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\n            node.attr('class', value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\n            const hasChildren = Optional.from(node.firstChild).exists(firstChild => {\n              var _a;\n              return !isZwsp$1((_a = firstChild.value) !== null && _a !== void 0 ? _a : '');\n            });\n            if (hasChildren) {\n              node.unwrap();\n            } else {\n              node.remove();\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('script,style', (nodes, name) => {\n        var _a;\n        const trim = value => {\n          return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\n        };\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const firstChild = node.firstChild;\n          const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';\n          if (name === 'script') {\n            const type = node.attr('type');\n            if (type) {\n              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\n            }\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n              firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\n            }\n          } else {\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n              firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('#comment', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const value = node.value;\n          if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {\n            node.name = '#cdata';\n            node.type = 4;\n            node.value = dom.decode(value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\n          } else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = unescape(value).substr(14);\n          }\n        }\n      });\n      htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.type === 7) {\n            node.remove();\n          } else if (node.type === 1) {\n            if (name === 'input' && !node.attr('type')) {\n              node.attr('type', 'text');\n            }\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', nodes => {\n        each$e(nodes, node => {\n          if (node.attr('data-mce-type') === 'format-caret') {\n            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\n              node.remove();\n            } else {\n              node.unwrap();\n            }\n          }\n        });\n      });\n      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,data-mce-block,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          nodes[i].attr(name, null);\n        }\n      });\n      if (settings.remove_trailing_brs) {\n        addNodeFilter(settings, htmlParser, htmlParser.schema);\n      }\n    };\n    const trimTrailingBr = rootNode => {\n      const isBr = node => {\n        return (node === null || node === void 0 ? void 0 : node.name) === 'br';\n      };\n      const brNode1 = rootNode.lastChild;\n      if (isBr(brNode1)) {\n        const brNode2 = brNode1.prev;\n        if (isBr(brNode2)) {\n          brNode1.remove();\n          brNode2.remove();\n        }\n      }\n    };\n\n    const preProcess$1 = (editor, node, args) => {\n      let oldDoc;\n      const dom = editor.dom;\n      let clonedNode = node.cloneNode(true);\n      const impl = document.implementation;\n      if (impl.createHTMLDocument) {\n        const doc = impl.createHTMLDocument('');\n        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\n          doc.body.appendChild(doc.importNode(node, true));\n        });\n        if (clonedNode.nodeName !== 'BODY') {\n          clonedNode = doc.body.firstChild;\n        } else {\n          clonedNode = doc.body;\n        }\n        oldDoc = dom.doc;\n        dom.doc = doc;\n      }\n      firePreProcess(editor, {\n        ...args,\n        node: clonedNode\n      });\n      if (oldDoc) {\n        dom.doc = oldDoc;\n      }\n      return clonedNode;\n    };\n    const shouldFireEvent = (editor, args) => {\n      return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;\n    };\n    const process$1 = (editor, node, args) => {\n      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\n    };\n\n    const addTempAttr = (htmlParser, tempAttrs, name) => {\n      if (Tools.inArray(tempAttrs, name) === -1) {\n        htmlParser.addAttributeFilter(name, (nodes, name) => {\n          let i = nodes.length;\n          while (i--) {\n            nodes[i].attr(name, null);\n          }\n        });\n        tempAttrs.push(name);\n      }\n    };\n    const postProcess = (editor, args, content) => {\n      if (!args.no_events && editor) {\n        const outArgs = firePostProcess(editor, {\n          ...args,\n          content\n        });\n        return outArgs.content;\n      } else {\n        return content;\n      }\n    };\n    const getHtmlFromNode = (dom, node, args) => {\n      const html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\n      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\n    };\n    const parseHtml = (htmlParser, html, args) => {\n      const parserArgs = args.selection ? {\n        forced_root_block: false,\n        ...args\n      } : args;\n      const rootNode = htmlParser.parse(html, parserArgs);\n      trimTrailingBr(rootNode);\n      return rootNode;\n    };\n    const serializeNode = (settings, schema, node) => {\n      const htmlSerializer = HtmlSerializer(settings, schema);\n      return htmlSerializer.serialize(node);\n    };\n    const toHtml = (editor, settings, schema, rootNode, args) => {\n      const content = serializeNode(settings, schema, rootNode);\n      return postProcess(editor, args, content);\n    };\n    const DomSerializerImpl = (settings, editor) => {\n      const tempAttrs = ['data-mce-selected'];\n      const defaultedSettings = {\n        entity_encoding: 'named',\n        remove_trailing_brs: true,\n        pad_empty_with_br: false,\n        ...settings\n      };\n      const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\n      const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);\n      const htmlParser = DomParser(defaultedSettings, schema);\n      register$3(htmlParser, defaultedSettings, dom);\n      const serialize = (node, parserArgs = {}) => {\n        const args = {\n          format: 'html',\n          ...parserArgs\n        };\n        const targetNode = process$1(editor, node, args);\n        const html = getHtmlFromNode(dom, targetNode, args);\n        const rootNode = parseHtml(htmlParser, html, args);\n        return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);\n      };\n      return {\n        schema,\n        addNodeFilter: htmlParser.addNodeFilter,\n        addAttributeFilter: htmlParser.addAttributeFilter,\n        serialize: serialize,\n        addRules: schema.addValidElements,\n        setRules: schema.setValidElements,\n        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\n        getTempAttrs: constant(tempAttrs),\n        getNodeFilters: htmlParser.getNodeFilters,\n        getAttributeFilters: htmlParser.getAttributeFilters,\n        removeNodeFilter: htmlParser.removeNodeFilter,\n        removeAttributeFilter: htmlParser.removeAttributeFilter\n      };\n    };\n\n    const DomSerializer = (settings, editor) => {\n      const domSerializer = DomSerializerImpl(settings, editor);\n      return {\n        schema: domSerializer.schema,\n        addNodeFilter: domSerializer.addNodeFilter,\n        addAttributeFilter: domSerializer.addAttributeFilter,\n        serialize: domSerializer.serialize,\n        addRules: domSerializer.addRules,\n        setRules: domSerializer.setRules,\n        addTempAttr: domSerializer.addTempAttr,\n        getTempAttrs: domSerializer.getTempAttrs,\n        getNodeFilters: domSerializer.getNodeFilters,\n        getAttributeFilters: domSerializer.getAttributeFilters,\n        removeNodeFilter: domSerializer.removeNodeFilter,\n        removeAttributeFilter: domSerializer.removeAttributeFilter\n      };\n    };\n\n    const defaultFormat$1 = 'html';\n    const setupArgs$1 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      getInner: true\n    });\n    const getContent = (editor, args = {}) => {\n      const format = args.format ? args.format : defaultFormat$1;\n      const defaultedArgs = setupArgs$1(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = getContent$2(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const defaultFormat = 'html';\n    const setupArgs = (args, content) => ({\n      format: defaultFormat,\n      ...args,\n      set: true,\n      content\n    });\n    const setContent = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs(args, content);\n      return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\n        const result = setContent$2(editor, updatedArgs.content, updatedArgs);\n        postProcessSetContent(editor, result.html, updatedArgs);\n        return result.content;\n      }).getOr(content);\n    };\n\n    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');\n    const deprecatedOptions = 'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format'.split(',');\n    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');\n    const deprecatedPlugins = [\n      {\n        name: 'template',\n        replacedWith: 'Advanced Template'\n      },\n      { name: 'rtc' }\n    ];\n    const getMatchingOptions = (options, searchingFor) => {\n      const settingNames = filter$5(searchingFor, setting => has$2(options, setting));\n      return sort(settingNames);\n    };\n    const getRemovedOptions = options => {\n      const settingNames = getMatchingOptions(options, removedOptions);\n      const forcedRootBlock = options.forced_root_block;\n      if (forcedRootBlock === false || forcedRootBlock === '') {\n        settingNames.push('forced_root_block (false only)');\n      }\n      return sort(settingNames);\n    };\n    const getDeprecatedOptions = options => getMatchingOptions(options, deprecatedOptions);\n    const getMatchingPlugins = (options, searchingFor) => {\n      const plugins = Tools.makeMap(options.plugins, ' ');\n      const hasPlugin = plugin => has$2(plugins, plugin);\n      const pluginNames = filter$5(searchingFor, hasPlugin);\n      return sort(pluginNames);\n    };\n    const getRemovedPlugins = options => getMatchingPlugins(options, removedPlugins);\n    const getDeprecatedPlugins = options => getMatchingPlugins(options, deprecatedPlugins.map(entry => entry.name));\n    const logRemovedWarnings = (rawOptions, normalizedOptions) => {\n      const removedOptions = getRemovedOptions(rawOptions);\n      const removedPlugins = getRemovedPlugins(normalizedOptions);\n      const hasRemovedPlugins = removedPlugins.length > 0;\n      const hasRemovedOptions = removedOptions.length > 0;\n      const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\n      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\n        const listJoiner = '\\n- ';\n        const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${ listJoiner }mobile` : '';\n        const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${ listJoiner }${ removedPlugins.join(listJoiner) }` : '';\n        const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${ listJoiner }${ removedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\n      }\n    };\n    const getPluginDescription = name => find$2(deprecatedPlugins, entry => entry.name === name).fold(() => name, entry => {\n      if (entry.replacedWith) {\n        return `${ name }, replaced by ${ entry.replacedWith }`;\n      } else {\n        return name;\n      }\n    });\n    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {\n      const deprecatedOptions = getDeprecatedOptions(rawOptions);\n      const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);\n      const hasDeprecatedPlugins = deprecatedPlugins.length > 0;\n      const hasDeprecatedOptions = deprecatedOptions.length > 0;\n      if (hasDeprecatedPlugins || hasDeprecatedOptions) {\n        const listJoiner = '\\n- ';\n        const pluginsMessage = hasDeprecatedPlugins ? `\\n\\nPlugins:${ listJoiner }${ deprecatedPlugins.map(getPluginDescription).join(listJoiner) }` : '';\n        const optionsMessage = hasDeprecatedOptions ? `\\n\\nOptions:${ listJoiner }${ deprecatedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled but will be removed soon.' + pluginsMessage + optionsMessage);\n      }\n    };\n    const logWarnings = (rawOptions, normalizedOptions) => {\n      logRemovedWarnings(rawOptions, normalizedOptions);\n      logDeprecatedWarnings(rawOptions, normalizedOptions);\n    };\n\n    const DOM$8 = DOMUtils.DOM;\n    const restoreOriginalStyles = editor => {\n      DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\n    };\n    const safeDestroy = x => Optional.from(x).each(x => x.destroy());\n    const clearDomReferences = editor => {\n      const ed = editor;\n      ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;\n      ed.bodyElement = ed.contentDocument = ed.contentWindow = null;\n      ed.iframeElement = ed.targetElm = null;\n      const selection = editor.selection;\n      if (selection) {\n        const dom = selection.dom;\n        ed.selection = selection.win = selection.dom = dom.doc = null;\n      }\n    };\n    const restoreForm = editor => {\n      const form = editor.formElement;\n      if (form) {\n        if (form._mceOldSubmit) {\n          form.submit = form._mceOldSubmit;\n          delete form._mceOldSubmit;\n        }\n        DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\n      }\n    };\n    const remove$1 = editor => {\n      if (!editor.removed) {\n        const {_selectionOverrides, editorUpload} = editor;\n        const body = editor.getBody();\n        const element = editor.getElement();\n        if (body) {\n          editor.save({ is_removing: true });\n        }\n        editor.removed = true;\n        editor.unbindAllNativeEvents();\n        if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {\n          DOM$8.remove(element.nextSibling);\n        }\n        fireRemove(editor);\n        editor.editorManager.remove(editor);\n        if (!editor.inline && body) {\n          restoreOriginalStyles(editor);\n        }\n        fireDetach(editor);\n        DOM$8.remove(editor.getContainer());\n        safeDestroy(_selectionOverrides);\n        safeDestroy(editorUpload);\n        editor.destroy();\n      }\n    };\n    const destroy = (editor, automatic) => {\n      const {selection, dom} = editor;\n      if (editor.destroyed) {\n        return;\n      }\n      if (!automatic && !editor.removed) {\n        editor.remove();\n        return;\n      }\n      if (!automatic) {\n        editor.editorManager.off('beforeunload', editor._beforeUnload);\n        if (editor.theme && editor.theme.destroy) {\n          editor.theme.destroy();\n        }\n        safeDestroy(selection);\n        safeDestroy(dom);\n      }\n      restoreForm(editor);\n      clearDomReferences(editor);\n      editor.destroyed = true;\n    };\n\n    const CreateIconManager = () => {\n      const lookup = {};\n      const add = (id, iconPack) => {\n        lookup[id] = iconPack;\n      };\n      const get = id => {\n        if (lookup[id]) {\n          return lookup[id];\n        } else {\n          return { icons: {} };\n        }\n      };\n      const has = id => has$2(lookup, id);\n      return {\n        add,\n        get,\n        has\n      };\n    };\n    const IconManager = CreateIconManager();\n\n    const ModelManager = AddOnManager.ModelManager;\n\n    const getProp = (propName, elm) => {\n      const rawElm = elm.dom;\n      return rawElm[propName];\n    };\n    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\n    const getClientWidth = curry(getProp, 'clientWidth');\n    const getClientHeight = curry(getProp, 'clientHeight');\n    const getMarginTop = curry(getComputedSizeProp, 'margin-top');\n    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\n    const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\n    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\n      const clientWidth = getClientWidth(bodyElm);\n      const clientHeight = getClientHeight(bodyElm);\n      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\n    };\n    const transpose = (inline, elm, clientX, clientY) => {\n      const clientRect = getBoundingClientRect(elm);\n      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\n      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\n      const x = clientX - deltaX;\n      const y = clientY - deltaY;\n      return {\n        x,\n        y\n      };\n    };\n    const isXYInContentArea = (editor, clientX, clientY) => {\n      const bodyElm = SugarElement.fromDom(editor.getBody());\n      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\n      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\n      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\n    };\n    const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\n    const isEditorAttachedToDom = editor => {\n      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\n      return fromDomSafe(rawContainer).map(inBody).getOr(false);\n    };\n\n    var NotificationManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a NotificationManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        close: unimplemented,\n        getArgs: unimplemented\n      };\n    };\n\n    const NotificationManager = editor => {\n      const notifications = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\n      };\n      const getTopNotification = () => {\n        return Optional.from(notifications[0]);\n      };\n      const isEqual = (a, b) => {\n        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\n      };\n      const reposition = () => {\n        each$e(notifications, notification => {\n          notification.reposition();\n        });\n      };\n      const addNotification = notification => {\n        notifications.push(notification);\n      };\n      const closeNotification = notification => {\n        findIndex$2(notifications, otherNotification => {\n          return otherNotification === notification;\n        }).each(index => {\n          notifications.splice(index, 1);\n        });\n      };\n      const open = (spec, fireEvent = true) => {\n        if (editor.removed || !isEditorAttachedToDom(editor)) {\n          return {};\n        }\n        if (fireEvent) {\n          editor.dispatch('BeforeOpenNotification', { notification: spec });\n        }\n        return find$2(notifications, notification => {\n          return isEqual(getImplementation().getArgs(notification), spec);\n        }).getOrThunk(() => {\n          editor.editorManager.setActive(editor);\n          const notification = getImplementation().open(spec, () => {\n            closeNotification(notification);\n            reposition();\n            if (hasEditorOrUiFocus(editor)) {\n              getTopNotification().fold(() => editor.focus(), top => focus$1(SugarElement.fromDom(top.getEl())));\n            }\n          });\n          addNotification(notification);\n          reposition();\n          editor.dispatch('OpenNotification', { notification: { ...notification } });\n          return notification;\n        });\n      };\n      const close = () => {\n        getTopNotification().each(notification => {\n          getImplementation().close(notification);\n          closeNotification(notification);\n          reposition();\n        });\n      };\n      const getNotifications = constant(notifications);\n      const registerEvents = editor => {\n        editor.on('SkinLoaded', () => {\n          const serviceMessage = getServiceMessage(editor);\n          if (serviceMessage) {\n            open({\n              text: serviceMessage,\n              type: 'warning',\n              timeout: 0\n            }, false);\n          }\n          reposition();\n        });\n        editor.on('show ResizeEditor ResizeWindow NodeChange', () => {\n          requestAnimationFrame(reposition);\n        });\n        editor.on('remove', () => {\n          each$e(notifications.slice(), notification => {\n            getImplementation().close(notification);\n          });\n        });\n      };\n      registerEvents(editor);\n      return {\n        open,\n        close,\n        getNotifications\n      };\n    };\n\n    const PluginManager = AddOnManager.PluginManager;\n\n    const ThemeManager = AddOnManager.ThemeManager;\n\n    var WindowManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a WindowManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        openUrl: unimplemented,\n        alert: unimplemented,\n        confirm: unimplemented,\n        close: unimplemented\n      };\n    };\n\n    const WindowManager = editor => {\n      let dialogs = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\n      };\n      const funcBind = (scope, f) => {\n        return (...args) => {\n          return f ? f.apply(scope, args) : undefined;\n        };\n      };\n      const fireOpenEvent = dialog => {\n        editor.dispatch('OpenWindow', { dialog });\n      };\n      const fireCloseEvent = dialog => {\n        editor.dispatch('CloseWindow', { dialog });\n      };\n      const addDialog = dialog => {\n        dialogs.push(dialog);\n        fireOpenEvent(dialog);\n      };\n      const closeDialog = dialog => {\n        fireCloseEvent(dialog);\n        dialogs = filter$5(dialogs, otherDialog => {\n          return otherDialog !== dialog;\n        });\n        if (dialogs.length === 0) {\n          editor.focus();\n        }\n      };\n      const getTopDialog = () => {\n        return Optional.from(dialogs[dialogs.length - 1]);\n      };\n      const storeSelectionAndOpenDialog = openDialog => {\n        editor.editorManager.setActive(editor);\n        store(editor);\n        editor.ui.show();\n        const dialog = openDialog();\n        addDialog(dialog);\n        return dialog;\n      };\n      const open = (args, params) => {\n        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\n      };\n      const openUrl = args => {\n        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\n      };\n      const alert = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const confirm = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const close = () => {\n        getTopDialog().each(dialog => {\n          getImplementation().close(dialog);\n          closeDialog(dialog);\n        });\n      };\n      editor.on('remove', () => {\n        each$e(dialogs, dialog => {\n          getImplementation().close(dialog);\n        });\n      });\n      return {\n        open,\n        openUrl,\n        alert,\n        confirm,\n        close\n      };\n    };\n\n    const displayNotification = (editor, message) => {\n      editor.notificationManager.open({\n        type: 'error',\n        text: message\n      });\n    };\n    const displayError = (editor, message) => {\n      if (editor._skinLoaded) {\n        displayNotification(editor, message);\n      } else {\n        editor.on('SkinLoaded', () => {\n          displayNotification(editor, message);\n        });\n      }\n    };\n    const uploadError = (editor, message) => {\n      displayError(editor, I18n.translate([\n        'Failed to upload image: {0}',\n        message\n      ]));\n    };\n    const logError = (editor, errorType, msg) => {\n      fireError(editor, errorType, { message: msg });\n      console.error(msg);\n    };\n    const createLoadError = (type, url, name) => name ? `Failed to load ${ type }: ${ name } from url ${ url }` : `Failed to load ${ type } url: ${ url }`;\n    const pluginLoadError = (editor, url, name) => {\n      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\n    };\n    const iconsLoadError = (editor, url, name) => {\n      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\n    };\n    const languageLoadError = (editor, url, name) => {\n      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\n    };\n    const themeLoadError = (editor, url, name) => {\n      logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\n    };\n    const modelLoadError = (editor, url, name) => {\n      logError(editor, 'ModelLoadError', createLoadError('model', url, name));\n    };\n    const pluginInitError = (editor, name, err) => {\n      const message = I18n.translate([\n        'Failed to initialize plugin: {0}',\n        name\n      ]);\n      fireError(editor, 'PluginLoadError', { message });\n      initError(message, err);\n      displayError(editor, message);\n    };\n    const initError = (message, ...x) => {\n      const console = window.console;\n      if (console) {\n        if (console.error) {\n          console.error(message, ...x);\n        } else {\n          console.log(message, ...x);\n        }\n      }\n    };\n\n    const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\n    const toContentSkinResourceName = url => 'content/' + url + '/content.css';\n    const isBundledCssSkinName = url => tinymce.Resource.has(toContentSkinResourceName(url));\n    const getContentCssUrls = editor => {\n      return transformToUrls(editor, getContentCss(editor));\n    };\n    const getFontCssUrls = editor => {\n      return transformToUrls(editor, getFontCss(editor));\n    };\n    const transformToUrls = (editor, cssLinks) => {\n      const skinUrl = editor.editorManager.baseURL + '/skins/content';\n      const suffix = editor.editorManager.suffix;\n      const contentCssFile = `content${ suffix }.css`;\n      return map$3(cssLinks, url => {\n        if (isBundledCssSkinName(url)) {\n          return url;\n        } else if (isContentCssSkinName(url) && !editor.inline) {\n          return `${ skinUrl }/${ url }/${ contentCssFile }`;\n        } else {\n          return editor.documentBaseURI.toAbsolute(url);\n        }\n      });\n    };\n    const appendContentCssFromSettings = editor => {\n      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\n    };\n\n    const getAllImages = elm => {\n      return elm ? from(elm.getElementsByTagName('img')) : [];\n    };\n    const ImageScanner = (uploadStatus, blobCache) => {\n      const cachedPromises = {};\n      const findAll = (elm, predicate = always) => {\n        const images = filter$5(getAllImages(elm), img => {\n          const src = img.src;\n          if (img.hasAttribute('data-mce-bogus')) {\n            return false;\n          }\n          if (img.hasAttribute('data-mce-placeholder')) {\n            return false;\n          }\n          if (!src || src === Env.transparentSrc) {\n            return false;\n          }\n          if (startsWith(src, 'blob:')) {\n            return !uploadStatus.isUploaded(src) && predicate(img);\n          }\n          if (startsWith(src, 'data:')) {\n            return predicate(img);\n          }\n          return false;\n        });\n        const promises = map$3(images, img => {\n          const imageSrc = img.src;\n          if (has$2(cachedPromises, imageSrc)) {\n            return cachedPromises[imageSrc].then(imageInfo => {\n              if (isString(imageInfo)) {\n                return imageInfo;\n              } else {\n                return {\n                  image: img,\n                  blobInfo: imageInfo.blobInfo\n                };\n              }\n            });\n          } else {\n            const newPromise = imageToBlobInfo(blobCache, imageSrc).then(blobInfo => {\n              delete cachedPromises[imageSrc];\n              return {\n                image: img,\n                blobInfo\n              };\n            }).catch(error => {\n              delete cachedPromises[imageSrc];\n              return error;\n            });\n            cachedPromises[imageSrc] = newPromise;\n            return newPromise;\n          }\n        });\n        return Promise.all(promises);\n      };\n      return { findAll };\n    };\n\n    const UploadStatus = () => {\n      const PENDING = 1, UPLOADED = 2;\n      let blobUriStatuses = {};\n      const createStatus = (status, resultUri) => {\n        return {\n          status,\n          resultUri\n        };\n      };\n      const hasBlobUri = blobUri => {\n        return blobUri in blobUriStatuses;\n      };\n      const getResultUri = blobUri => {\n        const result = blobUriStatuses[blobUri];\n        return result ? result.resultUri : null;\n      };\n      const isPending = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\n      };\n      const isUploaded = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\n      };\n      const markPending = blobUri => {\n        blobUriStatuses[blobUri] = createStatus(PENDING, null);\n      };\n      const markUploaded = (blobUri, resultUri) => {\n        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\n      };\n      const removeFailed = blobUri => {\n        delete blobUriStatuses[blobUri];\n      };\n      const destroy = () => {\n        blobUriStatuses = {};\n      };\n      return {\n        hasBlobUri,\n        getResultUri,\n        isPending,\n        isUploaded,\n        markPending,\n        markUploaded,\n        removeFailed,\n        destroy\n      };\n    };\n\n    let count = 0;\n    const seed = () => {\n      const rnd = () => {\n        return Math.round(Math.random() * 4294967295).toString(36);\n      };\n      const now = new Date().getTime();\n      return 's' + now.toString(36) + rnd() + rnd() + rnd();\n    };\n    const uuid = prefix => {\n      return prefix + count++ + seed();\n    };\n\n    const BlobCache = () => {\n      let cache = [];\n      const mimeToExt = mime => {\n        const mimes = {\n          'image/jpeg': 'jpg',\n          'image/jpg': 'jpg',\n          'image/gif': 'gif',\n          'image/png': 'png',\n          'image/apng': 'apng',\n          'image/avif': 'avif',\n          'image/svg+xml': 'svg',\n          'image/webp': 'webp',\n          'image/bmp': 'bmp',\n          'image/tiff': 'tiff'\n        };\n        return mimes[mime.toLowerCase()] || 'dat';\n      };\n      const create = (o, blob, base64, name, filename) => {\n        if (isString(o)) {\n          const id = o;\n          return toBlobInfo({\n            id,\n            name,\n            filename,\n            blob: blob,\n            base64: base64\n          });\n        } else if (isObject(o)) {\n          return toBlobInfo(o);\n        } else {\n          throw new Error('Unknown input type');\n        }\n      };\n      const toBlobInfo = o => {\n        if (!o.blob || !o.base64) {\n          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\n        }\n        const id = o.id || uuid('blobid');\n        const name = o.name || id;\n        const blob = o.blob;\n        return {\n          id: constant(id),\n          name: constant(name),\n          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\n          blob: constant(blob),\n          base64: constant(o.base64),\n          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\n          uri: constant(o.uri)\n        };\n      };\n      const add = blobInfo => {\n        if (!get(blobInfo.id())) {\n          cache.push(blobInfo);\n        }\n      };\n      const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\n      const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\n      const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\n      const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\n      const removeByUri = blobUri => {\n        cache = filter$5(cache, blobInfo => {\n          if (blobInfo.blobUri() === blobUri) {\n            URL.revokeObjectURL(blobInfo.blobUri());\n            return false;\n          }\n          return true;\n        });\n      };\n      const destroy = () => {\n        each$e(cache, cachedBlobInfo => {\n          URL.revokeObjectURL(cachedBlobInfo.blobUri());\n        });\n        cache = [];\n      };\n      return {\n        create,\n        add,\n        get,\n        getByUri,\n        getByData,\n        findFirst,\n        removeByUri,\n        destroy\n      };\n    };\n\n    const Uploader = (uploadStatus, settings) => {\n      const pendingPromises = {};\n      const pathJoin = (path1, path2) => {\n        if (path1) {\n          return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\n        }\n        return path2;\n      };\n      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', settings.url);\n        xhr.withCredentials = settings.credentials;\n        xhr.upload.onprogress = e => {\n          progress(e.loaded / e.total * 100);\n        };\n        xhr.onerror = () => {\n          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\n        };\n        xhr.onload = () => {\n          if (xhr.status < 200 || xhr.status >= 300) {\n            failure('HTTP Error: ' + xhr.status);\n            return;\n          }\n          const json = JSON.parse(xhr.responseText);\n          if (!json || !isString(json.location)) {\n            failure('Invalid JSON: ' + xhr.responseText);\n            return;\n          }\n          success(pathJoin(settings.basePath, json.location));\n        };\n        const formData = new FormData();\n        formData.append('file', blobInfo.blob(), blobInfo.filename());\n        xhr.send(formData);\n      });\n      const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;\n      const noUpload = () => new Promise(resolve => {\n        resolve([]);\n      });\n      const handlerSuccess = (blobInfo, url) => ({\n        url,\n        blobInfo,\n        status: true\n      });\n      const handlerFailure = (blobInfo, error) => ({\n        url: '',\n        blobInfo,\n        status: false,\n        error\n      });\n      const resolvePending = (blobUri, result) => {\n        Tools.each(pendingPromises[blobUri], resolve => {\n          resolve(result);\n        });\n        delete pendingPromises[blobUri];\n      };\n      const uploadBlobInfo = (blobInfo, handler, openNotification) => {\n        uploadStatus.markPending(blobInfo.blobUri());\n        return new Promise(resolve => {\n          let notification;\n          let progress;\n          try {\n            const closeNotification = () => {\n              if (notification) {\n                notification.close();\n                progress = noop;\n              }\n            };\n            const success = url => {\n              closeNotification();\n              uploadStatus.markUploaded(blobInfo.blobUri(), url);\n              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\n              resolve(handlerSuccess(blobInfo, url));\n            };\n            const failure = error => {\n              closeNotification();\n              uploadStatus.removeFailed(blobInfo.blobUri());\n              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\n              resolve(handlerFailure(blobInfo, error));\n            };\n            progress = percent => {\n              if (percent < 0 || percent > 100) {\n                return;\n              }\n              Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\n                notification = n;\n                n.progressBar.value(percent);\n              });\n            };\n            handler(blobInfo, progress).then(success, err => {\n              failure(isString(err) ? { message: err } : err);\n            });\n          } catch (ex) {\n            resolve(handlerFailure(blobInfo, ex));\n          }\n        });\n      };\n      const isDefaultHandler = handler => handler === defaultHandler;\n      const pendingUploadBlobInfo = blobInfo => {\n        const blobUri = blobInfo.blobUri();\n        return new Promise(resolve => {\n          pendingPromises[blobUri] = pendingPromises[blobUri] || [];\n          pendingPromises[blobUri].push(resolve);\n        });\n      };\n      const uploadBlobs = (blobInfos, openNotification) => {\n        blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\n        return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));\n      };\n      const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\n      return { upload };\n    };\n\n    const openNotification = editor => () => editor.notificationManager.open({\n      text: editor.translate('Image uploading...'),\n      type: 'info',\n      timeout: -1,\n      progressBar: true\n    });\n    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\n      url: getImageUploadUrl(editor),\n      basePath: getImageUploadBasePath(editor),\n      credentials: getImagesUploadCredentials(editor),\n      handler: getImagesUploadHandler(editor)\n    });\n    const ImageUploader = editor => {\n      const uploadStatus = UploadStatus();\n      const uploader = createUploader(editor, uploadStatus);\n      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined) };\n    };\n\n    const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);\n    const addPaddingToEmpty = editor => element => {\n      if (isEmptyForPadding(editor, element)) {\n        append$1(element, SugarElement.fromHtml('<br data-mce-bogus=\"1\" />'));\n      }\n    };\n    const EditorUpload = editor => {\n      const blobCache = BlobCache();\n      let uploader, imageScanner;\n      const uploadStatus = UploadStatus();\n      const urlFilters = [];\n      const aliveGuard = callback => {\n        return result => {\n          if (editor.selection) {\n            return callback(result);\n          }\n          return [];\n        };\n      };\n      const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\n      const replaceString = (content, search, replace) => {\n        let index = 0;\n        do {\n          index = content.indexOf(search, index);\n          if (index !== -1) {\n            content = content.substring(0, index) + replace + content.substr(index + search.length);\n            index += replace.length - search.length + 1;\n          }\n        } while (index !== -1);\n        return content;\n      };\n      const replaceImageUrl = (content, targetUrl, replacementUrl) => {\n        const replacementString = `src=\"${ replacementUrl }\"${ replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : '' }`;\n        content = replaceString(content, `src=\"${ targetUrl }\"`, replacementString);\n        content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\n        return content;\n      };\n      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\n        each$e(editor.undoManager.data, level => {\n          if (level.type === 'fragmented') {\n            level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\n          } else {\n            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n          }\n        });\n      };\n      const replaceImageUriInView = (image, resultUri) => {\n        const src = editor.convertURL(resultUri, 'src');\n        replaceUrlInUndoStack(image.src, resultUri);\n        setAll$1(SugarElement.fromDom(image), {\n          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\n          'data-mce-src': src\n        });\n      };\n      const uploadImages = () => {\n        if (!uploader) {\n          uploader = createUploader(editor, uploadStatus);\n        }\n        return scanForImages().then(aliveGuard(imageInfos => {\n          const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\n          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\n            const imagesToRemove = [];\n            let shouldDispatchChange = false;\n            const filteredResult = map$3(result, (uploadInfo, index) => {\n              const {blobInfo, image} = imageInfos[index];\n              let removed = false;\n              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\n                if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {\n                  shouldDispatchChange = true;\n                }\n                blobCache.removeByUri(image.src);\n                if (isRtc(editor)) ; else {\n                  replaceImageUriInView(image, uploadInfo.url);\n                }\n              } else if (uploadInfo.error) {\n                if (uploadInfo.error.remove) {\n                  replaceUrlInUndoStack(image.src, Env.transparentSrc);\n                  imagesToRemove.push(image);\n                  removed = true;\n                }\n                uploadError(editor, uploadInfo.error.message);\n              }\n              return {\n                element: image,\n                status: uploadInfo.status,\n                uploadUri: uploadInfo.url,\n                blobInfo,\n                removed\n              };\n            });\n            if (imagesToRemove.length > 0 && !isRtc(editor)) {\n              editor.undoManager.transact(() => {\n                each$e(fromDom$1(imagesToRemove), sugarElement => {\n                  const parentOpt = parent(sugarElement);\n                  remove$5(sugarElement);\n                  parentOpt.each(addPaddingToEmpty(editor));\n                  blobCache.removeByUri(sugarElement.dom.src);\n                });\n              });\n            } else if (shouldDispatchChange) {\n              editor.undoManager.dispatchChange();\n            }\n            return filteredResult;\n          }));\n        }));\n      };\n      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\n      const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\n      const addFilter = filter => {\n        urlFilters.push(filter);\n      };\n      const scanForImages = () => {\n        if (!imageScanner) {\n          imageScanner = ImageScanner(uploadStatus, blobCache);\n        }\n        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\n          const filteredResult = filter$5(result, resultItem => {\n            if (isString(resultItem)) {\n              displayError(editor, resultItem);\n              return false;\n            } else if (resultItem.uriType === 'blob') {\n              return false;\n            } else {\n              return true;\n            }\n          });\n          if (isRtc(editor)) ; else {\n            each$e(filteredResult, resultItem => {\n              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n              resultItem.image.src = resultItem.blobInfo.blobUri();\n              resultItem.image.removeAttribute('data-mce-src');\n            });\n          }\n          return filteredResult;\n        }));\n      };\n      const destroy = () => {\n        blobCache.destroy();\n        uploadStatus.destroy();\n        imageScanner = uploader = null;\n      };\n      const replaceBlobUris = content => {\n        return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\n          const resultUri = uploadStatus.getResultUri(blobUri);\n          if (resultUri) {\n            return 'src=\"' + resultUri + '\"';\n          }\n          let blobInfo = blobCache.getByUri(blobUri);\n          if (!blobInfo) {\n            blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\n              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\n            }, undefined);\n          }\n          if (blobInfo) {\n            const blob = blobInfo.blob();\n            return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\n          }\n          return match;\n        });\n      };\n      editor.on('SetContent', () => {\n        if (isAutomaticUploadsEnabled(editor)) {\n          uploadImagesAuto();\n        } else {\n          scanForImages();\n        }\n      });\n      editor.on('RawSaveContent', e => {\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('GetContent', e => {\n        if (e.source_view || e.format === 'raw' || e.format === 'tree') {\n          return;\n        }\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('PostRender', () => {\n        editor.parser.addNodeFilter('img', images => {\n          each$e(images, img => {\n            const src = img.attr('src');\n            if (!src || blobCache.getByUri(src)) {\n              return;\n            }\n            const resultUri = uploadStatus.getResultUri(src);\n            if (resultUri) {\n              img.attr('src', resultUri);\n            }\n          });\n        });\n      });\n      return {\n        blobCache,\n        addFilter,\n        uploadImages,\n        uploadImagesAuto,\n        scanForImages,\n        destroy\n      };\n    };\n\n    const get$1 = editor => {\n      const dom = editor.dom;\n      const schemaType = editor.schema.type;\n      const formats = {\n        valigntop: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'top' }\n          }],\n        valignmiddle: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'middle' }\n          }],\n        valignbottom: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'bottom' }\n          }],\n        alignleft: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-left',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'left' },\n            inherit: false,\n            preview: false\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'left' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: '0px',\n              marginRight: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: { float: 'left' }\n          }\n        ],\n        aligncenter: [\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'center' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-center',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: {\n              display: 'block',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object',\n            ceFalseOverride: true,\n            styles: {\n              display: 'table',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: '[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          }\n        ],\n        alignright: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-right',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'right' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'right' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginRight: '0px',\n              marginLeft: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: { float: 'right' },\n            preview: false\n          }\n        ],\n        alignjustify: [{\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'justify' },\n            inherit: false,\n            preview: 'font-family font-size'\n          }],\n        bold: [\n          {\n            inline: 'strong',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontWeight: 'bold' }\n          },\n          {\n            inline: 'b',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        italic: [\n          {\n            inline: 'em',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontStyle: 'italic' }\n          },\n          {\n            inline: 'i',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        underline: [\n          {\n            inline: 'span',\n            styles: { textDecoration: 'underline' },\n            exact: true\n          },\n          {\n            inline: 'u',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        strikethrough: (() => {\n          const span = {\n            inline: 'span',\n            styles: { textDecoration: 'line-through' },\n            exact: true\n          };\n          const strike = {\n            inline: 'strike',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          const s = {\n            inline: 's',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          return schemaType !== 'html4' ? [\n            s,\n            span,\n            strike\n          ] : [\n            span,\n            s,\n            strike\n          ];\n        })(),\n        forecolor: {\n          inline: 'span',\n          styles: { color: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        hilitecolor: {\n          inline: 'span',\n          styles: { backgroundColor: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        fontname: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontFamily: '%value' },\n          clear_child_styles: true\n        },\n        fontsize: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontSize: '%value' },\n          clear_child_styles: true\n        },\n        lineheight: {\n          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\n          styles: { lineHeight: '%value' }\n        },\n        fontsize_class: {\n          inline: 'span',\n          attributes: { class: '%value' }\n        },\n        blockquote: {\n          block: 'blockquote',\n          wrapper: true,\n          remove: 'all'\n        },\n        subscript: { inline: 'sub' },\n        superscript: { inline: 'sup' },\n        code: { inline: 'code' },\n        link: {\n          inline: 'a',\n          selector: 'a',\n          remove: 'all',\n          split: true,\n          deep: true,\n          onmatch: (node, _fmt, _itemName) => {\n            return isElement$6(node) && node.hasAttribute('href');\n          },\n          onformat: (elm, _fmt, vars) => {\n            Tools.each(vars, (value, key) => {\n              dom.setAttrib(elm, key, value);\n            });\n          }\n        },\n        lang: {\n          inline: 'span',\n          clear_child_styles: true,\n          remove_similar: true,\n          attributes: {\n            'lang': '%value',\n            'data-mce-lang': vars => {\n              var _a;\n              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\n            }\n          }\n        },\n        removeformat: [\n          {\n            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\n            remove: 'all',\n            split: true,\n            expand: false,\n            block_expand: true,\n            deep: true\n          },\n          {\n            selector: 'span',\n            attributes: [\n              'style',\n              'class'\n            ],\n            remove: 'empty',\n            split: true,\n            expand: false,\n            deep: true\n          },\n          {\n            selector: '*',\n            attributes: [\n              'style',\n              'class'\n            ],\n            split: false,\n            expand: false,\n            deep: true\n          }\n        ]\n      };\n      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\n        formats[name] = {\n          block: name,\n          remove: 'all'\n        };\n      });\n      return formats;\n    };\n\n    const genericBase = {\n      remove_similar: true,\n      inherit: false\n    };\n    const cellBase = {\n      selector: 'td,th',\n      ...genericBase\n    };\n    const cellFormats = {\n      tablecellbackgroundcolor: {\n        styles: { backgroundColor: '%value' },\n        ...cellBase\n      },\n      tablecellverticalalign: {\n        styles: { 'vertical-align': '%value' },\n        ...cellBase\n      },\n      tablecellbordercolor: {\n        styles: { borderColor: '%value' },\n        ...cellBase\n      },\n      tablecellclass: {\n        classes: ['%value'],\n        ...cellBase\n      },\n      tableclass: {\n        selector: 'table',\n        classes: ['%value'],\n        ...genericBase\n      },\n      tablecellborderstyle: {\n        styles: { borderStyle: '%value' },\n        ...cellBase\n      },\n      tablecellborderwidth: {\n        styles: { borderWidth: '%value' },\n        ...cellBase\n      }\n    };\n    const get = constant(cellFormats);\n\n    const FormatRegistry = editor => {\n      const formats = {};\n      const get$2 = name => isNonNullable(name) ? formats[name] : formats;\n      const has = name => has$2(formats, name);\n      const register = (name, format) => {\n        if (name) {\n          if (!isString(name)) {\n            each$d(name, (format, name) => {\n              register(name, format);\n            });\n          } else {\n            if (!isArray$1(format)) {\n              format = [format];\n            }\n            each$e(format, format => {\n              if (isUndefined(format.deep)) {\n                format.deep = !isSelectorFormat(format);\n              }\n              if (isUndefined(format.split)) {\n                format.split = !isSelectorFormat(format) || isInlineFormat(format);\n              }\n              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\n                format.remove = 'none';\n              }\n              if (isSelectorFormat(format) && isInlineFormat(format)) {\n                format.mixed = true;\n                format.block_expand = true;\n              }\n              if (isString(format.classes)) {\n                format.classes = format.classes.split(/\\s+/);\n              }\n            });\n            formats[name] = format;\n          }\n        }\n      };\n      const unregister = name => {\n        if (name && formats[name]) {\n          delete formats[name];\n        }\n        return formats;\n      };\n      register(get$1(editor));\n      register(get());\n      register(getFormats(editor));\n      return {\n        get: get$2,\n        has,\n        register,\n        unregister\n      };\n    };\n\n    const each$3 = Tools.each;\n    const dom = DOMUtils.DOM;\n    const isPreviewItem = item => isNonNullable(item) && isObject(item);\n    const parsedSelectorToHtml = (ancestry, editor) => {\n      const schema = editor && editor.schema || Schema({});\n      const decorate = (elm, item) => {\n        if (item.classes.length > 0) {\n          dom.addClass(elm, item.classes.join(' '));\n        }\n        dom.setAttribs(elm, item.attrs);\n      };\n      const createElement = sItem => {\n        const item = isString(sItem) ? {\n          name: sItem,\n          classes: [],\n          attrs: {}\n        } : sItem;\n        const elm = dom.create(item.name);\n        decorate(elm, item);\n        return elm;\n      };\n      const getRequiredParent = (elm, candidate) => {\n        const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());\n        const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;\n        if (parentsRequired && parentsRequired.length) {\n          return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];\n        } else {\n          return false;\n        }\n      };\n      const wrapInHtml = (elm, ancestors, siblings) => {\n        let parentCandidate;\n        const ancestor = ancestors[0];\n        const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;\n        const parentRequired = getRequiredParent(elm, ancestorName);\n        if (parentRequired) {\n          if (ancestorName === parentRequired) {\n            parentCandidate = ancestor;\n            ancestors = ancestors.slice(1);\n          } else {\n            parentCandidate = parentRequired;\n          }\n        } else if (ancestor) {\n          parentCandidate = ancestor;\n          ancestors = ancestors.slice(1);\n        } else if (!siblings) {\n          return elm;\n        }\n        const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');\n        parent.appendChild(elm);\n        if (siblings) {\n          Tools.each(siblings, sibling => {\n            const siblingElm = createElement(sibling);\n            parent.insertBefore(siblingElm, elm);\n          });\n        }\n        const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;\n        return wrapInHtml(parent, ancestors, parentSiblings);\n      };\n      const fragment = dom.create('div');\n      if (ancestry.length > 0) {\n        const item = ancestry[0];\n        const elm = createElement(item);\n        const siblings = isPreviewItem(item) ? item.siblings : undefined;\n        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));\n      }\n      return fragment;\n    };\n    const parseSelectorItem = item => {\n      item = Tools.trim(item);\n      let tagName = 'div';\n      const obj = {\n        name: tagName,\n        classes: [],\n        attrs: {},\n        selector: item\n      };\n      if (item !== '*') {\n        tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\n          switch ($1) {\n          case '#':\n            obj.attrs.id = $2;\n            break;\n          case '.':\n            obj.classes.push($2);\n            break;\n          case ':':\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\n              obj.attrs[$2] = $2;\n            }\n            break;\n          }\n          if ($3 === '[') {\n            const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\n            if (m) {\n              obj.attrs[m[1]] = m[2];\n            }\n          }\n          return '';\n        });\n      }\n      obj.name = tagName || 'div';\n      return obj;\n    };\n    const parseSelector = selector => {\n      if (!isString(selector)) {\n        return [];\n      }\n      selector = selector.split(/\\s*,\\s*/)[0];\n      selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\n      return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\n        const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\n        const obj = siblings.pop();\n        if (siblings.length) {\n          obj.siblings = siblings;\n        }\n        return obj;\n      }).reverse();\n    };\n    const getCssText = (editor, format) => {\n      let previewCss = '';\n      let previewStyles = getPreviewStyles(editor);\n      if (previewStyles === '') {\n        return '';\n      }\n      const removeVars = val => {\n        return isString(val) ? val.replace(/%(\\w+)/g, '') : '';\n      };\n      const getComputedStyle = (name, elm) => {\n        return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);\n      };\n      if (isString(format)) {\n        const formats = editor.formatter.get(format);\n        if (!formats) {\n          return '';\n        }\n        format = formats[0];\n      }\n      if ('preview' in format) {\n        const preview = format.preview;\n        if (preview === false) {\n          return '';\n        } else {\n          previewStyles = preview || previewStyles;\n        }\n      }\n      let name = format.block || format.inline || 'span';\n      let previewFrag;\n      const items = parseSelector(format.selector);\n      if (items.length > 0) {\n        if (!items[0].name) {\n          items[0].name = name;\n        }\n        name = format.selector;\n        previewFrag = parsedSelectorToHtml(items, editor);\n      } else {\n        previewFrag = parsedSelectorToHtml([name], editor);\n      }\n      const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\n      each$3(format.styles, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setStyle(previewElm, name, newValue);\n        }\n      });\n      each$3(format.attributes, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setAttrib(previewElm, name, newValue);\n        }\n      });\n      each$3(format.classes, value => {\n        const newValue = removeVars(value);\n        if (!dom.hasClass(previewElm, newValue)) {\n          dom.addClass(previewElm, newValue);\n        }\n      });\n      editor.dispatch('PreviewFormats');\n      dom.setStyles(previewFrag, {\n        position: 'absolute',\n        left: -65535\n      });\n      editor.getBody().appendChild(previewFrag);\n      const rawParentFontSize = getComputedStyle('fontSize');\n      const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;\n      each$3(previewStyles.split(' '), name => {\n        let value = getComputedStyle(name, previewElm);\n        if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n          value = getComputedStyle(name);\n          if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\n            return;\n          }\n        }\n        if (name === 'color') {\n          if (rgbaToHexString(value).toLowerCase() === '#000000') {\n            return;\n          }\n        }\n        if (name === 'font-size') {\n          if (/em|%$/.test(value)) {\n            if (parentFontSize === 0) {\n              return;\n            }\n            const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\n            value = numValue * parentFontSize + 'px';\n          }\n        }\n        if (name === 'border' && value) {\n          previewCss += 'padding:0 2px;';\n        }\n        previewCss += name + ':' + value + ';';\n      });\n      editor.dispatch('AfterPreviewFormats');\n      dom.remove(previewFrag);\n      return previewCss;\n    };\n\n    const setup$s = editor => {\n      editor.addShortcut('meta+b', '', 'Bold');\n      editor.addShortcut('meta+i', '', 'Italic');\n      editor.addShortcut('meta+u', '', 'Underline');\n      for (let i = 1; i <= 6; i++) {\n        editor.addShortcut('access+' + i, '', [\n          'FormatBlock',\n          false,\n          'h' + i\n        ]);\n      }\n      editor.addShortcut('access+7', '', [\n        'FormatBlock',\n        false,\n        'p'\n      ]);\n      editor.addShortcut('access+8', '', [\n        'FormatBlock',\n        false,\n        'div'\n      ]);\n      editor.addShortcut('access+9', '', [\n        'FormatBlock',\n        false,\n        'address'\n      ]);\n    };\n\n    const Formatter = editor => {\n      const formats = FormatRegistry(editor);\n      const formatChangeState = Cell({});\n      setup$s(editor);\n      setup$v(editor);\n      if (!isRtc(editor)) {\n        setup$u(formatChangeState, editor);\n      }\n      return {\n        get: formats.get,\n        has: formats.has,\n        register: formats.register,\n        unregister: formats.unregister,\n        apply: (name, vars, node) => {\n          applyFormat(editor, name, vars, node);\n        },\n        remove: (name, vars, node, similar) => {\n          removeFormat(editor, name, vars, node, similar);\n        },\n        toggle: (name, vars, node) => {\n          toggleFormat(editor, name, vars, node);\n        },\n        match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\n        closest: names => closestFormat(editor, names),\n        matchAll: (names, vars) => matchAllFormats(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\n        canApply: name => canApplyFormat(editor, name),\n        formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\n        getCssText: curry(getCssText, editor)\n      };\n    };\n\n    const shouldIgnoreCommand = cmd => {\n      switch (cmd.toLowerCase()) {\n      case 'undo':\n      case 'redo':\n      case 'mcefocus':\n        return true;\n      default:\n        return false;\n      }\n    };\n    const registerEvents = (editor, undoManager, locks) => {\n      const isFirstTypedCharacter = Cell(false);\n      const addNonTypingUndoLevel = e => {\n        setTyping(undoManager, false, locks);\n        undoManager.add({}, e);\n      };\n      editor.on('init', () => {\n        undoManager.add();\n      });\n      editor.on('BeforeExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          endTyping(undoManager, locks);\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('ExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('ObjectResizeStart cut', () => {\n        undoManager.beforeChange();\n      });\n      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\n      editor.on('dragend', addNonTypingUndoLevel);\n      editor.on('keyup', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        const isMeta = Env.os.isMacOS() && e.key === 'Meta';\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey || isMeta) {\n          addNonTypingUndoLevel();\n          editor.nodeChanged();\n        }\n        if (keyCode === 46 || keyCode === 8) {\n          editor.nodeChanged();\n        }\n        if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {\n          if (!editor.isDirty()) {\n            editor.setDirty(true);\n          }\n          editor.dispatch('TypingUndo');\n          isFirstTypedCharacter.set(false);\n          editor.nodeChanged();\n        }\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\n          if (undoManager.typing) {\n            addNonTypingUndoLevel(e);\n          }\n          return;\n        }\n        const modKey = e.ctrlKey && !e.altKey || e.metaKey;\n        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\n          undoManager.beforeChange();\n          setTyping(undoManager, true, locks);\n          undoManager.add({}, e);\n          isFirstTypedCharacter.set(true);\n          return;\n        }\n        const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n        if (hasOnlyMetaOrCtrlModifier) {\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('mousedown', e => {\n        if (undoManager.typing) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\n      const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\n      const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\n      editor.on('input', e => {\n        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('AddUndo Undo Redo ClearUndos', e => {\n        if (!e.isDefaultPrevented()) {\n          editor.nodeChanged();\n        }\n      });\n    };\n    const addKeyboardShortcuts = editor => {\n      editor.addShortcut('meta+z', '', 'Undo');\n      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\n    };\n\n    const UndoManager = editor => {\n      const beforeBookmark = value$2();\n      const locks = Cell(0);\n      const index = Cell(0);\n      const undoManager = {\n        data: [],\n        typing: false,\n        beforeChange: () => {\n          beforeChange(editor, locks, beforeBookmark);\n        },\n        add: (level, event) => {\n          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\n        },\n        dispatchChange: () => {\n          editor.setDirty(true);\n          const level = createFromEditor(editor);\n          level.bookmark = getUndoBookmark(editor.selection);\n          editor.dispatch('change', {\n            level,\n            lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()\n          });\n        },\n        undo: () => {\n          return undo(editor, undoManager, locks, index);\n        },\n        redo: () => {\n          return redo(editor, index, undoManager.data);\n        },\n        clear: () => {\n          clear(editor, undoManager, index);\n        },\n        reset: () => {\n          reset(editor, undoManager);\n        },\n        hasUndo: () => {\n          return hasUndo(editor, undoManager, index);\n        },\n        hasRedo: () => {\n          return hasRedo(editor, undoManager, index);\n        },\n        transact: callback => {\n          return transact(editor, undoManager, locks, callback);\n        },\n        ignore: callback => {\n          ignore(editor, locks, callback);\n        },\n        extra: (callback1, callback2) => {\n          extra(editor, undoManager, index, callback1, callback2);\n        }\n      };\n      if (!isRtc(editor)) {\n        registerEvents(editor, undoManager, locks);\n      }\n      addKeyboardShortcuts(editor);\n      return undoManager;\n    };\n\n    const nonTypingKeycodes = [\n      9,\n      27,\n      VK.HOME,\n      VK.END,\n      19,\n      20,\n      44,\n      144,\n      145,\n      33,\n      34,\n      45,\n      16,\n      17,\n      18,\n      91,\n      92,\n      93,\n      VK.DOWN,\n      VK.UP,\n      VK.LEFT,\n      VK.RIGHT\n    ].concat(Env.browser.isFirefox() ? [224] : []);\n    const placeholderAttr = 'data-mce-placeholder';\n    const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\n    const isDeleteEvent = e => {\n      const keyCode = e.keyCode;\n      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\n    };\n    const isNonTypingKeyboardEvent = e => {\n      if (isKeyboardEvent(e)) {\n        const keyCode = e.keyCode;\n        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\n      } else {\n        return false;\n      }\n    };\n    const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\n    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\n      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {\n        const firstElement = rootElm.firstElementChild;\n        if (!firstElement) {\n          return true;\n        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\n          return false;\n        } else {\n          return forcedRootBlock === firstElement.nodeName.toLowerCase();\n        }\n      } else {\n        return false;\n      }\n    };\n    const setup$r = editor => {\n      var _a;\n      const dom = editor.dom;\n      const rootBlock = getForcedRootBlock(editor);\n      const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';\n      const updatePlaceholder = (e, initial) => {\n        if (isNonTypingKeyboardEvent(e)) {\n          return;\n        }\n        const body = editor.getBody();\n        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\n        const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\n        if (isPlaceholderShown !== showPlaceholder || initial) {\n          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\n          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);\n          firePlaceholderToggle(editor, showPlaceholder);\n          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\n          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\n        }\n      };\n      if (isNotEmpty(placeholder)) {\n        editor.on('init', e => {\n          updatePlaceholder(e, true);\n          editor.on('change SetContent ExecCommand', updatePlaceholder);\n          editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\n        });\n      }\n    };\n\n    const blockPosition = (block, position) => ({\n      block,\n      position\n    });\n    const blockBoundary = (from, to) => ({\n      from,\n      to\n    });\n    const getBlockPosition = (rootNode, pos) => {\n      const rootElm = SugarElement.fromDom(rootNode);\n      const containerElm = SugarElement.fromDom(pos.container());\n      return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\n    };\n    const isDifferentBlocks = blockBoundary => !eq(blockBoundary.from.block, blockBoundary.to.block);\n    const getClosestHost = (root, scope) => {\n      const isRoot = node => eq(node, root);\n      const isHost = node => isTableCell$2(node) || isContentEditableTrue$3(node.dom);\n      return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);\n    };\n    const hasSameHost = (rootNode, blockBoundary) => {\n      const root = SugarElement.fromDom(rootNode);\n      return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));\n    };\n    const isEditable$1 = blockBoundary => isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;\n    const hasValidBlocks = blockBoundary => {\n      const isValidBlock = block => isTextBlock$2(block) || hasBlockAttr(block.dom);\n      return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);\n    };\n    const skipLastBr = (rootNode, forward, blockPosition) => {\n      if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(blockPosition.block)) {\n        return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\n          if (lastPositionInBlock.isEqual(blockPosition.position)) {\n            return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\n          } else {\n            return Optional.some(blockPosition);\n          }\n        }).getOr(blockPosition);\n      } else {\n        return blockPosition;\n      }\n    };\n    const readFromRange = (rootNode, forward, rng) => {\n      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\n      const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(rootNode, forward, blockPos))));\n      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary));\n    };\n    const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();\n\n    const getChildrenUntilBlockBoundary = (block, schema) => {\n      const children = children$1(block);\n      return findIndex$2(children, el => schema.isBlock(name(el))).fold(constant(children), index => children.slice(0, index));\n    };\n    const extractChildren = (block, schema) => {\n      const children = getChildrenUntilBlockBoundary(block, schema);\n      each$e(children, remove$5);\n      return children;\n    };\n    const removeEmptyRoot = (rootNode, block) => {\n      const parents = parentsAndSelf(block, rootNode);\n      return find$2(parents.reverse(), element => isEmpty$2(element)).each(remove$5);\n    };\n    const isEmptyBefore = el => filter$5(prevSiblings(el), el => !isEmpty$2(el)).length === 0;\n    const nestedBlockMerge = (rootNode, fromBlock, toBlock, schema, insertionPoint) => {\n      if (isEmpty$2(toBlock)) {\n        fillWithPaddingBr(toBlock);\n        return firstPositionIn(toBlock.dom);\n      }\n      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {\n        before$3(insertionPoint, SugarElement.fromTag('br'));\n      }\n      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\n      each$e(extractChildren(fromBlock, schema), child => {\n        before$3(insertionPoint, child);\n      });\n      removeEmptyRoot(rootNode, fromBlock);\n      return position;\n    };\n    const isInline = (schema, node) => schema.isInline(name(node));\n    const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema) => {\n      if (isEmpty$2(toBlock)) {\n        if (isEmpty$2(fromBlock)) {\n          const getInlineToBlockDescendants = el => {\n            const helper = (node, elements) => firstChild(node).fold(() => elements, child => isInline(schema, child) ? helper(child, elements.concat(shallow$1(child))) : elements);\n            return helper(el, []);\n          };\n          const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {\n            wrap$2(element, descendant);\n            return descendant;\n          }, createPaddingBr());\n          empty(fromBlock);\n          append$1(fromBlock, newFromBlockDescendants);\n        }\n        remove$5(toBlock);\n        return firstPositionIn(fromBlock.dom);\n      }\n      const position = lastPositionIn(toBlock.dom);\n      each$e(extractChildren(fromBlock, schema), child => {\n        append$1(toBlock, child);\n      });\n      removeEmptyRoot(rootNode, fromBlock);\n      return position;\n    };\n    const findInsertionPoint = (toBlock, block) => {\n      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\n      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\n    };\n    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\n    const trimBr = (first, block) => {\n      positionIn(first, block.dom).bind(position => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$5);\n    };\n    const mergeBlockInto = (rootNode, fromBlock, toBlock, schema) => {\n      trimBr(true, fromBlock);\n      trimBr(false, toBlock);\n      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema), curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema));\n    };\n    const mergeBlocks = (rootNode, forward, block1, block2, schema) => forward ? mergeBlockInto(rootNode, block2, block1, schema) : mergeBlockInto(rootNode, block1, block2, schema);\n\n    const backspaceDelete$9 = (editor, forward) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\n        mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block, editor.schema).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      });\n      return position;\n    };\n\n    const deleteRangeMergeBlocks = (rootNode, selection, schema) => {\n      const rng = selection.getRng();\n      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\n        if (!eq(block1, block2)) {\n          return Optional.some(() => {\n            rng.deleteContents();\n            mergeBlocks(rootNode, true, block1, block2, schema).each(pos => {\n              selection.setRng(pos.toRange());\n            });\n          });\n        } else {\n          return Optional.none();\n        }\n      }).getOr(Optional.none());\n    };\n    const isRawNodeInTable = (root, rawNode) => {\n      const node = SugarElement.fromDom(rawNode);\n      const isRoot = curry(eq, root);\n      return ancestor$4(node, isTableCell$2, isRoot).isSome();\n    };\n    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\n    const isEverythingSelected = (root, rng) => {\n      const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\n      const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\n      return !isSelectionInTable(root, rng) && noPrevious && noNext;\n    };\n    const emptyEditor = editor => {\n      return Optional.some(() => {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      });\n    };\n    const deleteRange$2 = editor => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);\n    };\n    const backspaceDelete$8 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);\n\n    const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\n    const getNodeRange = node => {\n      const rng = node.ownerDocument.createRange();\n      rng.selectNode(node);\n      return rng;\n    };\n    const selectNode = (editor, node) => {\n      const e = editor.dispatch('BeforeObjectSelected', { target: node });\n      if (e.isDefaultPrevented()) {\n        return Optional.none();\n      }\n      return Optional.some(getNodeRange(node));\n    };\n    const renderCaretAtRange = (editor, range, scrollIntoView) => {\n      const normalizedRange = normalizeRange(1, editor.getBody(), range);\n      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\n      const caretPositionNode = caretPosition.getNode();\n      if (isInlineFakeCaretTarget(caretPositionNode)) {\n        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\n      }\n      const caretPositionBeforeNode = caretPosition.getNode(true);\n      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\n        return showCaret(1, editor, caretPositionBeforeNode, false, false);\n      }\n      const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());\n      if (isInlineFakeCaretTarget(ceRoot)) {\n        return showCaret(1, editor, ceRoot, false, scrollIntoView);\n      }\n      return Optional.none();\n    };\n    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\n\n    const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\n    const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\n    const trimEmptyTextNode = (dom, node) => {\n      if (isText$a(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\n      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\n        if (range.collapsed) {\n          const deleteRange = range.cloneRange();\n          if (forward) {\n            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\n          } else {\n            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\n          }\n          deleteRange.deleteContents();\n        } else {\n          range.deleteContents();\n        }\n        editor.selection.setRng(caretRange);\n      });\n      trimEmptyTextNode(editor.dom, node);\n    };\n    const deleteBoundaryText = (editor, forward) => {\n      const range = editor.selection.getRng();\n      if (!isText$a(range.commonAncestorContainer)) {\n        return Optional.none();\n      }\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const nextCaretPosition = getNextPosFn(caretPosition);\n      const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;\n      if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {\n        return Optional.none();\n      } else if (isBeforeFn(normalizedNextCaretPosition)) {\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));\n      }\n      const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {\n          return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\n        }\n      }\n      return Optional.none();\n    };\n    const backspaceDelete$7 = (editor, forward) => deleteBoundaryText(editor, forward);\n\n    const getEdgeCefPosition = (editor, atStart) => {\n      const root = editor.getBody();\n      return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);\n    };\n    const isCefAtEdgeSelected = editor => {\n      const rng = editor.selection.getRng();\n      return !rng.collapsed && (getEdgeCefPosition(editor, true).exists(pos => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists(pos => pos.isEqual(CaretPosition.fromRangeEnd(rng))));\n    };\n\n    const isCompoundElement = node => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));\n    const DeleteAction = Adt.generate([\n      { remove: ['element'] },\n      { moveToElement: ['element'] },\n      { moveToPosition: ['position'] }\n    ]);\n    const isAtContentEditableBlockCaret = (forward, from) => {\n      const elm = from.getNode(!forward);\n      const caretLocation = forward ? 'after' : 'before';\n      return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\n    };\n    const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {\n      const inSameBlock = elm => schema.isInline(elm.nodeName.toLowerCase()) && !isInSameBlock(from, to, root);\n      return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\n    };\n    const deleteEmptyBlockOrMoveToCef = (root, forward, from, to) => {\n      const toCefElm = to.getNode(!forward);\n      return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\n    };\n    const findCefPosition = (root, forward, from, schema) => fromPosition(forward, root, from).bind(to => {\n      if (isCompoundElement(to.getNode())) {\n        return Optional.none();\n      } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$b(to.getNode())) {\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n      } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n      } else if (forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else if (!forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getContentEditableBlockAction = (forward, elm) => {\n      if (isNullable(elm)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\n      } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\n      } else {\n        return Optional.none();\n      }\n    };\n    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\n      if (isInSameBlock(from, to, root)) {\n        return Optional.none();\n      } else {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      }\n    });\n    const getContentEditableAction = (root, forward, from, schema) => {\n      if (isAtContentEditableBlockCaret(forward, from)) {\n        return getContentEditableBlockAction(forward, from.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from, schema));\n      } else {\n        return findCefPosition(root, forward, from, schema).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\n      }\n    };\n    const read = (root, forward, rng, schema) => {\n      const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\n      const from = CaretPosition.fromRangeStart(normalizedRange);\n      const rootElement = SugarElement.fromDom(root);\n      if (!forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode(true)));\n      } else if (forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode()));\n      } else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from, schema)) {\n        return findPreviousBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from, schema)) {\n        return findNextBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n      } else {\n        return getContentEditableAction(root, forward, from, schema);\n      }\n    };\n\n    const deleteElement$1 = (editor, forward) => element => {\n      editor._selectionOverrides.hideFakeCaret();\n      deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      return true;\n    };\n    const moveToElement = (editor, forward) => element => {\n      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const moveToPosition = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\n    const backspaceDeleteCaret = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng(), editor.schema).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\n    };\n    const deleteOffscreenSelection = rootElement => {\n      each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$5);\n    };\n    const backspaceDeleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {\n        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);\n        return hasCefAncestor.fold(() => Optional.some(() => {\n          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\n          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\n          paddEmptyBody(editor);\n        }), () => Optional.some(noop));\n      }\n      if (isCefAtEdgeSelected(editor)) {\n        return Optional.some(() => {\n          deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));\n        });\n      }\n      return Optional.none();\n    };\n    const paddEmptyElement = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\n      if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\n        const br = dom.create('br', { 'data-mce-bogus': '1' });\n        dom.setHTML(ceRoot, '');\n        ceRoot.appendChild(br);\n        selection.setRng(CaretPosition.before(br).toRange());\n      }\n      return true;\n    };\n    const backspaceDelete$6 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return backspaceDeleteCaret(editor, forward);\n      } else {\n        return backspaceDeleteRange(editor, forward);\n      }\n    };\n\n    const deleteCaret$2 = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map(elm => () => editor.selection.select(elm));\n    };\n    const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\n\n    const isText$2 = isText$a;\n    const startsWithCaretContainer = node => isText$2(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer = node => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const createZwsp = node => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      return doc.createTextNode(ZWSP$1);\n    };\n    const insertBefore$1 = node => {\n      var _a;\n      if (isText$2(node.previousSibling)) {\n        if (endsWithCaretContainer(node.previousSibling)) {\n          return node.previousSibling;\n        } else {\n          node.previousSibling.appendData(ZWSP$1);\n          return node.previousSibling;\n        }\n      } else if (isText$2(node)) {\n        if (startsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.insertData(0, ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);\n        return newNode;\n      }\n    };\n    const insertAfter$1 = node => {\n      var _a, _b;\n      if (isText$2(node.nextSibling)) {\n        if (startsWithCaretContainer(node.nextSibling)) {\n          return node.nextSibling;\n        } else {\n          node.nextSibling.insertData(0, ZWSP$1);\n          return node.nextSibling;\n        }\n      } else if (isText$2(node)) {\n        if (endsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.appendData(ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        if (node.nextSibling) {\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);\n        } else {\n          (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);\n        }\n        return newNode;\n      }\n    };\n    const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);\n    const insertInlineBefore = curry(insertInline, true);\n    const insertInlineAfter = curry(insertInline, false);\n\n    const insertInlinePos = (pos, before) => {\n      if (isText$a(pos.container())) {\n        return insertInline(before, pos.container());\n      } else {\n        return insertInline(before, pos.getNode());\n      }\n    };\n    const isPosCaretContainer = (pos, caret) => {\n      const caretNode = caret.get();\n      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\n    };\n    const renderCaret = (caret, location) => location.fold(element => {\n      remove$3(caret.get());\n      const text = insertInlineBefore(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, text.length - 1));\n    }, element => firstPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$3(caret.get());\n        const text = insertInlinePos(pos, true);\n        caret.set(text);\n        return CaretPosition(text, 1);\n      } else {\n        const node = caret.get();\n        return CaretPosition(node, 1);\n      }\n    }), element => lastPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$3(caret.get());\n        const text = insertInlinePos(pos, false);\n        caret.set(text);\n        return CaretPosition(text, text.length - 1);\n      } else {\n        const node = caret.get();\n        return CaretPosition(node, node.length - 1);\n      }\n    }), element => {\n      remove$3(caret.get());\n      const text = insertInlineAfter(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, 1));\n    });\n\n    const evaluateUntil = (fns, args) => {\n      for (let i = 0; i < fns.length; i++) {\n        const result = fns[i].apply(null, args);\n        if (result.isSome()) {\n          return result;\n        }\n      }\n      return Optional.none();\n    };\n\n    const Location = Adt.generate([\n      { before: ['element'] },\n      { start: ['element'] },\n      { end: ['element'] },\n      { after: ['element'] }\n    ]);\n    const rescope$1 = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const before = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\n    };\n    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\n    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\n    const start$1 = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const prevPos = prevPosition(inline, nPos);\n        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\n      });\n    };\n    const end = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const nextPos = nextPosition(inline, nPos);\n        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\n      });\n    };\n    const after = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\n    };\n    const isValidLocation = location => !isRtl(getElement(location));\n    const readLocation = (isInlineTarget, rootNode, pos) => {\n      const location = evaluateUntil([\n        before,\n        start$1,\n        end,\n        after\n      ], [\n        isInlineTarget,\n        rootNode,\n        pos\n      ]);\n      return location.filter(isValidLocation);\n    };\n    const getElement = location => location.fold(identity, identity, identity, identity);\n    const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\n    const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\n    const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\n    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\n    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\n      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\n        return Location.after(forward ? fromInline : toInline);\n      } else {\n        return location;\n      }\n    }).getOr(location);\n    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\n    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\n      const from = normalizePosition(forward, pos);\n      const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\n      const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\n      return location.filter(isValidLocation);\n    };\n    const findLocationSimple = (forward, location) => {\n      if (forward) {\n        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\n      } else {\n        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\n      }\n    };\n    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\n      const from = normalizePosition(forward, pos);\n      const fromLocation = readLocation(isInlineTarget, rootNode, from);\n      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\n    };\n\n    const hasSelectionModifyApi = editor => {\n      return isFunction(editor.selection.getSel().modify);\n    };\n    const moveRel = (forward, selection, pos) => {\n      const delta = forward ? 1 : -1;\n      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\n      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\n      return true;\n    };\n    const moveByWord = (forward, editor) => {\n      const rng = editor.selection.getRng();\n      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      if (!hasSelectionModifyApi(editor)) {\n        return false;\n      } else if (forward && isBeforeInline(pos)) {\n        return moveRel(true, editor.selection, pos);\n      } else if (!forward && isAfterInline(pos)) {\n        return moveRel(false, editor.selection, pos);\n      } else {\n        return false;\n      }\n    };\n\n    var BreakType;\n    (function (BreakType) {\n      BreakType[BreakType['Br'] = 0] = 'Br';\n      BreakType[BreakType['Block'] = 1] = 'Block';\n      BreakType[BreakType['Wrap'] = 2] = 'Wrap';\n      BreakType[BreakType['Eol'] = 3] = 'Eol';\n    }(BreakType || (BreakType = {})));\n    const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\n    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\n    const getBreakType = (scope, direction, currentPos, nextPos) => {\n      if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {\n        return BreakType.Br;\n      } else if (isInSameBlock(currentPos, nextPos) === false) {\n        return BreakType.Block;\n      } else {\n        return BreakType.Wrap;\n      }\n    };\n    const getPositionsUntil = (predicate, direction, scope, start) => {\n      const caretWalker = CaretWalker(scope);\n      let currentPos = start;\n      const positions = [];\n      while (currentPos) {\n        const nextPos = walk$1(direction, caretWalker, currentPos);\n        if (!nextPos) {\n          break;\n        }\n        if (isBr$6(nextPos.getNode(false))) {\n          if (direction === HDirection.Forwards) {\n            return {\n              positions: flip(direction, positions).concat([nextPos]),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          } else {\n            return {\n              positions: flip(direction, positions),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          }\n        }\n        if (!nextPos.isVisible()) {\n          currentPos = nextPos;\n          continue;\n        }\n        if (predicate(currentPos, nextPos)) {\n          const breakType = getBreakType(scope, direction, currentPos, nextPos);\n          return {\n            positions: flip(direction, positions),\n            breakType,\n            breakAt: Optional.some(nextPos)\n          };\n        }\n        positions.push(nextPos);\n        currentPos = nextPos;\n      }\n      return {\n        positions: flip(direction, positions),\n        breakType: BreakType.Eol,\n        breakAt: Optional.none()\n      };\n    };\n    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\n      const positions = getPositionsUntilBreak(scope, pos).positions;\n      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\n    }).getOr([]);\n    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\n      const lastDist = Math.abs(x - lastRect.left);\n      const newDist = Math.abs(x - newRect.left);\n      return newDist <= lastDist ? newPos : lastPos;\n    }).or(acc)), Optional.none());\n    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\n    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\n    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\n    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\n    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\n    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\n    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\n    const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\n    const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\n    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);\n    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);\n\n    const isContentEditableFalse$4 = isContentEditableFalse$b;\n    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\n    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\n      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\n      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\n      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {\n        return clientRect;\n      }\n      if (newDistance < oldDistance) {\n        return clientRect;\n      }\n      return oldClientRect;\n    });\n\n    const getNodeClientRects = node => {\n      const toArrayWithNode = clientRects => {\n        return map$3(clientRects, rect => {\n          const clientRect = clone$1(rect);\n          clientRect.node = node;\n          return clientRect;\n        });\n      };\n      if (isElement$6(node)) {\n        return toArrayWithNode(node.getClientRects());\n      } else if (isText$a(node)) {\n        const rng = node.ownerDocument.createRange();\n        rng.setStart(node, 0);\n        rng.setEnd(node, node.data.length);\n        return toArrayWithNode(rng.getClientRects());\n      } else {\n        return [];\n      }\n    };\n    const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\n\n    var VDirection;\n    (function (VDirection) {\n      VDirection[VDirection['Up'] = -1] = 'Up';\n      VDirection[VDirection['Down'] = 1] = 'Down';\n    }(VDirection || (VDirection = {})));\n    const findUntil = (direction, root, predicateFn, node) => {\n      let currentNode = node;\n      while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {\n        if (predicateFn(currentNode)) {\n          return;\n        }\n      }\n    };\n    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\n      let line = 0;\n      const result = [];\n      const add = node => {\n        let clientRects = getClientRects([node]);\n        if (direction === -1) {\n          clientRects = clientRects.reverse();\n        }\n        for (let i = 0; i < clientRects.length; i++) {\n          const clientRect = clientRects[i];\n          if (isBeflowFn(clientRect, targetClientRect)) {\n            continue;\n          }\n          if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {\n            line++;\n          }\n          clientRect.line = line;\n          if (predicateFn(clientRect)) {\n            return true;\n          }\n          result.push(clientRect);\n        }\n        return false;\n      };\n      const targetClientRect = last$2(caretPosition.getClientRects());\n      if (!targetClientRect) {\n        return result;\n      }\n      const node = caretPosition.getNode();\n      if (node) {\n        add(node);\n        findUntil(direction, root, add, node);\n      }\n      return result;\n    };\n    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\n    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\n    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\n    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\n    const getLastClientRect = caretPosition => {\n      return last$2(caretPosition.getClientRects());\n    };\n    const positionsUntil = (direction, root, predicateFn, node) => {\n      const caretWalker = CaretWalker(root);\n      let walkFn;\n      let isBelowFn;\n      let isAboveFn;\n      let caretPosition;\n      const result = [];\n      let line = 0;\n      if (direction === 1) {\n        walkFn = caretWalker.next;\n        isBelowFn = isBelow$1;\n        isAboveFn = isAbove$1;\n        caretPosition = CaretPosition.after(node);\n      } else {\n        walkFn = caretWalker.prev;\n        isBelowFn = isAbove$1;\n        isAboveFn = isBelow$1;\n        caretPosition = CaretPosition.before(node);\n      }\n      const targetClientRect = getLastClientRect(caretPosition);\n      do {\n        if (!caretPosition.isVisible()) {\n          continue;\n        }\n        const rect = getLastClientRect(caretPosition);\n        if (isAboveFn(rect, targetClientRect)) {\n          continue;\n        }\n        if (result.length > 0 && isBelowFn(rect, last$2(result))) {\n          line++;\n        }\n        const clientRect = clone$1(rect);\n        clientRect.position = caretPosition;\n        clientRect.line = line;\n        if (predicateFn(clientRect)) {\n          return result;\n        }\n        result.push(clientRect);\n      } while (caretPosition = walkFn(caretPosition));\n      return result;\n    };\n    const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\n    const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\n\n    const moveToRange = (editor, rng) => {\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, editor.selection.getRng());\n    };\n    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\n    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const forwards = direction === HDirection.Forwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forwards ? isBefore : isAfter;\n      if (!range.collapsed) {\n        const node = getSelectedNode(range);\n        if (isElement(node)) {\n          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\n        } else if (isCefAtEdgeSelected(editor)) {\n          const newRange = range.cloneRange();\n          newRange.collapse(direction === HDirection.Backwards);\n          return Optional.from(newRange);\n        }\n      }\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      if (isBeforeFn(caretPosition)) {\n        return selectNode(editor, caretPosition.getNode(!forwards));\n      }\n      let nextCaretPosition = getNextPosFn(caretPosition);\n      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\n      if (!nextCaretPosition) {\n        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\n      } else {\n        nextCaretPosition = normalizePosition(forwards, nextCaretPosition);\n      }\n      if (isBeforeFn(nextCaretPosition)) {\n        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\n      }\n      const peekCaretPosition = getNextPosFn(nextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\n        }\n      }\n      if (rangeIsInContainerBlock) {\n        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\n      }\n      return Optional.none();\n    };\n    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const caretClientRect = last$2(caretPosition.getClientRects());\n      const forwards = direction === VDirection.Down;\n      const root = editor.getBody();\n      if (!caretClientRect) {\n        return Optional.none();\n      }\n      if (isCefAtEdgeSelected(editor)) {\n        const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);\n        const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;\n        return getClosestFn(root, caretPosition).orThunk(() => Optional.from(caretPosition)).map(pos => pos.toRange());\n      }\n      const walkerFn = forwards ? downUntil : upUntil;\n      const linePositions = walkerFn(root, isAboveLine(1), caretPosition);\n      const nextLinePositions = filter$5(linePositions, isLine(1));\n      const clientX = caretClientRect.left;\n      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\n      if (nextLineRect && isElement(nextLineRect.node)) {\n        const dist1 = Math.abs(clientX - nextLineRect.left);\n        const dist2 = Math.abs(clientX - nextLineRect.right);\n        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\n      }\n      let currentNode;\n      if (isBefore(caretPosition)) {\n        currentNode = caretPosition.getNode();\n      } else if (isAfter(caretPosition)) {\n        currentNode = caretPosition.getNode(true);\n      } else {\n        currentNode = getSelectedNode(range);\n      }\n      if (currentNode) {\n        const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);\n        let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n        closestNextLineRect = last$2(filter$5(caretPositions, isLine(0)));\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n      }\n      if (nextLinePositions.length === 0) {\n        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\n      }\n      return Optional.none();\n    };\n    const getLineEndPoint = (editor, forward) => {\n      const rng = editor.selection.getRng();\n      const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      const host = getEditingHost(from.container(), editor.getBody());\n      if (forward) {\n        const lineInfo = getPositionsUntilNextLine(host, from);\n        return last$3(lineInfo.positions);\n      } else {\n        const lineInfo = getPositionsUntilPreviousLine(host, from);\n        return head(lineInfo.positions);\n      }\n    };\n    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    });\n\n    const setCaretPosition = (editor, pos) => {\n      const rng = editor.dom.createRng();\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      editor.selection.setRng(rng);\n    };\n    const setSelected = (state, elm) => {\n      if (state) {\n        elm.setAttribute('data-mce-selected', 'inline-boundary');\n      } else {\n        elm.removeAttribute('data-mce-selected');\n      }\n    };\n    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\n      setCaretPosition(editor, pos);\n      return location;\n    });\n    const getPositionFromRange = (range, root, forward) => {\n      const start = CaretPosition.fromRangeStart(range);\n      if (range.collapsed) {\n        return start;\n      } else {\n        const end = CaretPosition.fromRangeEnd(range);\n        return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);\n      }\n    };\n    const findLocation = (editor, caret, forward) => {\n      const rootNode = editor.getBody();\n      const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\n      return location.bind(location => renderCaretLocation(editor, caret, location));\n    };\n    const toggleInlines = (isInlineTarget, dom, elms) => {\n      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\n      const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);\n      const targetInlines = filter$5(elms, isInlineTarget);\n      each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));\n      each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));\n    };\n    const safeRemoveCaretContainer = (editor, caret) => {\n      const caretValue = caret.get();\n      if (editor.selection.isCollapsed() && !editor.composing && caretValue) {\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {\n          setCaretPosition(editor, removeAndReposition(caretValue, pos));\n          caret.set(null);\n        }\n      }\n    };\n    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\n      if (editor.selection.isCollapsed()) {\n        const inlines = filter$5(elms, isInlineTarget);\n        each$e(inlines, _inline => {\n          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n          readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\n        });\n      }\n    };\n    const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\n    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\n    const setupSelectedState = editor => {\n      const caret = Cell(null);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.on('NodeChange', e => {\n        if (isInlineBoundariesEnabled(editor)) {\n          toggleInlines(isInlineTarget$1, editor.dom, e.parents);\n          safeRemoveCaretContainer(editor, caret);\n          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\n        }\n      });\n      return caret;\n    };\n    const moveNextWord = curry(moveWord, true);\n    const movePrevWord = curry(moveWord, false);\n    const moveToLineEndPoint$2 = (editor, forward, caret) => {\n      if (isInlineBoundariesEnabled(editor)) {\n        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\n          const rng = editor.selection.getRng();\n          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n        });\n        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\n          const outsideLoc = outside(loc);\n          return renderCaret(caret, outsideLoc).exists(pos => {\n            setCaretPosition(editor, pos);\n            return true;\n          });\n        });\n      } else {\n        return false;\n      }\n    };\n\n    const rangeFromPositions = (from, to) => {\n      const range = document.createRange();\n      range.setStart(from.container(), from.offset());\n      range.setEnd(to.container(), to.offset());\n      return range;\n    };\n    const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\n    }).getOr(true);\n    const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\n    const deleteFromTo = (editor, caret, from, to) => {\n      const rootNode = editor.getBody();\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.undoManager.ignore(() => {\n        editor.selection.setRng(rangeFromPositions(from, to));\n        execNativeDeleteCommand(editor);\n        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\n      });\n      editor.nodeChanged();\n    };\n    const rescope = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\n      const rootNode = rescope(editor.getBody(), from.container());\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\n      const location = fromLocation.bind(location => {\n        if (forward) {\n          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\n        } else {\n          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\n        }\n      });\n      return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\n        const toPosition = navigate(forward, rootNode, from);\n        const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\n        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\n          if (hasOnlyTwoOrLessPositionsLeft(elm)) {\n            return Optional.some(() => {\n              deleteElement$2(editor, forward, SugarElement.fromDom(elm));\n            });\n          } else {\n            return Optional.none();\n          }\n        })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\n          return () => {\n            if (forward) {\n              deleteFromTo(editor, caret, from, to);\n            } else {\n              deleteFromTo(editor, caret, to, from);\n            }\n          };\n        })));\n      });\n    };\n    const backspaceDelete$4 = (editor, caret, forward) => {\n      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\n        const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return backspaceDeleteCollapsed(editor, caret, forward, from);\n      }\n      return Optional.none();\n    };\n\n    const hasMultipleChildren = elm => childNodesCount(elm) > 1;\n    const getParentsUntil = (editor, pred) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      const startElm = SugarElement.fromDom(editor.selection.getStart());\n      const parents = parentsAndSelf(startElm, rootElm);\n      return findIndex$2(parents, pred).fold(constant(parents), index => parents.slice(0, index));\n    };\n    const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\n    const getParentInlinesUntilMultichildInline = editor => getParentsUntil(editor, elm => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm));\n    const getParentInlines = editor => getParentsUntil(editor, el => editor.schema.isBlock(name(el)));\n    const getFormatNodes = (editor, parentInlines) => {\n      const isFormatElement$1 = curry(isFormatElement, editor);\n      return bind$3(parentInlines, elm => isFormatElement$1(elm) ? [elm.dom] : []);\n    };\n    const getFormatNodesAtStart = editor => {\n      const parentInlines = getParentInlines(editor);\n      return getFormatNodes(editor, parentInlines);\n    };\n    const deleteLastPosition = (forward, editor, target, parentInlines) => {\n      const formatNodes = getFormatNodes(editor, parentInlines);\n      if (formatNodes.length === 0) {\n        deleteElement$2(editor, forward, target);\n      } else {\n        const pos = replaceWithCaretFormat(target.dom, formatNodes);\n        editor.selection.setRng(pos.toRange());\n      }\n    };\n    const deleteCaret$1 = (editor, forward) => {\n      const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);\n      return last$3(parentInlines).bind(target => {\n        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\n          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n    const isBrInEmptyElement = (editor, elm) => {\n      const parentElm = elm.parentElement;\n      return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);\n    };\n    const isEmptyCaret = elm => isEmptyCaretFormatElement(SugarElement.fromDom(elm));\n    const createCaretFormatAtStart = (editor, formatNodes) => {\n      const startElm = editor.selection.getStart();\n      const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);\n      editor.selection.setRng(pos.toRange());\n    };\n    const updateCaretFormat = (editor, updateFormats) => {\n      const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));\n      if (missingFormats.length > 0) {\n        createCaretFormatAtStart(editor, missingFormats);\n      }\n    };\n    const rangeStartsAtTextContainer = rng => isText$a(rng.startContainer);\n    const rangeStartsAtStartOfTextContainer = rng => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);\n    const rangeStartParentIsFormatElement = (editor, rng) => {\n      const startParent = rng.startContainer.parentElement;\n      return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));\n    };\n    const rangeStartAndEndHaveSameParent = rng => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);\n    };\n    const rangeEndsAtEndOfEndContainer = rng => {\n      const endContainer = rng.endContainer;\n      return rng.endOffset === (isText$a(endContainer) ? endContainer.length : endContainer.childNodes.length);\n    };\n    const rangeEndsAtEndOfStartContainer = rng => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);\n    const rangeEndsAfterEndOfStartContainer = rng => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);\n    const rangeEndsAtOrAfterEndOfStartContainer = rng => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);\n    const requiresDeleteRangeOverride = editor => {\n      const rng = editor.selection.getRng();\n      return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);\n    };\n    const deleteRange$1 = editor => {\n      if (requiresDeleteRangeOverride(editor)) {\n        const formatNodes = getFormatNodesAtStart(editor);\n        return Optional.some(() => {\n          execNativeDeleteCommand(editor);\n          updateCaretFormat(editor, formatNodes);\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);\n    const hasAncestorInlineCaret = (elm, schema) => ancestor$1(elm, node => isCaretNode(node.dom), el => schema.isBlock(name(el)));\n    const hasAncestorInlineCaretAtStart = editor => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()), editor.schema);\n    const requiresRefreshCaretOverride = editor => {\n      const rng = editor.selection.getRng();\n      return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);\n    };\n    const refreshCaret = editor => {\n      if (requiresRefreshCaretOverride(editor)) {\n        createCaretFormatAtStart(editor, []);\n      }\n      return true;\n    };\n\n    const deleteElement = (editor, forward, element) => {\n      if (isNonNullable(element)) {\n        return Optional.some(() => {\n          editor._selectionOverrides.hideFakeCaret();\n          deleteElement$2(editor, forward, SugarElement.fromDom(element));\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteCaret = (editor, forward) => {\n      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\n      if (isNearMedia(fromPos)) {\n        return deleteElement(editor, forward, fromPos.getNode(!forward));\n      } else {\n        return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind(pos => deleteElement(editor, forward, pos.getNode(!forward)));\n      }\n    };\n    const deleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\n    };\n    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\n\n    const isEditable = target => closest$4(target, elm => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists(elm => isContentEditableTrue$3(elm.dom));\n    const parseIndentValue = value => toInt(value !== null && value !== void 0 ? value : '').getOr(0);\n    const getIndentStyleName = (useMargin, element) => {\n      const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';\n      const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\n      return indentStyleName + suffix;\n    };\n    const indentElement = (dom, command, useMargin, value, unit, element) => {\n      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\n      const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));\n      if (command === 'outdent') {\n        const styleValue = Math.max(0, parsedValue - value);\n        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\n      } else {\n        const styleValue = parsedValue + value + unit;\n        dom.setStyle(element, indentStyleName, styleValue);\n      }\n    };\n    const validateBlocks = (editor, blocks) => forall(blocks, block => {\n      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\n      const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);\n      const contentEditable = editor.dom.getContentEditable(block.dom);\n      return contentEditable !== 'false' && intentValue > 0;\n    });\n    const canOutdent = editor => {\n      const blocks = getBlocksToIndent(editor);\n      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\n    };\n    const isListComponent = el => isList(el) || isListItem$1(el);\n    const parentIsListComponent = el => parent(el).exists(isListComponent);\n    const getBlocksToIndent = editor => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));\n    const handle = (editor, command) => {\n      var _a, _b;\n      const {dom} = editor;\n      const indentation = getIndentation(editor);\n      const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';\n      const indentValue = parseIndentValue(indentation);\n      const useMargin = shouldIndentUseMargin(editor);\n      each$e(getBlocksToIndent(editor), block => {\n        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\n      });\n    };\n    const indent = editor => handle(editor, 'indent');\n    const outdent = editor => handle(editor, 'outdent');\n\n    const backspaceDelete$1 = editor => {\n      if (editor.selection.isCollapsed() && canOutdent(editor)) {\n        const dom = editor.dom;\n        const rng = editor.selection.getRng();\n        const pos = CaretPosition.fromRangeStart(rng);\n        const block = dom.getParent(rng.startContainer, dom.isBlock);\n        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)) {\n          return Optional.some(() => outdent(editor));\n        }\n      }\n      return Optional.none();\n    };\n\n    const findAction = (editor, caret, forward) => findMap([\n      backspaceDelete$1,\n      backspaceDelete$6,\n      backspaceDelete$7,\n      (editor, forward) => backspaceDelete$4(editor, caret, forward),\n      backspaceDelete$9,\n      backspaceDelete$a,\n      backspaceDelete$5,\n      backspaceDelete$2,\n      backspaceDelete$8,\n      backspaceDelete$3\n    ], item => item(editor, forward)).filter(_ => editor.selection.isEditable());\n    const deleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, false);\n      result.fold(() => {\n        if (editor.selection.isEditable()) {\n          execNativeDeleteCommand(editor);\n          paddEmptyBody(editor);\n        }\n      }, call);\n    };\n    const forwardDeleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, true);\n      result.fold(() => {\n        if (editor.selection.isEditable()) {\n          execNativeForwardDeleteCommand(editor);\n        }\n      }, call);\n    };\n    const setup$q = (editor, caret) => {\n      editor.addCommand('delete', () => {\n        deleteCommand(editor, caret);\n      });\n      editor.addCommand('forwardDelete', () => {\n        forwardDeleteCommand(editor, caret);\n      });\n    };\n\n    const SIGNIFICANT_MOVE = 5;\n    const LONGPRESS_DELAY = 400;\n    const getTouch = event => {\n      if (event.touches === undefined || event.touches.length !== 1) {\n        return Optional.none();\n      }\n      return Optional.some(event.touches[0]);\n    };\n    const isFarEnough = (touch, data) => {\n      const distX = Math.abs(touch.clientX - data.x);\n      const distY = Math.abs(touch.clientY - data.y);\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n    };\n    const setup$p = editor => {\n      const startData = value$2();\n      const longpressFired = Cell(false);\n      const debounceLongpress = last$1(e => {\n        editor.dispatch('longpress', {\n          ...e,\n          type: 'longpress'\n        });\n        longpressFired.set(true);\n      }, LONGPRESS_DELAY);\n      editor.on('touchstart', e => {\n        getTouch(e).each(touch => {\n          debounceLongpress.cancel();\n          const data = {\n            x: touch.clientX,\n            y: touch.clientY,\n            target: e.target\n          };\n          debounceLongpress.throttle(e);\n          longpressFired.set(false);\n          startData.set(data);\n        });\n      }, true);\n      editor.on('touchmove', e => {\n        debounceLongpress.cancel();\n        getTouch(e).each(touch => {\n          startData.on(data => {\n            if (isFarEnough(touch, data)) {\n              startData.clear();\n              longpressFired.set(false);\n              editor.dispatch('longpresscancel');\n            }\n          });\n        });\n      }, true);\n      editor.on('touchend touchcancel', e => {\n        debounceLongpress.cancel();\n        if (e.type === 'touchcancel') {\n          return;\n        }\n        startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\n          if (longpressFired.get()) {\n            e.preventDefault();\n          } else {\n            editor.dispatch('tap', {\n              ...e,\n              type: 'tap'\n            });\n          }\n        });\n      }, true);\n    };\n\n    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\n    const isValidTarget = (schema, node) => {\n      if (isText$a(node)) {\n        return true;\n      } else if (isElement$6(node)) {\n        return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node) && !isNonHtmlElementRoot(node);\n      } else {\n        return false;\n      }\n    };\n    const hasBlockParent = (blockElements, root, node) => {\n      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\n        return isBlockElement(blockElements, elm.dom);\n      });\n    };\n    const shouldRemoveTextNode = (blockElements, node) => {\n      if (isText$a(node)) {\n        if (node.data.length === 0) {\n          return true;\n        } else if (/^\\s+$/.test(node.data)) {\n          return !node.nextSibling || isBlockElement(blockElements, node.nextSibling) || isNonHtmlElementRoot(node.nextSibling);\n        }\n      }\n      return false;\n    };\n    const createRootBlock = editor => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n    const addRootBlocks = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const schema = editor.schema;\n      const blockElements = schema.getBlockElements();\n      const startNode = selection.getStart();\n      const rootNode = editor.getBody();\n      let rootBlockNode;\n      let tempNode;\n      let wrapped = false;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!startNode || !isElement$6(startNode)) {\n        return;\n      }\n      const rootNodeName = rootNode.nodeName.toLowerCase();\n      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {\n        return;\n      }\n      const rng = selection.getRng();\n      const {startContainer, startOffset, endContainer, endOffset} = rng;\n      const restoreSelection = hasFocus(editor);\n      let node = rootNode.firstChild;\n      while (node) {\n        if (isElement$6(node)) {\n          updateElement(schema, node);\n        }\n        if (isValidTarget(schema, node)) {\n          if (shouldRemoveTextNode(blockElements, node)) {\n            tempNode = node;\n            node = node.nextSibling;\n            dom.remove(tempNode);\n            continue;\n          }\n          if (!rootBlockNode) {\n            rootBlockNode = createRootBlock(editor);\n            rootNode.insertBefore(rootBlockNode, node);\n            wrapped = true;\n          }\n          tempNode = node;\n          node = node.nextSibling;\n          rootBlockNode.appendChild(tempNode);\n        } else {\n          rootBlockNode = null;\n          node = node.nextSibling;\n        }\n      }\n      if (wrapped && restoreSelection) {\n        rng.setStart(startContainer, startOffset);\n        rng.setEnd(endContainer, endOffset);\n        selection.setRng(rng);\n        editor.nodeChanged();\n      }\n    };\n    const insertEmptyLine = (editor, root, insertBlock) => {\n      const block = SugarElement.fromDom(createRootBlock(editor));\n      const br = createPaddingBr();\n      append$1(block, br);\n      insertBlock(root, block);\n      const rng = document.createRange();\n      rng.setStartBefore(br.dom);\n      rng.setEndBefore(br.dom);\n      return rng;\n    };\n    const setup$o = editor => {\n      editor.on('NodeChange', curry(addRootBlocks, editor));\n    };\n\n    const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n    const replaceMatchWithSpan = (editor, content, cls) => {\n      return function (match) {\n        const args = arguments, index = args[args.length - 2];\n        const prevChar = index > 0 ? content.charAt(index - 1) : '';\n        if (prevChar === '\"') {\n          return match;\n        }\n        if (prevChar === '>') {\n          const findStartTagIndex = content.lastIndexOf('<', index);\n          if (findStartTagIndex !== -1) {\n            const tagHtml = content.substring(findStartTagIndex, index);\n            if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n              return match;\n            }\n          }\n        }\n        return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n      };\n    };\n    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\n      let i = nonEditableRegExps.length, content = e.content;\n      if (e.format === 'raw') {\n        return;\n      }\n      while (i--) {\n        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\n      }\n      e.content = content;\n    };\n    const isValidContent = (nonEditableRegExps, content) => {\n      return forall(nonEditableRegExps, re => {\n        const matches = content.match(re);\n        return matches !== null && matches[0].length === content.length;\n      });\n    };\n    const setup$n = editor => {\n      const contentEditableAttrName = 'contenteditable';\n      const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\n      const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\n      const hasEditClass = hasClass(editClass);\n      const hasNonEditClass = hasClass(nonEditClass);\n      const nonEditableRegExps = getNonEditableRegExps(editor);\n      if (nonEditableRegExps.length > 0) {\n        editor.on('BeforeSetContent', e => {\n          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n        });\n      }\n      editor.parser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (hasEditClass(node)) {\n            node.attr(contentEditableAttrName, 'true');\n          } else if (hasNonEditClass(node)) {\n            node.attr(contentEditableAttrName, 'false');\n          }\n        }\n      });\n      editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (!hasEditClass(node) && !hasNonEditClass(node)) {\n            continue;\n          }\n          const content = node.attr('data-mce-content');\n          if (nonEditableRegExps.length > 0 && content) {\n            if (isValidContent(nonEditableRegExps, content)) {\n              node.name = '#text';\n              node.type = 3;\n              node.raw = true;\n              node.value = content;\n            } else {\n              node.remove();\n            }\n          } else {\n            node.attr(contentEditableAttrName, null);\n          }\n        }\n      });\n    };\n\n    const findBlockCaretContainer = editor => descendant$1(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\n    const showBlockCaretContainer = (editor, blockCaretContainer) => {\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n        showCaretContainerBlock(blockCaretContainer);\n        editor.selection.setRng(editor.selection.getRng());\n        editor.selection.scrollIntoView(blockCaretContainer);\n      }\n    };\n    const handleBlockContainer = (editor, e) => {\n      const blockCaretContainer = findBlockCaretContainer(editor);\n      if (!blockCaretContainer) {\n        return;\n      }\n      if (e.type === 'compositionstart') {\n        e.preventDefault();\n        e.stopPropagation();\n        showBlockCaretContainer(editor, blockCaretContainer);\n        return;\n      }\n      if (hasContent(blockCaretContainer)) {\n        showBlockCaretContainer(editor, blockCaretContainer);\n        editor.undoManager.add();\n      }\n    };\n    const setup$m = editor => {\n      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\n    };\n\n    const isContentEditableFalse$3 = isContentEditableFalse$b;\n    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);\n    const moveToCeFalseVertically = (direction, editor, range) => {\n      const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\n      const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\n      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$3);\n    };\n    const createTextBlock = editor => {\n      const textBlock = editor.dom.create(getForcedRootBlock(editor));\n      textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\n      return textBlock;\n    };\n    const exitPreBlock = (editor, direction, range) => {\n      const caretWalker = CaretWalker(editor.getBody());\n      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\n      if (range.collapsed) {\n        const pre = editor.dom.getParent(range.startContainer, 'PRE');\n        if (!pre) {\n          return;\n        }\n        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\n        if (!caretPos) {\n          const newBlock = SugarElement.fromDom(createTextBlock(editor));\n          if (direction === 1) {\n            after$4(SugarElement.fromDom(pre), newBlock);\n          } else {\n            before$3(SugarElement.fromDom(pre), newBlock);\n          }\n          editor.selection.select(newBlock.dom, true);\n          editor.selection.collapse();\n        }\n      }\n    };\n    const getHorizontalRange = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const getVerticalRange = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const flipDirection = (selection, forward) => {\n      const elm = forward ? selection.getEnd(true) : selection.getStart(true);\n      return isRtl(elm) ? !forward : forward;\n    };\n    const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveToLineEndPoint$1 = (editor, forward) => {\n      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\n      return moveToLineEndPoint$3(editor, forward, isCefPosition);\n    };\n    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map(pos => {\n      const rng = pos.toRange();\n      const curRng = editor.selection.getRng();\n      if (forward) {\n        rng.setStart(curRng.startContainer, curRng.startOffset);\n      } else {\n        rng.setEnd(curRng.endContainer, curRng.endOffset);\n      }\n      return rng;\n    }).exists(rng => {\n      moveToRange(editor, rng);\n      return true;\n    });\n\n    const isTarget = node => contains$2(['figcaption'], name(node));\n    const getClosestTargetBlock = (pos, root, schema) => {\n      const isRoot = curry(eq, root);\n      return closest$4(SugarElement.fromDom(pos.container()), el => schema.isBlock(name(el)), isRoot).filter(isTarget);\n    };\n    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\n    const moveCaretToNewEmptyLine = (editor, forward) => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getClosestTargetBlock(pos, root, editor.schema).exists(() => {\n        if (isAtFirstOrLastLine(root, forward, pos)) {\n          const insertFn = forward ? append$1 : prepend;\n          const rng = insertEmptyLine(editor, root, insertFn);\n          editor.selection.setRng(rng);\n          return true;\n        } else {\n          return false;\n        }\n      });\n    };\n    const moveV$3 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return moveCaretToNewEmptyLine(editor, forward);\n      } else {\n        return false;\n      }\n    };\n\n    const moveUp = (editor, details, summary) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (root.firstChild === details && isAtFirstLine(summary, pos)) {\n        editor.execCommand('InsertNewBlockBefore');\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const moveDown = (editor, details) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (root.lastChild === details && isAtLastLine(details, pos)) {\n        editor.execCommand('InsertNewBlockAfter');\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$2 = (editor, forward) => {\n      if (forward) {\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details')).map(details => moveDown(editor, details)).getOr(false);\n      } else {\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary')).bind(summary => Optional.from(editor.dom.getParent(summary, 'details')).map(details => moveUp(editor, details, summary))).getOr(false);\n      }\n    };\n    const moveV$2 = (editor, forward) => move$2(editor, forward);\n\n    const baseKeyPattern = {\n      shiftKey: false,\n      altKey: false,\n      ctrlKey: false,\n      metaKey: false,\n      keyCode: 0\n    };\n    const defaultPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      ...pattern\n    }));\n    const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      ...pattern\n    }));\n    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\n    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const action = (f, ...x) => () => f.apply(null, x);\n    const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\n    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\n\n    const moveH$1 = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveV$1 = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveToLineEndPoint = (editor, forward) => {\n      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\n      return moveToLineEndPoint$3(editor, forward, isNearMedia);\n    };\n\n    const adt = Adt.generate([\n      { none: ['current'] },\n      { first: ['current'] },\n      {\n        middle: [\n          'current',\n          'target'\n        ]\n      },\n      { last: ['current'] }\n    ]);\n    const none = current => adt.none(current);\n    const CellLocation = {\n      ...adt,\n      none\n    };\n\n    const firstLayer = (scope, selector) => {\n      return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n      return bind$3(children$1(scope), x => {\n        if (is$1(x, selector)) {\n          return predicate(x) ? [x] : [];\n        } else {\n          return filterFirstLayer(x, selector, predicate);\n        }\n      });\n    };\n\n    const lookup$1 = (tags, element, isRoot = never) => {\n      if (isRoot(element)) {\n        return Optional.none();\n      }\n      if (contains$2(tags, name(element))) {\n        return Optional.some(element);\n      }\n      const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\n      return ancestor$3(element, tags.join(','), isRootOrUpperTable);\n    };\n    const cell = (element, isRoot) => lookup$1([\n      'td',\n      'th'\n    ], element, isRoot);\n    const cells = ancestor => firstLayer(ancestor, 'th,td');\n    const table = (element, isRoot) => closest$3(element, 'table', isRoot);\n\n    const walk = (all, current, index, direction, isEligible = always) => {\n      const forwards = direction === 1;\n      if (!forwards && index <= 0) {\n        return CellLocation.first(all[0]);\n      } else if (forwards && index >= all.length - 1) {\n        return CellLocation.last(all[all.length - 1]);\n      } else {\n        const newIndex = index + direction;\n        const elem = all[newIndex];\n        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\n      }\n    };\n    const detect = (current, isRoot) => {\n      return table(current, isRoot).bind(table => {\n        const all = cells(table);\n        const index = findIndex$2(all, x => eq(current, x));\n        return index.map(index => ({\n          index,\n          all\n        }));\n      });\n    };\n    const next = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none(current);\n      }, info => {\n        return walk(info.all, current, info.index, 1, isEligible);\n      });\n    };\n    const prev = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none();\n      }, info => {\n        return walk(info.all, current, info.index, -1, isEligible);\n      });\n    };\n\n    const deflate = (rect, delta) => ({\n      left: rect.left - delta,\n      top: rect.top - delta,\n      right: rect.right + delta * 2,\n      bottom: rect.bottom + delta * 2,\n      width: rect.width + delta,\n      height: rect.height + delta\n    });\n    const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\n      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\n      return [\n        {\n          x: rect.left,\n          y: getYAxisValue(rect),\n          cell: td\n        },\n        {\n          x: rect.right,\n          y: getYAxisValue(rect),\n          cell: td\n        }\n      ];\n    });\n    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\n      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\n      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\n      return Optional.some(newDist < oldDist ? newCorner : oldCorner);\n    }), Optional.none());\n    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\n      const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\n      const corners = filter$5(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\n      return findClosestCorner(corners, x, y).map(corner => corner.cell);\n    };\n    const getBottomValue = rect => rect.bottom;\n    const getTopValue = rect => rect.top;\n    const isAbove = (corner, y) => corner.y < y;\n    const isBelow = (corner, y) => corner.y > y;\n    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\n    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\n    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\n    const findClosestPositionInBelowCell = (table, pos) => last$3(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\n\n    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\n    const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\n    const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\n    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\n      const lineInfo = getPositionsUntil(scope, pos);\n      if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {\n        return !hasNextBreak(getPositionsUntil, scope, lineInfo);\n      } else {\n        return lineInfo.breakAt.isNone();\n      }\n    };\n    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\n    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\n    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\n    };\n    const navigateHorizontally = (editor, forward, table, _td) => {\n      const rng = editor.selection.getRng();\n      const direction = forward ? 1 : -1;\n      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\n        showCaret(direction, editor, table, !forward, false).each(newRng => {\n          moveToRange(editor, newRng);\n        });\n        return true;\n      }\n      return false;\n    };\n    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\n    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\n    const getTable = (previous, pos) => {\n      const node = pos.getNode(previous);\n      return isTable$2(node) ? Optional.some(node) : Optional.none();\n    };\n    const renderBlock = (down, editor, table) => {\n      editor.undoManager.transact(() => {\n        const insertFn = down ? after$4 : before$3;\n        const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);\n        moveToRange(editor, rng);\n      });\n    };\n    const moveCaret = (editor, down, pos) => {\n      const table = down ? getTable(true, pos) : getTable(false, pos);\n      const last = down === false;\n      table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\n    };\n    const navigateVertically = (editor, down, table, td) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (!down && isAtFirstTableCellLine(td, pos)) {\n        const newPos = getClosestAbovePosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else if (down && isAtLastTableCellLine(td, pos)) {\n        const newPos = getClosestBelowPosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\n    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\n    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\n    const getCellFirstCursorPosition = cell => {\n      const selection = SimSelection.exact(cell, 0, cell, 0);\n      return toNative(selection);\n    };\n    const tabGo = (editor, isRoot, cell) => {\n      return cell.fold(Optional.none, Optional.none, (_current, next) => {\n        return first(next).map(cell => {\n          return getCellFirstCursorPosition(cell);\n        });\n      }, current => {\n        editor.execCommand('mceTableInsertRowAfter');\n        return tabForward(editor, isRoot, current);\n      });\n    };\n    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable$2));\n    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable$2));\n    const handleTab = (editor, forward) => {\n      const rootElements = [\n        'table',\n        'li',\n        'dl'\n      ];\n      const body = SugarElement.fromDom(editor.getBody());\n      const isRoot = element => {\n        const name$1 = name(element);\n        return eq(element, body) || contains$2(rootElements, name$1);\n      };\n      const rng = editor.selection.getRng();\n      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\n      return cell(container, isRoot).map(cell => {\n        table(cell, isRoot).each(table => {\n          editor.model.table.clearSelectedCells(table.dom);\n        });\n        editor.selection.collapse(!forward);\n        const navigation = !forward ? tabBackward : tabForward;\n        const rng = navigation(editor, isRoot, cell);\n        rng.each(range => {\n          editor.selection.setRng(range);\n        });\n        return true;\n      }).getOr(false);\n    };\n\n    const executeKeydownOverride$4 = (editor, caret, evt) => {\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      execute([\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$2, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$2, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$4, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$4, editor, true)\n        },\n        ...isMac ? [\n          {\n            keyCode: VK.UP,\n            action: action(selectToEndPoint, editor, false),\n            metaKey: true,\n            shiftKey: true\n          },\n          {\n            keyCode: VK.DOWN,\n            action: action(selectToEndPoint, editor, true),\n            metaKey: true,\n            shiftKey: true\n          }\n        ] : [],\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV, editor, true)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$2, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$2, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$1, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$1, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$1, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$1, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(move$3, editor, caret, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(move$3, editor, caret, false)\n        },\n        {\n          keyCode: VK.RIGHT,\n          ctrlKey: !isMac,\n          altKey: isMac,\n          action: action(moveNextWord, editor, caret)\n        },\n        {\n          keyCode: VK.LEFT,\n          ctrlKey: !isMac,\n          altKey: isMac,\n          action: action(movePrevWord, editor, caret)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$3, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$3, editor, true)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$l = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$4(editor, caret, evt);\n        }\n      });\n    };\n\n    const point = (container, offset) => ({\n      container,\n      offset\n    });\n\n    const DOM$7 = DOMUtils.DOM;\n    const alwaysNext = startNode => node => startNode === node ? -1 : 0;\n    const isBoundary = dom => node => dom.isBlock(node) || contains$2([\n      'BR',\n      'IMG',\n      'HR',\n      'INPUT'\n    ], node.nodeName) || dom.getContentEditable(node) === 'false';\n    const textBefore = (node, offset, rootNode) => {\n      if (isText$a(node) && offset >= 0) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\n      }\n    };\n    const textAfter = (node, offset, rootNode) => {\n      if (isText$a(node) && offset >= node.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\n      }\n    };\n    const scanLeft = (node, offset, rootNode) => {\n      if (!isText$a(node)) {\n        return Optional.none();\n      }\n      const text = node.data;\n      if (offset >= 0 && offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\n          const prevText = prev.container.data;\n          return scanLeft(prev.container, offset + prevText.length, rootNode);\n        });\n      }\n    };\n    const scanRight = (node, offset, rootNode) => {\n      if (!isText$a(node)) {\n        return Optional.none();\n      }\n      const text = node.data;\n      if (offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\n      }\n    };\n    const repeatLeft = (dom, node, offset, process, rootNode) => {\n      const search = TextSeeker(dom, isBoundary(dom));\n      return Optional.from(search.backwards(node, offset, process, rootNode));\n    };\n\n    const isValidTextRange = rng => rng.collapsed && isText$a(rng.startContainer);\n    const getText = rng => trim$2(rng.toString().replace(/\\u00A0/g, ' '));\n    const isWhitespace = chr => chr !== '' && ' \\xA0\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n    const stripTrigger = (text, trigger) => text.substring(trigger.length);\n    const findTrigger = (text, index, trigger) => {\n      let i;\n      const firstChar = trigger.charAt(0);\n      for (i = index - 1; i >= 0; i--) {\n        const char = text.charAt(i);\n        if (isWhitespace(char)) {\n          return Optional.none();\n        }\n        if (firstChar === char && contains$1(text, trigger, i, index)) {\n          break;\n        }\n      }\n      return Optional.some(i);\n    };\n    const findStart = (dom, initRange, trigger, minChars = 0) => {\n      if (!isValidTextRange(initRange)) {\n        return Optional.none();\n      }\n      const buffer = {\n        text: '',\n        offset: 0\n      };\n      const findTriggerIndex = (element, offset, text) => {\n        buffer.text = text + buffer.text;\n        buffer.offset += offset;\n        return findTrigger(buffer.text, buffer.offset, trigger).getOr(offset);\n      };\n      const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\n      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind(spot => {\n        const range = initRange.cloneRange();\n        range.setStart(spot.container, spot.offset);\n        range.setEnd(initRange.endContainer, initRange.endOffset);\n        if (range.collapsed) {\n          return Optional.none();\n        }\n        const text = getText(range);\n        const triggerIndex = text.lastIndexOf(trigger);\n        if (triggerIndex !== 0 || stripTrigger(text, trigger).length < minChars) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            text: stripTrigger(text, trigger),\n            range,\n            trigger\n          });\n        }\n      });\n    };\n    const getContext = (dom, initRange, trigger, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom, initRange, trigger, minChars), elm => {\n      const range = dom.createRng();\n      range.selectNode(elm.dom);\n      const text = getText(range);\n      return Optional.some({\n        range,\n        text: stripTrigger(text, trigger),\n        trigger\n      });\n    });\n\n    const isText$1 = node => node.nodeType === TEXT;\n    const isElement = node => node.nodeType === ELEMENT;\n    const toLast = node => {\n      if (isText$1(node)) {\n        return point(node, node.data.length);\n      } else {\n        const children = node.childNodes;\n        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\n      }\n    };\n    const toLeaf = (node, offset) => {\n      const children = node.childNodes;\n      if (children.length > 0 && offset < children.length) {\n        return toLeaf(children[offset], 0);\n      } else if (children.length > 0 && isElement(node) && children.length === offset) {\n        return toLast(children[children.length - 1]);\n      } else {\n        return point(node, offset);\n      }\n    };\n\n    const isPreviousCharContent = (dom, leaf) => {\n      var _a;\n      const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter(spot => {\n        const char = spot.container.data.charAt(spot.offset - 1);\n        return !isWhitespace(char);\n      }).isSome();\n    };\n    const isStartOfWord = dom => rng => {\n      const leaf = toLeaf(rng.startContainer, rng.startOffset);\n      return !isPreviousCharContent(dom, leaf);\n    };\n    const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, trigger => getContext(dom, initRange, trigger));\n    const lookup = (editor, getDatabase) => {\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\n    };\n    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {\n      var _a;\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';\n      const autocompleters = filter$5(database.lookupByTrigger(context.trigger), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\n      if (autocompleters.length === 0) {\n        return Optional.none();\n      }\n      const lookupData = Promise.all(map$3(autocompleters, ac => {\n        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\n        return fetchResult.then(results => ({\n          matchText: context.text,\n          items: results,\n          columns: ac.columns,\n          onAction: ac.onAction,\n          highlightOn: ac.highlightOn\n        }));\n      }));\n      return Optional.some({\n        lookupData,\n        context\n      });\n    };\n\n    var SimpleResultType;\n    (function (SimpleResultType) {\n      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n    }(SimpleResultType || (SimpleResultType = {})));\n    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n    const partition = results => {\n      const values = [];\n      const errors = [];\n      each$e(results, obj => {\n        fold$1(obj, err => errors.push(err), val => values.push(val));\n      });\n      return {\n        values,\n        errors\n      };\n    };\n    const mapError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return {\n          stype: SimpleResultType.Error,\n          serror: f(res.serror)\n        };\n      } else {\n        return res;\n      }\n    };\n    const map = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return {\n          stype: SimpleResultType.Value,\n          svalue: f(res.svalue)\n        };\n      } else {\n        return res;\n      }\n    };\n    const bind$1 = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return f(res.svalue);\n      } else {\n        return res;\n      }\n    };\n    const bindError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return f(res.serror);\n      } else {\n        return res;\n      }\n    };\n    const svalue = v => ({\n      stype: SimpleResultType.Value,\n      svalue: v\n    });\n    const serror = e => ({\n      stype: SimpleResultType.Error,\n      serror: e\n    });\n    const toResult = res => fold$1(res, Result.error, Result.value);\n    const fromResult = res => res.fold(serror, svalue);\n    const SimpleResult = {\n      fromResult,\n      toResult,\n      svalue,\n      partition,\n      serror,\n      bind: bind$1,\n      bindError,\n      map,\n      mapError,\n      fold: fold$1\n    };\n\n    const formatObj = input => {\n      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n    };\n    const formatErrors = errors => {\n      const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n          path: [],\n          getErrorInfo: constant('... (only showing first ten failures)')\n        }]) : errors;\n      return map$3(es, e => {\n        return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n      });\n    };\n\n    const nu = (path, getErrorInfo) => {\n      return SimpleResult.serror([{\n          path,\n          getErrorInfo\n        }]);\n    };\n    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n    const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n    const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n    const custom = (path, err) => nu(path, constant(err));\n\n    const chooseFrom = (path, input, branches, ch) => {\n      const fields = get$a(branches, ch);\n      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n    };\n    const choose$1 = (key, branches) => {\n      const extract = (path, input) => {\n        const choice = get$a(input, key);\n        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n      };\n      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const shallow = (old, nu) => {\n      return nu;\n    };\n    const deep = (old, nu) => {\n      const bothObjects = isPlainObject(old) && isPlainObject(nu);\n      return bothObjects ? deepMerge(old, nu) : nu;\n    };\n    const baseMerge = merger => {\n      return (...objects) => {\n        if (objects.length === 0) {\n          throw new Error(`Can't merge zero objects`);\n        }\n        const ret = {};\n        for (let j = 0; j < objects.length; j++) {\n          const curObject = objects[j];\n          for (const key in curObject) {\n            if (has$2(curObject, key)) {\n              ret[key] = merger(ret[key], curObject[key]);\n            }\n          }\n        }\n        return ret;\n      };\n    };\n    const deepMerge = baseMerge(deep);\n    const merge = baseMerge(shallow);\n\n    const required = () => ({\n      tag: 'required',\n      process: {}\n    });\n    const defaultedThunk = fallbackThunk => ({\n      tag: 'defaultedThunk',\n      process: fallbackThunk\n    });\n    const defaulted$1 = fallback => defaultedThunk(constant(fallback));\n    const asOption = () => ({\n      tag: 'option',\n      process: {}\n    });\n\n    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\n    const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\n    const consolidateObj = (objects, base) => {\n      const partition = SimpleResult.partition(objects);\n      return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\n    };\n    const consolidateArr = objects => {\n      const partitions = SimpleResult.partition(objects);\n      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\n    };\n    const ResultCombine = {\n      consolidateObj,\n      consolidateArr\n    };\n\n    const field$1 = (key, newKey, presence, prop) => ({\n      tag: 'field',\n      key,\n      newKey,\n      presence,\n      prop\n    });\n    const customField$1 = (newKey, instantiator) => ({\n      tag: 'custom',\n      newKey,\n      instantiator\n    });\n    const fold = (value, ifField, ifCustom) => {\n      switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n      }\n    };\n\n    const value = validator => {\n      const extract = (path, val) => {\n        return SimpleResult.bindError(validator(val), err => custom(path, err));\n      };\n      const toString = constant('val');\n      return {\n        extract,\n        toString\n      };\n    };\n    const anyValue$1 = value(SimpleResult.svalue);\n\n    const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n    const fallbackAccess = (obj, key, fallback, bundle) => {\n      const v = get$a(obj, key).getOrThunk(() => fallback(obj));\n      return bundle(v);\n    };\n    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\n    const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n      const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\n      return bundle(opt);\n    };\n    const extractField = (field, path, obj, key, prop) => {\n      const bundle = av => prop.extract(path.concat([key]), av);\n      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n        const result = prop.extract(path.concat([key]), ov);\n        return SimpleResult.map(result, Optional.some);\n      });\n      switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n      case 'mergeWithThunk': {\n          return fallbackAccess(obj, key, constant({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n      }\n    };\n    const extractFields = (path, obj, fields) => {\n      const success = {};\n      const errors = [];\n      for (const field of fields) {\n        fold(field, (key, newKey, presence, prop) => {\n          const result = extractField(presence, path, obj, key, prop);\n          SimpleResult.fold(result, err => {\n            errors.push(...err);\n          }, res => {\n            success[newKey] = res;\n          });\n        }, (newKey, instantiator) => {\n          success[newKey] = instantiator(obj);\n        });\n      }\n      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n    };\n    const objOf = values => {\n      const extract = (path, o) => extractFields(path, o, values);\n      const toString = () => {\n        const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n        return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n      };\n      return {\n        extract,\n        toString\n      };\n    };\n    const arrOf = prop => {\n      const extract = (path, array) => {\n        const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n        return ResultCombine.consolidateArr(results);\n      };\n      const toString = () => 'array(' + prop.toString() + ')';\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n    const extractValue = (label, prop, obj) => {\n      const res = prop.extract([label], obj);\n      return SimpleResult.mapError(res, errs => ({\n        input: obj,\n        errors: errs\n      }));\n    };\n    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n    const formatError = errInfo => {\n      return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n    };\n    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\n\n    const anyValue = constant(anyValue$1);\n    const typedValue = (validator, expectedType) => value(a => {\n      const actualType = typeof a;\n      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);\n    });\n    const number = typedValue(isNumber, 'number');\n    const string = typedValue(isString, 'string');\n    const boolean = typedValue(isBoolean, 'boolean');\n    const functionProcessor = typedValue(isFunction, 'function');\n\n    const field = field$1;\n    const customField = customField$1;\n    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${ value }\", choose one of \"${ values.join(', ') }\".`));\n    const requiredOf = (key, schema) => field(key, key, required(), schema);\n    const requiredString = key => requiredOf(key, string);\n    const requiredFunction = key => requiredOf(key, functionProcessor);\n    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\n    const optionOf = (key, schema) => field(key, key, asOption(), schema);\n    const optionString = key => optionOf(key, string);\n    const optionFunction = key => optionOf(key, functionProcessor);\n    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\n    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\n    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n\n    const type = requiredString('type');\n    const fetch$1 = requiredFunction('fetch');\n    const onAction = requiredFunction('onAction');\n    const onSetup = defaultedFunction('onSetup', () => noop);\n    const optionalText = optionString('text');\n    const optionalIcon = optionString('icon');\n    const optionalTooltip = optionString('tooltip');\n    const optionalLabel = optionString('label');\n    const active = defaultedBoolean('active', false);\n    const enabled = defaultedBoolean('enabled', true);\n    const primary = defaultedBoolean('primary', false);\n    const defaultedColumns = num => defaulted('columns', num);\n    const defaultedType = type => defaultedString('type', type);\n\n    const autocompleterSchema = objOf([\n      type,\n      requiredString('trigger'),\n      defaultedNumber('minChars', 1),\n      defaultedColumns(1),\n      defaultedNumber('maxResults', 10),\n      optionFunction('matches'),\n      fetch$1,\n      onAction,\n      defaultedArrayOf('highlightOn', [], string)\n    ]);\n    const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, {\n      trigger: spec.ch,\n      ...spec\n    });\n\n    const baseToolbarButtonFields = [\n      enabled,\n      optionalTooltip,\n      optionalIcon,\n      optionalText,\n      onSetup\n    ];\n\n    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n\n    const contextBarFields = [\n      defaultedFunction('predicate', never),\n      defaultedStringEnum('scope', 'node', [\n        'node',\n        'editor'\n      ]),\n      defaultedStringEnum('position', 'selection', [\n        'node',\n        'selection',\n        'line'\n      ])\n    ];\n\n    const contextButtonFields = baseToolbarButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n    const toggleOrNormal = choose('type', {\n      contextformbutton: contextButtonFields,\n      contextformtogglebutton: contextToggleButtonFields\n    });\n    objOf([\n      defaultedType('contextform'),\n      defaultedFunction('initValue', constant('')),\n      optionalLabel,\n      requiredArrayOf('commands', toggleOrNormal),\n      optionOf('launch', choose('type', {\n        contextformbutton: launchButtonFields,\n        contextformtogglebutton: launchToggleButtonFields\n      }))\n    ].concat(contextBarFields));\n\n    const register$2 = editor => {\n      const popups = editor.ui.registry.getAll().popups;\n      const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\n        throw new Error(formatError(err));\n      }, identity));\n      const triggers = stringArray(mapToArray(dataset, v => v.trigger));\n      const datasetValues = values(dataset);\n      const lookupByTrigger = trigger => filter$5(datasetValues, dv => dv.trigger === trigger);\n      return {\n        dataset,\n        triggers,\n        lookupByTrigger\n      };\n    };\n\n    const setupEditorInput = (editor, api) => {\n      const update = last$1(api.load, 50);\n      editor.on('keypress compositionend', e => {\n        if (e.which === 27) {\n          return;\n        }\n        update.throttle();\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.which;\n        if (keyCode === 8) {\n          update.throttle();\n        } else if (keyCode === 27) {\n          api.cancelIfNecessary();\n        }\n      });\n      editor.on('remove', update.cancel);\n    };\n    const setup$k = editor => {\n      const activeAutocompleter = value$2();\n      const uiActive = Cell(false);\n      const isActive = activeAutocompleter.isSet;\n      const cancelIfNecessary = () => {\n        if (isActive()) {\n          removeAutocompleterDecoration(editor);\n          fireAutocompleterEnd(editor);\n          uiActive.set(false);\n          activeAutocompleter.clear();\n        }\n      };\n      const commenceIfNecessary = context => {\n        if (!isActive()) {\n          addAutocompleterDecoration(editor, context.range);\n          activeAutocompleter.set({\n            trigger: context.trigger,\n            matchLength: context.text.length\n          });\n        }\n      };\n      const getAutocompleters = cached(() => register$2(editor));\n      const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.trigger).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\n      const load = fetchOptions => {\n        doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\n          commenceIfNecessary(lookupInfo.context);\n          lookupInfo.lookupData.then(lookupData => {\n            activeAutocompleter.get().map(ac => {\n              const context = lookupInfo.context;\n              if (ac.trigger === context.trigger) {\n                if (context.text.length - ac.matchLength >= 10) {\n                  cancelIfNecessary();\n                } else {\n                  activeAutocompleter.set({\n                    ...ac,\n                    matchLength: context.text.length\n                  });\n                  if (uiActive.get()) {\n                    fireAutocompleterUpdate(editor, { lookupData });\n                  } else {\n                    uiActive.set(true);\n                    fireAutocompleterStart(editor, { lookupData });\n                  }\n                }\n              }\n            });\n          });\n        });\n      };\n      editor.addCommand('mceAutocompleterReload', (_ui, value) => {\n        const fetchOptions = isObject(value) ? value.fetchOptions : {};\n        load(fetchOptions);\n      });\n      editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\n      setupEditorInput(editor, {\n        cancelIfNecessary,\n        load\n      });\n    };\n\n    const browser$1 = detect$2().browser;\n    const isSafari = browser$1.isSafari();\n    const emptyNodeContents = node => fillWithPaddingBr(SugarElement.fromDom(node));\n    const isEntireNodeSelected = (rng, node) => {\n      var _a;\n      return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);\n    };\n    const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));\n    const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();\n    const getDetailsElements = (dom, rng) => {\n      const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));\n      const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));\n      if (startDetails.isSome() || endDetails.isSome()) {\n        const startSummary = startDetails.bind(details => Optional.from(dom.select('summary', details)[0]));\n        return Optional.some({\n          startSummary,\n          startDetails,\n          endDetails\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists(pos => pos.isEqual(caretPos));\n    const isCaretInTheEndOf = (caretPos, element) => {\n      return lastPositionIn(element).exists(pos => {\n        if (isBr$6(pos.getNode())) {\n          return prevPosition(element, pos).exists(pos2 => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);\n        } else {\n          return pos.isEqual(caretPos);\n        }\n      });\n    };\n    const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheBeginningOf(caretPos, summary));\n    const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheEndOf(caretPos, summary));\n    const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists(details => prevPosition(details, caretPos).forall(pos => detailsElements.startSummary.exists(summary => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));\n    const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists(details => nextPosition(root, caretPos).forall(pos => !details.contains(pos.container())));\n    const setCaretToPosition = (editor, position) => {\n      const node = position.getNode();\n      if (!isUndefined(node)) {\n        editor.selection.setCursorLocation(node, position.offset());\n      }\n    };\n    const moveCaretToDetailsPos = (editor, pos, forward) => {\n      const details = editor.dom.getParent(pos.container(), 'details');\n      if (details && !details.open) {\n        const summary = editor.dom.select('summary', details)[0];\n        if (summary) {\n          const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);\n          newPos.each(pos => setCaretToPosition(editor, pos));\n        }\n      } else {\n        setCaretToPosition(editor, pos);\n      }\n    };\n    const isPartialDelete = (rng, detailsElements) => {\n      const containsStart = element => element.contains(rng.startContainer);\n      const containsEnd = element => element.contains(rng.endContainer);\n      const startInSummary = detailsElements.startSummary.exists(containsStart);\n      const endInSummary = detailsElements.startSummary.exists(containsEnd);\n      const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall(startDetails => detailsElements.endDetails.forall(endDetails => startDetails !== endDetails));\n      const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);\n      return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;\n    };\n    const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {\n      const {dom, selection} = editor;\n      const root = editor.getBody();\n      if (granularity === 'character') {\n        const caretPos = CaretPosition.fromRangeStart(selection.getRng());\n        const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);\n        const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);\n        const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);\n        const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);\n        const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);\n        if (inEmptyParentBlock) {\n          const firstOrLast = forward ? isLastBlock : isFirstBlock;\n          if (firstOrLast) {\n            const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists(pos => {\n              return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));\n            });\n            if (isBeforeAfterDetails) {\n              return true;\n            }\n          }\n        }\n        return navigate(forward, root, caretPos).fold(never, pos => {\n          const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);\n          if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {\n            if (!forward) {\n              moveCaretToDetailsPos(editor, pos, false);\n            }\n            if (parentBlock && inEmptyParentBlock) {\n              if (forward && isFirstBlock) {\n                return true;\n              } else if (!forward && isLastBlock) {\n                return true;\n              }\n              moveCaretToDetailsPos(editor, pos, forward);\n              editor.dom.remove(parentBlock);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        });\n      } else {\n        return false;\n      }\n    };\n    const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {\n      const selection = editor.selection;\n      const rng = selection.getRng();\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (granularity === 'selection') {\n        return isPartialDelete(rng, detailElements);\n      } else if (forward) {\n        return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);\n      } else {\n        return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);\n      }\n    };\n    const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), detailsElements => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));\n    const handleDeleteActionSafari = (editor, forward, granularity) => {\n      const selection = editor.selection;\n      const node = selection.getNode();\n      const rng = selection.getRng();\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      if (isSummary$1(node)) {\n        if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {\n          emptyNodeContents(node);\n        } else {\n          editor.undoManager.transact(() => {\n            const sel = selection.getSel();\n            let {anchorNode, anchorOffset, focusNode, focusOffset} = sel !== null && sel !== void 0 ? sel : {};\n            const applySelection = () => {\n              if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {\n                sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n              }\n            };\n            const updateSelection = () => {\n              anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n              anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;\n              focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n              focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;\n            };\n            const appendAllChildNodes = (from, to) => {\n              each$e(from.childNodes, child => {\n                if (isNode(child)) {\n                  to.appendChild(child);\n                }\n              });\n            };\n            const container = editor.dom.create('span', { 'data-mce-bogus': '1' });\n            appendAllChildNodes(node, container);\n            node.appendChild(container);\n            applySelection();\n            if (granularity === 'word' || granularity === 'line') {\n              sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);\n            }\n            if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {\n              emptyNodeContents(node);\n            } else {\n              editor.execCommand(forward ? 'ForwardDelete' : 'Delete');\n              updateSelection();\n              appendAllChildNodes(container, node);\n              applySelection();\n            }\n            editor.dom.remove(container);\n          });\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity) ? Optional.some(noop) : Optional.none();\n\n    const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {\n      const target = editor.getBody();\n      const overrides = {\n        bubbles: true,\n        composed: true,\n        data: null,\n        isComposing: false,\n        detail: 0,\n        view: null,\n        target,\n        currentTarget: target,\n        eventPhase: Event.AT_TARGET,\n        originalTarget: target,\n        explicitOriginalTarget: target,\n        isTrusted: false,\n        srcElement: target,\n        cancelable: false,\n        preventDefault: noop,\n        inputType\n      };\n      const input = clone$3(new InputEvent(eventType));\n      return editor.dispatch(eventType, {\n        ...input,\n        ...overrides,\n        ...specifics\n      });\n    };\n    const fireInputEvent = createAndFireInputEvent('input');\n    const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');\n\n    const platform$2 = detect$2();\n    const os = platform$2.os;\n    const isMacOSOriOS = os.isMacOS() || os.isiOS();\n    const browser = platform$2.browser;\n    const isFirefox = browser.isFirefox();\n    const executeKeydownOverride$3 = (editor, caret, evt) => {\n      const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\n      const isCollapsed = editor.selection.isCollapsed();\n      const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';\n      const getModifiedGranularity = isWord => {\n        if (isCollapsed) {\n          return isWord ? 'word' : 'line';\n        } else {\n          return 'selection';\n        }\n      };\n      executeWithDelayedAction([\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$1, editor)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$6, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$6, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$7, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$7, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$4, editor, caret, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$4, editor, caret, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$a, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$a, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete, editor, false, unmodifiedGranularity)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete, editor, true, unmodifiedGranularity)\n        },\n        ...isMacOSOriOS ? [\n          {\n            keyCode: VK.BACKSPACE,\n            altKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.DELETE,\n            altKey: true,\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.BACKSPACE,\n            metaKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(false))\n          }\n        ] : [\n          {\n            keyCode: VK.BACKSPACE,\n            ctrlKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.DELETE,\n            ctrlKey: true,\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n          }\n        ],\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$5, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$5, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$2, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$2, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$8, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$8, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$9, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$9, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$3, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$3, editor, true)\n        }\n      ], evt).filter(_ => editor.selection.isEditable()).each(applyAction => {\n        evt.preventDefault();\n        const beforeInput = fireBeforeInputEvent(editor, inputType);\n        if (!beforeInput.isDefaultPrevented()) {\n          applyAction();\n          fireInputEvent(editor, inputType);\n        }\n      });\n    };\n    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([\n      {\n        keyCode: VK.BACKSPACE,\n        action: action(paddEmptyElement, editor)\n      },\n      {\n        keyCode: VK.DELETE,\n        action: action(paddEmptyElement, editor)\n      },\n      ...isMacOSOriOS ? [\n        {\n          keyCode: VK.BACKSPACE,\n          altKey: true,\n          action: action(refreshCaret, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          altKey: true,\n          action: action(refreshCaret, editor)\n        },\n        ...isBackspaceKeydown ? [{\n            keyCode: isFirefox ? 224 : 91,\n            action: action(refreshCaret, editor)\n          }] : []\n      ] : [\n        {\n          keyCode: VK.BACKSPACE,\n          ctrlKey: true,\n          action: action(refreshCaret, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          ctrlKey: true,\n          action: action(refreshCaret, editor)\n        }\n      ]\n    ], evt);\n    const setup$j = (editor, caret) => {\n      let isBackspaceKeydown = false;\n      editor.on('keydown', evt => {\n        isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$3(editor, caret, evt);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeyupOverride(editor, evt, isBackspaceKeydown);\n        }\n        isBackspaceKeydown = false;\n      });\n    };\n\n    const firstNonWhiteSpaceNodeSibling = node => {\n      while (node) {\n        if (isElement$6(node) || isText$a(node) && node.data && /[\\r\\n\\s]/.test(node.data)) {\n          return node;\n        }\n        node = node.nextSibling;\n      }\n      return null;\n    };\n    const moveToCaretPosition = (editor, root) => {\n      const dom = editor.dom;\n      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\n      if (!root) {\n        return;\n      }\n      if (/^(LI|DT|DD)$/.test(root.nodeName)) {\n        const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\n        }\n      }\n      const rng = dom.createRng();\n      root.normalize();\n      if (root.hasChildNodes()) {\n        const walker = new DomTreeWalker(root, root);\n        let lastNode = root;\n        let node;\n        while (node = walker.current()) {\n          if (isText$a(node)) {\n            rng.setStart(node, 0);\n            rng.setEnd(node, 0);\n            break;\n          }\n          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n            rng.setStartBefore(node);\n            rng.setEndBefore(node);\n            break;\n          }\n          lastNode = node;\n          node = walker.next();\n        }\n        if (!node) {\n          rng.setStart(lastNode, 0);\n          rng.setEnd(lastNode, 0);\n        }\n      } else {\n        if (isBr$6(root)) {\n          if (root.nextSibling && dom.isBlock(root.nextSibling)) {\n            rng.setStartBefore(root);\n            rng.setEndBefore(root);\n          } else {\n            rng.setStartAfter(root);\n            rng.setEndAfter(root);\n          }\n        } else {\n          rng.setStart(root, 0);\n          rng.setEnd(root, 0);\n        }\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const getEditableRoot = (dom, node) => {\n      const root = dom.getRoot();\n      let editableRoot;\n      let parent = node;\n      while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {\n        if (dom.getContentEditable(parent) === 'true') {\n          editableRoot = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return parent !== root ? editableRoot : root;\n    };\n    const getParentBlock$1 = editor => {\n      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\n    };\n    const getParentBlockName = editor => {\n      return getParentBlock$1(editor).fold(constant(''), parentBlock => {\n        return parentBlock.nodeName.toUpperCase();\n      });\n    };\n    const isListItemParentBlock = editor => {\n      return getParentBlock$1(editor).filter(elm => {\n        return isListItem$1(SugarElement.fromDom(elm));\n      }).isSome();\n    };\n    const emptyBlock = elm => {\n      elm.innerHTML = '<br data-mce-bogus=\"1\">';\n    };\n    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\n      const dom = editor.dom;\n      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\n        const currentStyles = getAllRaw(SugarElement.fromDom(node));\n        const newStyles = {\n          ...currentStyles,\n          ...attrStyles\n        };\n        dom.setStyles(node, newStyles);\n      });\n      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\n      const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$5(currentClasses.split(/\\s+/), clazz => clazz !== ''));\n      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\n        const filteredClasses = filter$5(currentClasses, clazz => !contains$2(attrClasses, clazz));\n        const newClasses = [\n          ...attrClasses,\n          ...filteredClasses\n        ];\n        dom.setAttrib(node, 'class', newClasses.join(' '));\n      });\n      const appliedAttrs = [\n        'style',\n        'class'\n      ];\n      const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\n      dom.setAttribs(node, remainingAttrs);\n    };\n    const setForcedBlockAttrs = (editor, node) => {\n      const forcedRootBlockName = getForcedRootBlock(editor);\n      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\n        applyAttributes(editor, node, forcedRootBlockAttrs);\n      }\n    };\n    const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name, styles) => {\n      const dom = editor.dom;\n      const schema = editor.schema;\n      const newBlockName = getForcedRootBlock(editor);\n      const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      let node = container;\n      const textInlineElements = schema.getTextInlineElements();\n      let block;\n      if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\n        block = dom.create(name || newBlockName, styles || {});\n      } else {\n        block = parentBlock.cloneNode(false);\n      }\n      let caretNode = block;\n      if (!keepStyles) {\n        dom.setAttrib(block, 'style', null);\n        dom.setAttrib(block, 'class', null);\n      } else {\n        do {\n          if (textInlineElements[node.nodeName]) {\n            if (isCaretNode(node) || isBookmarkNode$1(node)) {\n              continue;\n            }\n            const clonedNode = node.cloneNode(false);\n            dom.setAttrib(clonedNode, 'id', '');\n            if (block.hasChildNodes()) {\n              clonedNode.appendChild(block.firstChild);\n              block.appendChild(clonedNode);\n            } else {\n              caretNode = clonedNode;\n              block.appendChild(clonedNode);\n            }\n          }\n        } while ((node = node.parentNode) && node !== editableRoot);\n      }\n      setForcedBlockAttrs(editor, block);\n      emptyBlock(caretNode);\n      return block;\n    };\n\n    const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);\n    const isAtDetailsEdge = (root, element, isTextBlock) => {\n      let node = element;\n      while (node && node !== root && isNull(node.nextSibling)) {\n        const parent = node.parentElement;\n        if (!parent || !isTextBlock(parent)) {\n          return isDetails(parent);\n        }\n        node = parent;\n      }\n      return false;\n    };\n    const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, el => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));\n    const insertNewLine = (editor, createNewBlock, parentBlock) => {\n      var _a, _b, _c;\n      const newBlock = createNewBlock(getForcedRootBlock(editor));\n      const root = getDetailsRoot(editor, parentBlock);\n      if (!root) {\n        return;\n      }\n      editor.dom.insertAfter(newBlock, root);\n      moveToCaretPosition(editor, newBlock);\n      if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {\n        editor.dom.remove(parentBlock);\n      }\n    };\n\n    const hasFirstChild = (elm, name) => {\n      return elm.firstChild && elm.firstChild.nodeName === name;\n    };\n    const isFirstChild = elm => {\n      var _a;\n      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\n    };\n    const hasParent = (elm, parentName) => {\n      const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;\n      return isNonNullable(parentNode) && parentNode.nodeName === parentName;\n    };\n    const isListBlock = elm => {\n      return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);\n    };\n    const isListItem = elm => {\n      return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);\n    };\n    const isNestedList = elm => {\n      return isListBlock(elm) && isListBlock(elm.parentNode);\n    };\n    const getContainerBlock = containerBlock => {\n      const containerBlockParent = containerBlock.parentNode;\n      return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;\n    };\n    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\n      let node = containerBlock[first ? 'firstChild' : 'lastChild'];\n      while (node) {\n        if (isElement$6(node)) {\n          break;\n        }\n        node = node[first ? 'nextSibling' : 'previousSibling'];\n      }\n      return node === parentBlock;\n    };\n    const getStyles = elm => foldl(mapToArray(getAllRaw(SugarElement.fromDom(elm)), (style, styleName) => `${ styleName }: ${ style };`), (acc, s) => acc + s, '');\n    const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const containerParent = containerBlock.parentNode;\n      if (containerBlock === editor.getBody() || !containerParent) {\n        return;\n      }\n      if (isNestedList(containerBlock)) {\n        newBlockName = 'LI';\n      }\n      const parentBlockStyles = isListItem(parentBlock) ? getStyles(parentBlock) : undefined;\n      let newBlock = isListItem(parentBlock) && parentBlockStyles ? createNewBlock(newBlockName, { style: getStyles(parentBlock) }) : createNewBlock(newBlockName);\n      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        if (hasParent(containerBlock, 'LI')) {\n          const containerBlockParent = getContainerBlock(containerBlock);\n          dom.insertAfter(newBlock, containerBlockParent);\n          if (isFirstChild(containerBlock)) {\n            dom.remove(containerBlockParent);\n          } else {\n            dom.remove(containerBlock);\n          }\n        } else {\n          dom.replace(newBlock, containerBlock);\n        }\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\n        if (hasParent(containerBlock, 'LI')) {\n          dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n          newBlock.appendChild(dom.doc.createTextNode(' '));\n          newBlock.appendChild(containerBlock);\n        } else {\n          containerParent.insertBefore(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n        dom.remove(parentBlock);\n      } else {\n        containerBlock = getContainerBlock(containerBlock);\n        const tmpRng = rng.cloneRange();\n        tmpRng.setStartAfter(parentBlock);\n        tmpRng.setEndAfter(containerBlock);\n        const fragment = tmpRng.extractContents();\n        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\n          const previousChildren = filter$5(map$3(newBlock.children, SugarElement.fromDom), not(isTag('br')));\n          newBlock = fragment.firstChild;\n          dom.insertAfter(fragment, containerBlock);\n          each$e(previousChildren, child => prepend(SugarElement.fromDom(newBlock), child));\n          if (parentBlockStyles) {\n            newBlock.setAttribute('style', parentBlockStyles);\n          }\n        } else {\n          dom.insertAfter(fragment, containerBlock);\n          dom.insertAfter(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      }\n      moveToCaretPosition(editor, newBlock);\n    };\n\n    const trimZwsp = fragment => {\n      each$e(descendants$1(SugarElement.fromDom(fragment), isText$b), text => {\n        const rawNode = text.dom;\n        rawNode.nodeValue = trim$2(rawNode.data);\n      });\n    };\n    const isWithinNonEditableList = (editor, node) => {\n      const parentList = editor.dom.getParent(node, 'ol,ul,dl');\n      return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';\n    };\n    const isEmptyAnchor = (dom, elm) => {\n      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\n    };\n    const containerAndSiblingName = (container, nodeName) => {\n      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\n    };\n    const canSplitBlock = (dom, node) => {\n      return isNonNullable(node) && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';\n    };\n    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\n      var _a;\n      const firstChilds = [];\n      if (!block) {\n        return;\n      }\n      let currentNode = block;\n      while (currentNode = currentNode.firstChild) {\n        if (dom.isBlock(currentNode)) {\n          return;\n        }\n        if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {\n          firstChilds.push(currentNode);\n        }\n      }\n      let i = firstChilds.length;\n      while (i--) {\n        currentNode = firstChilds[i];\n        if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '') {\n          dom.remove(currentNode);\n        } else {\n          if (isEmptyAnchor(dom, currentNode)) {\n            dom.remove(currentNode);\n          }\n        }\n      }\n    };\n    const normalizeZwspOffset = (start, container, offset) => {\n      if (!isText$a(container)) {\n        return offset;\n      } else if (start) {\n        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\n      } else {\n        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\n      }\n    };\n    const includeZwspInRange = rng => {\n      const newRng = rng.cloneRange();\n      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\n      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\n      return newRng;\n    };\n    const trimLeadingLineBreaks = node => {\n      let currentNode = node;\n      do {\n        if (isText$a(currentNode)) {\n          currentNode.data = currentNode.data.replace(/^[\\r\\n]+/, '');\n        }\n        currentNode = currentNode.firstChild;\n      } while (currentNode);\n    };\n    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\n      var _a, _b;\n      const dom = editor.dom;\n      const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\n        parentBlock = parentBlock || editableRoot;\n        if (!parentBlock.hasChildNodes()) {\n          const newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          parentBlock.appendChild(newBlock);\n          rng.setStart(newBlock, 0);\n          rng.setEnd(newBlock, 0);\n          return newBlock;\n        }\n        let node = container;\n        while (node && node.parentNode !== parentBlock) {\n          node = node.parentNode;\n        }\n        let startNode;\n        while (node && !dom.isBlock(node)) {\n          startNode = node;\n          node = node.previousSibling;\n        }\n        const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;\n        if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {\n          const startNodeParent = startNode.parentNode;\n          const newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          startNodeParent.insertBefore(newBlock, startNode);\n          node = startNode;\n          while (node && !dom.isBlock(node)) {\n            const next = node.nextSibling;\n            newBlock.appendChild(node);\n            node = next;\n          }\n          rng.setStart(container, offset);\n          rng.setEnd(container, offset);\n        }\n      }\n      return container;\n    };\n    const addBrToBlockIfNeeded = (dom, block) => {\n      block.normalize();\n      const lastChild = block.lastChild;\n      if (!lastChild || isElement$6(lastChild) && /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\n        dom.add(block, 'br');\n      }\n    };\n    const shouldEndContainer = (editor, container) => {\n      const optionValue = shouldEndContainerOnEmptyBlock(editor);\n      if (isNullable(container)) {\n        return false;\n      } else if (isString(optionValue)) {\n        return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());\n      } else {\n        return optionValue;\n      }\n    };\n    const insert$3 = (editor, evt) => {\n      let container;\n      let offset;\n      let parentBlockName;\n      let containerBlock;\n      let isAfterLastNodeInContainer = false;\n      const dom = editor.dom;\n      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();\n      const rng = editor.selection.getRng();\n      const newBlockName = getForcedRootBlock(editor);\n      const start = SugarElement.fromDom(rng.startContainer);\n      const child = child$1(start, rng.startOffset);\n      const isCef = child.exists(element => isHTMLElement$1(element) && !isEditable$2(element));\n      const collapsedAndCef = rng.collapsed && isCef;\n      const createNewBlock$1 = (name, styles) => {\n        return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name, styles);\n      };\n      const isCaretAtStartOrEndOfBlock = start => {\n        const normalizedOffset = normalizeZwspOffset(start, container, offset);\n        if (isText$a(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {\n          return false;\n        }\n        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {\n          return true;\n        }\n        if (start && isElement$6(container) && container === parentBlock.firstChild) {\n          return true;\n        }\n        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {\n          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\n        }\n        const walker = new DomTreeWalker(container, parentBlock);\n        if (isText$a(container)) {\n          if (start && normalizedOffset === 0) {\n            walker.prev();\n          } else if (!start && normalizedOffset === container.data.length) {\n            walker.next();\n          }\n        }\n        let node;\n        while (node = walker.current()) {\n          if (isElement$6(node)) {\n            if (!node.getAttribute('data-mce-bogus')) {\n              const name = node.nodeName.toLowerCase();\n              if (nonEmptyElementsMap[name] && name !== 'br') {\n                return false;\n              }\n            }\n          } else if (isText$a(node) && !isWhitespaceText(node.data)) {\n            return false;\n          }\n          if (start) {\n            walker.prev();\n          } else {\n            walker.next();\n          }\n        }\n        return true;\n      };\n      const insertNewBlockAfter = () => {\n        let block;\n        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\n          block = createNewBlock$1(newBlockName);\n        } else {\n          block = createNewBlock$1();\n        }\n        if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, { includeZwsp: true })) {\n          block = dom.split(containerBlock, parentBlock);\n        } else {\n          dom.insertAfter(block, parentBlock);\n        }\n        moveToCaretPosition(editor, block);\n        return block;\n      };\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      container = rng.startContainer;\n      offset = rng.startOffset;\n      const shiftKey = !!(evt && evt.shiftKey);\n      const ctrlKey = !!(evt && evt.ctrlKey);\n      if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {\n        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$a(container)) {\n          offset = container.data.length;\n        } else {\n          offset = 0;\n        }\n      }\n      const editableRoot = getEditableRoot(dom, container);\n      if (!editableRoot || isWithinNonEditableList(editor, container)) {\n        return;\n      }\n      if (!shiftKey) {\n        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();\n      containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      if (containerBlockName === 'LI' && !ctrlKey) {\n        const liBlock = containerBlock;\n        parentBlock = liBlock;\n        containerBlock = liBlock.parentNode;\n        parentBlockName = containerBlockName;\n      }\n      if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {\n        return insertNewLine(editor, createNewBlock$1, parentBlock);\n      }\n      if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {\n        if (dom.isEmpty(parentBlock)) {\n          insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);\n          return;\n        }\n      }\n      if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {\n        return;\n      }\n      const parentBlockParent = parentBlock.parentNode;\n      let newBlock;\n      if (collapsedAndCef) {\n        newBlock = createNewBlock$1(newBlockName);\n        child.fold(() => {\n          append$1(start, SugarElement.fromDom(newBlock));\n        }, child => {\n          before$3(child, SugarElement.fromDom(newBlock));\n        });\n        editor.selection.setCursorLocation(newBlock, 0);\n      } else if (isCaretContainerBlock$1(parentBlock)) {\n        newBlock = showCaretContainerBlock(parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        setForcedBlockAttrs(editor, newBlock);\n        moveToCaretPosition(editor, newBlock);\n      } else if (isCaretAtStartOrEndOfBlock(false)) {\n        newBlock = insertNewBlockAfter();\n      } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {\n        newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);\n        const isNearChildren = hasChildNodes(SugarElement.fromDom(rng.startContainer)) && rng.collapsed;\n        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') || isNearChildren ? newBlock : parentBlock);\n      } else {\n        const tmpRng = includeZwspInRange(rng).cloneRange();\n        tmpRng.setEndAfter(parentBlock);\n        const fragment = tmpRng.extractContents();\n        trimZwsp(fragment);\n        trimLeadingLineBreaks(fragment);\n        newBlock = fragment.firstChild;\n        dom.insertAfter(fragment, parentBlock);\n        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\n        addBrToBlockIfNeeded(dom, parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        newBlock.normalize();\n        if (dom.isEmpty(newBlock)) {\n          dom.remove(newBlock);\n          insertNewBlockAfter();\n        } else {\n          setForcedBlockAttrs(editor, newBlock);\n          moveToCaretPosition(editor, newBlock);\n        }\n      }\n      dom.setAttrib(newBlock, 'id', '');\n      editor.dispatch('NewBlock', { newBlock });\n    };\n    const fakeEventName$1 = 'insertParagraph';\n    const blockbreak = {\n      insert: insert$3,\n      fakeEventName: fakeEventName$1\n    };\n\n    const hasRightSideContent = (schema, container, parentBlock) => {\n      const walker = new DomTreeWalker(container, parentBlock);\n      let node;\n      const nonEmptyElementsMap = schema.getNonEmptyElements();\n      while (node = walker.next()) {\n        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$a(node) && node.length > 0) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const moveSelectionToBr = (editor, brElm, extraBr) => {\n      const rng = editor.dom.createRng();\n      if (!extraBr) {\n        rng.setStartAfter(brElm);\n        rng.setEndAfter(brElm);\n      } else {\n        rng.setStartBefore(brElm);\n        rng.setEndBefore(brElm);\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const insertBrAtCaret = (editor, evt) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const rng = selection.getRng();\n      let brElm;\n      let extraBr = false;\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      let offset = rng.startOffset;\n      let container = rng.startContainer;\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$a(container)) {\n          offset = container.data.length;\n        } else {\n          offset = 0;\n        }\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      const isControlKey = !!(evt && evt.ctrlKey);\n      if (containerBlockName === 'LI' && !isControlKey) {\n        parentBlock = containerBlock;\n      }\n      if (isText$a(container) && offset >= container.data.length) {\n        if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {\n          brElm = dom.create('br');\n          rng.insertNode(brElm);\n          rng.setStartAfter(brElm);\n          rng.setEndAfter(brElm);\n          extraBr = true;\n        }\n      }\n      brElm = dom.create('br');\n      rangeInsertNode(dom, rng, brElm);\n      moveSelectionToBr(editor, brElm, extraBr);\n      editor.undoManager.add();\n    };\n    const insertBrBefore = (editor, inline) => {\n      const br = SugarElement.fromTag('br');\n      before$3(SugarElement.fromDom(inline), br);\n      editor.undoManager.add();\n    };\n    const insertBrAfter = (editor, inline) => {\n      if (!hasBrAfter(editor.getBody(), inline)) {\n        after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\n      }\n      const br = SugarElement.fromTag('br');\n      after$4(SugarElement.fromDom(inline), br);\n      moveSelectionToBr(editor, br.dom, false);\n      editor.undoManager.add();\n    };\n    const isBeforeBr = pos => {\n      return isBr$6(pos.getNode());\n    };\n    const hasBrAfter = (rootNode, startNode) => {\n      if (isBeforeBr(CaretPosition.after(startNode))) {\n        return true;\n      } else {\n        return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\n          return isBr$6(pos.getNode());\n        }).getOr(false);\n      }\n    };\n    const isAnchorLink = elm => {\n      return elm && elm.nodeName === 'A' && 'href' in elm;\n    };\n    const isInsideAnchor = location => {\n      return location.fold(never, isAnchorLink, isAnchorLink, never);\n    };\n    const readInlineAnchorLocation = editor => {\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const position = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\n    };\n    const insertBrOutsideAnchor = (editor, location) => {\n      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\n    };\n    const insert$2 = (editor, evt) => {\n      const anchorLocation = readInlineAnchorLocation(editor);\n      if (anchorLocation.isSome()) {\n        anchorLocation.each(curry(insertBrOutsideAnchor, editor));\n      } else {\n        insertBrAtCaret(editor, evt);\n      }\n    };\n    const fakeEventName = 'insertLineBreak';\n    const linebreak = {\n      insert: insert$2,\n      fakeEventName\n    };\n\n    const matchesSelector = (editor, selector) => {\n      return getParentBlock$1(editor).filter(parentBlock => {\n        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\n      }).isSome();\n    };\n    const shouldInsertBr = editor => {\n      return matchesSelector(editor, getBrNewLineSelector(editor));\n    };\n    const shouldBlockNewLine$1 = editor => {\n      return matchesSelector(editor, getNoNewLineSelector(editor));\n    };\n\n    const newLineAction = Adt.generate([\n      { br: [] },\n      { block: [] },\n      { none: [] }\n    ]);\n    const shouldBlockNewLine = (editor, _shiftKey) => {\n      return shouldBlockNewLine$1(editor);\n    };\n    const inListBlock = requiredState => {\n      return (editor, _shiftKey) => {\n        return isListItemParentBlock(editor) === requiredState;\n      };\n    };\n    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\n      const state = getParentBlockName(editor) === blockName.toUpperCase();\n      return state === requiredState;\n    };\n    const inCefBlock = editor => {\n      const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());\n      return isNullable(editableRoot);\n    };\n    const inPreBlock = requiredState => inBlock('pre', requiredState);\n    const inSummaryBlock = () => inBlock('summary', true);\n    const shouldPutBrInPre = requiredState => {\n      return (editor, _shiftKey) => {\n        return shouldPutBrInPre$1(editor) === requiredState;\n      };\n    };\n    const inBrContext = (editor, _shiftKey) => {\n      return shouldInsertBr(editor);\n    };\n    const hasShiftKey = (_editor, shiftKey) => {\n      return shiftKey;\n    };\n    const canInsertIntoEditableRoot = editor => {\n      const forcedRootBlock = getForcedRootBlock(editor);\n      const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());\n      return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\n    };\n    const isInRootWithEmptyOrCEF = editor => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const child = child$1(start, rng.startOffset);\n      const isCefOpt = child.map(element => isHTMLElement$1(element) && !isEditable$2(element));\n      return rng.collapsed && isCefOpt.getOr(true);\n    };\n    const match = (predicates, action) => {\n      return (editor, shiftKey) => {\n        const isMatch = foldl(predicates, (res, p) => {\n          return res && p(editor, shiftKey);\n        }, true);\n        return isMatch ? Optional.some(action) : Optional.none();\n      };\n    };\n    const getAction = (editor, evt) => {\n      return evaluateUntil([\n        match([shouldBlockNewLine], newLineAction.none()),\n        match([\n          inPreBlock(true),\n          inCefBlock\n        ], newLineAction.none()),\n        match([inSummaryBlock()], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false)\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true),\n          hasShiftKey\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true)\n        ], newLineAction.br()),\n        match([\n          inListBlock(true),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([inListBlock(true)], newLineAction.block()),\n        match([inBrContext], newLineAction.br()),\n        match([hasShiftKey], newLineAction.br()),\n        match([canInsertIntoEditableRoot], newLineAction.block()),\n        match([isInRootWithEmptyOrCEF], newLineAction.block())\n      ], [\n        editor,\n        !!(evt && evt.shiftKey)\n      ]).getOr(newLineAction.none());\n    };\n\n    const insertBreak = (breakType, editor, evt) => {\n      if (!editor.selection.isCollapsed()) {\n        execEditorDeleteCommand(editor);\n      }\n      if (isNonNullable(evt)) {\n        const event = fireBeforeInputEvent(editor, breakType.fakeEventName);\n        if (event.isDefaultPrevented()) {\n          return;\n        }\n      }\n      breakType.insert(editor, evt);\n      if (isNonNullable(evt)) {\n        fireInputEvent(editor, breakType.fakeEventName);\n      }\n    };\n    const insert$1 = (editor, evt) => {\n      const br = () => insertBreak(linebreak, editor, evt);\n      const block = () => insertBreak(blockbreak, editor, evt);\n      const logicalAction = getAction(editor, evt);\n      switch (getNewlineBehavior(editor)) {\n      case 'linebreak':\n        logicalAction.fold(br, br, noop);\n        break;\n      case 'block':\n        logicalAction.fold(block, block, noop);\n        break;\n      case 'invert':\n        logicalAction.fold(block, br, noop);\n        break;\n      default:\n        logicalAction.fold(br, block, noop);\n        break;\n      }\n    };\n\n    const platform$1 = detect$2();\n    const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();\n    const handleEnterKeyEvent = (editor, event) => {\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n      event.preventDefault();\n      endTypingLevelIgnoreLocks(editor.undoManager);\n      editor.undoManager.transact(() => {\n        insert$1(editor, event);\n      });\n    };\n    const isCaretAfterKoreanCharacter = rng => {\n      if (!rng.collapsed) {\n        return false;\n      }\n      const startContainer = rng.startContainer;\n      if (isText$a(startContainer)) {\n        const koreanCharRegex = /^[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uD7B0-\\uD7FF]$/;\n        const char = startContainer.data.charAt(rng.startOffset - 1);\n        return koreanCharRegex.test(char);\n      } else {\n        return false;\n      }\n    };\n    const setup$i = editor => {\n      let iOSSafariKeydownBookmark = Optional.none();\n      const iOSSafariKeydownOverride = editor => {\n        iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());\n        editor.undoManager.add();\n      };\n      const iOSSafariKeyupOverride = (editor, event) => {\n        editor.undoManager.undo();\n        iOSSafariKeydownBookmark.fold(noop, b => editor.selection.moveToBookmark(b));\n        handleEnterKeyEvent(editor, event);\n        iOSSafariKeydownBookmark = Optional.none();\n      };\n      editor.on('keydown', event => {\n        if (event.keyCode === VK.ENTER) {\n          if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {\n            iOSSafariKeydownOverride(editor);\n          } else {\n            handleEnterKeyEvent(editor, event);\n          }\n        }\n      });\n      editor.on('keyup', event => {\n        if (event.keyCode === VK.ENTER) {\n          iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));\n        }\n      });\n    };\n\n    const executeKeydownOverride$2 = (editor, caret, evt) => {\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      execute([\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$1, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$1, editor, false)\n        },\n        ...!isMac ? [\n          {\n            keyCode: VK.HOME,\n            action: action(selectToEndPoint, editor, false),\n            ctrlKey: true,\n            shiftKey: true\n          },\n          {\n            keyCode: VK.END,\n            action: action(selectToEndPoint, editor, true),\n            ctrlKey: true,\n            shiftKey: true\n          }\n        ] : [],\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint, editor, false)\n        },\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$h = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$2(editor, caret, evt);\n        }\n      });\n    };\n\n    const setup$g = editor => {\n      editor.on('input', e => {\n        if (!e.isComposing) {\n          normalizeNbspsInEditor(editor);\n        }\n      });\n    };\n\n    const platform = detect$2();\n    const executeKeyupAction = (editor, caret, evt) => {\n      execute([\n        {\n          keyCode: VK.PAGE_UP,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        },\n        {\n          keyCode: VK.PAGE_DOWN,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        }\n      ], evt);\n    };\n    const stopImmediatePropagation = e => e.stopImmediatePropagation();\n    const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\n    const setNodeChangeBlocker = (blocked, editor, block) => {\n      if (block && !blocked.get()) {\n        editor.on('NodeChange', stopImmediatePropagation, true);\n      } else if (!block && blocked.get()) {\n        editor.off('NodeChange', stopImmediatePropagation);\n      }\n      blocked.set(block);\n    };\n    const setup$f = (editor, caret) => {\n      if (platform.os.isMacOS()) {\n        return;\n      }\n      const blocked = Cell(false);\n      editor.on('keydown', evt => {\n        if (isPageUpDown(evt)) {\n          setNodeChangeBlocker(blocked, editor, true);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeyupAction(editor, caret, evt);\n        }\n        if (isPageUpDown(evt) && blocked.get()) {\n          setNodeChangeBlocker(blocked, editor, false);\n          editor.nodeChanged();\n        }\n      });\n    };\n\n    const setup$e = editor => {\n      editor.on('beforeinput', e => {\n        if (!editor.selection.isEditable() || exists(e.getTargetRanges(), rng => !isEditableRange(editor.dom, rng))) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const insertTextAtPosition = (text, pos) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$a(container)) {\n        container.insertData(offset, text);\n        return Optional.some(CaretPosition(container, offset + text.length));\n      } else {\n        return getElementFromPosition(pos).map(elm => {\n          const textNode = SugarElement.fromText(text);\n          if (pos.isAtEnd()) {\n            after$4(elm, textNode);\n          } else {\n            before$3(elm, textNode);\n          }\n          return CaretPosition(textNode.dom, text.length);\n        });\n      }\n    };\n    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\n    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\n\n    const insertSpaceOrNbspAtPosition = (root, pos, schema) => needsToHaveNbsp(root, pos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\n    const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => checkPos => needsToHaveNbsp(root, checkPos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const setSelection = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      editor.nodeChanged();\n    };\n    const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));\n    const insertSpaceOrNbspAtSelection = editor => {\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        const isInlineTarget$1 = curry(isInlineTarget, editor);\n        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos, editor.schema)(checkPos).each(setSelection(editor)));\n      } else {\n        return Optional.none();\n      }\n    };\n    const insertSpaceInSummaryAtSelectionOnFirefox = editor => {\n      const insertSpaceThunk = () => {\n        const root = SugarElement.fromDom(editor.getBody());\n        if (!editor.selection.isCollapsed()) {\n          editor.getDoc().execCommand('Delete');\n        }\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(setSelection(editor));\n      };\n      return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);\n    };\n\n    const executeKeydownOverride$1 = (editor, evt) => {\n      executeWithDelayedAction([\n        {\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceOrNbspAtSelection, editor)\n        },\n        {\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)\n        }\n      ], evt).each(applyAction => {\n        evt.preventDefault();\n        const event = fireBeforeInputEvent(editor, 'insertText', { data: ' ' });\n        if (!event.isDefaultPrevented()) {\n          applyAction();\n          fireInputEvent(editor, 'insertText', { data: ' ' });\n        }\n      });\n    };\n    const setup$d = editor => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$1(editor, evt);\n        }\n      });\n    };\n\n    const tableTabNavigation = editor => {\n      if (hasTableTabNavigation(editor)) {\n        return [\n          {\n            keyCode: VK.TAB,\n            action: action(handleTab, editor, true)\n          },\n          {\n            keyCode: VK.TAB,\n            shiftKey: true,\n            action: action(handleTab, editor, false)\n          }\n        ];\n      } else {\n        return [];\n      }\n    };\n    const executeKeydownOverride = (editor, evt) => {\n      execute([...tableTabNavigation(editor)], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$c = editor => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride(editor, evt);\n        }\n      });\n    };\n\n    const setup$b = editor => {\n      editor.addShortcut('Meta+P', '', 'mcePrint');\n      setup$k(editor);\n      if (isRtc(editor)) {\n        return Cell(null);\n      } else {\n        const caret = setupSelectedState(editor);\n        setup$e(editor);\n        setup$m(editor);\n        setup$l(editor, caret);\n        setup$j(editor, caret);\n        setup$i(editor);\n        setup$d(editor);\n        setup$g(editor);\n        setup$c(editor);\n        setup$h(editor, caret);\n        setup$f(editor, caret);\n        return caret;\n      }\n    };\n\n    class NodeChange {\n      constructor(editor) {\n        this.lastPath = [];\n        this.editor = editor;\n        let lastRng;\n        const self = this;\n        if (!('onselectionchange' in editor.getDoc())) {\n          editor.on('NodeChange click mouseup keyup focus', e => {\n            const nativeRng = editor.selection.getRng();\n            const fakeRng = {\n              startContainer: nativeRng.startContainer,\n              startOffset: nativeRng.startOffset,\n              endContainer: nativeRng.endContainer,\n              endOffset: nativeRng.endOffset\n            };\n            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\n              editor.dispatch('SelectionChange');\n            }\n            lastRng = fakeRng;\n          });\n        }\n        editor.on('contextmenu', () => {\n          editor.dispatch('SelectionChange');\n        });\n        editor.on('SelectionChange', () => {\n          const startElm = editor.selection.getStart(true);\n          if (!startElm) {\n            return;\n          }\n          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n            editor.nodeChanged({ selectionChange: true });\n          }\n        });\n        editor.on('mouseup', e => {\n          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\n            if (editor.selection.getNode().nodeName === 'IMG') {\n              Delay.setEditorTimeout(editor, () => {\n                editor.nodeChanged();\n              });\n            } else {\n              editor.nodeChanged();\n            }\n          }\n        });\n      }\n      nodeChanged(args = {}) {\n        const selection = this.editor.selection;\n        let node;\n        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {\n          const root = this.editor.getBody();\n          node = selection.getStart(true) || root;\n          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {\n            node = root;\n          }\n          const parents = [];\n          this.editor.dom.getParent(node, node => {\n            if (node === root) {\n              return true;\n            } else {\n              parents.push(node);\n              return false;\n            }\n          });\n          this.editor.dispatch('NodeChange', {\n            ...args,\n            element: node,\n            parents\n          });\n        }\n      }\n      isSameElementPath(startElm) {\n        let i;\n        const editor = this.editor;\n        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\n        if (currentPath.length === this.lastPath.length) {\n          for (i = currentPath.length; i >= 0; i--) {\n            if (currentPath[i] !== this.lastPath[i]) {\n              break;\n            }\n          }\n          if (i === -1) {\n            this.lastPath = currentPath;\n            return true;\n          }\n        }\n        this.lastPath = currentPath;\n        return false;\n      }\n    }\n\n    const imageId = generate$1('image');\n    const getDragImage = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[imageId]);\n    };\n    const setDragImage = (transfer, imageData) => {\n      const dt = transfer;\n      dt[imageId] = imageData;\n    };\n\n    const eventId = generate$1('event');\n    const getEvent = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[eventId]);\n    };\n    const mkSetEventFn = type => transfer => {\n      const dt = transfer;\n      dt[eventId] = type;\n    };\n    const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);\n    const setDragstartEvent = mkSetEventFn(0);\n    const setDropEvent = mkSetEventFn(2);\n    const setDragendEvent = mkSetEventFn(1);\n    const checkEvent = expectedType => transfer => {\n      const dt = transfer;\n      return Optional.from(dt[eventId]).exists(type => type === expectedType);\n    };\n    const isInDragStartEvent = checkEvent(0);\n\n    const createEmptyFileList = () => Object.freeze({\n      length: 0,\n      item: _ => null\n    });\n\n    const modeId = generate$1('mode');\n    const getMode = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[modeId]);\n    };\n    const mkSetModeFn = mode => transfer => {\n      const dt = transfer;\n      dt[modeId] = mode;\n    };\n    const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);\n    const setReadWriteMode = mkSetModeFn(0);\n    const setReadOnlyMode = mkSetModeFn(2);\n    const setProtectedMode = mkSetModeFn(1);\n    const checkMode = expectedMode => transfer => {\n      const dt = transfer;\n      return Optional.from(dt[modeId]).exists(mode => mode === expectedMode);\n    };\n    const isInReadWriteMode = checkMode(0);\n    const isInProtectedMode = checkMode(1);\n\n    const normalizeItems = (dataTransfer, itemsImpl) => ({\n      ...itemsImpl,\n      get length() {\n        return itemsImpl.length;\n      },\n      add: (data, type) => {\n        if (isInReadWriteMode(dataTransfer)) {\n          if (isString(data)) {\n            if (!isUndefined(type)) {\n              return itemsImpl.add(data, type);\n            }\n          } else {\n            return itemsImpl.add(data);\n          }\n        }\n        return null;\n      },\n      remove: idx => {\n        if (isInReadWriteMode(dataTransfer)) {\n          itemsImpl.remove(idx);\n        }\n      },\n      clear: () => {\n        if (isInReadWriteMode(dataTransfer)) {\n          itemsImpl.clear();\n        }\n      }\n    });\n\n    const validDropEffects = [\n      'none',\n      'copy',\n      'link',\n      'move'\n    ];\n    const validEffectAlloweds = [\n      'none',\n      'copy',\n      'copyLink',\n      'copyMove',\n      'link',\n      'linkMove',\n      'move',\n      'all',\n      'uninitialized'\n    ];\n    const createDataTransfer = () => {\n      const dataTransferImpl = new window.DataTransfer();\n      let dropEffect = 'move';\n      let effectAllowed = 'all';\n      const dataTransfer = {\n        get dropEffect() {\n          return dropEffect;\n        },\n        set dropEffect(effect) {\n          if (contains$2(validDropEffects, effect)) {\n            dropEffect = effect;\n          }\n        },\n        get effectAllowed() {\n          return effectAllowed;\n        },\n        set effectAllowed(allowed) {\n          if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {\n            effectAllowed = allowed;\n          }\n        },\n        get items() {\n          return normalizeItems(dataTransfer, dataTransferImpl.items);\n        },\n        get files() {\n          if (isInProtectedMode(dataTransfer)) {\n            return createEmptyFileList();\n          } else {\n            return dataTransferImpl.files;\n          }\n        },\n        get types() {\n          return dataTransferImpl.types;\n        },\n        setDragImage: (image, x, y) => {\n          if (isInReadWriteMode(dataTransfer)) {\n            setDragImage(dataTransfer, {\n              image,\n              x,\n              y\n            });\n            dataTransferImpl.setDragImage(image, x, y);\n          }\n        },\n        getData: format => {\n          if (isInProtectedMode(dataTransfer)) {\n            return '';\n          } else {\n            return dataTransferImpl.getData(format);\n          }\n        },\n        setData: (format, data) => {\n          if (isInReadWriteMode(dataTransfer)) {\n            dataTransferImpl.setData(format, data);\n          }\n        },\n        clearData: format => {\n          if (isInReadWriteMode(dataTransfer)) {\n            dataTransferImpl.clearData(format);\n          }\n        }\n      };\n      setReadWriteMode(dataTransfer);\n      return dataTransfer;\n    };\n    const cloneDataTransfer = original => {\n      const clone = createDataTransfer();\n      const originalMode = getMode(original);\n      setReadOnlyMode(original);\n      setDragstartEvent(clone);\n      clone.dropEffect = original.dropEffect;\n      clone.effectAllowed = original.effectAllowed;\n      getDragImage(original).each(imageData => clone.setDragImage(imageData.image, imageData.x, imageData.y));\n      each$e(original.types, type => {\n        if (type !== 'Files') {\n          clone.setData(type, original.getData(type));\n        }\n      });\n      each$e(original.files, file => clone.items.add(file));\n      getEvent(original).each(type => {\n        setEvent(clone, type);\n      });\n      originalMode.each(mode => {\n        setMode$1(original, mode);\n        setMode$1(clone, mode);\n      });\n      return clone;\n    };\n\n    const getHtmlData = dataTransfer => {\n      const html = dataTransfer.getData('text/html');\n      return html === '' ? Optional.none() : Optional.some(html);\n    };\n    const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);\n\n    const internalMimeType = 'x-tinymce/html';\n    const internalHtmlMime = constant(internalMimeType);\n    const internalMark = '<!-- ' + internalMimeType + ' -->';\n    const mark = html => internalMark + html;\n    const unmark = html => html.replace(internalMark, '');\n    const isMarked = html => html.indexOf(internalMark) !== -1;\n\n    const isPlainText = text => {\n      return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\n    };\n    const openContainer = (rootTag, rootAttrs) => {\n      let tag = '<' + rootTag;\n      const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\n      if (attrs.length) {\n        tag += ' ' + attrs.join(' ');\n      }\n      return tag + '>';\n    };\n    const toBlockElements = (text, rootTag, rootAttrs) => {\n      const blocks = text.split(/\\n\\n/);\n      const tagOpen = openContainer(rootTag, rootAttrs);\n      const tagClose = '</' + rootTag + '>';\n      const paragraphs = map$3(blocks, p => {\n        return p.split(/\\n/).join('<br />');\n      });\n      const stitch = p => {\n        return tagOpen + p + tagClose;\n      };\n      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\n    };\n\n    const pasteBinDefaultContent = '%MCEPASTEBIN%';\n    const create$6 = (editor, lastRngCell) => {\n      const {dom, selection} = editor;\n      const body = editor.getBody();\n      lastRngCell.set(selection.getRng());\n      const pasteBinElm = dom.add(editor.getBody(), 'div', {\n        'id': 'mcepastebin',\n        'class': 'mce-pastebin',\n        'contentEditable': true,\n        'data-mce-bogus': 'all',\n        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\n      }, pasteBinDefaultContent);\n      if (Env.browser.isFirefox()) {\n        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\n      }\n      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\n        e.stopPropagation();\n      });\n      pasteBinElm.focus();\n      selection.select(pasteBinElm, true);\n    };\n    const remove = (editor, lastRngCell) => {\n      const dom = editor.dom;\n      if (getEl(editor)) {\n        let pasteBinClone;\n        const lastRng = lastRngCell.get();\n        while (pasteBinClone = getEl(editor)) {\n          dom.remove(pasteBinClone);\n          dom.unbind(pasteBinClone);\n        }\n        if (lastRng) {\n          editor.selection.setRng(lastRng);\n        }\n      }\n      lastRngCell.set(null);\n    };\n    const getEl = editor => editor.dom.get('mcepastebin');\n    const isPasteBin = elm => isNonNullable(elm) && elm.id === 'mcepastebin';\n    const getHtml = editor => {\n      const dom = editor.dom;\n      const copyAndRemove = (toElm, fromElm) => {\n        toElm.appendChild(fromElm);\n        dom.remove(fromElm, true);\n      };\n      const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);\n      each$e(pasteBinClones, pasteBinClone => {\n        copyAndRemove(pasteBinElm, pasteBinClone);\n      });\n      const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\n      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\n        const cleanWrapper = dom.create('div');\n        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\n        copyAndRemove(cleanWrapper, dirtyWrappers[i]);\n      }\n      return pasteBinElm ? pasteBinElm.innerHTML : '';\n    };\n    const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\n    const PasteBin = editor => {\n      const lastRng = Cell(null);\n      return {\n        create: () => create$6(editor, lastRng),\n        remove: () => remove(editor, lastRng),\n        getEl: () => getEl(editor),\n        getHtml: () => getHtml(editor),\n        getLastRng: lastRng.get\n      };\n    };\n\n    const filter$1 = (content, items) => {\n      Tools.each(items, v => {\n        if (is$4(v, RegExp)) {\n          content = content.replace(v, '');\n        } else {\n          content = content.replace(v[0], v[1]);\n        }\n      });\n      return content;\n    };\n    const innerText = html => {\n      const schema = Schema();\n      const domParser = DomParser({}, schema);\n      let text = '';\n      const voidElements = schema.getVoidElements();\n      const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\n      const blockElements = schema.getBlockElements();\n      const walk = node => {\n        const name = node.name, currentNode = node;\n        if (name === 'br') {\n          text += '\\n';\n          return;\n        }\n        if (name === 'wbr') {\n          return;\n        }\n        if (voidElements[name]) {\n          text += ' ';\n        }\n        if (ignoreElements[name]) {\n          text += ' ';\n          return;\n        }\n        if (node.type === 3) {\n          text += node.value;\n        }\n        if (!(node.name in schema.getVoidElements())) {\n          let currentNode = node.firstChild;\n          if (currentNode) {\n            do {\n              walk(currentNode);\n            } while (currentNode = currentNode.next);\n          }\n        }\n        if (blockElements[name] && currentNode.next) {\n          text += '\\n';\n          if (name === 'p') {\n            text += '\\n';\n          }\n        }\n      };\n      html = filter$1(html, [/<!\\[[^\\]]+\\]>/g]);\n      walk(domParser.parse(html));\n      return text;\n    };\n    const trimHtml = html => {\n      const trimSpaces = (all, s1, s2) => {\n        if (!s1 && !s2) {\n          return ' ';\n        }\n        return nbsp;\n      };\n      html = filter$1(html, [\n        /^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig,\n        /<!--StartFragment-->|<!--EndFragment-->/g,\n        [\n          /( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g,\n          trimSpaces\n        ],\n        /<br class=\"Apple-interchange-newline\">/g,\n        /<br>$/i\n      ]);\n      return html;\n    };\n    const createIdGenerator = prefix => {\n      let count = 0;\n      return () => {\n        return prefix + count++;\n      };\n    };\n    const getImageMimeType = ext => {\n      const lowerExt = ext.toLowerCase();\n      const mimeOverrides = {\n        jpg: 'jpeg',\n        jpe: 'jpeg',\n        jfi: 'jpeg',\n        jif: 'jpeg',\n        jfif: 'jpeg',\n        pjpeg: 'jpeg',\n        pjp: 'jpeg',\n        svg: 'svg+xml'\n      };\n      return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\n    };\n\n    const preProcess = (editor, html) => {\n      const parser = DomParser({\n        sanitize: shouldSanitizeXss(editor),\n        sandbox_iframes: shouldSandboxIframes(editor)\n      }, editor.schema);\n      parser.addNodeFilter('meta', nodes => {\n        Tools.each(nodes, node => {\n          node.remove();\n        });\n      });\n      const fragment = parser.parse(html, {\n        forced_root_block: false,\n        isRootContent: true\n      });\n      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);\n    };\n    const processResult = (content, cancelled) => ({\n      content,\n      cancelled\n    });\n    const postProcessFilter = (editor, html, internal) => {\n      const tempBody = editor.dom.create('div', { style: 'display:none' }, html);\n      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\n      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\n    };\n    const filterContent = (editor, content, internal) => {\n      const preProcessArgs = firePastePreProcess(editor, content, internal);\n      const filteredContent = preProcess(editor, preProcessArgs.content);\n      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\n        return postProcessFilter(editor, filteredContent, internal);\n      } else {\n        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\n      }\n    };\n    const process = (editor, html, internal) => {\n      return filterContent(editor, html, internal);\n    };\n\n    const pasteHtml$1 = (editor, html) => {\n      editor.insertContent(html, {\n        merge: shouldPasteMergeFormats(editor),\n        paste: true\n      });\n      return true;\n    };\n    const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\-\\/+=.,!;:&%@^~(){}?#]+$/i.test(url);\n    const isImageUrl = (editor, url) => {\n      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${ type.toLowerCase() }`));\n    };\n    const createImage = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.insertContent('<img src=\"' + url + '\">');\n      });\n      return true;\n    };\n    const createLink = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.execCommand('mceInsertLink', false, url);\n      });\n      return true;\n    };\n    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\n    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\n    const smartInsertContent = (editor, html) => {\n      Tools.each([\n        linkSelection,\n        insertImage,\n        pasteHtml$1\n      ], action => {\n        return !action(editor, html, pasteHtml$1);\n      });\n    };\n    const insertContent = (editor, html, pasteAsText) => {\n      if (pasteAsText || !isSmartPasteEnabled(editor)) {\n        pasteHtml$1(editor, html);\n      } else {\n        smartInsertContent(editor, html);\n      }\n    };\n\n    const uniqueId = createIdGenerator('mceclip');\n    const createPasteDataTransfer = html => {\n      const dataTransfer = createDataTransfer();\n      setHtmlData(dataTransfer, html);\n      setReadOnlyMode(dataTransfer);\n      return dataTransfer;\n    };\n    const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {\n      const res = process(editor, content, internal);\n      if (!res.cancelled) {\n        const content = res.content;\n        const doPasteAction = () => insertContent(editor, content, pasteAsText);\n        if (shouldSimulateInputEvent) {\n          const args = fireBeforeInputEvent(editor, 'insertFromPaste', { dataTransfer: createPasteDataTransfer(content) });\n          if (!args.isDefaultPrevented()) {\n            doPasteAction();\n            fireInputEvent(editor, 'insertFromPaste');\n          }\n        } else {\n          doPasteAction();\n        }\n      }\n    };\n    const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {\n      const internal = internalFlag ? internalFlag : isMarked(html);\n      doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);\n    };\n    const pasteText = (editor, text, shouldSimulateInputEvent) => {\n      const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\n      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\n      const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n      doPaste(editor, html, false, true, shouldSimulateInputEvent);\n    };\n    const getDataTransferItems = dataTransfer => {\n      const items = {};\n      if (dataTransfer && dataTransfer.types) {\n        for (let i = 0; i < dataTransfer.types.length; i++) {\n          const contentType = dataTransfer.types[i];\n          try {\n            items[contentType] = dataTransfer.getData(contentType);\n          } catch (ex) {\n            items[contentType] = '';\n          }\n        }\n      }\n      return items;\n    };\n    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n    const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\n    const extractFilename = (editor, str) => {\n      const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\n      return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;\n    };\n    const createBlobInfo = (editor, blobCache, file, base64) => {\n      const id = uniqueId();\n      const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\n      const name = useFileName ? extractFilename(editor, file.name) : id;\n      const filename = useFileName ? file.name : undefined;\n      const blobInfo = blobCache.create(id, file, base64, name, filename);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const pasteImage = (editor, imageItem) => {\n      parseDataUri(imageItem.uri).each(({data, type, base64Encoded}) => {\n        const base64 = base64Encoded ? data : btoa(data);\n        const file = imageItem.file;\n        const blobCache = editor.editorUpload.blobCache;\n        const existingBlobInfo = blobCache.getByData(base64, type);\n        const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\n        pasteHtml(editor, `<img src=\"${ blobInfo.blobUri() }\">`, false, true);\n      });\n    };\n    const isClipboardEvent = event => event.type === 'paste';\n    const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\n      return blobToDataUri(file).then(uri => ({\n        file,\n        uri\n      }));\n    }));\n    const isImage = editor => {\n      const allowedExtensions = getAllowedImageFileTypes(editor);\n      return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\n        return getImageMimeType(extension) === file.type;\n      });\n    };\n    const getImagesFromDataTransfer = (editor, dataTransfer) => {\n      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\n        return item.kind === 'file' ? [item.getAsFile()] : [];\n      }) : [];\n      const files = dataTransfer.files ? from(dataTransfer.files) : [];\n      return filter$5(items.length > 0 ? items : files, isImage(editor));\n    };\n    const pasteImageData = (editor, e, rng) => {\n      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\n      if (shouldPasteDataImages(editor) && dataTransfer) {\n        const images = getImagesFromDataTransfer(editor, dataTransfer);\n        if (images.length > 0) {\n          e.preventDefault();\n          readFilesAsDataUris(images).then(fileResults => {\n            if (rng) {\n              editor.selection.setRng(rng);\n            }\n            each$e(fileResults, result => {\n              pasteImage(editor, result);\n            });\n          });\n          return true;\n        }\n      }\n      return false;\n    };\n    const isBrokenAndroidClipboardEvent = e => {\n      var _a, _b;\n      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\n    };\n    const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\n    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {\n      let content = trimHtml(html);\n      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\n      const isPlainTextHtml = !isInternal && isPlainText(content);\n      const isAbsoluteUrl$1 = isAbsoluteUrl(content);\n      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\n        plainTextMode = true;\n      }\n      if (plainTextMode || isAbsoluteUrl$1) {\n        if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\n          content = clipboardContent['text/plain'];\n        } else {\n          content = innerText(content);\n        }\n      }\n      if (isDefaultPasteBinContent(content)) {\n        return;\n      }\n      if (plainTextMode) {\n        pasteText(editor, content, shouldSimulateInputEvent);\n      } else {\n        pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);\n      }\n    };\n    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\n      let keyboardPastePlainTextState;\n      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\n      editor.on('keydown', e => {\n        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\n        }\n      });\n      editor.on('paste', e => {\n        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n          return;\n        }\n        const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\n        keyboardPastePlainTextState = false;\n        const clipboardContent = getDataTransferItems(e.clipboardData);\n        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\n          return;\n        }\n        if (hasContentType(clipboardContent, 'text/html')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);\n        } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);\n        } else {\n          pasteBin.create();\n          Delay.setEditorTimeout(editor, () => {\n            const html = pasteBin.getHtml();\n            pasteBin.remove();\n            insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);\n          }, 0);\n        }\n      });\n    };\n    const registerDataImageFilter = editor => {\n      const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\n      const isDataUri = src => startsWith(src, 'data:');\n      const isPasteInsert = args => {\n        var _a;\n        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\n      };\n      editor.parser.addNodeFilter('img', (nodes, name, args) => {\n        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\n          for (const node of nodes) {\n            const src = node.attr('src');\n            if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\n              if (isWebKitFakeUrl(src)) {\n                node.remove();\n              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\n                node.remove();\n              }\n            }\n          }\n        }\n      });\n    };\n    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\n      registerEventHandlers(editor, pasteBin, pasteFormat);\n      registerDataImageFilter(editor);\n    };\n\n    const togglePlainTextPaste = (editor, pasteFormat) => {\n      if (pasteFormat.get() === 'text') {\n        pasteFormat.set('html');\n        firePastePlainTextToggle(editor, false);\n      } else {\n        pasteFormat.set('text');\n        firePastePlainTextToggle(editor, true);\n      }\n      editor.focus();\n    };\n    const register$1 = (editor, pasteFormat) => {\n      editor.addCommand('mceTogglePlainTextPaste', () => {\n        togglePlainTextPaste(editor, pasteFormat);\n      });\n      editor.addCommand('mceInsertClipboardContent', (ui, value) => {\n        if (value.html) {\n          pasteHtml(editor, value.html, value.internal, false);\n        }\n        if (value.text) {\n          pasteText(editor, value.text, false);\n        }\n      });\n    };\n\n    const setHtml5Clipboard = (clipboardData, html, text) => {\n      if (clipboardData) {\n        try {\n          clipboardData.clearData();\n          clipboardData.setData('text/html', html);\n          clipboardData.setData('text/plain', text);\n          clipboardData.setData(internalHtmlMime(), html);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    };\n    const setClipboardData = (evt, data, fallback, done) => {\n      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\n        evt.preventDefault();\n        done();\n      } else {\n        fallback(data.html, done);\n      }\n    };\n    const fallback = editor => (html, done) => {\n      const {dom, selection} = editor;\n      const outer = dom.create('div', {\n        'contenteditable': 'false',\n        'data-mce-bogus': 'all'\n      });\n      const inner = dom.create('div', { contenteditable: 'true' }, html);\n      dom.setStyles(outer, {\n        position: 'fixed',\n        top: '0',\n        left: '-3000px',\n        width: '1000px',\n        overflow: 'hidden'\n      });\n      outer.appendChild(inner);\n      dom.add(editor.getBody(), outer);\n      const range = selection.getRng();\n      inner.focus();\n      const offscreenRange = dom.createRng();\n      offscreenRange.selectNodeContents(inner);\n      selection.setRng(offscreenRange);\n      Delay.setEditorTimeout(editor, () => {\n        selection.setRng(range);\n        dom.remove(outer);\n        done();\n      }, 0);\n    };\n    const getData = editor => ({\n      html: mark(editor.selection.getContent({ contextual: true })),\n      text: editor.selection.getContent({ format: 'text' })\n    });\n    const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\n    const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\n    const cut = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor) && editor.selection.isEditable()) {\n        setClipboardData(evt, getData(editor), fallback(editor), () => {\n          if (Env.browser.isChromium() || Env.browser.isFirefox()) {\n            const rng = editor.selection.getRng();\n            Delay.setEditorTimeout(editor, () => {\n              editor.selection.setRng(rng);\n              editor.execCommand('Delete');\n            }, 0);\n          } else {\n            editor.execCommand('Delete');\n          }\n        });\n      }\n    };\n    const copy = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n        setClipboardData(evt, getData(editor), fallback(editor), noop);\n      }\n    };\n    const register = editor => {\n      editor.on('cut', cut(editor));\n      editor.on('copy', copy(editor));\n    };\n\n    const getCaretRangeFromEvent = (editor, e) => {\n      var _a, _b;\n      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\n    };\n    const isPlainTextFileUrl = content => {\n      const plainTextContent = content['text/plain'];\n      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\n    };\n    const setFocusedRange = (editor, rng) => {\n      editor.focus();\n      if (rng) {\n        editor.selection.setRng(rng);\n      }\n    };\n    const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\n    const needsCustomInternalDrop = (dom, schema, target, dropContent) => {\n      const parentTransparent = dom.getParent(target, node => isTransparentBlock(schema, node));\n      const inSummary = !isNull(dom.getParent(target, 'summary'));\n      if (inSummary) {\n        return true;\n      } else if (parentTransparent && has$2(dropContent, 'text/html')) {\n        const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;\n        return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));\n      } else {\n        return false;\n      }\n    };\n    const setupSummaryDeleteByDragFix = editor => {\n      editor.on('input', e => {\n        const hasNoSummary = el => isNull(el.querySelector('summary'));\n        if (e.inputType === 'deleteByDrag') {\n          const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);\n          each$e(brokenDetailElements, details => {\n            if (isBr$6(details.firstChild)) {\n              details.firstChild.remove();\n            }\n            const summary = editor.dom.create('summary');\n            summary.appendChild(createPaddingBr().dom);\n            details.prepend(summary);\n          });\n        }\n      });\n    };\n    const setup$a = (editor, draggingInternallyState) => {\n      if (shouldPasteBlockDrop(editor)) {\n        editor.on('dragend dragover draggesture dragdrop drop drag', e => {\n          e.preventDefault();\n          e.stopPropagation();\n        });\n      }\n      if (!shouldPasteDataImages(editor)) {\n        editor.on('drop', e => {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && hasImage(dataTransfer)) {\n            e.preventDefault();\n          }\n        });\n      }\n      editor.on('drop', e => {\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        const rng = getCaretRangeFromEvent(editor, e);\n        if (isNullable(rng)) {\n          return;\n        }\n        const dropContent = getDataTransferItems(e.dataTransfer);\n        const internal = hasContentType(dropContent, internalHtmlMime());\n        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\n          return;\n        }\n        const internalContent = dropContent[internalHtmlMime()];\n        const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\n        const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);\n        const isInternalDrop = draggingInternallyState.get();\n        if (isInternalDrop && !needsInternalDrop) {\n          return;\n        }\n        if (content) {\n          e.preventDefault();\n          Delay.setEditorTimeout(editor, () => {\n            editor.undoManager.transact(() => {\n              if (internalContent || isInternalDrop && needsInternalDrop) {\n                editor.execCommand('Delete');\n              }\n              setFocusedRange(editor, rng);\n              const trimmedContent = trimHtml(content);\n              if (dropContent['text/html']) {\n                pasteHtml(editor, trimmedContent, internal, true);\n              } else {\n                pasteText(editor, trimmedContent, true);\n              }\n            });\n          });\n        }\n      });\n      editor.on('dragstart', _e => {\n        draggingInternallyState.set(true);\n      });\n      editor.on('dragover dragend', e => {\n        if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {\n          e.preventDefault();\n          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\n        }\n        if (e.type === 'dragend') {\n          draggingInternallyState.set(false);\n        }\n      });\n      setupSummaryDeleteByDragFix(editor);\n    };\n\n    const setup$9 = editor => {\n      const processEvent = f => e => {\n        f(editor, e);\n      };\n      const preProcess = getPastePreProcess(editor);\n      if (isFunction(preProcess)) {\n        editor.on('PastePreProcess', processEvent(preProcess));\n      }\n      const postProcess = getPastePostProcess(editor);\n      if (isFunction(postProcess)) {\n        editor.on('PastePostProcess', processEvent(postProcess));\n      }\n    };\n\n    const addPreProcessFilter = (editor, filterFunc) => {\n      editor.on('PastePreProcess', e => {\n        e.content = filterFunc(editor, e.content, e.internal);\n      });\n    };\n    const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\n    const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\n    const removeWebKitStyles = (editor, content, internal) => {\n      const webKitStylesOption = getPasteWebkitStyles(editor);\n      if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\n        return content;\n      }\n      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\n      if (webKitStyles && webKitStylesOption !== 'none') {\n        const dom = editor.dom, node = editor.selection.getNode();\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\n          const inputStyles = dom.parseStyle(dom.decode(value));\n          const outputStyles = {};\n          for (let i = 0; i < webKitStyles.length; i++) {\n            const inputValue = inputStyles[webKitStyles[i]];\n            let compareInput = inputValue;\n            let currentValue = dom.getStyle(node, webKitStyles[i], true);\n            if (/color/.test(webKitStyles[i])) {\n              compareInput = rgbToHex(compareInput);\n              currentValue = rgbToHex(currentValue);\n            }\n            if (currentValue !== compareInput) {\n              outputStyles[webKitStyles[i]] = inputValue;\n            }\n          }\n          const outputStyle = dom.serializeStyle(outputStyles, 'span');\n          if (outputStyle) {\n            return before + ' style=\"' + outputStyle + '\"' + after;\n          }\n          return before + after;\n        });\n      } else {\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\n      }\n      content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\n        return before + ' style=\"' + value + '\"' + after;\n      });\n      return content;\n    };\n    const setup$8 = editor => {\n      if (Env.browser.isChromium() || Env.browser.isSafari()) {\n        addPreProcessFilter(editor, removeWebKitStyles);\n      }\n    };\n\n    const setup$7 = editor => {\n      const draggingInternallyState = Cell(false);\n      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\n      const pasteBin = PasteBin(editor);\n      setup$8(editor);\n      register$1(editor, pasteFormat);\n      setup$9(editor);\n      editor.on('PreInit', () => {\n        register(editor);\n        setup$a(editor, draggingInternallyState);\n        registerEventsAndFilters(editor, pasteBin, pasteFormat);\n      });\n    };\n\n    const preventSummaryToggle = editor => {\n      editor.on('click', e => {\n        if (editor.dom.getParent(e.target, 'details')) {\n          e.preventDefault();\n        }\n      });\n    };\n    const filterDetails = editor => {\n      editor.parser.addNodeFilter('details', elms => {\n        const initialStateOption = getDetailsInitialState(editor);\n        each$e(elms, details => {\n          if (initialStateOption === 'expanded') {\n            details.attr('open', 'open');\n          } else if (initialStateOption === 'collapsed') {\n            details.attr('open', null);\n          }\n        });\n      });\n      editor.serializer.addNodeFilter('details', elms => {\n        const serializedStateOption = getDetailsSerializedState(editor);\n        each$e(elms, details => {\n          if (serializedStateOption === 'expanded') {\n            details.attr('open', 'open');\n          } else if (serializedStateOption === 'collapsed') {\n            details.attr('open', null);\n          }\n        });\n      });\n    };\n    const setup$6 = editor => {\n      preventSummaryToggle(editor);\n      filterDetails(editor);\n    };\n\n    const isBr = isBr$6;\n    const isText = isText$a;\n    const isContentEditableFalse$2 = elm => isContentEditableFalse$b(elm.dom);\n    const isContentEditableTrue = elm => isContentEditableTrue$3(elm.dom);\n    const isRoot = rootNode => elm => eq(SugarElement.fromDom(rootNode), elm);\n    const getClosestScope = (node, rootNode, schema) => closest$4(SugarElement.fromDom(node), elm => isContentEditableTrue(elm) || schema.isBlock(name(elm)), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;\n    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));\n    const findEdgeCaretCandidate = (startNode, scope, forward) => {\n      const walker = new DomTreeWalker(startNode, scope);\n      const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);\n      let result = startNode;\n      for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {\n        if (isCaretCandidate$3(current)) {\n          result = current;\n        }\n      }\n      return result;\n    };\n    const findClosestBlockRange = (startRng, rootNode, schema) => {\n      const startPos = CaretPosition.fromRangeStart(startRng);\n      const clickNode = startPos.getNode();\n      const scope = getClosestScope(clickNode, rootNode, schema);\n      const startNode = findEdgeCaretCandidate(clickNode, scope, false);\n      const endNode = findEdgeCaretCandidate(clickNode, scope, true);\n      const rng = document.createRange();\n      getClosestCef(startNode, scope).fold(() => {\n        if (isText(startNode)) {\n          rng.setStart(startNode, 0);\n        } else {\n          rng.setStartBefore(startNode);\n        }\n      }, cef => rng.setStartBefore(cef.dom));\n      getClosestCef(endNode, scope).fold(() => {\n        if (isText(endNode)) {\n          rng.setEnd(endNode, endNode.data.length);\n        } else {\n          rng.setEndAfter(endNode);\n        }\n      }, cef => rng.setEndAfter(cef.dom));\n      return rng;\n    };\n    const onTripleClickSelect = editor => {\n      const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody(), editor.schema);\n      editor.selection.setRng(normalize(rng));\n    };\n    const setup$5 = editor => {\n      editor.on('mousedown', e => {\n        if (e.detail >= 3) {\n          e.preventDefault();\n          onTripleClickSelect(editor);\n        }\n      });\n    };\n\n    var FakeCaretPosition;\n    (function (FakeCaretPosition) {\n      FakeCaretPosition['Before'] = 'before';\n      FakeCaretPosition['After'] = 'after';\n    }(FakeCaretPosition || (FakeCaretPosition = {})));\n    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\n    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\n    const isOverlapping = (r1, r2) => {\n      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\n      return collidesY(r1, r2) && overlap > 0.5;\n    };\n    const splitRectsPerAxis = (rects, y) => {\n      const intersectingRects = filter$5(rects, rect => isInsideY(y, rect));\n      return boundingClientRectFromRects(intersectingRects).fold(() => [\n        [],\n        rects\n      ], boundingRect => {\n        const {\n          pass: horizontal,\n          fail: vertical\n        } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\n        return [\n          horizontal,\n          vertical\n        ];\n      });\n    };\n    const clientInfo = (rect, clientX) => {\n      return {\n        node: rect.node,\n        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\n      };\n    };\n    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\n    const closestChildCaretCandidateNodeRect = (children, clientX, clientY, findCloserTextNode) => {\n      const caretCandidateRect = rect => {\n        if (isCaretCandidate$3(rect.node)) {\n          return Optional.some(rect);\n        } else if (isElement$6(rect.node)) {\n          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY, false);\n        } else {\n          return Optional.none();\n        }\n      };\n      const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {\n        return caretCandidateRect(sndClosest).filter(rect => {\n          const deltaDistance = Math.abs(distance(closest, clientX, clientY) - distance(rect, clientX, clientY));\n          return deltaDistance < 2 && isText$a(rect.node);\n        });\n      };\n      const findClosestCaretCandidateNodeRect = (rects, distance) => {\n        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n        return findMap(sortedRects, caretCandidateRect).map(closest => {\n          if (findCloserTextNode && !isText$a(closest.node) && sortedRects.length > 1) {\n            return tryFindSecondBestTextNode(closest, sortedRects[1], distance).getOr(closest);\n          } else {\n            return closest;\n          }\n        });\n      };\n      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\n      const {\n        pass: above,\n        fail: below\n      } = partition$2(verticalRects, rect => rect.top < clientY);\n      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\n    };\n    const traverseUp = (rootElm, scope, clientX, clientY) => {\n      const helper = (scope, prevScope) => {\n        const isDragGhostContainer = node => isElement$6(node) && node.classList.contains('mce-drag-container');\n        const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));\n        return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY, true), prevScope => {\n          const uncheckedChildren = filter$5(childNodesWithoutGhost, node => node !== prevScope.dom);\n          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY, true);\n        }).orThunk(() => {\n          const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\n          return parent.bind(newScope => helper(newScope, Optional.some(scope)));\n        });\n      };\n      return helper(scope, Optional.none());\n    };\n    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\n      const rootElm = SugarElement.fromDom(root);\n      const ownerDoc = documentOrOwner(rootElm);\n      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\n      const element = elementAtPoint.getOr(rootElm);\n      return traverseUp(rootElm, element, clientX, clientY);\n    };\n    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\n\n    const getAbsolutePosition = elm => {\n      var _a, _b;\n      const clientRect = elm.getBoundingClientRect();\n      const doc = elm.ownerDocument;\n      const docElem = doc.documentElement;\n      const win = doc.defaultView;\n      return {\n        top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,\n        left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft\n      };\n    };\n    const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\n      left: 0,\n      top: 0\n    };\n    const getScrollPosition = editor => {\n      const body = editor.getBody();\n      return editor.inline ? {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      } : {\n        left: 0,\n        top: 0\n      };\n    };\n    const getBodyScroll = editor => {\n      const body = editor.getBody(), docElm = editor.getDoc().documentElement;\n      const inlineScroll = {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      };\n      const iframeScroll = {\n        left: body.scrollLeft || docElm.scrollLeft,\n        top: body.scrollTop || docElm.scrollTop\n      };\n      return editor.inline ? inlineScroll : iframeScroll;\n    };\n    const getMousePosition = (editor, event) => {\n      if (event.target.ownerDocument !== editor.getDoc()) {\n        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\n        const scrollPosition = getBodyScroll(editor);\n        return {\n          left: event.pageX - iframePosition.left + scrollPosition.left,\n          top: event.pageY - iframePosition.top + scrollPosition.top\n        };\n      }\n      return {\n        left: event.pageX,\n        top: event.pageY\n      };\n    };\n    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\n      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\n      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\n    });\n    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\n\n    const getTargetProps = target => ({\n      target,\n      srcElement: target\n    });\n    const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({\n      ...mouseEvent,\n      dataTransfer,\n      type,\n      ...getTargetProps(target)\n    });\n    const makeDndEvent = (type, target, dataTransfer) => {\n      const fail = die('Function not supported on simulated event.');\n      const event = {\n        bubbles: true,\n        cancelBubble: false,\n        cancelable: true,\n        composed: false,\n        currentTarget: null,\n        defaultPrevented: false,\n        eventPhase: 0,\n        isTrusted: true,\n        returnValue: false,\n        timeStamp: 0,\n        type,\n        composedPath: fail,\n        initEvent: fail,\n        preventDefault: noop,\n        stopImmediatePropagation: noop,\n        stopPropagation: noop,\n        AT_TARGET: window.Event.AT_TARGET,\n        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,\n        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,\n        NONE: window.Event.NONE,\n        altKey: false,\n        button: 0,\n        buttons: 0,\n        clientX: 0,\n        clientY: 0,\n        ctrlKey: false,\n        metaKey: false,\n        movementX: 0,\n        movementY: 0,\n        offsetX: 0,\n        offsetY: 0,\n        pageX: 0,\n        pageY: 0,\n        relatedTarget: null,\n        screenX: 0,\n        screenY: 0,\n        shiftKey: false,\n        x: 0,\n        y: 0,\n        detail: 0,\n        view: null,\n        which: 0,\n        initUIEvent: fail,\n        initMouseEvent: fail,\n        getModifierState: fail,\n        dataTransfer,\n        ...getTargetProps(target)\n      };\n      return event;\n    };\n    const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {\n      const copy = cloneDataTransfer(dataTransfer);\n      if (eventType === 'dragstart') {\n        setDragstartEvent(copy);\n        setReadWriteMode(copy);\n      } else if (eventType === 'drop') {\n        setDropEvent(copy);\n        setReadOnlyMode(copy);\n      } else {\n        setDragendEvent(copy);\n        setProtectedMode(copy);\n      }\n      return copy;\n    };\n    const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {\n      const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);\n      return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);\n    };\n\n    const scrollPixelsPerInterval = 32;\n    const scrollIntervalValue = 100;\n    const mouseRangeToTriggerScrollInsideEditor = 8;\n    const mouseRangeToTriggerScrollOutsideEditor = 16;\n    const isContentEditableFalse$1 = isContentEditableFalse$b;\n    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);\n    const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);\n    const isValidDropTarget = (editor, targetElement, dragElement) => {\n      if (isNullable(targetElement)) {\n        return false;\n      } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\n        return false;\n      } else {\n        return editor.dom.isEditable(targetElement);\n      }\n    };\n    const createGhost = (editor, elm, width, height) => {\n      const dom = editor.dom;\n      const clonedElm = elm.cloneNode(true);\n      dom.setStyles(clonedElm, {\n        width,\n        height\n      });\n      dom.setAttrib(clonedElm, 'data-mce-selected', null);\n      const ghostElm = dom.create('div', {\n        'class': 'mce-drag-container',\n        'data-mce-bogus': 'all',\n        'unselectable': 'on',\n        'contenteditable': 'false'\n      });\n      dom.setStyles(ghostElm, {\n        position: 'absolute',\n        opacity: 0.5,\n        overflow: 'hidden',\n        border: 0,\n        padding: 0,\n        margin: 0,\n        width,\n        height\n      });\n      dom.setStyles(clonedElm, {\n        margin: 0,\n        boxSizing: 'border-box'\n      });\n      ghostElm.appendChild(clonedElm);\n      return ghostElm;\n    };\n    const appendGhostToBody = (ghostElm, bodyElm) => {\n      if (ghostElm.parentNode !== bodyElm) {\n        bodyElm.appendChild(ghostElm);\n      }\n    };\n    const scrollEditor = (direction, amount) => win => () => {\n      const current = direction === 'left' ? win.scrollX : win.scrollY;\n      win.scroll({\n        [direction]: current + amount,\n        behavior: 'smooth'\n      });\n    };\n    const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);\n    const scrollRight = scrollEditor('left', scrollPixelsPerInterval);\n    const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);\n    const scrollDown = scrollEditor('top', scrollPixelsPerInterval);\n    const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {\n      let overflowX = 0, overflowY = 0;\n      ghostElm.style.left = position.pageX + 'px';\n      ghostElm.style.top = position.pageY + 'px';\n      if (position.pageX + width > maxX) {\n        overflowX = position.pageX + width - maxX;\n      }\n      if (position.pageY + height > maxY) {\n        overflowY = position.pageY + height - maxY;\n      }\n      ghostElm.style.width = width - overflowX + 'px';\n      ghostElm.style.height = height - overflowY + 'px';\n      const clientHeight = contentAreaContainer.clientHeight;\n      const clientWidth = contentAreaContainer.clientWidth;\n      const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;\n      const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;\n      state.on(state => {\n        state.intervalId.clear();\n        if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {\n          if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {\n            state.intervalId.set(scrollDown(win));\n          } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {\n            state.intervalId.set(scrollUp(win));\n          } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {\n            state.intervalId.set(scrollRight(win));\n          } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {\n            state.intervalId.set(scrollLeft(win));\n          } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {\n            state.intervalId.set(scrollDown(window));\n          } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n            state.intervalId.set(scrollUp(window));\n          } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {\n            state.intervalId.set(scrollRight(window));\n          } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n            state.intervalId.set(scrollLeft(window));\n          }\n        }\n      });\n    };\n    const removeElement = elm => {\n      if (elm && elm.parentNode) {\n        elm.parentNode.removeChild(elm);\n      }\n    };\n    const removeElementWithPadding = (dom, elm) => {\n      const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);\n      removeElement(elm);\n      if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {\n        fillWithPaddingBr(SugarElement.fromDom(parentBlock));\n      }\n    };\n    const isLeftMouseButtonPressed = e => e.button === 0;\n    const applyRelPos = (state, position) => ({\n      pageX: position.pageX - state.relX,\n      pageY: position.pageY + 5\n    });\n    const start = (state, editor) => e => {\n      if (isLeftMouseButtonPressed(e)) {\n        const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);\n        if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {\n          const elmPos = editor.dom.getPos(ceElm);\n          const bodyElm = editor.getBody();\n          const docElm = editor.getDoc().documentElement;\n          state.set({\n            element: ceElm,\n            dataTransfer: createDataTransfer(),\n            dragging: false,\n            screenX: e.screenX,\n            screenY: e.screenY,\n            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\n            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\n            relX: e.pageX - elmPos.x,\n            relY: e.pageY - elmPos.y,\n            width: ceElm.offsetWidth,\n            height: ceElm.offsetHeight,\n            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),\n            intervalId: repeatable(scrollIntervalValue)\n          });\n        }\n      }\n    };\n    const placeCaretAt = (editor, clientX, clientY) => {\n      editor._selectionOverrides.hideFakeCaret();\n      closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), caretInfo => {\n        const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n        if (range) {\n          editor.selection.setRng(range);\n        } else {\n          editor.selection.placeCaretAt(clientX, clientY);\n        }\n      });\n    };\n    const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {\n      if (type === 'dragstart') {\n        setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));\n      }\n      const event = makeDragEvent(type, target, dataTransfer, mouseEvent);\n      const args = editor.dispatch(type, event);\n      return args;\n    };\n    const move = (state, editor) => {\n      const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);\n      editor.on('remove', throttledPlaceCaretAt.cancel);\n      const state_ = state;\n      return e => state.on(state => {\n        const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\n        if (!state.dragging && movement > 10) {\n          const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);\n          if (isNonNullable(args.dataTransfer)) {\n            state.dataTransfer = args.dataTransfer;\n          }\n          if (args.isDefaultPrevented()) {\n            return;\n          }\n          state.dragging = true;\n          editor.focus();\n        }\n        if (state.dragging) {\n          const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;\n          const targetPos = applyRelPos(state, calc(editor, e));\n          appendGhostToBody(state.ghost, editor.getBody());\n          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);\n          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\n        }\n      });\n    };\n    const getRawTarget = selection => {\n      const sel = selection.getSel();\n      if (isNonNullable(sel)) {\n        const rng = sel.getRangeAt(0);\n        const startContainer = rng.startContainer;\n        return isText$a(startContainer) ? startContainer.parentNode : startContainer;\n      } else {\n        return null;\n      }\n    };\n    const drop = (state, editor) => e => {\n      state.on(state => {\n        var _a;\n        state.intervalId.clear();\n        if (state.dragging) {\n          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\n            const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();\n            const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);\n            if (!args.isDefaultPrevented()) {\n              editor.undoManager.transact(() => {\n                removeElementWithPadding(editor.dom, state.element);\n                getHtmlData(state.dataTransfer).each(content => editor.insertContent(content));\n                editor._selectionOverrides.hideFakeCaret();\n              });\n            }\n          }\n          dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);\n        }\n      });\n      removeDragState(state);\n    };\n    const stopDragging = (state, editor, e) => {\n      state.on(state => {\n        state.intervalId.clear();\n        if (state.dragging) {\n          e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), mouseEvent => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));\n        }\n      });\n      removeDragState(state);\n    };\n    const stop = (state, editor) => e => stopDragging(state, editor, Optional.some(e));\n    const removeDragState = state => {\n      state.on(state => {\n        state.intervalId.clear();\n        removeElement(state.ghost);\n      });\n      state.clear();\n    };\n    const bindFakeDragEvents = editor => {\n      const state = value$2();\n      const pageDom = DOMUtils.DOM;\n      const rootDocument = document;\n      const dragStartHandler = start(state, editor);\n      const dragHandler = move(state, editor);\n      const dropHandler = drop(state, editor);\n      const dragEndHandler = stop(state, editor);\n      editor.on('mousedown', dragStartHandler);\n      editor.on('mousemove', dragHandler);\n      editor.on('mouseup', dropHandler);\n      pageDom.bind(rootDocument, 'mousemove', dragHandler);\n      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\n      editor.on('remove', () => {\n        pageDom.unbind(rootDocument, 'mousemove', dragHandler);\n        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\n      });\n      editor.on('keydown', e => {\n        if (e.keyCode === VK.ESC) {\n          stopDragging(state, editor, Optional.none());\n        }\n      });\n    };\n    const blockUnsupportedFileDrop = editor => {\n      const preventFileDrop = e => {\n        if (!e.isDefaultPrevented()) {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\n            e.preventDefault();\n            if (e.type === 'drop') {\n              displayError(editor, 'Dropped file type is not supported');\n            }\n          }\n        }\n      };\n      const preventFileDropIfUIElement = e => {\n        if (isUIElement(editor, e.target)) {\n          preventFileDrop(e);\n        }\n      };\n      const setup = () => {\n        const pageDom = DOMUtils.DOM;\n        const dom = editor.dom;\n        const doc = document;\n        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\n        const eventNames = [\n          'drop',\n          'dragover'\n        ];\n        each$e(eventNames, name => {\n          pageDom.bind(doc, name, preventFileDropIfUIElement);\n          dom.bind(editorRoot, name, preventFileDrop);\n        });\n        editor.on('remove', () => {\n          each$e(eventNames, name => {\n            pageDom.unbind(doc, name, preventFileDropIfUIElement);\n            dom.unbind(editorRoot, name, preventFileDrop);\n          });\n        });\n      };\n      editor.on('init', () => {\n        Delay.setEditorTimeout(editor, setup, 0);\n      });\n    };\n    const init$2 = editor => {\n      bindFakeDragEvents(editor);\n      if (shouldBlockUnsupportedDrop(editor)) {\n        blockUnsupportedFileDrop(editor);\n      }\n    };\n\n    const setup$4 = editor => {\n      const renderFocusCaret = first$1(() => {\n        if (!editor.removed && editor.getBody().contains(document.activeElement)) {\n          const rng = editor.selection.getRng();\n          if (rng.collapsed) {\n            const caretRange = renderRangeCaret(editor, rng, false);\n            editor.selection.setRng(caretRange);\n          }\n        }\n      }, 0);\n      editor.on('focus', () => {\n        renderFocusCaret.throttle();\n      });\n      editor.on('blur', () => {\n        renderFocusCaret.cancel();\n      });\n    };\n\n    const setup$3 = editor => {\n      editor.on('init', () => {\n        editor.on('focusin', e => {\n          const target = e.target;\n          if (isMedia$2(target)) {\n            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\n            const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;\n            if (editor.selection.getNode() !== node) {\n              selectNode(editor, node).each(rng => editor.selection.setRng(rng));\n            }\n          }\n        });\n      });\n    };\n\n    const isContentEditableFalse = isContentEditableFalse$b;\n    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\n    const SelectionOverrides = editor => {\n      const selection = editor.selection, dom = editor.dom;\n      const rootNode = editor.getBody();\n      const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));\n      const realSelectionId = 'sel-' + dom.uniqueId();\n      const elementSelectionAttr = 'data-mce-selected';\n      let selectedElement;\n      const isFakeSelectionElement = node => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');\n      const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);\n      const setRange = range => {\n        if (range) {\n          selection.setRng(range);\n        }\n      };\n      const showCaret = (direction, node, before, scrollIntoView = true) => {\n        const e = editor.dispatch('ShowCaret', {\n          target: node,\n          direction,\n          before\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        if (scrollIntoView) {\n          selection.scrollIntoView(node, direction === -1);\n        }\n        return fakeCaret.show(before, node);\n      };\n      const showBlockCaretContainer = blockCaretContainer => {\n        if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n          showCaretContainerBlock(blockCaretContainer);\n          selection.scrollIntoView(blockCaretContainer);\n        }\n      };\n      const registerEvents = () => {\n        editor.on('click', e => {\n          if (!dom.isEditable(e.target)) {\n            e.preventDefault();\n            editor.focus();\n          }\n        });\n        editor.on('blur NewBlock', removeElementSelection);\n        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\n        editor.on('tap', e => {\n          const targetElm = e.target;\n          const contentEditableRoot = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(contentEditableRoot)) {\n            e.preventDefault();\n            selectNode(editor, contentEditableRoot).each(setElementSelection);\n          } else if (isFakeSelectionTargetElement(targetElm)) {\n            selectNode(editor, targetElm).each(setElementSelection);\n          }\n        }, true);\n        editor.on('mousedown', e => {\n          const targetElm = e.target;\n          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\n            return;\n          }\n          if (!isXYInContentArea(editor, e.clientX, e.clientY)) {\n            return;\n          }\n          removeElementSelection();\n          hideFakeCaret();\n          const closestContentEditable = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(closestContentEditable)) {\n            e.preventDefault();\n            selectNode(editor, closestContentEditable).each(setElementSelection);\n          } else {\n            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\n              e.preventDefault();\n              const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n              setRange(range);\n              if (isHTMLElement(closestContentEditable)) {\n                closestContentEditable.focus();\n              } else {\n                editor.getBody().focus();\n              }\n            });\n          }\n        });\n        editor.on('keypress', e => {\n          if (VK.modifierPressed(e)) {\n            return;\n          }\n          if (isContentEditableFalse(selection.getNode())) {\n            e.preventDefault();\n          }\n        });\n        editor.on('GetSelectionRange', e => {\n          let rng = e.range;\n          if (selectedElement) {\n            if (!selectedElement.parentNode) {\n              selectedElement = null;\n              return;\n            }\n            rng = rng.cloneRange();\n            rng.selectNode(selectedElement);\n            e.range = rng;\n          }\n        });\n        editor.on('SetSelectionRange', e => {\n          e.range = normalizeVoidElementSelection(e.range);\n          const rng = setElementSelection(e.range, e.forward);\n          if (rng) {\n            e.range = rng;\n          }\n        });\n        const isPasteBin = node => isElement$6(node) && node.id === 'mcepastebin';\n        editor.on('AfterSetSelectionRange', e => {\n          const rng = e.range;\n          const parent = rng.startContainer.parentElement;\n          if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {\n            hideFakeCaret();\n          }\n          if (!isFakeSelectionElement(parent)) {\n            removeElementSelection();\n          }\n        });\n        init$2(editor);\n        setup$4(editor);\n        setup$3(editor);\n      };\n      const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\n      const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\n      const normalizeVoidElementSelection = rng => {\n        const voidElements = editor.schema.getVoidElements();\n        const newRng = dom.createRng();\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\n          if (startOffset === 0) {\n            newRng.setStartBefore(startContainer);\n          } else {\n            newRng.setStartAfter(startContainer);\n          }\n        } else {\n          newRng.setStart(startContainer, startOffset);\n        }\n        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\n          if (endOffset === 0) {\n            newRng.setEndBefore(endContainer);\n          } else {\n            newRng.setEndAfter(endContainer);\n          }\n        } else {\n          newRng.setEnd(endContainer, endOffset);\n        }\n        return newRng;\n      };\n      const setupOffscreenSelection = (node, targetClone) => {\n        const body = SugarElement.fromDom(editor.getBody());\n        const doc = editor.getDoc();\n        const realSelectionContainer = descendant$1(body, '#' + realSelectionId).getOrThunk(() => {\n          const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\n          set$3(newContainer, 'id', realSelectionId);\n          append$1(body, newContainer);\n          return newContainer;\n        });\n        const newRange = dom.createRng();\n        empty(realSelectionContainer);\n        append(realSelectionContainer, [\n          SugarElement.fromText(nbsp, doc),\n          SugarElement.fromDom(targetClone),\n          SugarElement.fromText(nbsp, doc)\n        ]);\n        newRange.setStart(realSelectionContainer.dom.firstChild, 1);\n        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\n        setAll(realSelectionContainer, { top: dom.getPos(node, editor.getBody()).y + 'px' });\n        focus$1(realSelectionContainer);\n        const sel = selection.getSel();\n        if (sel) {\n          sel.removeAllRanges();\n          sel.addRange(newRange);\n        }\n        return newRange;\n      };\n      const selectElement = elm => {\n        const targetClone = elm.cloneNode(true);\n        const e = editor.dispatch('ObjectSelected', {\n          target: elm,\n          targetClone\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        const range = setupOffscreenSelection(elm, e.targetClone);\n        const nodeElm = SugarElement.fromDom(elm);\n        each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${ elementSelectionAttr }]`), elm => {\n          if (!eq(nodeElm, elm)) {\n            remove$a(elm, elementSelectionAttr);\n          }\n        });\n        if (!dom.getAttrib(elm, elementSelectionAttr)) {\n          elm.setAttribute(elementSelectionAttr, '1');\n        }\n        selectedElement = elm;\n        hideFakeCaret();\n        return range;\n      };\n      const setElementSelection = (range, forward) => {\n        if (!range) {\n          return null;\n        }\n        if (range.collapsed) {\n          if (!isRangeInCaretContainer(range)) {\n            const dir = forward ? 1 : -1;\n            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\n            const beforeNode = caretPosition.getNode(!forward);\n            if (isNonNullable(beforeNode)) {\n              if (isFakeCaretTarget(beforeNode)) {\n                return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\n              }\n              if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {\n                const rng = dom.createRng();\n                rng.setStart(beforeNode, 0);\n                rng.setEnd(beforeNode, 0);\n                return rng;\n              }\n            }\n            const afterNode = caretPosition.getNode(forward);\n            if (isNonNullable(afterNode)) {\n              if (isFakeCaretTarget(afterNode)) {\n                return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\n              }\n              if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {\n                const rng = dom.createRng();\n                rng.setStart(afterNode, 1);\n                rng.setEnd(afterNode, 1);\n                return rng;\n              }\n            }\n          }\n          return null;\n        }\n        let startContainer = range.startContainer;\n        let startOffset = range.startOffset;\n        const endOffset = range.endOffset;\n        if (isText$a(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\n          startContainer = startContainer.parentNode;\n          startOffset = dom.nodeIndex(startContainer);\n          startContainer = startContainer.parentNode;\n        }\n        if (!isElement$6(startContainer)) {\n          return null;\n        }\n        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\n          const node = startContainer.childNodes[startOffset];\n          if (isFakeSelectionTargetElement(node)) {\n            return selectElement(node);\n          }\n        }\n        return null;\n      };\n      const removeElementSelection = () => {\n        if (selectedElement) {\n          selectedElement.removeAttribute(elementSelectionAttr);\n        }\n        descendant$1(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$5);\n        selectedElement = null;\n      };\n      const destroy = () => {\n        fakeCaret.destroy();\n        selectedElement = null;\n      };\n      const hideFakeCaret = () => {\n        fakeCaret.hide();\n      };\n      if (!isRtc(editor)) {\n        registerEvents();\n      }\n      return {\n        showCaret,\n        showBlockCaretContainer,\n        hideFakeCaret,\n        destroy\n      };\n    };\n\n    const getNormalizedTextOffset = (container, offset) => {\n      let normalizedOffset = offset;\n      for (let node = container.previousSibling; isText$a(node); node = node.previousSibling) {\n        normalizedOffset += node.data.length;\n      }\n      return normalizedOffset;\n    };\n    const generatePath = (dom, root, node, offset, normalized) => {\n      if (isText$a(node) && (offset < 0 || offset > node.data.length)) {\n        return [];\n      }\n      const p = normalized && isText$a(node) ? [getNormalizedTextOffset(node, offset)] : [offset];\n      let current = node;\n      while (current !== root && current.parentNode) {\n        p.push(dom.nodeIndex(current, normalized));\n        current = current.parentNode;\n      }\n      return current === root ? p.reverse() : [];\n    };\n    const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {\n      const start = generatePath(dom, root, startNode, startOffset, normalized);\n      const end = generatePath(dom, root, endNode, endOffset, normalized);\n      return {\n        start,\n        end\n      };\n    };\n    const resolvePath = (root, path) => {\n      const nodePath = path.slice();\n      const offset = nodePath.pop();\n      if (!isNumber(offset)) {\n        return Optional.none();\n      } else {\n        const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\n        return resolvedNode.bind(node => {\n          if (isText$a(node) && (offset < 0 || offset > node.data.length)) {\n            return Optional.none();\n          } else {\n            return Optional.some({\n              node,\n              offset\n            });\n          }\n        });\n      }\n    };\n    const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({\n      node: startNode,\n      offset: startOffset\n    }) => resolvePath(root, range.end).map(({\n      node: endNode,\n      offset: endOffset\n    }) => {\n      const rng = document.createRange();\n      rng.setStart(startNode, startOffset);\n      rng.setEnd(endNode, endOffset);\n      return rng;\n    }));\n    const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);\n\n    const cleanEmptyNodes = (dom, node, isRoot) => {\n      if (node && dom.isEmpty(node) && !isRoot(node)) {\n        const parent = node.parentNode;\n        dom.remove(node, isText$a(node.firstChild) && isWhitespaceText(node.firstChild.data));\n        cleanEmptyNodes(dom, parent, isRoot);\n      }\n    };\n    const deleteRng = (dom, rng, isRoot, clean = true) => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      rng.deleteContents();\n      if (clean && !isRoot(rng.startContainer)) {\n        if (isText$a(rng.startContainer) && rng.startContainer.data.length === 0) {\n          dom.remove(rng.startContainer);\n        }\n        if (isText$a(rng.endContainer) && rng.endContainer.data.length === 0) {\n          dom.remove(rng.endContainer);\n        }\n        cleanEmptyNodes(dom, startParent, isRoot);\n        if (startParent !== endParent) {\n          cleanEmptyNodes(dom, endParent, isRoot);\n        }\n      }\n    };\n    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {\n      const dynamicPatterns = patternSet.dynamicPatternsLookup({\n        text: beforeText,\n        block\n      });\n      return {\n        ...patternSet,\n        blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),\n        inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)\n      };\n    };\n    const getBeforeText = (dom, block, node, offset) => {\n      const rng = dom.createRng();\n      rng.setStart(block, 0);\n      rng.setEnd(node, offset);\n      return rng.toString();\n    };\n\n    const startsWithSingleSpace = s => /^\\s[^\\s]/.test(s);\n    const stripPattern = (dom, block, pattern) => {\n      const firstTextNode = textAfter(block, 0, block);\n      firstTextNode.each(spot => {\n        const node = spot.container;\n        scanRight(node, pattern.start.length, block).each(end => {\n          const rng = dom.createRng();\n          rng.setStart(node, 0);\n          rng.setEnd(end.container, end.offset);\n          deleteRng(dom, rng, e => e === block);\n        });\n        const text = SugarElement.fromDom(node);\n        const textContent = get$3(text);\n        if (startsWithSingleSpace(textContent)) {\n          set(text, textContent.slice(1));\n        }\n      });\n    };\n    const applyPattern$1 = (editor, match) => {\n      const dom = editor.dom;\n      const pattern = match.pattern;\n      const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n      const isBlockFormatName = (name, formatter) => {\n        const formatSet = formatter.get(name);\n        return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\n      };\n      getParentBlock(editor, rng).each(block => {\n        if (pattern.type === 'block-format') {\n          if (isBlockFormatName(pattern.format, editor.formatter)) {\n            editor.undoManager.transact(() => {\n              stripPattern(editor.dom, block, pattern);\n              editor.formatter.apply(pattern.format);\n            });\n          }\n        } else if (pattern.type === 'block-command') {\n          editor.undoManager.transact(() => {\n            stripPattern(editor.dom, block, pattern);\n            editor.execCommand(pattern.cmd, false, pattern.value);\n          });\n        }\n      });\n      return true;\n    };\n    const sortPatterns$1 = patterns => sort(patterns, (a, b) => b.start.length - a.start.length);\n    const findPattern$1 = (patterns, text) => {\n      const sortedPatterns = sortPatterns$1(patterns);\n      const nuText = text.replace(nbsp, ' ');\n      return find$2(sortedPatterns, pattern => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\n    };\n    const findPatterns$1 = (editor, block, patternSet, normalizedMatches) => {\n      var _a;\n      const dom = editor.dom;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!dom.is(block, forcedRootBlock)) {\n        return [];\n      }\n      const blockText = (_a = block.textContent) !== null && _a !== void 0 ? _a : '';\n      return findPattern$1(patternSet.blockPatterns, blockText).map(pattern => {\n        if (Tools.trim(blockText).length === pattern.start.length) {\n          return [];\n        }\n        return [{\n            pattern,\n            range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)\n          }];\n      }).getOr([]);\n    };\n    const applyMatches$1 = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const bookmark = editor.selection.getBookmark();\n      each$e(matches, match => applyPattern$1(editor, match));\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const newMarker = (dom, id) => dom.create('span', {\n      'data-mce-type': 'bookmark',\n      id\n    });\n    const rangeFromMarker = (dom, marker) => {\n      const rng = dom.createRng();\n      rng.setStartAfter(marker.start);\n      rng.setEndBefore(marker.end);\n      return rng;\n    };\n    const createMarker = (dom, markerPrefix, pathRange) => {\n      const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n      const startNode = rng.startContainer;\n      const endNode = rng.endContainer;\n      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n      const startParentNode = textStart.parentNode;\n      const endParentNode = textEnd.parentNode;\n      return {\n        prefix: markerPrefix,\n        end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n        start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n      };\n    };\n    const removeMarker = (dom, marker, isRoot) => {\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n    };\n\n    const isReplacementPattern = pattern => pattern.start.length === 0;\n    const matchesPattern = patternContent => (element, offset) => {\n      const text = element.data;\n      const searchText = text.substring(0, offset);\n      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\n      const startIndex = searchText.lastIndexOf(patternContent);\n      if (startIndex !== -1) {\n        return startIndex + patternContent.length;\n      } else if (startEndIndex !== -1) {\n        return startEndIndex + 1;\n      } else {\n        return -1;\n      }\n    };\n    const findPatternStartFromSpot = (dom, pattern, block, spot) => {\n      const startPattern = pattern.start;\n      const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\n      return startSpot.bind(spot => {\n        var _a, _b;\n        const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;\n        const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;\n        if (isCompleteMatch) {\n          const rng = dom.createRng();\n          rng.setStart(spot.container, spot.offset - startPattern.length);\n          rng.setEnd(spot.container, spot.offset);\n          return Optional.some(rng);\n        } else {\n          const offset = spot.offset - startPattern.length;\n          return scanLeft(spot.container, offset, block).map(nextSpot => {\n            const rng = dom.createRng();\n            rng.setStart(nextSpot.container, nextSpot.offset);\n            rng.setEnd(spot.container, spot.offset);\n            return rng;\n          }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\n        }\n      });\n    };\n    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {\n      if (pattern.start.length === 0 && !requireGap) {\n        const rng = dom.createRng();\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        return Optional.some(rng);\n      }\n      return textBefore(node, offset, block).bind(spot => {\n        const start = findPatternStartFromSpot(dom, pattern, block, spot);\n        return start.bind(startRange => {\n          var _a;\n          if (requireGap) {\n            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\n              return Optional.none();\n            } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {\n              return Optional.none();\n            }\n          }\n          return Optional.some(startRange);\n        });\n      });\n    };\n    const findPattern = (editor, block, details, normalizedMatches) => {\n      const dom = editor.dom;\n      const root = dom.getRoot();\n      const pattern = details.pattern;\n      const endNode = details.position.container;\n      const endOffset = details.position.offset;\n      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\n        const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);\n        if (isReplacementPattern(pattern)) {\n          return Optional.some({\n            matches: [{\n                pattern,\n                startRng: endPathRng,\n                endRng: endPathRng\n              }],\n            position: spot\n          });\n        } else {\n          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);\n          const results = resultsOpt.getOr({\n            matches: [],\n            position: spot\n          });\n          const pos = results.position;\n          const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\n          return start.map(startRng => {\n            const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);\n            return {\n              matches: results.matches.concat([{\n                  pattern,\n                  startRng: startPathRng,\n                  endRng: endPathRng\n                }]),\n              position: point(startRng.startContainer, startRng.startOffset)\n            };\n          });\n        }\n      });\n    };\n    const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {\n      const dom = editor.dom;\n      return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\n        const text = getBeforeText(dom, block, node, offset);\n        for (let i = 0; i < patterns.length; i++) {\n          const pattern = patterns[i];\n          if (!endsWith(text, pattern.end)) {\n            continue;\n          }\n          const patternsWithoutCurrent = patterns.slice();\n          patternsWithoutCurrent.splice(i, 1);\n          const result = findPattern(editor, block, {\n            pattern,\n            remainingPatterns: patternsWithoutCurrent,\n            position: endSpot\n          }, normalizedMatches);\n          if (result.isNone() && offset > 0) {\n            return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);\n          }\n          if (result.isSome()) {\n            return result;\n          }\n        }\n        return Optional.none();\n      });\n    };\n    const applyPattern = (editor, pattern, patternRange) => {\n      editor.selection.setRng(patternRange);\n      if (pattern.type === 'inline-format') {\n        each$e(pattern.format, format => {\n          editor.formatter.apply(format);\n        });\n      } else {\n        editor.execCommand(pattern.cmd, false, pattern.value);\n      }\n    };\n    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\n      const markerRange = rangeFromMarker(editor.dom, marker);\n      deleteRng(editor.dom, markerRange, isRoot);\n      applyPattern(editor, pattern, markerRange);\n    };\n    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\n      const dom = editor.dom;\n      const markerEndRange = rangeFromMarker(dom, endMarker);\n      const markerStartRange = rangeFromMarker(dom, startMarker);\n      deleteRng(dom, markerStartRange, isRoot);\n      deleteRng(dom, markerEndRange, isRoot);\n      const patternMarker = {\n        prefix: startMarker.prefix,\n        start: startMarker.end,\n        end: endMarker.start\n      };\n      const patternRange = rangeFromMarker(dom, patternMarker);\n      applyPattern(editor, pattern, patternRange);\n    };\n    const addMarkers = (dom, matches) => {\n      const markerPrefix = generate$1('mce_textpattern');\n      const matchesWithEnds = foldr(matches, (acc, match) => {\n        const endMarker = createMarker(dom, markerPrefix + `_end${ acc.length }`, match.endRng);\n        return acc.concat([{\n            ...match,\n            endMarker\n          }]);\n      }, []);\n      return foldr(matchesWithEnds, (acc, match) => {\n        const idx = matchesWithEnds.length - acc.length - 1;\n        const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${ idx }`, match.startRng);\n        return acc.concat([{\n            ...match,\n            startMarker\n          }]);\n      }, []);\n    };\n    const sortPatterns = patterns => sort(patterns, (a, b) => b.end.length - a.end.length);\n    const getBestMatches = (matches, matchesWithSortedPatterns) => {\n      const hasSameMatches = forall(matches, match => exists(matchesWithSortedPatterns, sortedMatch => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));\n      if (matches.length === matchesWithSortedPatterns.length) {\n        if (hasSameMatches) {\n          return matches;\n        } else {\n          return matchesWithSortedPatterns;\n        }\n      }\n      return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;\n    };\n    const findPatterns = (editor, block, node, offset, patternSet, normalizedMatches) => {\n      const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n      const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n      return getBestMatches(matches, matchesWithSortedPatterns);\n    };\n    const applyMatches = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const dom = editor.dom;\n      const bookmark = editor.selection.getBookmark();\n      const matchesWithMarkers = addMarkers(dom, matches);\n      each$e(matchesWithMarkers, match => {\n        const block = dom.getParent(match.startMarker.start, dom.isBlock);\n        const isRoot = node => node === block;\n        if (isReplacementPattern(match.pattern)) {\n          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n        } else {\n          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n        }\n        removeMarker(dom, match.endMarker, isRoot);\n        removeMarker(dom, match.startMarker, isRoot);\n      });\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const handleEnter = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      return getParentBlock(editor, rng).map(block => {\n        var _a;\n        const offset = Math.max(0, rng.startOffset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');\n        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, true);\n        const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);\n        if (blockMatches.length > 0 || inlineMatches.length > 0) {\n          editor.undoManager.add();\n          editor.undoManager.extra(() => {\n            editor.execCommand('mceInsertNewLine');\n          }, () => {\n            insert$5(editor);\n            applyMatches(editor, inlineMatches);\n            applyMatches$1(editor, blockMatches);\n            const range = editor.selection.getRng();\n            const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n            editor.execCommand('mceInsertNewLine');\n            spot.each(s => {\n              const node = s.container;\n              if (node.data.charAt(s.offset - 1) === zeroWidth) {\n                node.deleteData(s.offset - 1, 1);\n                cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\n              }\n            });\n          });\n          return true;\n        }\n        return false;\n      }).getOr(false);\n    };\n    const handleInlineKey = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      getParentBlock(editor, rng).map(block => {\n        const offset = Math.max(0, rng.startOffset - 1);\n        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\n        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, false);\n        if (inlineMatches.length > 0) {\n          editor.undoManager.transact(() => {\n            applyMatches(editor, inlineMatches);\n          });\n        }\n      });\n    };\n    const checkKeyEvent = (codes, event, predicate) => {\n      for (let i = 0; i < codes.length; i++) {\n        if (predicate(codes[i], event)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\n      return code === event.keyCode && !VK.modifierPressed(event);\n    });\n    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\n      return chr.charCodeAt(0) === event.charCode;\n    });\n\n    const setup$2 = editor => {\n      const charCodes = [\n        ',',\n        '.',\n        ';',\n        ':',\n        '!',\n        '?'\n      ];\n      const keyCodes = [32];\n      const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));\n      const hasDynamicPatterns = () => hasTextPatternsLookup(editor);\n      editor.on('keydown', e => {\n        if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed()) {\n          const patternSet = getPatternSet();\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns && handleEnter(editor, patternSet)) {\n            e.preventDefault();\n          }\n        }\n      }, true);\n      const handleInlineTrigger = () => {\n        if (editor.selection.isCollapsed()) {\n          const patternSet = getPatternSet();\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns) {\n            handleInlineKey(editor, patternSet);\n          }\n        }\n      };\n      editor.on('keyup', e => {\n        if (checkKeyCode(keyCodes, e)) {\n          handleInlineTrigger();\n        }\n      });\n      editor.on('keypress', e => {\n        if (checkCharCode(charCodes, e)) {\n          Delay.setEditorTimeout(editor, handleInlineTrigger);\n        }\n      });\n    };\n\n    const setup$1 = editor => {\n      setup$2(editor);\n    };\n\n    const Quirks = editor => {\n      const each = Tools.each;\n      const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;\n      const browser = Env.browser;\n      const isGecko = browser.isFirefox();\n      const isWebKit = browser.isChromium() || browser.isSafari();\n      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      const setEditorCommandState = (cmd, state) => {\n        try {\n          editor.getDoc().execCommand(cmd, false, String(state));\n        } catch (ex) {\n        }\n      };\n      const isDefaultPrevented = e => {\n        return e.isDefaultPrevented();\n      };\n      const emptyEditorWhenDeleting = () => {\n        const serializeRng = rng => {\n          const body = dom.create('body');\n          const contents = rng.cloneContents();\n          body.appendChild(contents);\n          return selection.serializer.serialize(body, { format: 'html' });\n        };\n        const allContentsSelected = rng => {\n          const selection = serializeRng(rng);\n          const allRng = dom.createRng();\n          allRng.selectNode(editor.getBody());\n          const allSelection = serializeRng(allRng);\n          return selection === allSelection;\n        };\n        editor.on('keydown', e => {\n          const keyCode = e.keyCode;\n          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {\n            const isCollapsed = editor.selection.isCollapsed();\n            const body = editor.getBody();\n            if (isCollapsed && !isEmpty$2(SugarElement.fromDom(body))) {\n              return;\n            }\n            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n              return;\n            }\n            e.preventDefault();\n            editor.setContent('');\n            if (body.firstChild && dom.isBlock(body.firstChild)) {\n              editor.selection.setCursorLocation(body.firstChild, 0);\n            } else {\n              editor.selection.setCursorLocation(body, 0);\n            }\n            editor.nodeChanged();\n          }\n        });\n      };\n      const selectAll = () => {\n        editor.shortcuts.add('meta+a', null, 'SelectAll');\n      };\n      const documentElementEditingFocus = () => {\n        if (!editor.inline) {\n          dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\n            let rng;\n            if (e.target === editor.getDoc().documentElement) {\n              rng = selection.getRng();\n              editor.getBody().focus();\n              if (e.type === 'mousedown') {\n                if (isCaretContainer$2(rng.startContainer)) {\n                  return;\n                }\n                selection.placeCaretAt(e.clientX, e.clientY);\n              } else {\n                selection.setRng(rng);\n              }\n            }\n          });\n        }\n      };\n      const removeHrOnBackspace = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (!editor.getBody().getElementsByTagName('hr').length) {\n              return;\n            }\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const node = selection.getNode();\n              const previousSibling = node.previousSibling;\n              if (node.nodeName === 'HR') {\n                dom.remove(node);\n                e.preventDefault();\n                return;\n              }\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\n                dom.remove(previousSibling);\n                e.preventDefault();\n              }\n            }\n          }\n        });\n      };\n      const focusBody = () => {\n        if (!Range.prototype.getClientRects) {\n          editor.on('mousedown', e => {\n            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\n              const body = editor.getBody();\n              body.blur();\n              Delay.setEditorTimeout(editor, () => {\n                body.focus();\n              });\n            }\n          });\n        }\n      };\n      const selectControlElements = () => {\n        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\n        editor.on('click', e => {\n          const target = e.target;\n          if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {\n            e.preventDefault();\n            editor.selection.select(target);\n            editor.nodeChanged();\n          }\n          if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {\n            e.preventDefault();\n            selection.select(target);\n          }\n        });\n      };\n      const removeStylesWhenDeletingAcrossBlockElements = () => {\n        const getAttributeApplyFunction = () => {\n          const template = dom.getAttribs(selection.getStart().cloneNode(false));\n          return () => {\n            const target = selection.getStart();\n            if (target !== editor.getBody()) {\n              dom.setAttrib(target, 'style', null);\n              each(template, attr => {\n                target.setAttributeNode(attr.cloneNode(true));\n              });\n            }\n          };\n        };\n        const isSelectionAcrossElements = () => {\n          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\n        };\n        editor.on('keypress', e => {\n          let applyAttributes;\n          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\n            applyAttributes = getAttributeApplyFunction();\n            editor.getDoc().execCommand('delete', false);\n            applyAttributes();\n            e.preventDefault();\n            return false;\n          } else {\n            return true;\n          }\n        });\n        dom.bind(editor.getDoc(), 'cut', e => {\n          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n            const applyAttributes = getAttributeApplyFunction();\n            Delay.setEditorTimeout(editor, () => {\n              applyAttributes();\n            });\n          }\n        });\n      };\n      const disableBackspaceIntoATable = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const previousSibling = selection.getNode().previousSibling;\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\n                e.preventDefault();\n                return false;\n              }\n            }\n          }\n          return true;\n        });\n      };\n      const removeBlockQuoteOnBackSpace = () => {\n        editor.on('keydown', e => {\n          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\n            return;\n          }\n          let rng = selection.getRng();\n          const container = rng.startContainer;\n          const offset = rng.startOffset;\n          const root = dom.getRoot();\n          let parent = container;\n          if (!rng.collapsed || offset !== 0) {\n            return;\n          }\n          while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\n            parent = parent.parentNode;\n          }\n          if (parent.nodeName === 'BLOCKQUOTE') {\n            editor.formatter.toggle('blockquote', undefined, parent);\n            rng = dom.createRng();\n            rng.setStart(container, 0);\n            rng.setEnd(container, 0);\n            selection.setRng(rng);\n          }\n        });\n      };\n      const setGeckoEditingOptions = () => {\n        const setOpts = () => {\n          setEditorCommandState('StyleWithCSS', false);\n          setEditorCommandState('enableInlineTableEditing', false);\n          if (!getObjectResizing(editor)) {\n            setEditorCommandState('enableObjectResizing', false);\n          }\n        };\n        if (!isReadOnly$1(editor)) {\n          editor.on('BeforeExecCommand mousedown', setOpts);\n        }\n      };\n      const addBrAfterLastLinks = () => {\n        const fixLinks = () => {\n          each(dom.select('a:not([data-mce-block])'), node => {\n            var _a;\n            let parentNode = node.parentNode;\n            const root = dom.getRoot();\n            if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {\n              while (parentNode && !dom.isBlock(parentNode)) {\n                if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {\n                  return;\n                }\n                parentNode = parentNode.parentNode;\n              }\n              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });\n            }\n          });\n        };\n        editor.on('SetContent ExecCommand', e => {\n          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\n            fixLinks();\n          }\n        });\n      };\n      const setDefaultBlockType = () => {\n        editor.on('init', () => {\n          setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\n        });\n      };\n      const isAllContentSelected = editor => {\n        const body = editor.getBody();\n        const rng = editor.selection.getRng();\n        return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;\n      };\n      const normalizeSelection = () => {\n        editor.on('keyup focusin mouseup', e => {\n          if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {\n            selection.normalize();\n          }\n        }, true);\n      };\n      const showBrokenImageIcon = () => {\n        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\n      };\n      const restoreFocusOnKeyDown = () => {\n        if (!editor.inline) {\n          editor.on('keydown', () => {\n            if (document.activeElement === document.body) {\n              editor.getWin().focus();\n            }\n          });\n        }\n      };\n      const bodyHeight = () => {\n        if (!editor.inline) {\n          editor.contentStyles.push('body {min-height: 150px}');\n          editor.on('click', e => {\n            let rng;\n            if (e.target.nodeName === 'HTML') {\n              rng = editor.selection.getRng();\n              editor.getBody().focus();\n              editor.selection.setRng(rng);\n              editor.selection.normalize();\n              editor.nodeChanged();\n            }\n          });\n        }\n      };\n      const blockCmdArrowNavigation = () => {\n        if (isMac) {\n          editor.on('keydown', e => {\n            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\n              e.preventDefault();\n              const selection = editor.selection.getSel();\n              selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\n            }\n          });\n        }\n      };\n      const tapLinksAndImages = () => {\n        editor.on('click', e => {\n          let elm = e.target;\n          do {\n            if (elm.tagName === 'A') {\n              e.preventDefault();\n              return;\n            }\n          } while (elm = elm.parentNode);\n        });\n        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\n      };\n      const blockFormSubmitInsideEditor = () => {\n        editor.on('init', () => {\n          editor.dom.bind(editor.getBody(), 'submit', e => {\n            e.preventDefault();\n          });\n        });\n      };\n      const removeAppleInterchangeBrs = () => {\n        parser.addNodeFilter('br', nodes => {\n          let i = nodes.length;\n          while (i--) {\n            if (nodes[i].attr('class') === 'Apple-interchange-newline') {\n              nodes[i].remove();\n            }\n          }\n        });\n      };\n      const refreshContentEditable = noop;\n      const isHidden = () => {\n        if (!isGecko || editor.removed) {\n          return false;\n        }\n        const sel = editor.selection.getSel();\n        return !sel || !sel.rangeCount || sel.rangeCount === 0;\n      };\n      const setupRtc = () => {\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          blockFormSubmitInsideEditor();\n          selectAll();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          }\n        }\n        if (isGecko) {\n          focusBody();\n          setGeckoEditingOptions();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n        }\n      };\n      const dropDragEndEvent = () => {\n        editor.on('drop', event => {\n          var _a;\n          const data = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n          if (isString(data) && /^<img[^>]*>$/.test(data)) {\n            editor.dispatch('dragend', new window.DragEvent('dragend', event));\n          }\n        });\n      };\n      const setup = () => {\n        removeBlockQuoteOnBackSpace();\n        emptyEditorWhenDeleting();\n        if (!Env.windowsPhone) {\n          normalizeSelection();\n        }\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          setDefaultBlockType();\n          blockFormSubmitInsideEditor();\n          disableBackspaceIntoATable();\n          removeAppleInterchangeBrs();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          } else {\n            selectAll();\n          }\n        }\n        if (isGecko) {\n          removeHrOnBackspace();\n          focusBody();\n          removeStylesWhenDeletingAcrossBlockElements();\n          setGeckoEditingOptions();\n          addBrAfterLastLinks();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n          disableBackspaceIntoATable();\n          dropDragEndEvent();\n        }\n      };\n      if (isRtc(editor)) {\n        setupRtc();\n      } else {\n        setup();\n      }\n      return {\n        refreshContentEditable,\n        isHidden\n      };\n    };\n\n    const DOM$6 = DOMUtils.DOM;\n    const appendStyle = (editor, text) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const container = getStyleContainer(getRootNode(body));\n      const style = SugarElement.fromTag('style');\n      set$3(style, 'type', 'text/css');\n      append$1(style, SugarElement.fromText(text));\n      append$1(container, style);\n      editor.on('remove', () => {\n        remove$5(style);\n      });\n    };\n    const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\n    const removeUndefined = obj => filter$4(obj, v => isUndefined(v) === false);\n    const mkParserSettings = editor => {\n      const getOption = editor.options.get;\n      const blobCache = editor.editorUpload.blobCache;\n      return removeUndefined({\n        allow_conditional_comments: getOption('allow_conditional_comments'),\n        allow_html_data_urls: getOption('allow_html_data_urls'),\n        allow_svg_data_urls: getOption('allow_svg_data_urls'),\n        allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\n        allow_script_urls: getOption('allow_script_urls'),\n        allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\n        convert_unsafe_embeds: getOption('convert_unsafe_embeds'),\n        convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\n        fix_list_elements: getOption('fix_list_elements'),\n        font_size_legacy_values: getOption('font_size_legacy_values'),\n        forced_root_block: getOption('forced_root_block'),\n        forced_root_block_attrs: getOption('forced_root_block_attrs'),\n        preserve_cdata: getOption('preserve_cdata'),\n        inline_styles: getOption('inline_styles'),\n        root_name: getRootName(editor),\n        sandbox_iframes: getOption('sandbox_iframes'),\n        sanitize: getOption('xss_sanitization'),\n        validate: true,\n        blob_cache: blobCache,\n        document: editor.getDoc()\n      });\n    };\n    const mkSchemaSettings = editor => {\n      const getOption = editor.options.get;\n      return removeUndefined({\n        custom_elements: getOption('custom_elements'),\n        extended_valid_elements: getOption('extended_valid_elements'),\n        invalid_elements: getOption('invalid_elements'),\n        invalid_styles: getOption('invalid_styles'),\n        schema: getOption('schema'),\n        valid_children: getOption('valid_children'),\n        valid_classes: getOption('valid_classes'),\n        valid_elements: getOption('valid_elements'),\n        valid_styles: getOption('valid_styles'),\n        verify_html: getOption('verify_html'),\n        padd_empty_block_inline_children: getOption('format_empty_lines')\n      });\n    };\n    const mkSerializerSettings = editor => {\n      const getOption = editor.options.get;\n      return {\n        ...mkParserSettings(editor),\n        ...mkSchemaSettings(editor),\n        ...removeUndefined({\n          remove_trailing_brs: getOption('remove_trailing_brs'),\n          pad_empty_with_br: getOption('pad_empty_with_br'),\n          url_converter: getOption('url_converter'),\n          url_converter_scope: getOption('url_converter_scope'),\n          element_format: getOption('element_format'),\n          entities: getOption('entities'),\n          entity_encoding: getOption('entity_encoding'),\n          indent: getOption('indent'),\n          indent_after: getOption('indent_after'),\n          indent_before: getOption('indent_before')\n        })\n      };\n    };\n    const createParser = editor => {\n      const parser = DomParser(mkParserSettings(editor), editor.schema);\n      parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\n        const dom = editor.dom;\n        const internalName = 'data-mce-' + name;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(name);\n          if (value && !node.attr(internalName)) {\n            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\n              continue;\n            }\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n              if (!value.length) {\n                value = null;\n              }\n              node.attr(internalName, value);\n              node.attr(name, value);\n            } else if (name === 'tabindex') {\n              node.attr(internalName, value);\n              node.attr(name, null);\n            } else {\n              node.attr(internalName, editor.convertURL(value, name, node.name));\n            }\n          }\n        }\n      });\n      parser.addNodeFilter('script', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const type = node.attr('type') || 'no/type';\n          if (type.indexOf('mce-') !== 0) {\n            node.attr('type', 'mce-' + type);\n          }\n        }\n      });\n      if (shouldPreserveCData(editor)) {\n        parser.addNodeFilter('#cdata', nodes => {\n          var _a;\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.type = 8;\n            node.name = '#comment';\n            node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';\n          }\n        });\n      }\n      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\n        let i = nodes.length;\n        const nonEmptyElements = editor.schema.getNonEmptyElements();\n        while (i--) {\n          const node = nodes[i];\n          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\n            node.append(new AstNode('br', 1));\n          }\n        }\n      });\n      return parser;\n    };\n    const autoFocus = editor => {\n      const autoFocus = getAutoFocus(editor);\n      if (autoFocus) {\n        Delay.setEditorTimeout(editor, () => {\n          let focusEditor;\n          if (autoFocus === true) {\n            focusEditor = editor;\n          } else {\n            focusEditor = editor.editorManager.get(autoFocus);\n          }\n          if (focusEditor && !focusEditor.destroyed) {\n            focusEditor.focus();\n            focusEditor.selection.scrollIntoView();\n          }\n        }, 100);\n      }\n    };\n    const moveSelectionToFirstCaretPosition = editor => {\n      const root = editor.dom.getRoot();\n      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\n        firstPositionIn(root).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const initEditor = editor => {\n      editor.bindPendingEventDelegates();\n      editor.initialized = true;\n      fireInit(editor);\n      editor.focus(true);\n      moveSelectionToFirstCaretPosition(editor);\n      editor.nodeChanged({ initial: true });\n      const initInstanceCallback = getInitInstanceCallback(editor);\n      if (isFunction(initInstanceCallback)) {\n        initInstanceCallback.call(editor, editor);\n      }\n      autoFocus(editor);\n    };\n    const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\n    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\n      const {\n        pass: bundledCss,\n        fail: normalCss\n      } = partition$2(css, name => tinymce.Resource.has(toContentSkinResourceName(name)));\n      const bundledPromises = bundledCss.map(url => {\n        const css = tinymce.Resource.get(toContentSkinResourceName(url));\n        if (isString(css)) {\n          return Promise.resolve(getStyleSheetLoader$1(editor).loadRawCss(url, css));\n        }\n        return Promise.resolve();\n      });\n      const promises = [\n        ...bundledPromises,\n        getStyleSheetLoader$1(editor).loadAll(normalCss)\n      ];\n      if (editor.inline) {\n        return promises;\n      } else {\n        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\n      }\n    };\n    const loadContentCss = editor => {\n      const styleSheetLoader = getStyleSheetLoader$1(editor);\n      const fontCss = getFontCss(editor);\n      const css = editor.contentCSS;\n      const removeCss = () => {\n        styleSheetLoader.unloadAll(css);\n        if (!editor.inline) {\n          editor.ui.styleSheetLoader.unloadAll(fontCss);\n        }\n      };\n      const loaded = () => {\n        if (editor.removed) {\n          removeCss();\n        } else {\n          editor.on('remove', removeCss);\n        }\n      };\n      if (editor.contentStyles.length > 0) {\n        let contentCssText = '';\n        Tools.each(editor.contentStyles, style => {\n          contentCssText += style + '\\r\\n';\n        });\n        editor.dom.addStyle(contentCssText);\n      }\n      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\n      const contentStyle = getContentStyle(editor);\n      if (contentStyle) {\n        appendStyle(editor, contentStyle);\n      }\n      return allStylesheets;\n    };\n    const preInit = editor => {\n      const doc = editor.getDoc(), body = editor.getBody();\n      firePreInit(editor);\n      if (!shouldBrowserSpellcheck(editor)) {\n        doc.body.spellcheck = false;\n        DOM$6.setAttrib(body, 'spellcheck', 'false');\n      }\n      editor.quirks = Quirks(editor);\n      firePostRender(editor);\n      const directionality = getDirectionality(editor);\n      if (directionality !== undefined) {\n        body.dir = directionality;\n      }\n      const protect = getProtect(editor);\n      if (protect) {\n        editor.on('BeforeSetContent', e => {\n          Tools.each(protect, pattern => {\n            e.content = e.content.replace(pattern, str => {\n              return '<!--mce:protected ' + escape(str) + '-->';\n            });\n          });\n        });\n      }\n      editor.on('SetContent', () => {\n        editor.addVisual(editor.getBody());\n      });\n      editor.on('compositionstart compositionend', e => {\n        editor.composing = e.type === 'compositionstart';\n      });\n    };\n    const loadInitialContent = editor => {\n      if (!isRtc(editor)) {\n        editor.load({\n          initial: true,\n          format: 'html'\n        });\n      }\n      editor.startContent = editor.getContent({ format: 'raw' });\n    };\n    const initEditorWithInitialContent = editor => {\n      if (editor.removed !== true) {\n        loadInitialContent(editor);\n        initEditor(editor);\n      }\n    };\n    const startProgress = editor => {\n      let canceled = false;\n      const progressTimeout = setTimeout(() => {\n        if (!canceled) {\n          editor.setProgressState(true);\n        }\n      }, 500);\n      return () => {\n        clearTimeout(progressTimeout);\n        canceled = true;\n        editor.setProgressState(false);\n      };\n    };\n    const contentBodyLoaded = editor => {\n      const targetElm = editor.getElement();\n      let doc = editor.getDoc();\n      if (editor.inline) {\n        DOM$6.addClass(targetElm, 'mce-content-body');\n        editor.contentDocument = doc = document;\n        editor.contentWindow = window;\n        editor.bodyElement = targetElm;\n        editor.contentAreaContainer = targetElm;\n      }\n      const body = editor.getBody();\n      body.disabled = true;\n      editor.readonly = isReadOnly$1(editor);\n      editor._editableRoot = hasEditableRoot$1(editor);\n      if (!editor.readonly && editor.hasEditableRoot()) {\n        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\n          body.style.position = 'relative';\n        }\n        body.contentEditable = 'true';\n      }\n      body.disabled = false;\n      editor.editorUpload = EditorUpload(editor);\n      editor.schema = Schema(mkSchemaSettings(editor));\n      editor.dom = DOMUtils(doc, {\n        keep_values: true,\n        url_converter: editor.convertURL,\n        url_converter_scope: editor,\n        update_styles: true,\n        root_element: editor.inline ? editor.getBody() : null,\n        collect: editor.inline,\n        schema: editor.schema,\n        contentCssCors: shouldUseContentCssCors(editor),\n        referrerPolicy: getReferrerPolicy(editor),\n        onSetAttrib: e => {\n          editor.dispatch('SetAttrib', e);\n        },\n        force_hex_color: shouldForceHexColor(editor)\n      });\n      editor.parser = createParser(editor);\n      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\n      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\n      editor.annotator = Annotator(editor);\n      editor.formatter = Formatter(editor);\n      editor.undoManager = UndoManager(editor);\n      editor._nodeChangeDispatcher = new NodeChange(editor);\n      editor._selectionOverrides = SelectionOverrides(editor);\n      setup$p(editor);\n      setup$6(editor);\n      setup$n(editor);\n      if (!isRtc(editor)) {\n        setup$5(editor);\n        setup$1(editor);\n      }\n      const caret = setup$b(editor);\n      setup$q(editor, caret);\n      setup$o(editor);\n      setup$r(editor);\n      setup$7(editor);\n      const setupRtcThunk = setup$t(editor);\n      preInit(editor);\n      setupRtcThunk.fold(() => {\n        const cancelProgress = startProgress(editor);\n        loadContentCss(editor).then(() => {\n          initEditorWithInitialContent(editor);\n          cancelProgress();\n        });\n      }, setupRtc => {\n        editor.setProgressState(true);\n        loadContentCss(editor).then(() => {\n          setupRtc().then(_rtcMode => {\n            editor.setProgressState(false);\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          }, err => {\n            editor.notificationManager.open({\n              type: 'error',\n              text: String(err)\n            });\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          });\n        });\n      });\n    };\n\n    const filter = always;\n    const bind = (element, event, handler) => bind$2(element, event, filter, handler);\n\n    const DOM$5 = DOMUtils.DOM;\n    const createIframeElement = (id, title, customAttrs, tabindex) => {\n      const iframe = SugarElement.fromTag('iframe');\n      tabindex.each(t => set$3(iframe, 'tabindex', t));\n      setAll$1(iframe, customAttrs);\n      setAll$1(iframe, {\n        id: id + '_ifr',\n        frameBorder: '0',\n        allowTransparency: 'true',\n        title\n      });\n      add$2(iframe, 'tox-edit-area__iframe');\n      return iframe;\n    };\n    const getIframeHtml = editor => {\n      let iframeHTML = getDocType(editor) + '<html><head>';\n      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\n        iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\n      }\n      iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\n      const bodyId = getBodyId(editor);\n      const bodyClass = getBodyClass(editor);\n      const translatedAriaText = editor.translate(getIframeAriaText(editor));\n      if (getContentSecurityPolicy(editor)) {\n        iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\n      }\n      iframeHTML += '</head>' + `<body id=\"${ bodyId }\" class=\"mce-content-body ${ bodyClass }\" data-id=\"${ editor.id }\" aria-label=\"${ translatedAriaText }\">` + '<br>' + '</body></html>';\n      return iframeHTML;\n    };\n    const createIframe = (editor, boxInfo) => {\n      const iframeTitle = editor.translate('Rich Text Area');\n      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\n      const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;\n      ifr.onload = () => {\n        ifr.onload = null;\n        editor.dispatch('load');\n      };\n      editor.contentAreaContainer = boxInfo.iframeContainer;\n      editor.iframeElement = ifr;\n      editor.iframeHTML = getIframeHtml(editor);\n      DOM$5.add(boxInfo.iframeContainer, ifr);\n    };\n    const setupIframeBody = editor => {\n      const iframe = editor.iframeElement;\n      const ready = () => {\n        editor.contentDocument = iframe.contentDocument;\n        contentBodyLoaded(editor);\n      };\n      if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {\n        const doc = editor.getDoc();\n        doc.open();\n        doc.write(editor.iframeHTML);\n        doc.close();\n        ready();\n      } else {\n        const binder = bind(SugarElement.fromDom(iframe), 'load', () => {\n          binder.unbind();\n          ready();\n        });\n        iframe.srcdoc = editor.iframeHTML;\n      }\n    };\n    const init$1 = (editor, boxInfo) => {\n      createIframe(editor, boxInfo);\n      if (boxInfo.editorContainer) {\n        boxInfo.editorContainer.style.display = editor.orgDisplay;\n        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\n      }\n      editor.getElement().style.display = 'none';\n      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\n      editor.getElement().style.visibility = editor.orgVisibility;\n      setupIframeBody(editor);\n    };\n\n    const DOM$4 = DOMUtils.DOM;\n    const initPlugin = (editor, initializedPlugins, plugin) => {\n      const Plugin = PluginManager.get(plugin);\n      const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\n      plugin = Tools.trim(plugin);\n      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\n        if (editor.plugins[plugin]) {\n          return;\n        }\n        try {\n          const pluginInstance = Plugin(editor, pluginUrl) || {};\n          editor.plugins[plugin] = pluginInstance;\n          if (isFunction(pluginInstance.init)) {\n            pluginInstance.init(editor, pluginUrl);\n            initializedPlugins.push(plugin);\n          }\n        } catch (e) {\n          pluginInitError(editor, plugin, e);\n        }\n      }\n    };\n    const trimLegacyPrefix = name => {\n      return name.replace(/^\\-/, '');\n    };\n    const initPlugins = editor => {\n      const initializedPlugins = [];\n      each$e(getPlugins(editor), name => {\n        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\n      });\n    };\n    const initIcons = editor => {\n      const iconPackName = Tools.trim(getIconPackName(editor));\n      const currentIcons = editor.ui.registry.getAll().icons;\n      const loadIcons = {\n        ...IconManager.get('default').icons,\n        ...IconManager.get(iconPackName).icons\n      };\n      each$d(loadIcons, (svgData, icon) => {\n        if (!has$2(currentIcons, icon)) {\n          editor.ui.registry.addIcon(icon, svgData);\n        }\n      });\n    };\n    const initTheme = editor => {\n      const theme = getTheme(editor);\n      if (isString(theme)) {\n        const Theme = ThemeManager.get(theme);\n        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\n        if (isFunction(editor.theme.init)) {\n          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\n        }\n      } else {\n        editor.theme = {};\n      }\n    };\n    const initModel = editor => {\n      const model = getModel(editor);\n      const Model = ModelManager.get(model);\n      editor.model = Model(editor, ModelManager.urls[model]);\n    };\n    const renderFromLoadedTheme = editor => {\n      const render = editor.theme.renderUI;\n      return render ? render() : renderThemeFalse(editor);\n    };\n    const renderFromThemeFunc = editor => {\n      const elm = editor.getElement();\n      const theme = getTheme(editor);\n      const info = theme(editor, elm);\n      if (info.editorContainer.nodeType) {\n        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\n      }\n      if (info.iframeContainer && info.iframeContainer.nodeType) {\n        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\n      }\n      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\n      return info;\n    };\n    const createThemeFalseResult = (element, iframe) => {\n      return {\n        editorContainer: element,\n        iframeContainer: iframe,\n        api: {}\n      };\n    };\n    const renderThemeFalseIframe = targetElement => {\n      const iframeContainer = DOM$4.create('div');\n      DOM$4.insertAfter(iframeContainer, targetElement);\n      return createThemeFalseResult(iframeContainer, iframeContainer);\n    };\n    const renderThemeFalse = editor => {\n      const targetElement = editor.getElement();\n      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\n    };\n    const renderThemeUi = editor => {\n      const elm = editor.getElement();\n      editor.orgDisplay = elm.style.display;\n      if (isString(getTheme(editor))) {\n        return renderFromLoadedTheme(editor);\n      } else if (isFunction(getTheme(editor))) {\n        return renderFromThemeFunc(editor);\n      } else {\n        return renderThemeFalse(editor);\n      }\n    };\n    const augmentEditorUiApi = (editor, api) => {\n      const uiApiFacade = {\n        show: Optional.from(api.show).getOr(noop),\n        hide: Optional.from(api.hide).getOr(noop),\n        isEnabled: Optional.from(api.isEnabled).getOr(always),\n        setEnabled: state => {\n          if (!editor.mode.isReadOnly()) {\n            Optional.from(api.setEnabled).each(f => f(state));\n          }\n        }\n      };\n      editor.ui = {\n        ...editor.ui,\n        ...uiApiFacade\n      };\n    };\n    const init = async editor => {\n      editor.dispatch('ScriptsLoaded');\n      initIcons(editor);\n      initTheme(editor);\n      initModel(editor);\n      initPlugins(editor);\n      const renderInfo = await renderThemeUi(editor);\n      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\n      editor.editorContainer = renderInfo.editorContainer;\n      appendContentCssFromSettings(editor);\n      if (editor.inline) {\n        contentBodyLoaded(editor);\n      } else {\n        init$1(editor, {\n          editorContainer: renderInfo.editorContainer,\n          iframeContainer: renderInfo.iframeContainer\n        });\n      }\n    };\n\n    const DOM$3 = DOMUtils.DOM;\n    const hasSkipLoadPrefix = name => name.charAt(0) === '-';\n    const loadLanguage = (scriptLoader, editor) => {\n      const languageCode = getLanguageCode(editor);\n      const languageUrl = getLanguageUrl(editor);\n      if (!I18n.hasCode(languageCode) && languageCode !== 'en') {\n        const url = isNotEmpty(languageUrl) ? languageUrl : `${ editor.editorManager.baseURL }/langs/${ languageCode }.js`;\n        scriptLoader.add(url).catch(() => {\n          languageLoadError(editor, url, languageCode);\n        });\n      }\n    };\n    const loadTheme = (editor, suffix) => {\n      const theme = getTheme(editor);\n      if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\n        const themeUrl = getThemeUrl(editor);\n        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${ theme }/theme${ suffix }.js`;\n        ThemeManager.load(theme, url).catch(() => {\n          themeLoadError(editor, url, theme);\n        });\n      }\n    };\n    const loadModel = (editor, suffix) => {\n      const model = getModel(editor);\n      if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\n        const modelUrl = getModelUrl(editor);\n        const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${ model }/model${ suffix }.js`;\n        ModelManager.load(model, url).catch(() => {\n          modelLoadError(editor, url, model);\n        });\n      }\n    };\n    const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\n      url,\n      name: Optional.none()\n    }));\n    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\n      url: `${ editor.editorManager.baseURL }/icons/${ name }/icons${ suffix }.js`,\n      name: Optional.some(name)\n    }));\n    const loadIcons = (scriptLoader, editor, suffix) => {\n      const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\n      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\n      each$e(cat([\n        defaultIconsUrl,\n        customIconsUrl\n      ]), urlMeta => {\n        scriptLoader.add(urlMeta.url).catch(() => {\n          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\n        });\n      });\n    };\n    const loadPlugins = (editor, suffix) => {\n      const loadPlugin = (name, url) => {\n        PluginManager.load(name, url).catch(() => {\n          pluginLoadError(editor, url, name);\n        });\n      };\n      each$d(getExternalPlugins$1(editor), (url, name) => {\n        loadPlugin(name, url);\n        editor.options.set('plugins', getPlugins(editor).concat(name));\n      });\n      each$e(getPlugins(editor), plugin => {\n        plugin = Tools.trim(plugin);\n        if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\n          loadPlugin(plugin, `plugins/${ plugin }/plugin${ suffix }.js`);\n        }\n      });\n    };\n    const isThemeLoaded = editor => {\n      const theme = getTheme(editor);\n      return !isString(theme) || isNonNullable(ThemeManager.get(theme));\n    };\n    const isModelLoaded = editor => {\n      const model = getModel(editor);\n      return isNonNullable(ModelManager.get(model));\n    };\n    const loadScripts = (editor, suffix) => {\n      const scriptLoader = ScriptLoader.ScriptLoader;\n      const initEditor = () => {\n        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\n          init(editor);\n        }\n      };\n      loadTheme(editor, suffix);\n      loadModel(editor, suffix);\n      loadLanguage(scriptLoader, editor);\n      loadIcons(scriptLoader, editor, suffix);\n      loadPlugins(editor, suffix);\n      scriptLoader.loadQueue().then(initEditor, initEditor);\n    };\n    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\n      contentCssCors: hasContentCssCors(editor),\n      referrerPolicy: getReferrerPolicy(editor)\n    });\n    const render = editor => {\n      const id = editor.id;\n      I18n.setCode(getLanguageCode(editor));\n      const readyHandler = () => {\n        DOM$3.unbind(window, 'ready', readyHandler);\n        editor.render();\n      };\n      if (!EventUtils.Event.domLoaded) {\n        DOM$3.bind(window, 'ready', readyHandler);\n        return;\n      }\n      if (!editor.getElement()) {\n        return;\n      }\n      const element = SugarElement.fromDom(editor.getElement());\n      const snapshot = clone$4(element);\n      editor.on('remove', () => {\n        eachr(element.dom.attributes, attr => remove$a(element, attr.name));\n        setAll$1(element, snapshot);\n      });\n      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\n      if (!isInline$1(editor)) {\n        editor.orgVisibility = editor.getElement().style.visibility;\n        editor.getElement().style.visibility = 'hidden';\n      } else {\n        editor.inline = true;\n      }\n      const form = editor.getElement().form || DOM$3.getParent(id, 'form');\n      if (form) {\n        editor.formElement = form;\n        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\n          DOM$3.insertAfter(DOM$3.create('input', {\n            type: 'hidden',\n            name: id\n          }), id);\n          editor.hasHiddenInput = true;\n        }\n        editor.formEventDelegate = e => {\n          editor.dispatch(e.type, e);\n        };\n        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\n        editor.on('reset', () => {\n          editor.resetContent();\n        });\n        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n          form._mceOldSubmit = form.submit;\n          form.submit = () => {\n            editor.editorManager.triggerSave();\n            editor.setDirty(false);\n            return form._mceOldSubmit(form);\n          };\n        }\n      }\n      editor.windowManager = WindowManager(editor);\n      editor.notificationManager = NotificationManager(editor);\n      if (isEncodingXml(editor)) {\n        editor.on('GetContent', e => {\n          if (e.save) {\n            e.content = DOM$3.encode(e.content);\n          }\n        });\n      }\n      if (shouldAddFormSubmitTrigger(editor)) {\n        editor.on('submit', () => {\n          if (editor.initialized) {\n            editor.save();\n          }\n        });\n      }\n      if (shouldAddUnloadTrigger(editor)) {\n        editor._beforeUnload = () => {\n          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\n            editor.save({\n              format: 'raw',\n              no_events: true,\n              set_dirty: false\n            });\n          }\n        };\n        editor.editorManager.on('BeforeUnload', editor._beforeUnload);\n      }\n      editor.editorManager.add(editor);\n      loadScripts(editor, editor.suffix);\n    };\n\n    const setEditableRoot = (editor, state) => {\n      if (editor._editableRoot !== state) {\n        editor._editableRoot = state;\n        if (!editor.readonly) {\n          editor.getBody().contentEditable = String(editor.hasEditableRoot());\n          editor.nodeChanged();\n        }\n        fireEditableRootStateChange(editor, state);\n      }\n    };\n    const hasEditableRoot = editor => editor._editableRoot;\n\n    const sectionResult = (sections, settings) => ({\n      sections: constant(sections),\n      options: constant(settings)\n    });\n    const deviceDetection = detect$2().deviceType;\n    const isPhone = deviceDetection.isPhone();\n    const isTablet = deviceDetection.isTablet();\n    const normalizePlugins = plugins => {\n      if (isNullable(plugins)) {\n        return [];\n      } else {\n        const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\n        const trimmedPlugins = map$3(pluginNames, trim$4);\n        return filter$5(trimmedPlugins, isNotEmpty);\n      }\n    };\n    const extractSections = (keys, options) => {\n      const result = bifilter(options, (value, key) => {\n        return contains$2(keys, key);\n      });\n      return sectionResult(result.t, result.f);\n    };\n    const getSection = (sectionResult, name, defaults = {}) => {\n      const sections = sectionResult.sections();\n      const sectionOptions = get$a(sections, name).getOr({});\n      return Tools.extend({}, defaults, sectionOptions);\n    };\n    const hasSection = (sectionResult, name) => {\n      return has$2(sectionResult.sections(), name);\n    };\n    const getSectionConfig = (sectionResult, name) => {\n      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\n    };\n    const getMobileOverrideOptions = (mobileOptions, isPhone) => {\n      const defaultMobileOptions = {\n        table_grid: false,\n        object_resizing: false,\n        resize: false,\n        toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\n        toolbar_sticky: false\n      };\n      const defaultPhoneOptions = { menubar: false };\n      return {\n        ...defaultMobileOptions,\n        ...isPhone ? defaultPhoneOptions : {}\n      };\n    };\n    const getExternalPlugins = (overrideOptions, options) => {\n      var _a;\n      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\n      if (overrideOptions && overrideOptions.external_plugins) {\n        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\n      } else {\n        return userDefinedExternalPlugins;\n      }\n    };\n    const combinePlugins = (forcedPlugins, plugins) => [\n      ...normalizePlugins(forcedPlugins),\n      ...normalizePlugins(plugins)\n    ];\n    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\n      if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\n        return mobilePlugins;\n      } else {\n        return desktopPlugins;\n      }\n    };\n    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\n      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\n      const desktopPlugins = normalizePlugins(options.plugins);\n      const mobileConfig = getSectionConfig(sectionResult, 'mobile');\n      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\n      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\n      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\n      return Tools.extend(options, {\n        forced_plugins: forcedPlugins,\n        plugins: combinedPlugins\n      });\n    };\n    const isOnMobile = (isMobileDevice, sectionResult) => {\n      return isMobileDevice && hasSection(sectionResult, 'mobile');\n    };\n    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\n      var _a;\n      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};\n      const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\n      const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options()) });\n      return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\n    };\n    const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);\n\n    const addVisual = (editor, elm) => addVisual$1(editor, elm);\n\n    const registerExecCommands$3 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      const toggleAlign = align => () => {\n        each$e('left,center,right,justify'.split(','), name => {\n          if (align !== name) {\n            editor.formatter.remove('align' + name);\n          }\n        });\n        if (align !== 'none') {\n          toggleFormat('align' + align);\n        }\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: toggleAlign('left'),\n        JustifyCenter: toggleAlign('center'),\n        JustifyRight: toggleAlign('right'),\n        JustifyFull: toggleAlign('justify'),\n        JustifyNone: toggleAlign('none')\n      });\n    };\n    const registerQueryStateCommands$1 = editor => {\n      const alignStates = name => () => {\n        const selection = editor.selection;\n        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\n        return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: alignStates('alignleft'),\n        JustifyCenter: alignStates('aligncenter'),\n        JustifyRight: alignStates('alignright'),\n        JustifyFull: alignStates('alignjustify')\n      }, 'state');\n    };\n    const registerCommands$b = editor => {\n      registerExecCommands$3(editor);\n      registerQueryStateCommands$1(editor);\n    };\n\n    const registerCommands$a = editor => {\n      editor.editorCommands.addCommands({\n        'Cut,Copy,Paste': command => {\n          const doc = editor.getDoc();\n          let failed;\n          try {\n            doc.execCommand(command);\n          } catch (ex) {\n            failed = true;\n          }\n          if (command === 'paste' && !doc.queryCommandEnabled(command)) {\n            failed = true;\n          }\n          if (failed || !doc.queryCommandSupported(command)) {\n            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\n            if (Env.os.isMacOS() || Env.os.isiOS()) {\n              msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\n            }\n            editor.notificationManager.open({\n              text: msg,\n              type: 'error'\n            });\n          }\n        }\n      });\n    };\n\n    const trimOrPadLeftRight = (dom, rng, html, schema) => {\n      const root = SugarElement.fromDom(dom.getRoot());\n      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {\n        html = html.replace(/^ /, '&nbsp;');\n      } else {\n        html = html.replace(/^&nbsp;/, ' ');\n      }\n      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {\n        html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\n      } else {\n        html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\n      }\n      return html;\n    };\n\n    const processValue$1 = value => {\n      if (typeof value !== 'string') {\n        const details = Tools.extend({\n          paste: value.paste,\n          data: { paste: value.paste }\n        }, value);\n        return {\n          content: value.content,\n          details\n        };\n      }\n      return {\n        content: value,\n        details: {}\n      };\n    };\n    const trimOrPad = (editor, value) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      if (/^ | $/.test(value)) {\n        return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);\n      } else {\n        return value;\n      }\n    };\n    const insertAtCaret = (editor, value) => {\n      if (editor.selection.isEditable()) {\n        const {content, details} = processValue$1(value);\n        preProcessSetContent(editor, {\n          ...details,\n          content: trimOrPad(editor, content),\n          format: 'html',\n          set: false,\n          selection: true\n        }).each(args => {\n          const insertedContent = insertContent$1(editor, args.content, details);\n          postProcessSetContent(editor, insertedContent, args);\n          editor.addVisual();\n        });\n      }\n    };\n\n    const registerCommands$9 = editor => {\n      editor.editorCommands.addCommands({\n        mceCleanup: () => {\n          const bm = editor.selection.getBookmark();\n          editor.setContent(editor.getContent());\n          editor.selection.moveToBookmark(bm);\n        },\n        insertImage: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));\n        },\n        insertHorizontalRule: () => {\n          editor.execCommand('mceInsertContent', false, '<hr>');\n        },\n        insertText: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.encode(value));\n        },\n        insertHTML: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceInsertContent: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceSetContent: (_command, _ui, value) => {\n          editor.setContent(value);\n        },\n        mceReplaceContent: (_command, _ui, value) => {\n          editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({ format: 'text' })));\n        },\n        mceNewDocument: () => {\n          editor.setContent(getNewDocumentContent(editor));\n        }\n      });\n    };\n\n    const legacyPropNames = {\n      'font-size': 'size',\n      'font-family': 'face'\n    };\n    const isFont = isTag('font');\n    const getSpecifiedFontProp = (propName, rootElm, elm) => {\n      const getProperty = elm => getRaw(elm, propName).orThunk(() => {\n        if (isFont(elm)) {\n          return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\n        } else {\n          return Optional.none();\n        }\n      });\n      const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\n      return closest$1(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\n    };\n    const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\n    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\n    const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\n    const getFontSize = getFontProp('font-size');\n    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\n\n    const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).bind(caret => {\n      const container = caret.container();\n      return Optional.from(isText$a(container) ? container.parentNode : container);\n    });\n    const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\n      const root = editor.getBody();\n      const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\n      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\n    });\n    const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\n    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\n\n    const fromFontSizeNumber = (editor, value) => {\n      if (/^[0-9.]+$/.test(value)) {\n        const fontSizeNumber = parseInt(value, 10);\n        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\n          const fontSizes = getFontStyleValues(editor);\n          const fontClasses = getFontSizeClasses(editor);\n          if (fontClasses.length > 0) {\n            return fontClasses[fontSizeNumber - 1] || value;\n          } else {\n            return fontSizes[fontSizeNumber - 1] || value;\n          }\n        } else {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    };\n    const normalizeFontNames = font => {\n      const fonts = font.split(/\\s*,\\s*/);\n      return map$3(fonts, font => {\n        if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\n          return `'${ font }'`;\n        } else {\n          return font;\n        }\n      }).join(',');\n    };\n    const fontNameAction = (editor, value) => {\n      const font = fromFontSizeNumber(editor, value);\n      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });\n      editor.nodeChanged();\n    };\n    const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\n    const fontSizeAction = (editor, value) => {\n      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });\n      editor.nodeChanged();\n    };\n    const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\n\n    const lineHeightQuery = editor => mapRange(editor, elm => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const specifiedStyle = closest$1(elm, elm => getRaw(elm, 'line-height'), curry(eq, root));\n      const computedStyle = () => {\n        const lineHeight = parseFloat(get$7(elm, 'line-height'));\n        const fontSize = parseFloat(get$7(elm, 'font-size'));\n        return String(lineHeight / fontSize);\n      };\n      return specifiedStyle.getOrThunk(computedStyle);\n    }).getOr('');\n    const lineHeightAction = (editor, lineHeight) => {\n      editor.formatter.toggle('lineheight', { value: String(lineHeight) });\n      editor.nodeChanged();\n    };\n\n    const registerExecCommands$2 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\n          toggleFormat(command);\n        },\n        'ForeColor,HiliteColor': (command, _ui, value) => {\n          toggleFormat(command, { value });\n        },\n        'BackColor': (_command, _ui, value) => {\n          toggleFormat('hilitecolor', { value });\n        },\n        'FontName': (_command, _ui, value) => {\n          fontNameAction(editor, value);\n        },\n        'FontSize': (_command, _ui, value) => {\n          fontSizeAction(editor, value);\n        },\n        'LineHeight': (_command, _ui, value) => {\n          lineHeightAction(editor, value);\n        },\n        'Lang': (command, _ui, lang) => {\n          var _a;\n          toggleFormat(command, {\n            value: lang.code,\n            customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null\n          });\n        },\n        'RemoveFormat': command => {\n          editor.formatter.remove(command);\n        },\n        'mceBlockQuote': () => {\n          toggleFormat('blockquote');\n        },\n        'FormatBlock': (_command, _ui, value) => {\n          toggleFormat(isString(value) ? value : 'p');\n        },\n        'mceToggleFormat': (_command, _ui, value) => {\n          toggleFormat(value);\n        }\n      });\n    };\n    const registerQueryValueCommands = editor => {\n      const isFormatMatch = name => editor.formatter.match(name);\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\n        'mceBlockQuote': () => isFormatMatch('blockquote')\n      }, 'state');\n      editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\n      editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\n      editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\n    };\n    const registerCommands$8 = editor => {\n      registerExecCommands$2(editor);\n      registerQueryValueCommands(editor);\n    };\n\n    const registerCommands$7 = editor => {\n      editor.editorCommands.addCommands({\n        mceAddUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        mceEndUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        Undo: () => {\n          editor.undoManager.undo();\n        },\n        Redo: () => {\n          editor.undoManager.redo();\n        }\n      });\n    };\n\n    const registerCommands$6 = editor => {\n      editor.editorCommands.addCommands({\n        Indent: () => {\n          indent(editor);\n        },\n        Outdent: () => {\n          outdent(editor);\n        }\n      });\n      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, 'state');\n    };\n\n    const registerCommands$5 = editor => {\n      const applyLinkToSelection = (_command, _ui, value) => {\n        const linkDetails = isString(value) ? { href: value } : value;\n        const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\n        if (isObject(linkDetails) && isString(linkDetails.href)) {\n          linkDetails.href = linkDetails.href.replace(/ /g, '%20');\n          if (!anchor || !linkDetails.href) {\n            editor.formatter.remove('link');\n          }\n          if (linkDetails.href) {\n            editor.formatter.apply('link', linkDetails, anchor);\n          }\n        }\n      };\n      editor.editorCommands.addCommands({\n        unlink: () => {\n          if (editor.selection.isEditable()) {\n            if (editor.selection.isCollapsed()) {\n              const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\n              if (elm) {\n                editor.dom.remove(elm, true);\n              }\n              return;\n            }\n            editor.formatter.remove('link');\n          }\n        },\n        mceInsertLink: applyLinkToSelection,\n        createLink: applyLinkToSelection\n      });\n    };\n\n    const registerExecCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        'InsertUnorderedList,InsertOrderedList': command => {\n          editor.getDoc().execCommand(command);\n          const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\n          if (listElm) {\n            const listParent = listElm.parentNode;\n            if (listParent && /^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\n              const bm = editor.selection.getBookmark();\n              editor.dom.split(listParent, listElm);\n              editor.selection.moveToBookmark(bm);\n            }\n          }\n        }\n      });\n    };\n    const registerQueryStateCommands = editor => {\n      editor.editorCommands.addCommands({\n        'InsertUnorderedList,InsertOrderedList': command => {\n          const list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');\n          return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');\n        }\n      }, 'state');\n    };\n    const registerCommands$4 = editor => {\n      registerExecCommands$1(editor);\n      registerQueryStateCommands(editor);\n    };\n\n    const getTopParentBlock = (editor, node, root, container) => {\n      const dom = editor.dom;\n      const selector = node => dom.isBlock(node) && node.parentElement === root;\n      const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);\n      return Optional.from(topParentBlock).map(SugarElement.fromDom);\n    };\n    const insert = (editor, before) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const node = before ? editor.selection.getStart() : editor.selection.getEnd();\n      const container = before ? rng.startContainer : rng.endContainer;\n      const root = getEditableRoot(dom, container);\n      if (!root || !root.isContentEditable) {\n        return;\n      }\n      const insertFn = before ? before$3 : after$4;\n      const newBlockName = getForcedRootBlock(editor);\n      getTopParentBlock(editor, node, root, container).each(parentBlock => {\n        const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);\n        insertFn(parentBlock, SugarElement.fromDom(newBlock));\n        editor.selection.setCursorLocation(newBlock, 0);\n        editor.dispatch('NewBlock', { newBlock });\n        fireInputEvent(editor, 'insertParagraph');\n      });\n    };\n    const insertBefore = editor => insert(editor, true);\n    const insertAfter = editor => insert(editor, false);\n\n    const registerCommands$3 = editor => {\n      editor.editorCommands.addCommands({\n        InsertNewBlockBefore: () => {\n          insertBefore(editor);\n        },\n        InsertNewBlockAfter: () => {\n          insertAfter(editor);\n        }\n      });\n    };\n\n    const registerCommands$2 = editor => {\n      editor.editorCommands.addCommands({\n        insertParagraph: () => {\n          insertBreak(blockbreak, editor);\n        },\n        mceInsertNewLine: (_command, _ui, value) => {\n          insert$1(editor, value);\n        },\n        InsertLineBreak: (_command, _ui, _value) => {\n          insertBreak(linebreak, editor);\n        }\n      });\n    };\n\n    const registerCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        mceSelectNodeDepth: (_command, _ui, value) => {\n          let counter = 0;\n          editor.dom.getParent(editor.selection.getNode(), node => {\n            if (isElement$6(node) && counter++ === value) {\n              editor.selection.select(node);\n              return false;\n            } else {\n              return true;\n            }\n          }, editor.getBody());\n        },\n        mceSelectNode: (_command, _ui, value) => {\n          editor.selection.select(value);\n        },\n        selectAll: () => {\n          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);\n          if (editingHost) {\n            const rng = editor.dom.createRng();\n            rng.selectNodeContents(editingHost);\n            editor.selection.setRng(rng);\n          }\n        }\n      });\n    };\n\n    const registerExecCommands = editor => {\n      editor.editorCommands.addCommands({\n        mceRemoveNode: (_command, _ui, value) => {\n          const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\n          if (node !== editor.getBody()) {\n            const bm = editor.selection.getBookmark();\n            editor.dom.remove(node, true);\n            editor.selection.moveToBookmark(bm);\n          }\n        },\n        mcePrint: () => {\n          editor.getWin().print();\n        },\n        mceFocus: (_command, _ui, value) => {\n          focus(editor, value === true);\n        },\n        mceToggleVisualAid: () => {\n          editor.hasVisual = !editor.hasVisual;\n          editor.addVisual();\n        }\n      });\n    };\n    const registerCommands = editor => {\n      registerCommands$b(editor);\n      registerCommands$a(editor);\n      registerCommands$7(editor);\n      registerCommands$1(editor);\n      registerCommands$9(editor);\n      registerCommands$5(editor);\n      registerCommands$6(editor);\n      registerCommands$3(editor);\n      registerCommands$2(editor);\n      registerCommands$4(editor);\n      registerCommands$8(editor);\n      registerExecCommands(editor);\n    };\n\n    const selectionSafeCommands = ['toggleview'];\n    const isSelectionSafeCommand = command => contains$2(selectionSafeCommands, command.toLowerCase());\n    class EditorCommands {\n      constructor(editor) {\n        this.commands = {\n          state: {},\n          exec: {},\n          value: {}\n        };\n        this.editor = editor;\n      }\n      execCommand(command, ui = false, value, args) {\n        const editor = this.editor;\n        const lowerCaseCommand = command.toLowerCase();\n        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\n        if (editor.removed) {\n          return false;\n        }\n        if (lowerCaseCommand !== 'mcefocus') {\n          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\n            editor.focus();\n          } else {\n            restore(editor);\n          }\n        }\n        const eventArgs = editor.dispatch('BeforeExecCommand', {\n          command,\n          ui,\n          value\n        });\n        if (eventArgs.isDefaultPrevented()) {\n          return false;\n        }\n        const func = this.commands.exec[lowerCaseCommand];\n        if (isFunction(func)) {\n          func(lowerCaseCommand, ui, value);\n          editor.dispatch('ExecCommand', {\n            command,\n            ui,\n            value\n          });\n          return true;\n        }\n        return false;\n      }\n      queryCommandState(command) {\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n          return false;\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.state[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return false;\n      }\n      queryCommandValue(command) {\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n          return '';\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.value[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return '';\n      }\n      addCommands(commandList, type = 'exec') {\n        const commands = this.commands;\n        each$d(commandList, (callback, command) => {\n          each$e(command.toLowerCase().split(','), command => {\n            commands[type][command] = callback;\n          });\n        });\n      }\n      addCommand(command, callback, scope) {\n        const lowerCaseCommand = command.toLowerCase();\n        this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\n      }\n      queryCommandSupported(command) {\n        const lowerCaseCommand = command.toLowerCase();\n        if (this.commands.exec[lowerCaseCommand]) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      addQueryStateHandler(command, callback, scope) {\n        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n      addQueryValueHandler(command, callback, scope) {\n        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n    }\n\n    const internalContentEditableAttr = 'data-mce-contenteditable';\n    const toggleClass = (elm, cls, state) => {\n      if (has(elm, cls) && !state) {\n        remove$7(elm, cls);\n      } else if (state) {\n        add$2(elm, cls);\n      }\n    };\n    const setEditorCommandState = (editor, cmd, state) => {\n      try {\n        editor.getDoc().execCommand(cmd, false, String(state));\n      } catch (ex) {\n      }\n    };\n    const setContentEditable = (elm, state) => {\n      elm.dom.contentEditable = state ? 'true' : 'false';\n    };\n    const switchOffContentEditableTrue = elm => {\n      each$e(descendants(elm, '*[contenteditable=\"true\"]'), elm => {\n        set$3(elm, internalContentEditableAttr, 'true');\n        setContentEditable(elm, false);\n      });\n    };\n    const switchOnContentEditableTrue = elm => {\n      each$e(descendants(elm, `*[${ internalContentEditableAttr }=\"true\"]`), elm => {\n        remove$a(elm, internalContentEditableAttr);\n        setContentEditable(elm, true);\n      });\n    };\n    const removeFakeSelection = editor => {\n      Optional.from(editor.selection.getNode()).each(elm => {\n        elm.removeAttribute('data-mce-selected');\n      });\n    };\n    const restoreFakeSelection = editor => {\n      editor.selection.setRng(editor.selection.getRng());\n    };\n    const toggleReadOnly = (editor, state) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      toggleClass(body, 'mce-content-readonly', state);\n      if (state) {\n        editor.selection.controlSelection.hideResizeRect();\n        editor._selectionOverrides.hideFakeCaret();\n        removeFakeSelection(editor);\n        editor.readonly = true;\n        setContentEditable(body, false);\n        switchOffContentEditableTrue(body);\n      } else {\n        editor.readonly = false;\n        if (editor.hasEditableRoot()) {\n          setContentEditable(body, true);\n        }\n        switchOnContentEditableTrue(body);\n        setEditorCommandState(editor, 'StyleWithCSS', false);\n        setEditorCommandState(editor, 'enableInlineTableEditing', false);\n        setEditorCommandState(editor, 'enableObjectResizing', false);\n        if (hasEditorOrUiFocus(editor)) {\n          editor.focus();\n        }\n        restoreFakeSelection(editor);\n        editor.nodeChanged();\n      }\n    };\n    const isReadOnly = editor => editor.readonly;\n    const registerFilters = editor => {\n      editor.parser.addAttributeFilter('contenteditable', nodes => {\n        if (isReadOnly(editor)) {\n          each$e(nodes, node => {\n            node.attr(internalContentEditableAttr, node.attr('contenteditable'));\n            node.attr('contenteditable', 'false');\n          });\n        }\n      });\n      editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {\n        if (isReadOnly(editor)) {\n          each$e(nodes, node => {\n            node.attr('contenteditable', node.attr(internalContentEditableAttr));\n          });\n        }\n      });\n      editor.serializer.addTempAttr(internalContentEditableAttr);\n    };\n    const registerReadOnlyContentFilters = editor => {\n      if (editor.serializer) {\n        registerFilters(editor);\n      } else {\n        editor.on('PreInit', () => {\n          registerFilters(editor);\n        });\n      }\n    };\n    const isClickEvent = e => e.type === 'click';\n    const allowedEvents = ['copy'];\n    const isReadOnlyAllowedEvent = e => contains$2(allowedEvents, e.type);\n    const getAnchorHrefOpt = (editor, elm) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\n    };\n    const processReadonlyEvents = (editor, e) => {\n      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\n        const elm = SugarElement.fromDom(e.target);\n        getAnchorHrefOpt(editor, elm).each(href => {\n          e.preventDefault();\n          if (/^#/.test(href)) {\n            const targetEl = editor.dom.select(`${ href },[name=\"${ removeLeading(href, '#') }\"]`);\n            if (targetEl.length) {\n              editor.selection.scrollIntoView(targetEl[0], true);\n            }\n          } else {\n            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\n          }\n        });\n      } else if (isReadOnlyAllowedEvent(e)) {\n        editor.dispatch(e.type, e);\n      }\n    };\n    const registerReadOnlySelectionBlockers = editor => {\n      editor.on('ShowCaret', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n      editor.on('ObjectSelected', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\n    class EventDispatcher {\n      static isNative(name) {\n        return !!nativeEvents[name.toLowerCase()];\n      }\n      constructor(settings) {\n        this.bindings = {};\n        this.settings = settings || {};\n        this.scope = this.settings.scope || this;\n        this.toggleEvent = this.settings.toggleEvent || never;\n      }\n      fire(name, args) {\n        return this.dispatch(name, args);\n      }\n      dispatch(name, args) {\n        const lcName = name.toLowerCase();\n        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\n        if (this.settings.beforeFire) {\n          this.settings.beforeFire(event);\n        }\n        const handlers = this.bindings[lcName];\n        if (handlers) {\n          for (let i = 0, l = handlers.length; i < l; i++) {\n            const callback = handlers[i];\n            if (callback.removed) {\n              continue;\n            }\n            if (callback.once) {\n              this.off(lcName, callback.func);\n            }\n            if (event.isImmediatePropagationStopped()) {\n              return event;\n            }\n            if (callback.func.call(this.scope, event) === false) {\n              event.preventDefault();\n              return event;\n            }\n          }\n        }\n        return event;\n      }\n      on(name, callback, prepend, extra) {\n        if (callback === false) {\n          callback = never;\n        }\n        if (callback) {\n          const wrappedCallback = {\n            func: callback,\n            removed: false\n          };\n          if (extra) {\n            Tools.extend(wrappedCallback, extra);\n          }\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!handlers) {\n              handlers = [];\n              this.toggleEvent(currentName, true);\n            }\n            if (prepend) {\n              handlers = [\n                wrappedCallback,\n                ...handlers\n              ];\n            } else {\n              handlers = [\n                ...handlers,\n                wrappedCallback\n              ];\n            }\n            this.bindings[currentName] = handlers;\n          }\n        }\n        return this;\n      }\n      off(name, callback) {\n        if (name) {\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!currentName) {\n              each$d(this.bindings, (_value, bindingName) => {\n                this.toggleEvent(bindingName, false);\n                delete this.bindings[bindingName];\n              });\n              return this;\n            }\n            if (handlers) {\n              if (!callback) {\n                handlers.length = 0;\n              } else {\n                const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\n                handlers = filteredHandlers.fail;\n                this.bindings[currentName] = handlers;\n                each$e(filteredHandlers.pass, handler => {\n                  handler.removed = true;\n                });\n              }\n              if (!handlers.length) {\n                this.toggleEvent(name, false);\n                delete this.bindings[currentName];\n              }\n            }\n          }\n        } else {\n          each$d(this.bindings, (_value, name) => {\n            this.toggleEvent(name, false);\n          });\n          this.bindings = {};\n        }\n        return this;\n      }\n      once(name, callback, prepend) {\n        return this.on(name, callback, prepend, { once: true });\n      }\n      has(name) {\n        name = name.toLowerCase();\n        const binding = this.bindings[name];\n        return !(!binding || binding.length === 0);\n      }\n    }\n\n    const getEventDispatcher = obj => {\n      if (!obj._eventDispatcher) {\n        obj._eventDispatcher = new EventDispatcher({\n          scope: obj,\n          toggleEvent: (name, state) => {\n            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n              obj.toggleNativeEvent(name, state);\n            }\n          }\n        });\n      }\n      return obj._eventDispatcher;\n    };\n    const Observable = {\n      fire(name, args, bubble) {\n        return this.dispatch(name, args, bubble);\n      },\n      dispatch(name, args, bubble) {\n        const self = this;\n        if (self.removed && name !== 'remove' && name !== 'detach') {\n          return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\n        }\n        const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\n        if (bubble !== false && self.parent) {\n          let parent = self.parent();\n          while (parent && !dispatcherArgs.isPropagationStopped()) {\n            parent.dispatch(name, dispatcherArgs, false);\n            parent = parent.parent ? parent.parent() : undefined;\n          }\n        }\n        return dispatcherArgs;\n      },\n      on(name, callback, prepend) {\n        return getEventDispatcher(this).on(name, callback, prepend);\n      },\n      off(name, callback) {\n        return getEventDispatcher(this).off(name, callback);\n      },\n      once(name, callback) {\n        return getEventDispatcher(this).once(name, callback);\n      },\n      hasEventListeners(name) {\n        return getEventDispatcher(this).has(name);\n      }\n    };\n\n    const DOM$2 = DOMUtils.DOM;\n    let customEventRootDelegates;\n    const getEventTarget = (editor, eventName) => {\n      if (eventName === 'selectionchange') {\n        return editor.getDoc();\n      }\n      if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {\n        return editor.getDoc().documentElement;\n      }\n      const eventRoot = getEventRoot(editor);\n      if (eventRoot) {\n        if (!editor.eventRoot) {\n          editor.eventRoot = DOM$2.select(eventRoot)[0];\n        }\n        return editor.eventRoot;\n      }\n      return editor.getBody();\n    };\n    const isListening = editor => !editor.hidden && !isReadOnly(editor);\n    const fireEvent = (editor, eventName, e) => {\n      if (isListening(editor)) {\n        editor.dispatch(eventName, e);\n      } else if (isReadOnly(editor)) {\n        processReadonlyEvents(editor, e);\n      }\n    };\n    const bindEventDelegate = (editor, eventName) => {\n      if (!editor.delegates) {\n        editor.delegates = {};\n      }\n      if (editor.delegates[eventName] || editor.removed) {\n        return;\n      }\n      const eventRootElm = getEventTarget(editor, eventName);\n      if (getEventRoot(editor)) {\n        if (!customEventRootDelegates) {\n          customEventRootDelegates = {};\n          editor.editorManager.on('removeEditor', () => {\n            if (!editor.editorManager.activeEditor) {\n              if (customEventRootDelegates) {\n                each$d(customEventRootDelegates, (_value, name) => {\n                  editor.dom.unbind(getEventTarget(editor, name));\n                });\n                customEventRootDelegates = null;\n              }\n            }\n          });\n        }\n        if (customEventRootDelegates[eventName]) {\n          return;\n        }\n        const delegate = e => {\n          const target = e.target;\n          const editors = editor.editorManager.get();\n          let i = editors.length;\n          while (i--) {\n            const body = editors[i].getBody();\n            if (body === target || DOM$2.isChildOf(target, body)) {\n              fireEvent(editors[i], eventName, e);\n            }\n          }\n        };\n        customEventRootDelegates[eventName] = delegate;\n        DOM$2.bind(eventRootElm, eventName, delegate);\n      } else {\n        const delegate = e => {\n          fireEvent(editor, eventName, e);\n        };\n        DOM$2.bind(eventRootElm, eventName, delegate);\n        editor.delegates[eventName] = delegate;\n      }\n    };\n    const EditorObservable = {\n      ...Observable,\n      bindPendingEventDelegates() {\n        const self = this;\n        Tools.each(self._pendingNativeEvents, name => {\n          bindEventDelegate(self, name);\n        });\n      },\n      toggleNativeEvent(name, state) {\n        const self = this;\n        if (name === 'focus' || name === 'blur') {\n          return;\n        }\n        if (self.removed) {\n          return;\n        }\n        if (state) {\n          if (self.initialized) {\n            bindEventDelegate(self, name);\n          } else {\n            if (!self._pendingNativeEvents) {\n              self._pendingNativeEvents = [name];\n            } else {\n              self._pendingNativeEvents.push(name);\n            }\n          }\n        } else if (self.initialized && self.delegates) {\n          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n          delete self.delegates[name];\n        }\n      },\n      unbindAllNativeEvents() {\n        const self = this;\n        const body = self.getBody();\n        const dom = self.dom;\n        if (self.delegates) {\n          each$d(self.delegates, (value, name) => {\n            self.dom.unbind(getEventTarget(self, name), name, value);\n          });\n          delete self.delegates;\n        }\n        if (!self.inline && body && dom) {\n          body.onload = null;\n          dom.unbind(self.getWin());\n          dom.unbind(self.getDoc());\n        }\n        if (dom) {\n          dom.unbind(body);\n          dom.unbind(self.getContainer());\n        }\n      }\n    };\n\n    const stringListProcessor = value => {\n      if (isString(value)) {\n        return {\n          value: value.split(/[ ,]/),\n          valid: true\n        };\n      } else if (isArrayOf(value, isString)) {\n        return {\n          value,\n          valid: true\n        };\n      } else {\n        return {\n          valid: false,\n          message: `The value must be a string[] or a comma/space separated string.`\n        };\n      }\n    };\n    const getBuiltInProcessor = type => {\n      const validator = (() => {\n        switch (type) {\n        case 'array':\n          return isArray$1;\n        case 'boolean':\n          return isBoolean;\n        case 'function':\n          return isFunction;\n        case 'number':\n          return isNumber;\n        case 'object':\n          return isObject;\n        case 'string':\n          return isString;\n        case 'string[]':\n          return stringListProcessor;\n        case 'object[]':\n          return val => isArrayOf(val, isObject);\n        case 'regexp':\n          return val => is$4(val, RegExp);\n        default:\n          return always;\n        }\n      })();\n      return value => processValue(value, validator, `The value must be a ${ type }.`);\n    };\n    const isBuiltInSpec = spec => isString(spec.processor);\n    const getErrorMessage = (message, result) => {\n      const additionalText = isEmpty$3(result.message) ? '' : `. ${ result.message }`;\n      return message + additionalText;\n    };\n    const isValidResult = result => result.valid;\n    const processValue = (value, processor, message = '') => {\n      const result = processor(value);\n      if (isBoolean(result)) {\n        return result ? {\n          value: value,\n          valid: true\n        } : {\n          valid: false,\n          message\n        };\n      } else {\n        return result;\n      }\n    };\n    const processDefaultValue = (name, defaultValue, processor) => {\n      if (!isUndefined(defaultValue)) {\n        const result = processValue(defaultValue, processor);\n        if (isValidResult(result)) {\n          return result.value;\n        } else {\n          console.error(getErrorMessage(`Invalid default value passed for the \"${ name }\" option`, result));\n        }\n      }\n      return undefined;\n    };\n    const create$5 = (editor, initialOptions) => {\n      const registry = {};\n      const values = {};\n      const setValue = (name, value, processor) => {\n        const result = processValue(value, processor);\n        if (isValidResult(result)) {\n          values[name] = result.value;\n          return true;\n        } else {\n          console.warn(getErrorMessage(`Invalid value passed for the ${ name } option`, result));\n          return false;\n        }\n      };\n      const register = (name, spec) => {\n        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\n        const defaultValue = processDefaultValue(name, spec.default, processor);\n        registry[name] = {\n          ...spec,\n          default: defaultValue,\n          processor\n        };\n        const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\n        initValue.each(value => setValue(name, value, processor));\n      };\n      const isRegistered = name => has$2(registry, name);\n      const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\n      const set = (name, value) => {\n        if (!isRegistered(name)) {\n          console.warn(`\"${ name }\" is not a registered option. Ensure the option has been registered before setting a value.`);\n          return false;\n        } else {\n          const spec = registry[name];\n          if (spec.immutable) {\n            console.error(`\"${ name }\" is an immutable option and cannot be updated`);\n            return false;\n          } else {\n            return setValue(name, value, spec.processor);\n          }\n        }\n      };\n      const unset = name => {\n        const registered = isRegistered(name);\n        if (registered) {\n          delete values[name];\n        }\n        return registered;\n      };\n      const isSet = name => has$2(values, name);\n      return {\n        register,\n        isRegistered,\n        get,\n        set,\n        unset,\n        isSet\n      };\n    };\n\n    const defaultModes = [\n      'design',\n      'readonly'\n    ];\n    const switchToMode = (editor, activeMode, availableModes, mode) => {\n      const oldMode = availableModes[activeMode.get()];\n      const newMode = availableModes[mode];\n      try {\n        newMode.activate();\n      } catch (e) {\n        console.error(`problem while activating editor mode ${ mode }:`, e);\n        return;\n      }\n      oldMode.deactivate();\n      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\n        toggleReadOnly(editor, newMode.editorReadOnly);\n      }\n      activeMode.set(mode);\n      fireSwitchMode(editor, mode);\n    };\n    const setMode = (editor, availableModes, activeMode, mode) => {\n      if (mode === activeMode.get()) {\n        return;\n      } else if (!has$2(availableModes, mode)) {\n        throw new Error(`Editor mode '${ mode }' is invalid`);\n      }\n      if (editor.initialized) {\n        switchToMode(editor, activeMode, availableModes, mode);\n      } else {\n        editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\n      }\n    };\n    const registerMode = (availableModes, mode, api) => {\n      if (contains$2(defaultModes, mode)) {\n        throw new Error(`Cannot override default mode ${ mode }`);\n      }\n      return {\n        ...availableModes,\n        [mode]: {\n          ...api,\n          deactivate: () => {\n            try {\n              api.deactivate();\n            } catch (e) {\n              console.error(`problem while deactivating editor mode ${ mode }:`, e);\n            }\n          }\n        }\n      };\n    };\n\n    const create$4 = editor => {\n      const activeMode = Cell('design');\n      const availableModes = Cell({\n        design: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: false\n        },\n        readonly: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: true\n        }\n      });\n      registerReadOnlyContentFilters(editor);\n      registerReadOnlySelectionBlockers(editor);\n      return {\n        isReadOnly: () => isReadOnly(editor),\n        set: mode => setMode(editor, availableModes.get(), activeMode, mode),\n        get: () => activeMode.get(),\n        register: (mode, api) => {\n          availableModes.set(registerMode(availableModes.get(), mode, api));\n        }\n      };\n    };\n\n    const each$2 = Tools.each, explode = Tools.explode;\n    const keyCodeLookup = {\n      f1: 112,\n      f2: 113,\n      f3: 114,\n      f4: 115,\n      f5: 116,\n      f6: 117,\n      f7: 118,\n      f8: 119,\n      f9: 120,\n      f10: 121,\n      f11: 122,\n      f12: 123\n    };\n    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\n    const isModifier = key => key in modifierNames;\n    const parseShortcut = pattern => {\n      const shortcut = {};\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      each$2(explode(pattern.toLowerCase(), '+'), value => {\n        if (isModifier(value)) {\n          shortcut[value] = true;\n        } else {\n          if (/^[0-9]{2,}$/.test(value)) {\n            shortcut.keyCode = parseInt(value, 10);\n          } else {\n            shortcut.charCode = value.charCodeAt(0);\n            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n          }\n        }\n      });\n      const id = [shortcut.keyCode];\n      let key;\n      for (key in modifierNames) {\n        if (shortcut[key]) {\n          id.push(key);\n        } else {\n          shortcut[key] = false;\n        }\n      }\n      shortcut.id = id.join(',');\n      if (shortcut.access) {\n        shortcut.alt = true;\n        if (isMac) {\n          shortcut.ctrl = true;\n        } else {\n          shortcut.shift = true;\n        }\n      }\n      if (shortcut.meta) {\n        if (isMac) {\n          shortcut.meta = true;\n        } else {\n          shortcut.ctrl = true;\n          shortcut.meta = false;\n        }\n      }\n      return shortcut;\n    };\n    class Shortcuts {\n      constructor(editor) {\n        this.shortcuts = {};\n        this.pendingPatterns = [];\n        this.editor = editor;\n        const self = this;\n        editor.on('keyup keypress keydown', e => {\n          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\n            each$2(self.shortcuts, shortcut => {\n              if (self.matchShortcut(e, shortcut)) {\n                self.pendingPatterns = shortcut.subpatterns.slice(0);\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(shortcut);\n                }\n              }\n            });\n            if (self.matchShortcut(e, self.pendingPatterns[0])) {\n              if (self.pendingPatterns.length === 1) {\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(self.pendingPatterns[0]);\n                }\n              }\n              self.pendingPatterns.shift();\n            }\n          }\n        });\n      }\n      add(pattern, desc, cmdFunc, scope) {\n        const self = this;\n        const func = self.normalizeCommandFunc(cmdFunc);\n        each$2(explode(Tools.trim(pattern)), pattern => {\n          const shortcut = self.createShortcut(pattern, desc, func, scope);\n          self.shortcuts[shortcut.id] = shortcut;\n        });\n        return true;\n      }\n      remove(pattern) {\n        const shortcut = this.createShortcut(pattern);\n        if (this.shortcuts[shortcut.id]) {\n          delete this.shortcuts[shortcut.id];\n          return true;\n        }\n        return false;\n      }\n      normalizeCommandFunc(cmdFunc) {\n        const self = this;\n        const cmd = cmdFunc;\n        if (typeof cmd === 'string') {\n          return () => {\n            self.editor.execCommand(cmd, false, null);\n          };\n        } else if (Tools.isArray(cmd)) {\n          return () => {\n            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\n          };\n        } else {\n          return cmd;\n        }\n      }\n      createShortcut(pattern, desc, cmdFunc, scope) {\n        const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\n        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\n          func: cmdFunc,\n          scope: scope || this.editor\n        });\n        return Tools.extend(shortcuts[0], {\n          desc: this.editor.translate(desc),\n          subpatterns: shortcuts.slice(1)\n        });\n      }\n      hasModifier(e) {\n        return e.altKey || e.ctrlKey || e.metaKey;\n      }\n      isFunctionKey(e) {\n        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\n      }\n      matchShortcut(e, shortcut) {\n        if (!shortcut) {\n          return false;\n        }\n        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\n          return false;\n        }\n        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\n          return false;\n        }\n        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\n          e.preventDefault();\n          return true;\n        }\n        return false;\n      }\n      executeShortcutAction(shortcut) {\n        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\n      }\n    }\n\n    const create$3 = () => {\n      const buttons = {};\n      const menuItems = {};\n      const popups = {};\n      const icons = {};\n      const contextMenus = {};\n      const contextToolbars = {};\n      const sidebars = {};\n      const views = {};\n      const add = (collection, type) => (name, spec) => {\n        collection[name.toLowerCase()] = {\n          ...spec,\n          type\n        };\n      };\n      const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\n      return {\n        addButton: add(buttons, 'button'),\n        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\n        addToggleButton: add(buttons, 'togglebutton'),\n        addMenuButton: add(buttons, 'menubutton'),\n        addSplitButton: add(buttons, 'splitbutton'),\n        addMenuItem: add(menuItems, 'menuitem'),\n        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\n        addToggleMenuItem: add(menuItems, 'togglemenuitem'),\n        addAutocompleter: add(popups, 'autocompleter'),\n        addContextMenu: add(contextMenus, 'contextmenu'),\n        addContextToolbar: add(contextToolbars, 'contexttoolbar'),\n        addContextForm: add(contextToolbars, 'contextform'),\n        addSidebar: add(sidebars, 'sidebar'),\n        addView: add(views, 'views'),\n        addIcon,\n        getAll: () => ({\n          buttons,\n          menuItems,\n          icons,\n          popups,\n          contextMenus,\n          contextToolbars,\n          sidebars,\n          views\n        })\n      };\n    };\n\n    const registry = () => {\n      const bridge = create$3();\n      return {\n        addAutocompleter: bridge.addAutocompleter,\n        addButton: bridge.addButton,\n        addContextForm: bridge.addContextForm,\n        addContextMenu: bridge.addContextMenu,\n        addContextToolbar: bridge.addContextToolbar,\n        addIcon: bridge.addIcon,\n        addMenuButton: bridge.addMenuButton,\n        addMenuItem: bridge.addMenuItem,\n        addNestedMenuItem: bridge.addNestedMenuItem,\n        addSidebar: bridge.addSidebar,\n        addSplitButton: bridge.addSplitButton,\n        addToggleButton: bridge.addToggleButton,\n        addGroupToolbarButton: bridge.addGroupToolbarButton,\n        addToggleMenuItem: bridge.addToggleMenuItem,\n        addView: bridge.addView,\n        getAll: bridge.getAll\n      };\n    };\n\n    const DOM$1 = DOMUtils.DOM;\n    const extend = Tools.extend, each$1 = Tools.each;\n    class Editor {\n      constructor(id, options, editorManager) {\n        this.plugins = {};\n        this.contentCSS = [];\n        this.contentStyles = [];\n        this.loadedCSS = {};\n        this.isNotDirty = false;\n        this.composing = false;\n        this.destroyed = false;\n        this.hasHiddenInput = false;\n        this.iframeElement = null;\n        this.initialized = false;\n        this.readonly = false;\n        this.removed = false;\n        this.startContent = '';\n        this._pendingNativeEvents = [];\n        this._skinLoaded = false;\n        this._editableRoot = true;\n        this.editorManager = editorManager;\n        this.documentBaseUrl = editorManager.documentBaseURL;\n        extend(this, EditorObservable);\n        const self = this;\n        this.id = id;\n        this.hidden = false;\n        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\n        this.options = create$5(self, normalizedOptions);\n        register$7(self);\n        const getOption = this.options.get;\n        if (getOption('deprecation_warnings')) {\n          logWarnings(options, normalizedOptions);\n        }\n        const suffix = getOption('suffix');\n        if (suffix) {\n          editorManager.suffix = suffix;\n        }\n        this.suffix = editorManager.suffix;\n        const baseUrl = getOption('base_url');\n        if (baseUrl) {\n          editorManager._setBaseUrl(baseUrl);\n        }\n        this.baseUri = editorManager.baseURI;\n        const referrerPolicy = getReferrerPolicy(self);\n        if (referrerPolicy) {\n          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\n          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\n        }\n        const contentCssCors = hasContentCssCors(self);\n        if (isNonNullable(contentCssCors)) {\n          DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);\n        }\n        AddOnManager.languageLoad = getOption('language_load');\n        AddOnManager.baseURL = editorManager.baseURL;\n        this.setDirty(false);\n        this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });\n        this.baseURI = this.baseUri;\n        this.inline = isInline$1(self);\n        this.hasVisual = isVisualAidsEnabled(self);\n        this.shortcuts = new Shortcuts(this);\n        this.editorCommands = new EditorCommands(this);\n        registerCommands(this);\n        const cacheSuffix = getOption('cache_suffix');\n        if (cacheSuffix) {\n          Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\n        }\n        this.ui = {\n          registry: registry(),\n          styleSheetLoader: undefined,\n          show: noop,\n          hide: noop,\n          setEnabled: noop,\n          isEnabled: always\n        };\n        this.mode = create$4(self);\n        editorManager.dispatch('SetupEditor', { editor: this });\n        const setupCallback = getSetupCallback(self);\n        if (isFunction(setupCallback)) {\n          setupCallback.call(self, self);\n        }\n      }\n      render() {\n        render(this);\n      }\n      focus(skipFocus) {\n        this.execCommand('mceFocus', false, skipFocus);\n      }\n      hasFocus() {\n        return hasFocus(this);\n      }\n      translate(text) {\n        return I18n.translate(text);\n      }\n      getParam(name, defaultVal, type) {\n        const options = this.options;\n        if (!options.isRegistered(name)) {\n          if (isNonNullable(type)) {\n            options.register(name, {\n              processor: type,\n              default: defaultVal\n            });\n          } else {\n            options.register(name, {\n              processor: always,\n              default: defaultVal\n            });\n          }\n        }\n        return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\n      }\n      hasPlugin(name, loaded) {\n        const hasPlugin = contains$2(getPlugins(this), name);\n        if (hasPlugin) {\n          return loaded ? PluginManager.get(name) !== undefined : true;\n        } else {\n          return false;\n        }\n      }\n      nodeChanged(args) {\n        this._nodeChangeDispatcher.nodeChanged(args);\n      }\n      addCommand(name, callback, scope) {\n        this.editorCommands.addCommand(name, callback, scope);\n      }\n      addQueryStateHandler(name, callback, scope) {\n        this.editorCommands.addQueryStateHandler(name, callback, scope);\n      }\n      addQueryValueHandler(name, callback, scope) {\n        this.editorCommands.addQueryValueHandler(name, callback, scope);\n      }\n      addShortcut(pattern, desc, cmdFunc, scope) {\n        this.shortcuts.add(pattern, desc, cmdFunc, scope);\n      }\n      execCommand(cmd, ui, value, args) {\n        return this.editorCommands.execCommand(cmd, ui, value, args);\n      }\n      queryCommandState(cmd) {\n        return this.editorCommands.queryCommandState(cmd);\n      }\n      queryCommandValue(cmd) {\n        return this.editorCommands.queryCommandValue(cmd);\n      }\n      queryCommandSupported(cmd) {\n        return this.editorCommands.queryCommandSupported(cmd);\n      }\n      show() {\n        const self = this;\n        if (self.hidden) {\n          self.hidden = false;\n          if (self.inline) {\n            self.getBody().contentEditable = 'true';\n          } else {\n            DOM$1.show(self.getContainer());\n            DOM$1.hide(self.id);\n          }\n          self.load();\n          self.dispatch('show');\n        }\n      }\n      hide() {\n        const self = this;\n        if (!self.hidden) {\n          self.save();\n          if (self.inline) {\n            self.getBody().contentEditable = 'false';\n            if (self === self.editorManager.focusedEditor) {\n              self.editorManager.focusedEditor = null;\n            }\n          } else {\n            DOM$1.hide(self.getContainer());\n            DOM$1.setStyle(self.id, 'display', self.orgDisplay);\n          }\n          self.hidden = true;\n          self.dispatch('hide');\n        }\n      }\n      isHidden() {\n        return this.hidden;\n      }\n      setProgressState(state, time) {\n        this.dispatch('ProgressState', {\n          state,\n          time\n        });\n      }\n      load(args = {}) {\n        const self = this;\n        const elm = self.getElement();\n        if (self.removed) {\n          return '';\n        }\n        if (elm) {\n          const loadArgs = {\n            ...args,\n            load: true\n          };\n          const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\n          const html = self.setContent(value, loadArgs);\n          if (!loadArgs.no_events) {\n            self.dispatch('LoadContent', {\n              ...loadArgs,\n              element: elm\n            });\n          }\n          return html;\n        } else {\n          return '';\n        }\n      }\n      save(args = {}) {\n        const self = this;\n        let elm = self.getElement();\n        if (!elm || !self.initialized || self.removed) {\n          return '';\n        }\n        const getArgs = {\n          ...args,\n          save: true,\n          element: elm\n        };\n        let html = self.getContent(getArgs);\n        const saveArgs = {\n          ...getArgs,\n          content: html\n        };\n        if (!saveArgs.no_events) {\n          self.dispatch('SaveContent', saveArgs);\n        }\n        if (saveArgs.format === 'raw') {\n          self.dispatch('RawSaveContent', saveArgs);\n        }\n        html = saveArgs.content;\n        if (!isTextareaOrInput(elm)) {\n          if (args.is_removing || !self.inline) {\n            elm.innerHTML = html;\n          }\n          const form = DOM$1.getParent(self.id, 'form');\n          if (form) {\n            each$1(form.elements, elm => {\n              if (elm.name === self.id) {\n                elm.value = html;\n                return false;\n              } else {\n                return true;\n              }\n            });\n          }\n        } else {\n          elm.value = html;\n        }\n        saveArgs.element = getArgs.element = elm = null;\n        if (saveArgs.set_dirty !== false) {\n          self.setDirty(false);\n        }\n        return html;\n      }\n      setContent(content, args) {\n        return setContent(this, content, args);\n      }\n      getContent(args) {\n        return getContent(this, args);\n      }\n      insertContent(content, args) {\n        if (args) {\n          content = extend({ content }, args);\n        }\n        this.execCommand('mceInsertContent', false, content);\n      }\n      resetContent(initialContent) {\n        if (initialContent === undefined) {\n          setContent(this, this.startContent, { format: 'raw' });\n        } else {\n          setContent(this, initialContent);\n        }\n        this.undoManager.reset();\n        this.setDirty(false);\n        this.nodeChanged();\n      }\n      isDirty() {\n        return !this.isNotDirty;\n      }\n      setDirty(state) {\n        const oldState = !this.isNotDirty;\n        this.isNotDirty = !state;\n        if (state && state !== oldState) {\n          this.dispatch('dirty');\n        }\n      }\n      getContainer() {\n        const self = this;\n        if (!self.container) {\n          self.container = self.editorContainer || DOM$1.get(self.id + '_parent');\n        }\n        return self.container;\n      }\n      getContentAreaContainer() {\n        return this.contentAreaContainer;\n      }\n      getElement() {\n        if (!this.targetElm) {\n          this.targetElm = DOM$1.get(this.id);\n        }\n        return this.targetElm;\n      }\n      getWin() {\n        const self = this;\n        if (!self.contentWindow) {\n          const elm = self.iframeElement;\n          if (elm) {\n            self.contentWindow = elm.contentWindow;\n          }\n        }\n        return self.contentWindow;\n      }\n      getDoc() {\n        const self = this;\n        if (!self.contentDocument) {\n          const win = self.getWin();\n          if (win) {\n            self.contentDocument = win.document;\n          }\n        }\n        return self.contentDocument;\n      }\n      getBody() {\n        var _a, _b;\n        const doc = this.getDoc();\n        return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;\n      }\n      convertURL(url, name, elm) {\n        const self = this, getOption = self.options.get;\n        const urlConverterCallback = getUrlConverterCallback(self);\n        if (isFunction(urlConverterCallback)) {\n          return urlConverterCallback.call(self, url, elm, true, name);\n        }\n        if (!getOption('convert_urls') || elm === 'link' || isObject(elm) && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\n          return url;\n        }\n        const urlObject = new URI(url);\n        if (urlObject.protocol !== 'http' && urlObject.protocol !== 'https' && urlObject.protocol !== '') {\n          return url;\n        }\n        if (getOption('relative_urls')) {\n          return self.documentBaseURI.toRelative(url);\n        }\n        url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\n        return url;\n      }\n      addVisual(elm) {\n        addVisual(this, elm);\n      }\n      setEditableRoot(state) {\n        setEditableRoot(this, state);\n      }\n      hasEditableRoot() {\n        return hasEditableRoot(this);\n      }\n      remove() {\n        remove$1(this);\n      }\n      destroy(automatic) {\n        destroy(this, automatic);\n      }\n      uploadImages() {\n        return this.editorUpload.uploadImages();\n      }\n      _scanForImages() {\n        return this.editorUpload.scanForImages();\n      }\n    }\n\n    const DOM = DOMUtils.DOM;\n    const each = Tools.each;\n    let boundGlobalEvents = false;\n    let beforeUnloadDelegate;\n    let editors = [];\n    const globalEventDelegate = e => {\n      const type = e.type;\n      each(EditorManager.get(), editor => {\n        switch (type) {\n        case 'scroll':\n          editor.dispatch('ScrollWindow', e);\n          break;\n        case 'resize':\n          editor.dispatch('ResizeWindow', e);\n          break;\n        }\n      });\n    };\n    const toggleGlobalEvents = state => {\n      if (state !== boundGlobalEvents) {\n        const DOM = DOMUtils.DOM;\n        if (state) {\n          DOM.bind(window, 'resize', globalEventDelegate);\n          DOM.bind(window, 'scroll', globalEventDelegate);\n        } else {\n          DOM.unbind(window, 'resize', globalEventDelegate);\n          DOM.unbind(window, 'scroll', globalEventDelegate);\n        }\n        boundGlobalEvents = state;\n      }\n    };\n    const removeEditorFromList = targetEditor => {\n      const oldEditors = editors;\n      editors = filter$5(editors, editor => {\n        return targetEditor !== editor;\n      });\n      if (EditorManager.activeEditor === targetEditor) {\n        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\n      }\n      if (EditorManager.focusedEditor === targetEditor) {\n        EditorManager.focusedEditor = null;\n      }\n      return oldEditors.length !== editors.length;\n    };\n    const purgeDestroyedEditor = editor => {\n      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\n        removeEditorFromList(editor);\n        editor.unbindAllNativeEvents();\n        editor.destroy(true);\n        editor.removed = true;\n      }\n    };\n    const isQuirksMode = document.compatMode !== 'CSS1Compat';\n    const EditorManager = {\n      ...Observable,\n      baseURI: null,\n      baseURL: null,\n      defaultOptions: {},\n      documentBaseURL: null,\n      suffix: null,\n      majorVersion: '6',\n      minorVersion: '8.6',\n      releaseDate: 'TBD',\n      i18n: I18n,\n      activeEditor: null,\n      focusedEditor: null,\n      setup() {\n        const self = this;\n        let baseURL = '';\n        let suffix = '';\n        let documentBaseURL = URI.getDocumentBaseUrl(document.location);\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n          documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(documentBaseURL)) {\n            documentBaseURL += '/';\n          }\n        }\n        const preInit = window.tinymce || window.tinyMCEPreInit;\n        if (preInit) {\n          baseURL = preInit.base || preInit.baseURL;\n          suffix = preInit.suffix;\n        } else {\n          const scripts = document.getElementsByTagName('script');\n          for (let i = 0; i < scripts.length; i++) {\n            const src = scripts[i].src || '';\n            if (src === '') {\n              continue;\n            }\n            const srcScript = src.substring(src.lastIndexOf('/'));\n            if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n              if (srcScript.indexOf('.min') !== -1) {\n                suffix = '.min';\n              }\n              baseURL = src.substring(0, src.lastIndexOf('/'));\n              break;\n            }\n          }\n          if (!baseURL && document.currentScript) {\n            const src = document.currentScript.src;\n            if (src.indexOf('.min') !== -1) {\n              suffix = '.min';\n            }\n            baseURL = src.substring(0, src.lastIndexOf('/'));\n          }\n        }\n        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n        self.documentBaseURL = documentBaseURL;\n        self.baseURI = new URI(self.baseURL);\n        self.suffix = suffix;\n        setup$w(self);\n      },\n      overrideDefaults(defaultOptions) {\n        const baseUrl = defaultOptions.base_url;\n        if (baseUrl) {\n          this._setBaseUrl(baseUrl);\n        }\n        const suffix = defaultOptions.suffix;\n        if (suffix) {\n          this.suffix = suffix;\n        }\n        this.defaultOptions = defaultOptions;\n        const pluginBaseUrls = defaultOptions.plugin_base_urls;\n        if (pluginBaseUrls !== undefined) {\n          each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\n            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\n          });\n        }\n      },\n      init(options) {\n        const self = this;\n        let result;\n        const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\n        const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\n        const createId = elm => {\n          let id = elm.id;\n          if (!id) {\n            id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\n            elm.setAttribute('id', id);\n          }\n          return id;\n        };\n        const execCallback = name => {\n          const callback = options[name];\n          if (!callback) {\n            return;\n          }\n          return callback.apply(self, []);\n        };\n        const findTargets = options => {\n          if (Env.browser.isIE() || Env.browser.isEdge()) {\n            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers');\n            return [];\n          } else if (isQuirksMode) {\n            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\n            return [];\n          } else if (isString(options.selector)) {\n            return DOM.select(options.selector);\n          } else if (isNonNullable(options.target)) {\n            return [options.target];\n          } else {\n            return [];\n          }\n        };\n        let provideResults = editors => {\n          result = editors;\n        };\n        const initEditors = () => {\n          let initCount = 0;\n          const editors = [];\n          let targets;\n          const createEditor = (id, options, targetElm) => {\n            const editor = new Editor(id, options, self);\n            editors.push(editor);\n            editor.on('init', () => {\n              if (++initCount === targets.length) {\n                provideResults(editors);\n              }\n            });\n            editor.targetElm = editor.targetElm || targetElm;\n            editor.render();\n          };\n          DOM.unbind(window, 'ready', initEditors);\n          execCallback('onpageload');\n          targets = unique$1(findTargets(options));\n          Tools.each(targets, elm => {\n            purgeDestroyedEditor(self.get(elm.id));\n          });\n          targets = Tools.grep(targets, elm => {\n            return !self.get(elm.id);\n          });\n          if (targets.length === 0) {\n            provideResults([]);\n          } else {\n            each(targets, elm => {\n              if (isInvalidInlineTarget(options, elm)) {\n                initError('Could not initialize inline editor on invalid inline target element', elm);\n              } else {\n                createEditor(createId(elm), options, elm);\n              }\n            });\n          }\n        };\n        DOM.bind(window, 'ready', initEditors);\n        return new Promise(resolve => {\n          if (result) {\n            resolve(result);\n          } else {\n            provideResults = editors => {\n              resolve(editors);\n            };\n          }\n        });\n      },\n      get(id) {\n        if (arguments.length === 0) {\n          return editors.slice(0);\n        } else if (isString(id)) {\n          return find$2(editors, editor => {\n            return editor.id === id;\n          }).getOr(null);\n        } else if (isNumber(id)) {\n          return editors[id] ? editors[id] : null;\n        } else {\n          return null;\n        }\n      },\n      add(editor) {\n        const self = this;\n        const existingEditor = self.get(editor.id);\n        if (existingEditor === editor) {\n          return editor;\n        }\n        if (existingEditor === null) {\n          editors.push(editor);\n        }\n        toggleGlobalEvents(true);\n        self.activeEditor = editor;\n        self.dispatch('AddEditor', { editor });\n        if (!beforeUnloadDelegate) {\n          beforeUnloadDelegate = e => {\n            const event = self.dispatch('BeforeUnload');\n            if (event.returnValue) {\n              e.preventDefault();\n              e.returnValue = event.returnValue;\n              return event.returnValue;\n            }\n          };\n          window.addEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        return editor;\n      },\n      createEditor(id, options) {\n        return this.add(new Editor(id, options, this));\n      },\n      remove(selector) {\n        const self = this;\n        let editor;\n        if (!selector) {\n          for (let i = editors.length - 1; i >= 0; i--) {\n            self.remove(editors[i]);\n          }\n          return;\n        }\n        if (isString(selector)) {\n          each(DOM.select(selector), elm => {\n            editor = self.get(elm.id);\n            if (editor) {\n              self.remove(editor);\n            }\n          });\n          return;\n        }\n        editor = selector;\n        if (isNull(self.get(editor.id))) {\n          return null;\n        }\n        if (removeEditorFromList(editor)) {\n          self.dispatch('RemoveEditor', { editor });\n        }\n        if (editors.length === 0) {\n          window.removeEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        editor.remove();\n        toggleGlobalEvents(editors.length > 0);\n        return editor;\n      },\n      execCommand(cmd, ui, value) {\n        var _a;\n        const self = this;\n        const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\n        switch (cmd) {\n        case 'mceAddEditor': {\n            if (!self.get(editorId)) {\n              const editorOptions = value.options;\n              new Editor(editorId, editorOptions, self).render();\n            }\n            return true;\n          }\n        case 'mceRemoveEditor': {\n            const editor = self.get(editorId);\n            if (editor) {\n              editor.remove();\n            }\n            return true;\n          }\n        case 'mceToggleEditor': {\n            const editor = self.get(editorId);\n            if (!editor) {\n              self.execCommand('mceAddEditor', false, value);\n              return true;\n            }\n            if (editor.isHidden()) {\n              editor.show();\n            } else {\n              editor.hide();\n            }\n            return true;\n          }\n        }\n        if (self.activeEditor) {\n          return self.activeEditor.execCommand(cmd, ui, value);\n        }\n        return false;\n      },\n      triggerSave: () => {\n        each(editors, editor => {\n          editor.save();\n        });\n      },\n      addI18n: (code, items) => {\n        I18n.add(code, items);\n      },\n      translate: text => {\n        return I18n.translate(text);\n      },\n      setActive(editor) {\n        const activeEditor = this.activeEditor;\n        if (this.activeEditor !== editor) {\n          if (activeEditor) {\n            activeEditor.dispatch('deactivate', { relatedTarget: editor });\n          }\n          editor.dispatch('activate', { relatedTarget: activeEditor });\n        }\n        this.activeEditor = editor;\n      },\n      _setBaseUrl(baseUrl) {\n        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\n        this.baseURI = new URI(this.baseURL);\n      }\n    };\n    EditorManager.setup();\n\n    const setup = () => {\n      const dataValue = value$2();\n      const FakeClipboardItem = items => ({\n        items,\n        types: keys(items),\n        getType: type => get$a(items, type).getOrUndefined()\n      });\n      const write = data => {\n        dataValue.set(data);\n      };\n      const read = () => dataValue.get().getOrUndefined();\n      const clear = dataValue.clear;\n      return {\n        FakeClipboardItem,\n        write,\n        read,\n        clear\n      };\n    };\n    const FakeClipboard = setup();\n\n    const min = Math.min, max = Math.max, round = Math.round;\n    const relativePosition = (rect, targetRect, rel) => {\n      let x = targetRect.x;\n      let y = targetRect.y;\n      const w = rect.w;\n      const h = rect.h;\n      const targetW = targetRect.w;\n      const targetH = targetRect.h;\n      const relChars = (rel || '').split('');\n      if (relChars[0] === 'b') {\n        y += targetH;\n      }\n      if (relChars[1] === 'r') {\n        x += targetW;\n      }\n      if (relChars[0] === 'c') {\n        y += round(targetH / 2);\n      }\n      if (relChars[1] === 'c') {\n        x += round(targetW / 2);\n      }\n      if (relChars[3] === 'b') {\n        y -= h;\n      }\n      if (relChars[4] === 'r') {\n        x -= w;\n      }\n      if (relChars[3] === 'c') {\n        y -= round(h / 2);\n      }\n      if (relChars[4] === 'c') {\n        x -= round(w / 2);\n      }\n      return create$2(x, y, w, h);\n    };\n    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\n      for (let i = 0; i < rels.length; i++) {\n        const pos = relativePosition(rect, targetRect, rels[i]);\n        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n          return rels[i];\n        }\n      }\n      return null;\n    };\n    const inflate = (rect, w, h) => {\n      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\n    };\n    const intersect = (rect, cropRect) => {\n      const x1 = max(rect.x, cropRect.x);\n      const y1 = max(rect.y, cropRect.y);\n      const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\n      const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\n      if (x2 - x1 < 0 || y2 - y1 < 0) {\n        return null;\n      }\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const clamp = (rect, clampRect, fixedSize) => {\n      let x1 = rect.x;\n      let y1 = rect.y;\n      let x2 = rect.x + rect.w;\n      let y2 = rect.y + rect.h;\n      const cx2 = clampRect.x + clampRect.w;\n      const cy2 = clampRect.y + clampRect.h;\n      const underflowX1 = max(0, clampRect.x - x1);\n      const underflowY1 = max(0, clampRect.y - y1);\n      const overflowX2 = max(0, x2 - cx2);\n      const overflowY2 = max(0, y2 - cy2);\n      x1 += underflowX1;\n      y1 += underflowY1;\n      if (fixedSize) {\n        x2 += underflowX1;\n        y2 += underflowY1;\n        x1 -= overflowX2;\n        y1 -= overflowY2;\n      }\n      x2 -= overflowX2;\n      y2 -= overflowY2;\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const create$2 = (x, y, w, h) => {\n      return {\n        x,\n        y,\n        w,\n        h\n      };\n    };\n    const fromClientRect = clientRect => {\n      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n    };\n    const Rect = {\n      inflate,\n      relativePosition,\n      findBestRelativePosition,\n      intersect,\n      clamp,\n      create: create$2,\n      fromClientRect\n    };\n\n    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {\n      let done = false;\n      let timer = null;\n      const complete = completer => (...args) => {\n        if (!done) {\n          done = true;\n          if (timer !== null) {\n            clearTimeout(timer);\n            timer = null;\n          }\n          completer.apply(null, args);\n        }\n      };\n      const resolve = complete(resolveCb);\n      const reject = complete(rejectCb);\n      const start = (...args) => {\n        if (!done && timer === null) {\n          timer = setTimeout(() => reject.apply(null, args), timeout);\n        }\n      };\n      return {\n        start,\n        resolve,\n        reject\n      };\n    };\n    const create$1 = () => {\n      const tasks = {};\n      const resultFns = {};\n      const resources = {};\n      const load = (id, url) => {\n        const loadErrMsg = `Script at URL \"${ url }\" failed to load`;\n        const runErrMsg = `Script at URL \"${ url }\" did not call \\`tinymce.Resource.add('${ id }', data)\\` within 1 second`;\n        if (tasks[id] !== undefined) {\n          return tasks[id];\n        } else {\n          const task = new Promise((resolve, reject) => {\n            const waiter = awaiter(resolve, reject);\n            resultFns[id] = waiter.resolve;\n            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\n          });\n          tasks[id] = task;\n          return task;\n        }\n      };\n      const add = (id, data) => {\n        if (resultFns[id] !== undefined) {\n          resultFns[id](data);\n          delete resultFns[id];\n        }\n        tasks[id] = Promise.resolve(data);\n        resources[id] = data;\n      };\n      const has = id => {\n        return id in resources;\n      };\n      const unload = id => {\n        delete tasks[id];\n      };\n      const get = id => resources[id];\n      return {\n        load,\n        add,\n        has,\n        get,\n        unload\n      };\n    };\n    const Resource = create$1();\n\n    const create = () => (() => {\n      let data = {};\n      let keys = [];\n      const storage = {\n        getItem: key => {\n          const item = data[key];\n          return item ? item : null;\n        },\n        setItem: (key, value) => {\n          keys.push(key);\n          data[key] = String(value);\n        },\n        key: index => {\n          return keys[index];\n        },\n        removeItem: key => {\n          keys = keys.filter(k => k === key);\n          delete data[key];\n        },\n        clear: () => {\n          keys = [];\n          data = {};\n        },\n        length: 0\n      };\n      Object.defineProperty(storage, 'length', {\n        get: () => keys.length,\n        configurable: false,\n        enumerable: false\n      });\n      return storage;\n    })();\n\n    let localStorage;\n    try {\n      const test = '__storage_test__';\n      localStorage = window.localStorage;\n      localStorage.setItem(test, test);\n      localStorage.removeItem(test);\n    } catch (e) {\n      localStorage = create();\n    }\n    var LocalStorage = localStorage;\n\n    const publicApi = {\n      geom: { Rect },\n      util: {\n        Delay,\n        Tools,\n        VK,\n        URI,\n        EventDispatcher,\n        Observable,\n        I18n,\n        LocalStorage,\n        ImageUploader\n      },\n      dom: {\n        EventUtils,\n        TreeWalker: DomTreeWalker,\n        TextSeeker,\n        DOMUtils,\n        ScriptLoader,\n        RangeUtils,\n        Serializer: DomSerializer,\n        StyleSheetLoader,\n        ControlSelection,\n        BookmarkManager,\n        Selection: EditorSelection,\n        Event: EventUtils.Event\n      },\n      html: {\n        Styles,\n        Entities,\n        Node: AstNode,\n        Schema,\n        DomParser,\n        Writer,\n        Serializer: HtmlSerializer\n      },\n      Env,\n      AddOnManager,\n      Annotator,\n      Formatter,\n      UndoManager,\n      EditorCommands,\n      WindowManager,\n      NotificationManager,\n      EditorObservable,\n      Shortcuts,\n      Editor,\n      FocusManager,\n      EditorManager,\n      DOM: DOMUtils.DOM,\n      ScriptLoader: ScriptLoader.ScriptLoader,\n      PluginManager,\n      ThemeManager,\n      ModelManager,\n      IconManager,\n      Resource,\n      FakeClipboard,\n      trim: Tools.trim,\n      isArray: Tools.isArray,\n      is: Tools.is,\n      toArray: Tools.toArray,\n      makeMap: Tools.makeMap,\n      each: Tools.each,\n      map: Tools.map,\n      grep: Tools.grep,\n      inArray: Tools.inArray,\n      extend: Tools.extend,\n      walk: Tools.walk,\n      resolve: Tools.resolve,\n      explode: Tools.explode,\n      _addCacheSuffix: Tools._addCacheSuffix\n    };\n    const tinymce$1 = Tools.extend(EditorManager, publicApi);\n\n    const exportToModuleLoaders = tinymce => {\n      if (typeof module === 'object') {\n        try {\n          module.exports = tinymce;\n        } catch (_) {\n        }\n      }\n    };\n    const exportToWindowGlobal = tinymce => {\n      window.tinymce = tinymce;\n      window.tinyMCE = tinymce;\n    };\n    exportToWindowGlobal(tinymce$1);\n    exportToModuleLoaders(tinymce$1);\n\n})();\n"],"names":["typeOf$1","x","isEquatableType","sort$1","xs","compareFn","clone","contramap","eqa","f","eq$2","y","tripleEq","eqString","eqArray","len","i","eqSortedArray","eqRecord","kx","ky","q","eqAny","tx","ty","getPrototypeOf$2","hasProto","v","constructor","predicate","_a","typeOf","o","proto","isType$1","type","value","isSimpleType","eq$1","t","a","is$4","isObject","isString","isPlainObject","isArray$1","isNull","isBoolean","isUndefined","isNullable","isNonNullable","isFunction","isNumber","isArrayOf","pred","noop","compose","fa","fb","args","compose1","fbc","fab","constant","identity","tripleEquals","b","curry","fn","initialArgs","restArgs","all","not","die","msg","apply$1","call","never","always","Optional","tag","onNone","onSome","mapper","binder","replacement","thunk","message","worker","nativeSlice","nativeIndexOf","nativePush","rawIndexOf","ts","indexOf$1","r","contains$2","exists","map$3","each$e","eachr","partition$2","pass","fail","filter$5","foldr","acc","foldl","findUntil$1","until","find$2","findIndex$2","flatten","bind$3","forall","reverse","difference","a1","a2","mapToObject","sort","comparator","copy","get$b","head","last$3","from","findMap","arr","unique$1","isDuplicated","keys","hasOwnProperty$1","each$d","obj","props","k","map$2","tupleMap","tuple","objAcc","internalFilter","onTrue","onFalse","bifilter","filter$4","mapToArray","name","values","get$a","key","has$2","hasNonNullableKey","equal$1","eq","stringArray","isArrayLike","isArray","toArray$1","array","l","each$c","cb","s","n","map$1","callback","out","item","index","filter$3","indexOf","reduce","collection","iteratee","accumulator","thisArg","findIndex$1","last$2","cached","called","DeviceType","os","browser","userAgent","mediaMatch","isiPad","isiPhone","isMobile","isTouch","isTablet","isPhone","iOSwebview","isDesktop","firstMatch","regexes","find$1","agent","group","nu$3","detect$5","versionRegexes","cleanedAgent","unknown$2","major","minor","Version","detectBrowser$1","browsers","userAgentData","uaBrand","lcBrand","info","detect$4","candidates","candidate","detectBrowser","version","detectOs","oses","removeFromStart","str","numChars","checkRange","substr","start","removeLeading","prefix","startsWith","contains$1","end","idx","endsWith","suffix","blank","trim$4","lTrim","rTrim","isNotEmpty","isEmpty$3","repeat","count","toInt","radix","num","normalVersionRegex","checkContains","target","uastring","PlatformInfo","edge","chromium","ie","opera","firefox","safari","unknown$1","nu$2","current","isBrowser","Browser","windows","ios","android","linux","macos","solaris","freebsd","chromeos","unknown","nu$1","isOS","OperatingSystem","PlatformDetection","userAgentDataOpt","deviceType","query","platform$4","detect$2","platform$3","browser$3","os$1","windowsPhone","Env","whiteSpaceRegExp$1","trim$3","is$3","makeMap$4","items","delim","map","resolvedItems","hasOwnProperty","extend$3","exts","ext","walk$4","Tools","path","d","url","cacheSuffix","is$2","lhs","rhs","left","equals","lift2","cat","push","oa","ob","lift3","oc","someIf","Global","parts","scope","resolve$2","p","unsafe","getOrDie","actual","getPrototypeOf$1","sandHTMLElement","isPrototypeOf","COMMENT","DOCUMENT","DOCUMENT_FRAGMENT","ELEMENT","TEXT","element","type$1","isType","isComment$1","isHTMLElement$1","isElement$7","isText$b","isDocument$2","isDocumentFragment$1","isTag","e","rawSet","dom","set$3","setAll$1","attrs","get$9","getOpt","has$1","remove$a","hasNone","clone$4","attr","read$4","add$4","id","nu","remove$9","supports","get$8","add$3","clazz","remove$8","toggle$2","add$2","cleanClass","remove$7","toggle$1","result","has","fromHtml$1","html","div","fromDom$2","fromTag","node","fromText","text","SugarElement","docElm","toArray","recurse","cur","is$1","selector","elem","bypassSelector","base","one","e1","e2","contains","d1","d2","owner$1","documentOrOwner","dos","documentElement","defaultView","parent","parentElement","parents$1","isRoot","stop","ret","rawParent","siblings","filterSelf","elements","children$1","prevSibling","nextSibling","prevSiblings","nextSiblings","child$1","cs","firstChild","lastChild","childNodesCount","hasChildNodes","getHead","doc","isShadowRoot","supported","isSupported$1","getRootNode","getStyleContainer","getContentContainer","getShadowRoot","getShadowHost","getOriginalEventTarget","event","el","isOpenShadowHost","composedPath","inBody","ClosestOrAncestor","is","ancestor","ancestor$4","closest$4","test","sibling$1","child","descendant$2","descend","res","ancestor$3","descendant$1","closest$3","closest$2","isEditable$2","assumeEditable","editable","getRaw$1","isSupported","internalSet","property","internalRemove","set$2","setAll","css","get$7","getUnsafeProperty","getRaw","raw","getAllRaw","ruleName","remove$6","reflow","before$3","marker","after$4","sibling","append$1","prepend","wrap$2","wrapper","after$3","append","empty","rogue","remove$5","unwrap","children","fromHtml","fromDom$1","nodes","get$6","set$1","content","docDom","fragment","contentElements","getOuter","container","mkEvent","prevent","kill","fromRawEvent","rawEvent","handle$1","filter","handler","useCapture","wrapped","unbind","bind$2","top","SugarPosition","boxPosition","box","firstDefinedOrZero","absolute","body","win","scrollTop","scrollLeft","clientTop","clientLeft","viewport","get$5","_DOC","to","intoView","alignToTop","get$4","_win","bounds","width","height","getBounds","scroll","visualViewport","descendants$1","descendants","ancestor$2","DomTreeWalker","startNode","rootNode","shallow","startName","siblingName","isNodeType","isRestrictedNode","isElement$6","isHTMLElement","isSVGElement","matchNodeName","lowerCasedName","matchNodeNames","names","lowerCasedNames","nodeName","matchStyleValues","computed","hasAttribute","attrName","hasAttributeValue","attrValue","isBogus$2","isBogusAll$1","isTable$2","hasContentEditableState","isTextareaOrInput","isText$a","isCData","isPi","isComment","isDocument$1","isDocumentFragment","isBr$6","isImg","isContentEditableTrue$3","isContentEditableFalse$b","isTableCell$3","isTableCellOrCaption","isMedia$2","isListItem$2","isDetails","isSummary$1","zeroWidth","nbsp","isZwsp$2","char","removeZwsp","api$1","get","getOption","get$3","set","tableCells","tableSections","textBlocks","listItems$1","lists","wsElements","lazyLookup","lookup","isTable$1","isBr$5","isTextBlock$2","isList","isListItem$1","isTableSection","isTableCell$2","isWsPreserveElement","getLastChildren$1","elm","rawNode","removeTrailingBr","allBrs","brs","createPaddingBr","br","fillWithPaddingBr","trimBlockTrailingBr","schema","lastChildPrevSibling","ZWSP$1","isZwsp$1","trim$2","insert$5","editor","isElement$5","isText$9","isCaretContainerBlock$1","isCaretContainerInline","isCaretContainer$2","hasContent","insertInline$1","before","textNode","parentNode","endsWithCaretContainer$1","startsWithCaretContainer$1","isBeforeInline","pos","isAfterInline","insertBlock","blockName","blockNode","trimBogusBr","lastBr","showCaretContainerBlock","caretContainer","isRangeInCaretContainerBlock","range","isContentEditableTrue$2","isContentEditableFalse$a","isBr$4","isText$8","isInvalidTextElement","isAtomicInline","isTable","isCaretContainer$1","isCaretCandidate$3","isNonUiContentEditableFalse","isUnselectable","isInEditable","root","tempNode","isAtomicContentEditableFalse","isAtomic$1","isEditableCaretCandidate$1","whiteSpaceRegExp","isWhitespaceText","isZwsp","c","isCollapsibleWhitespace$1","isNewLineChar","isNewline","normalize$4","tabSpaces","isStartOfContent","isEndOfContent","tabSpace","normalizedText","hasWhitespacePreserveParent","rootElement","isWhitespace$1","isNamedAnchor","isContent$1","isBookmark","isBogus$1","isBogusAll","hasNonEditableParent","isEmptyNode","targetNode","skipBogus","brCount","walker","isEmpty$2","isNonHtmlElementRootName","isNonHtmlElementRoot","toScopeType","namespaceElements","createNamespaceTracker","scopes","peek","currentScope","transparentBlockAttr","elementNames","makeSelectorFromSchemaMap","ns","updateTransparent","blocksSelector","transparent","updateBlockStateOnChildren","transparentSelector","trimEdge","leftSide","childPropertyName","split$2","parentElm","splitElm","beforeFragment","afterFragment","splitInvalidChildren","transparentBlocks","blocksElements","isBlock","transparentBlock","parentBlock","invalidChildren","stateScope","unwrapInvalidChildren","isTransparentBlock","block","isTransparentInline","updateChildren","updateElement","isTransparentElement","updateCaret","caretParent","parents","hasBlockAttr","isTransparentElementName","isTransparentAstBlock","browser$2","firstElement","getTableCaptionDeltaY","caption","bodyTop","captionTop","captionHeight","hasChild","getPos","rootElm","offsetParent","castOffsetParent","StyleSheetLoader","documentOrShadowRoot","settings","idCount","loadedStates","edos","_setReferrerPolicy","referrerPolicy","_setContentCssCors","contentCssCors","addStyle","removeStyle","styleContainer","getOrCreateState","load","success","failure","link","urlWithSuffix","state","resolve","callbacks","status","passed","failed","linkElem","loadRawCss","styleElem","loadAll","urls","results","unload","instance","referenceElement","rootDom","sl","isSpan","isInlineContent","surroundedByInlineContent","prev","next","prevIsInline","nextIsInline","isBookmarkNode$2","isKeepTextNode","isKeepElement","isDocument","trimNode","currentChildren","makeMap$3","attrsCharsRegExp","textCharsRegExp","rawCharsRegExp","entityRegExp","asciiMap","baseEntities","reverseEntities","nativeDecode","buildEntitiesLookup","itemList","chr","entity","namedEntities","encodeRaw","encodeAllRaw","encodeNumeric","encodeNamed","entities","resolveEntities","Entities","entitiesMap","encodeNamedAndNumeric","encodeCustomNamed","nameMap","numeric","split$1","patternToRegExp","parseCustomElementsRules","customElementRegExp","rule","matches","inline","cloneName","getElementSetsAsStrings","globalAttributes","blockContent","phrasingContent","transparentContent","flowContent","makeSchema","addElement","attributes","add","childNames","ni","allAttributes","addAttrs","schemaItem","prefixToOperation","parseValidChildrenRules","childRuleRegExp","operation","validChildren","parseValidElementsAttrDataIntoElement","attrData","targetElement","attrRuleRegExp","hasPatternsRegExp","attributesOrder","attrType","attrPrefix","attrPattern","cloneAttributesInto","parseValidElementsRules","globalElement","validElements","elementRuleRegExp","elementName","outputName","attrsPrefix","mapCache","makeMap$2","each$b","extend$2","explode$2","createMap","defaultValue","extendWith","getTextRootBlockElements","compileElementMap","mode","styles","Schema","patternElements","customElementsMap","specialElements","createLookupTable","option","newValue","schemaType","schemaItems","validStyles","invalidStyles","validClasses","whitespaceElementsMap","selfClosingElementsMap","voidElementsMap","boolAttrMap","nonEmptyOrMoveCaretBeforeOnEnter","nonEmptyElementsMap","moveCaretBeforeOnEnterElementsMap","headings","textBlockElementsMap","blockElementsMap","textInlineElementsMap","transparentElementsMap","wrapBlockElementsMap","addValidElements","aliasName","patternElement","setValidElements","addCustomElements","customElements","customRule","elmName","addValidChildren","getElementRule","_val","getValidStyles","getInvalidStyles","getValidClasses","getBoolAttrs","getBlockElements","getTextBlockElements","getTextInlineElements","getVoidElements","getSelfClosingElements","getNonEmptyElements","getMoveCaretBeforeOnEnterElements","getWhitespaceElements","getTransparentElements","getWrapBlockElements","getSpecialElements","isValidChild","isValid","attrPatterns","isInline","isWrapper","getCustomElements","hexColour","normalizeHex","hex","toHex","component","fromRgba","rgbaColour","rgbRegex","rgbaRegex","red","green","blue","alpha","fromStringValues","g","fromString","rgbaString","rgbMatch","rgbaMatch","toString","rgba","rgbaToHexString","color","h","Styles","urlOrStrRegExp","styleRegExp","trimRightRegExp","encodingLookup","invisibleChar","encodingItems","self","isEncoded","urlConverter","urlConverterScope","compress","noJoin","right","bottom","canCompress","compress2","encode","decode","keepSlashes","decodeSingleHexSequence","escSeq","decodeHexSequences","processUrl","match","url2","url3","str2","scriptUrl","serializeStyles","elemName","validStyleList","styleList","styleMap","deprecated","isNativeEvent","hasIsDefaultPrevented","needsNormalizing","clone$3","originalEvent","data","keyArg","normalize$3","fallbackTarget","eventExpandoPrefix","mouseEventRe","addEvent","capture","removeEvent","isMouseEvent","fix","eventDoc","mouseEvent","bindOnReady","eventUtils","isDocReady","readyHandler","EventUtils","callbackList","defaultNativeHandler","evt","namesList","nativeHandler","fakeName","eventMap","ci","newCallbackList","each$a","grep","internalStyleName","numericalCssMap","legacySetAttribute","camelCaseToHyphens","findNodeIndex","normalized","lastNodeType","nodeType","updateInternalStyleAttr","rawValue","convertStyleToString","cssValue","cssName","applyStyle$1","$elm","normalizedName","setupAttrHooks","getContext","keepValues","keepUrlHook","sugarElm","internalName","attrHooks","DOMUtils","addedStyles","files","counter","stdMode","boxModel","styleSheetLoader","boundEvents","events","_get","getAttrib","defaultVal","hook","getAttribs","setAttrib","run","val","originalValue","deep","getRoot","getViewPort","argWin","vp","getPos$1","setStyle","setStyles","stylesArg","getStyle","getSize","w","getRect","size","elms","getParents","collect","resolvedRoot","selectorVal","getParent","_findSib","func","getNext","getPrev","isParentNode","select","_b","context","setAttribs","setHTML","create","newElm","createHTML","outHtml","createFragment","frag","remove","keepChildren","$node","removeAllAttribs","parseStyle","cssText","serializeStyle","styleElm","loadCSS","toggleClass","cls","classes","addClass","removeClass","hasClass","show","hide","isHidden","uniqueId","getOuterHTML","setOuterHTML","insertAfter","reference","referenceNode","replace","oldElm","replacee","rename","attrNode","findCommonAncestor","ps","pe","isNonEmptyElement","isEmpty","options","whitespaceElements","nonEmptyElements","bogusVal","createRng","split","replacementElm","bind","rv","boundTarget","boundName","boundFunc","dispatch","fire","getContentEditable","contentEditable","_","DOM$b","QUEUED","LOADING","LOADED","FAILED","ScriptLoader","reject","cleanup","done","error","queue","scripts","execCallbacks","processResults","failures","reason","processQueue","nextQueuedItem","uniqueScripts","Cell","initial","firstIndex","isRaw","isTokenised","currentCode","getLanguageData","I18n","newCode","code","langData","lcNames","translation","lcName","getLangData","textStr","removeContext","substitued","$1","$2","dir","AddOnManager","_listeners","runListeners","matchedListeners","listener","isLoaded","isAdded","loadLanguagePack","languages","language","wrappedLanguages","requireLangPack","waitFor","addOn","createUrl","baseUrl","dep","addOnUrl","urlString","singleton","doRevoke","subject","revoke","repeatable","delay","intervalId","functionToRepeat","value$2","first$1","rate","timer","last$1","cancel","annotation","dataAnnotation","dataAnnotationId","dataAnnotationActive","dataAnnotationClasses","dataAnnotationAttributes","isRoot$1","identify","annotationName","rng","an","newStart","uid","findMarkers","isAnnotation","isBogusElement","descendant","findAll","markers","directory","m","nodesAlready","setup$y","registry","changeCallbacks","initData","withCallbacks","updateCallbacks","callbackMap","outputData","fireCallbacks","fireNoAnnotation","toggleActiveAttr","onNodeChange","annotations","setup$x","dataAnnotation$1","identifyParserNode","removeDirectAnnotation","customAttrNames","customClasses","classList","newClassList","create$c","unique","generate$1","time","random","remove$4","clone$2","original","isDeep","shallow$1","deep$1","shallowAs","mutate","TextWalker","isBoundary","walk","direction","TextSeeker","isBlockBoundary","offset","process","newOffset","round$2","clone$1","rect","collapse","toStart","isEqual","rect1","rect2","isValidOverflow","overflowY","isAbove$1","halfHeight","isBelow$1","containsXY","clientX","clientY","boundingClientRectFromRects","rects","prevRect","distanceToRectEdgeFromXY","cx","cy","overlapY","r1","r2","clamp$2","min","max","getSelectedNode","startContainer","startOffset","getNode$1","childNodes","safeOffset","getNodeUnsafe","extendingChars","isExtendingChar","ch","or","and","isElement$4","isCaretCandidate$2","isBlock$2","isFloated","isValidElementCaretCandidate","isNotPre","isText$7","isBr$3","nodeIndex$1","resolveIndex$1","createRange$1","isWhiteSpace$1","isRange","isHiddenWhiteSpaceRange","getBrClientRect","brNode","nbsp$1","clientRect","getBoundingClientRectWebKitText","sc","ec","so","eo","newRng","getBoundingClientRect$1","isZeroRect","clientRects","collapseAndInflateWidth","newClientRect","getCaretPositionClientRects","caretPosition","addUniqueAndValidRect","addCharacterOffset","beforeNode","CaretPosition","isAtStart","isAtEnd","toRange","getClientRects","isVisible","getNode","pos1","pos2","trimEmptyTextNode$1","insertNode","insertFragment","rangeInsertNode","isText$6","isBogus","nodeIndex","normalizedParent","getChildNodes","normalizedTextOffset","equal","normalizedNodeIndex","numTextFragments","createPathItem","parentsUntil$1","create$b","outputOffset","resolvePathItem","findTextPosition","targetOffset","dataLen","resolve$1","paths","nodeOffset","isContentEditableFalse$9","getNormalizedTextOffset$1","trim","trimmedOffset","getPoint","point","after","getLocation","selection","forward","fakeCaret","findIndex","moveEndPoint$1","normalizeTableCellSelection","findSibling","findAdjacentContentEditableFalseElm","getOffsetBookmark","getCaretBookmark","getRangeBookmark","createBookmarkSpan","filled","getPersistentBookmark","collapsed","rng2","endBookmarkNode","startBookmarkNode","getBookmark$2","getUndoBookmark","value$1","applyHelper","constHelper","outputHelper","output","_onError","onValue","Result","onError","_onValue","optional","err","Adt","cases","constructors","adt","acase","keys$1","argLength","foldArgs","branches","branchKeys","reqKey","label","partition$1","errors","isInlinePattern","pattern","isBlockPattern","normalizePattern","formatOrCmd","onFormat","onCommand","formats","format","cmd","command","commandValue","getBlockPatterns","patterns","getInlinePatterns","createPatternSet","dynamicPatternsLookup","fromRawPatterns","fromRawPatternsLookup","lookupFn","ctx","rawPatterns","deviceDetection$1","DOM$a","getHash","isRegExp","stringOrObjectProcessor","bodyOptionProcessor","valid","bodyObj","register$7","registerOption","isInline$1","getIframeAttrs","getDocType","getDocumentBaseUrl","getBodyId","getBodyClass","getContentSecurityPolicy","shouldPutBrInPre$1","getForcedRootBlock","getForcedRootBlockAttrs","getNewlineBehavior","getBrNewLineSelector","getNoNewLineSelector","shouldKeepStyles","shouldEndContainerOnEmptyBlock","isAutomaticUploadsEnabled","shouldReuseFileName","shouldReplaceBlobUris","getIconPackName","getIconsUrl","getImageUploadUrl","getImageUploadBasePath","getImagesUploadCredentials","getImagesUploadHandler","shouldUseContentCssCors","getReferrerPolicy","getLanguageCode","getLanguageUrl","shouldIndentUseMargin","getIndentation","getContentCss","getContentStyle","getFontCss","getDirectionality","getInlineBoundarySelector","getObjectResizing","getResizeImgProportional","getPlaceholder","getEventRoot","getServiceMessage","getTheme","getThemeUrl","getModel","getModelUrl","isInlineBoundariesEnabled","getFormats","getPreviewStyles","canFormatEmptyLines","getFormatNoneditableSelector","getCustomUiSelector","hasHiddenInput","shouldPatchSubmit","shouldAddFormSubmitTrigger","shouldAddUnloadTrigger","getCustomUndoRedoLevels","shouldDisableNodeChange","isReadOnly$1","hasEditableRoot$1","hasContentCssCors","getPlugins","getExternalPlugins$1","shouldBlockUnsupportedDrop","isVisualAidsEnabled","getVisualAidsTableClass","getVisualAidsAnchorClass","getIframeAriaText","getSetupCallback","getInitInstanceCallback","getUrlConverterCallback","getAutoFocus","shouldBrowserSpellcheck","getProtect","shouldPasteBlockDrop","shouldPasteDataImages","getPastePreProcess","getPastePostProcess","getNewDocumentContent","getPasteWebkitStyles","shouldPasteRemoveWebKitStyles","shouldPasteMergeFormats","isSmartPasteEnabled","isPasteAsTextEnabled","getPasteTabSpaces","shouldAllowHtmlDataUrls","getTextPatterns","getTextPatternsLookup","getNonEditableClass","getEditableClass","getNonEditableRegExps","shouldPreserveCData","shouldHighlightOnFocus","shouldSanitizeXss","shouldUseDocumentWrite","hasTextPatternsLookup","getFontStyleValues","getFontSizeClasses","isEncodingXml","getAllowedImageFileTypes","hasTableTabNavigation","getDetailsInitialState","getDetailsSerializedState","shouldForceHexColor","shouldSandboxIframes","isElement$3","isText$5","removeNode$1","trimCount","trimmedText","deleteZwspChars","removeUnchanged","remove$3","removeTextAndReposition","removeElementAndReposition","newPosition","removeTextCaretContainer","removeElementCaretContainer","removeAndReposition","caretContainerNode","isContentEditableFalse$8","isMedia$1","isTableCell$1","inlineFakeCaretSelector","getAbsoluteClientRect","scrollX","scrollY","rootRect","margin","trimInlineCaretContainers","fakeCaretTargetNodes","FakeCaret","hasFocus","lastVisualCaret","cursorInterval","caretBlock","caret","startBlink","isInlineFakeCaretTarget","caretState","isFakeCaretTableBrowser","isFakeCaretTarget","isContentEditableTrue$1","isContentEditableFalse$7","isMedia","isBlockLike","isCaretContainer","isCaretContainerBlock","isElement$2","isText$4","isCaretCandidate$1","isForwards","isBackwards","skipCaretContainers","findNode","predicateFn","isCefOrCaretContainer","getEditingHost","isCETrue","getParentBlock$3","isInSameBlock","caretPosition1","caretPosition2","getChildNodeAtRelativeOffset","relativeOffset","beforeAfter","isNodesInSameBlock","node1","node2","lean","before$2","after$2","normalizeRange","leanLeft","leanRight","location","getRelativeCefElm","getNormalizedRangeEndPoint","normalizedRange","getElementFromPosition","getElementFromPrevPosition","getVisualCaretPosition","walkFn","isMoveInsideSameBlock","inSameBlock","HDirection","isContentEditableFalse$6","isText$3","isElement$1","isBr$2","isCaretCandidate","isAtomic","isEditableCaretCandidate","getParents$3","nodeAtIndex","getCaretCandidatePosition","moveForwardFromBr","nextNode","findCaretPosition$1","startPos","innerNode","rootContentEditableFalseElm","CaretWalker","walkToPositionIn","position","fromPosition","afterElement","isBeforeOrStart","isAfterOrEnd","isBeforeAfterSameElement","isAtBr","shouldSkipPosition","navigate","navigateIgnore","ignoreFilter","positionIn","nextPosition","prevPosition","firstPositionIn","lastPositionIn","CARET_ID","isCaretNode","getParentCaretContainer","currentNode","isStringPathBookmark","bookmark","isRangeBookmark","isIdBookmark","isIndexBookmark","isPathBookmark","isForwardBookmark","addBogus","resolveCaretPositionBookmark","endPos","insertZwsp","isEmpty$1","tryFindRangePosition","padEmptyCaretContainer","setEndPoint","isValidTextNode","restoreEndPoint","markerParent","keep","otherMarker","resolvePaths","resolveId","spos","epos","resolveIndex","getBookmark$1","moveToBookmark","isBookmarkNode$1","isNbsp","expected","isWhiteSpace","isContent","getRanges$1","ranges","getSelectedNodes","hasMultipleRanges","getCellsFromRanges","getCellsFromElement","getCellsFromElementOrRanges","selectedCells","getCellsFromEditor","getClosestTable","cell","getStartNode","getEndNode","getFirstChildren","getLastChildren","hasAllContentsSelected","endNode","moveEndPoint","hasAnyRanges","sel","runOnRanges","executor","fakeSelectionNodes","fakeNodeRng","preserve","fillBookmark","isNode","isElementNode$1","isElementDirectlySelected","selectedAttr","preserveSelection","action","shouldMoveStart","selectedNodeBeforeAction","isSelectedBeforeNodeNoneditable","moveStartToNearestText","selectedNode","isWhiteSpaceNode$1","getNonWhiteSpaceSibling","inc","nextName","isTextBlock$1","ed","allowSpaces","isEmptyTextNode$1","isWrapNoneditableTarget","baseDataSelector","formatNoneditableSelector","isWrappableNoneditable","replaceVars","vars","isEq$5","str1","normalizeStyleValue","strValue","style","getTextDecoration","decoration","getParents$2","isFormatPredicate","formatName","isVariableFormatName","isVariableValue","field","fieldValues","areSimilarFormats","otherFormatName","validKeys","filterObj","validKey","fmt1","filteredFmt1","fmt2","filteredFmt2","isBlockFormat","isWrappingBlockFormat","isNonWrappingBlockFormat","isSelectorFormat","isInlineFormat","isMixedFormat","shouldExpandToSelector","getEmptyCaretContainers","isCaretContainerEmpty","isEmptyCaretFormatElement","isBookmarkNode","getParents$1","isWhiteSpaceNode","isTextBlock","isBogusBr","findParentContentEditable","walkText","findSpace","findContent","findWordEndPoint","includeTrailingSpaces","lastTextNode","textSeeker","textOffset","findSelectorEndPoint","formatList","curFormat","findBlockEndPoint","scopeRoot","isAtBlockBoundary$1","findParentContainer","isSelfOrParentBookmark","expandRng","includeTrailingSpace","endContainer","endOffset","walk$3","exclude","firstNode","lastNode","collectSiblings","findEndPoint","walkBoundary","startPoint","endPoint","validBlocks","isZeroWidth","wrapName","applyWordGrab","applyAnnotation","masterUId","decorate","directAnnotation","otherData","attributeNames","makeAnnotation","eDoc","master","annotate","newWrappers","finishWrapper","getOrOpenWrapper","processElements","elems","processElement","processNodes","annotateWithBookmark","initialRng","hasFakeSelection","masterUid","selectionRng","Annotator","changes","removeAnnotations","BookmarkManager","isXYWithinRange","firePreProcess","firePostProcess","fireRemove","fireDetach","fireSwitchMode","fireObjectResizeStart","origin","fireObjectResized","firePreInit","firePostRender","fireInit","firePlaceholderToggle","fireError","errorType","fireFormatApply","fireFormatRemove","fireBeforeSetContent","fireSetContent","fireBeforeGetContent","fireGetContent","fireAutocompleterStart","fireAutocompleterUpdate","fireAutocompleterEnd","firePastePreProcess","internal","firePastePostProcess","firePastePlainTextToggle","fireEditableRootStateChange","VK","elementSelectionAttr","controlElmSelector","abs","round$1","resizeHandles","isTouchEvent","ControlSelection","editableDoc","rootDocument","selectedElm","selectedElmGhost","resizeHelper","selectedHandle","resizeBackdrop","startX","startY","selectedElmX","selectedElmY","startW","startH","ratio","resizeStarted","startScrollWidth","startScrollHeight","isImage","isEventOnImageOutsideRange","touch","contextMenuSelectImage","getResizeTargets","isResizable","createGhostElement","setSizeProp","targets","setGhostElmSize","ghostElm","resizeGhostElement","deltaX","deltaY","proportional","resizeHelperX","resizeHelperY","endGhostResize","wasResizeStarted","showResizeRect","targetElm","unbindResizeHandleEvents","targetWidth","targetHeight","hideResizeRect","handle","startDrag","handleElm","throttledShowResizeRect","removeSelected","isChildOrEqual","updateResizeRect","controlElm","selectedValue","img","disableGeckoResize","startElm","setStart","situ","setFinish","relativeToNative","startSitu","finishSitu","exactToNative","soffset","finish","foffset","adt$3","fromRange","getRanges","doDiagnose","rev","diagnose","SimRange","caretPositionFromPoint","caretRangeFromPoint","availableSearch","fromPoint$1","adt$2","cata","onBefore","onOn","onAfter","getStart$2","before$1","on","after$1","Situ","adt$1","exactFromRange","simRange","getStart$1","_finishSitu","_soffset","_finish","_foffset","domRange","relative","exact","getWin","SimSelection","beforeSpecial","name$1","preprocessRelative","preprocessExact","preprocess","fromElements","toNative","getDomRange","filtered","getAtPoint","fromPoint","isEq$4","rng1","findParent","hasParent$1","hasParentWithName","isCeFalseCaretContainer","hasBrBeforeAfter","isPrevNode","hasContentEditableFalseParent","findTextNodeRelative","isAfterNode","lastInlineElement","parentBlockContainer","normalizeEndPoint","directionLeft","normalize$2","normRng","splitText","newContainer","RangeUtils","rangeLike","newRange","normalizedRng","api","getOffset","aggregate","properties","cumulativeInclusions","get$2","getDocument","walkUp","navigation","rest","pathTo","Navigation","find","frames","loc","excludeFromDescend","fireScrollIntoViewEvent","fireAfterScrollIntoViewEvent","last","markerInfo","cleanupFun","createMarker$1","span","elementMarker","withMarker","preserveWith","_s","_e","applyWithMarker","withScrollEvents","withElement","startElement","endElement","scrollToMarker","viewHeight","intoWindowIfNeeded","viewportBottom","markerTop","markerBottom","largerThanViewport","intoWindow","intoFrame","frameViewHeight","op","viewportBounds","rangeIntoWindow","elementIntoWindow","rangeIntoFrame","elementIntoFrame","scrollElementIntoView","scrollRangeIntoView","focus$1","preventScroll","hasFocus$1","active$1","search","clamp$1","normalizeRng","isOrContains","isRngInRoot","shouldStore","nativeRangeToSelectionRange","readRange","getBookmark","validate","bookmarkToNativeRng","store","newBookmark","getRng","restore","FocusManager","className","wrappedSetTimeout","wrappedSetInterval","Delay","isManualNodeChange","registerPageMouseUp","throttledStore","mouseUpPage","registerMouseUp","registerEditorEvents","register$6","documentFocusInHandler","DOM$9","isEditorUIElement","isEditorContentAreaElement","isUIElement","customSelector","getActiveElement","registerEvents$1","editorManager","toggleContentAreaOnFocus","contentArea","focusedEditor","activeEditor","unregisterDocumentEvents","setup$w","getContentEditableHost","getCollapsedNode","getFocusInElement","normalizeSelection","caretPos","focusBody","hasElementFocus","hasIframeFocus","hasInlineFocus","rawBody","hasUiFocus","hasEditorOrUiFocus","focusEditor","bookmarkRng","contentEditableHost","activateEditor","focus","skipFocus","isEditableRange","getEndpointElement","real","getStart","getEnd$1","skipEmptyTextNodes","forwards","orig","getSelectedBlocks","endElm","selectedBlocks","processRanges","getEnd","isTextNodeWithCursorPosition","isContentEditableFalse$5","elementsWithCursorPosition","isCursorPosition","first","descendantRtl","autocompleteSelector","create$9","findIn","detect$1","remove$2","typeLookup","walk$2","isEmptyTextNode","AstNode","selfAttrs","cloneAttrs","selfAttr","refNode","whitespace","unescapedTextParents","containsZwsp","getTemporaryNodeSelector","tempAttrs","getTemporaryNodes","createZwspCommentWalker","createUnescapedZwspTextWalker","hasZwspComment","hasUnescapedZwspText","hasTemporaryNode","trimTemporaryNodes","emptyAllNodeValuesInWalker","curr","emptyZwspComments","emptyUnescapedZwspTexts","trim$1","conditionalTrims","trimmed","cloned","condition","cleanupBogusElements","bogusElements","cleanupInputNames","inputs","input","trimEmptyContents","emptyRegExp","getPlainTextContent","offscreenDiv","getContentFromBody","getContentInternal","makeMap$1","Writer","indent","indentBefore","indentAfter","htmlOutput","HtmlSerializer","writer","handlers","sortedAttrs","elementRule","nonInheritableStyles","shorthandStyleProps","getStyleProps","isNonInheritableStyle","hasInheritableStyles","getLonghandStyleProps","prop","hasStyleConflict","nodeStyleProps","parentNodeStyleProps","valueMismatch","nodeValue","parentValue","nodeStyleProp","propExists","longhandProps","isChar","delta","isBeforeSpace","isAfterSpace","isEmptyText","matchesElementPosition","isImageBlock","isCefNode","isBeforeImageBlock","isAfterImageBlock","isBeforeMedia","isAfterMedia","isBeforeTable","isAfterTable","isBeforeContentEditableFalse","isAfterContentEditableFalse","dropLast","parentsUntil","parentsAndSelf","navigateIgnoreEmptyTextNodes","isBlock$1","getClosestBlock$1","isAtBeforeAfterBlockBoundary","newPos","fromBlock","isAtBlockBoundary","isAtStartOfBlock","isAtEndOfBlock","isBeforeBlock","isAfterBlock","isBr$1","findBr","parentBlocks","isBeforeBr$1","isAfterBr","findPreviousBr","findNextBr","isInMiddleOfText","getClosestBlock","hasSpaceBefore","hasSpaceAfter","isPreValue","isInPre","isAtBeginningOfBody","isAtEndOfBody","isAtLineBoundary","isCefBlock","isSiblingCefBlock","isBeforeCefBlock","nextPos","isNextCefBlock","isAfterCefBlock","prevPos","isPrevCefBlock","needsToHaveNbsp","needsToBeNbspLeft","needsToBeNbspRight","needsToBeNbsp","isNbspAt","isWhiteSpaceAt","hasNbsp","normalizeNbspMiddle","chars","normalizeNbspAtStart","makeNbsp","firstPos","normalizeNbspInMiddleOfTextNode","newText","normalizeNbspAtEnd","lastPos","normalizeNbsps","normalizeNbspsInEditor","normalize$1","normalizeWhitespaceAfter","whitespaceCount","normalizeWhitespaceBefore","mergeTextNodes","prevNode","normalizeWhitespace","mergeToPrev","whitespaceOffset","newNode","removeNode","needsReposition","reposition","beforeOrStartOf","afterOrEndOf","getPreviousSiblingCaretPosition","getNextSiblingCaretPosition","findCaretPositionBackwardsFromElm","findCaretPositionForwardsFromElm","findCaretPositionBackwards","findCaretPositionForward","findCaretPosition","findCaretPosOutsideElmAfterDelete","setSelection$1","eqRawNode","paddEmptyBlock","preserveEmptyCaret","deleteNormalized","afterDeletePosOpt","prevTextOpt","nextTextOpt","isInlineElement","deleteElement$2","moveCaret","afterDeletePos","normalizedAfterDeletePos","paddPos","strongRtl","hasStrongRtl","isInlineTarget","isRtl","findInlineParents","findRootInline","hasSameParentBlock","block1","block2","isAtZwsp","normalizePosition","normalizeForwards","normalizeBackwards","execCommandIgnoreInputEvents","inputBlocker","execEditorDeleteCommand","execNativeDeleteCommand","execNativeForwardDeleteCommand","isBeforeRoot","isTextBlockOrListItem","getParentBlock$2","paddEmptyBody","moveSelection","willDeleteLastPositionInElement","fromPos","normalizedFirstPos","normalizedLastPos","normalizedFromPos","freefallRtl","deleteRangeContents","lastBlock","additionalCleanupNodes","ancestor$1","isRootFromElement","getTableCells","table","getTable$1","selectionInTableWithNestedTable","details","startTable","endTable","isStartTableParentOfEndTable","isEndTableParentOfStartTable","adjustQuirksInDetails","getTableDetailsFromRange","isStartInTable","isEndInTable","isSameTable","tableCellRng","tableSelection","cells","deleteAction","getClosestCell$1","isExpandedCellRng","cellRng","getTableFromCellRng","startParentTable","endParentTable","isSingleCellTable","rows","getCellRng","startCell","endCell","getCellRangeFromStartTable","getCellRangeFromEndTable","getTableSelectionFromCellRng","getTableSelections","selectionDetails","sameTableSelection","startTableSelection","endTableSelection","getCellIndex","getSelectedCells","startIndex","endIndex","isSingleCellTableContentSelected","optCellRng","unselectCells","otherContentRng","handleSingleTable","handleMultiTable","startTableSelectedCells","endTableSelectedCells","getActionFromRange","cleanCells","getOutsideBlock","handleEmptyBlock","startInTable","emptyBlock","deleteContentInsideCell","isFirstCellInSelection","insideTableRng","deleteCellContents","collapseAndRestoreCellSelection","emptySingleTableCells","outsideDetails","editorRng","cellsToClean","outsideBlock","endPointCell","emptyMultiTableCells","startTableCells","endTableCells","betweenRng","startTableCellsToClean","endTableCellsToClean","deleteTableElement","deleteCellRange","deleteCaptionRange","emptyElement","deleteTableRange","getParentCaption","deleteRange$3","getParentCell","deleteBetweenCells","fromCell","toCell","isDeleteOfLastCharPos","fromCaption","emptyCaretCaption","validateCaretCaption","toCaption","deleteCaretInsideCaption","deleteCaretCells","deleteCaretCaption","isNearTable","isBeforeOrAfterTable","deleteCaret$3","backspaceDelete$a","getContentEditableRoot$1","internalAttributesPrefixes","each$9","ElementUtils","internalAttributes","compare","attribs","isAttributeInternal","compareObjects","obj1","obj2","attributeName","isHeading","isSummary","traverse","matchNode$1","nodeFilters","attributeFilters","nl","ai","al","findMatchingNodes","childNode","runFilters","matchRecord","filteringAttributes","filter$2","paddEmptyNode","astNode","isPaddedWithNbsp","hasOnlyChild","isPadded","isLineBreakNode","findClosestEditingHost","editableNode","removeOrUnwrapInvalidNode","originalNodeParent","cleanInvalidNodes","onCreate","textBlockElements","nonSplittableElements","fixed","isSplittableElement","newParent","isInvalid","hasClosest","parentName","createRange","normalizeBlockSelectionRange","newEndPos","normalize","hasOnlyOneChild$1","isPaddingNode","isPaddedEmptyBlock","isEmptyFragmentElement","isListFragment","cleanupDomFragment","domFragment","toDomFragment","serializer","listItems","isPadding","isListItemPadded","isEmptyOrPadded","trimListItems","getParentLi","isParentBlockLi","getSplit","beforeRng","afterRng","findFirstIn","newCaretPos","findLastOf","insertMiddle","li","insertBefore$2","insertAfter$2","insertAtCaret$1","liTarget","liElms","BEGINNING","END","isAt","caretWalker","newPosNode","mergeableWrappedElements","shouldPasteContentOnly","isPastingSingleElement","isWrappedElement","isContentEditable","isPastingInTheSameBlockTag","isPastingInContentEditable","isTableCell","isTableCellContentSelected","validInsertion","trimBrsFromTableCell","reduceInlineTextElements","merge","textInlineElements","elementUtils","markFragmentElements","unmarkFragmentElements","isPartOfFragment","canHaveChildren","moveSelectionToMarker","_c","nextRng","parentEditableElm","findNextCaretRng","isCell","deleteSelectedContent","findMarkerNode","markerNode","notHeadingsInSummary","insertHtmlAtCaret","parser","bookmarkHtml","caretElement","parserArgs","editingHost","toExtract","isTreeNode","setEditorHtml","noSelection","setContentString","padd","forcedRootBlockName","trimmedHtml","setContentTree","setContentInternal","ensureIsRoot","transform","transformed","closest$1","isEq$3","matchesUnInheritedFormatSelector","matchParents","similar","matchedNode","matchNode","matchName","matchItems","itemName","matchAttributes","expectedValue","isEmptyValue","match$2","matchAll","matchedFormatNames","checkedMap","closest","rawElm","canApply","matchAllOnNode","formatNames","matchSimilar","ZWSP","importNode","ownerDocument","findFirstTextNode","createCaretContainer","fill","trimZwspFromCaretContainer","removeCaretContainerNode","removeCaretContainer","insertCaretContainerNode","formatNode","appendNode","insertFormatNodesIntoCaretContainer","formatNodes","innerMostFormatNode","cleanFormatNode","formatter","validFormats","matchedFormats","fmtName","clonedFormatNode","applyCaretFormat","wordcharRegex","removeCaretFormat","hasContentAfter","expandedRng","parentsAfter","newCaretContainer","cleanedFormatNode","caretTextNode","disableCaretContainer","keyCode","endsWithNbsp","setup$v","createCaretFormat","innerMost","replaceWithCaretFormat","createCaretFormatAtStart$1","isFormatElement","inlineElements","postProcessHooks","isPre","addPostProcessHook","postProcess$1","hasPreSibling","pre","blocks","joinPre","pre1","pre2","sPre2","preBlocks","listItemStyles","hasListStyles","fmt","findExpandedListItemFormat","getExpandedListItemFormat","isRngStartAtStartOfElement","isRngEndAtEndOfElement","isEditableListItem","getFullySelectedBlocks","middle","getFullySelectedListItems","getPartiallySelectedListItems","each$8","isElementNode","findElementSibling","mergeSiblingsNodes","isPrevEditable","isNextEditable","tmpSibling","mergeSiblings","clearChildStyles","_value","processChildElements","unwrapEmptySpan","hasStyle","applyStyle","removeResult","MCE_ATTR_RE","each$7","isEq$2","isTableCellOrRow","isChildOfInlineParent","getContainer","lastIdx","normalizeTableSelection","wrap$1","wrapWithSiblings","isColorFormatAndAnchor","rootBlockElm","forcedRootBlock","processFormatAttrOrStyle","removeEmptyStyleAttributeIfNeeded","removeStyles","compareNode","stylesModified","styleName","styleValue","normalizedStyleValue","removeListStyleFormats","liFmt","removeNodeFormatInternal","preserveAttributes","attrsToPreserve","currentValue","valueOut","findFormatRoot","formatRoot","removeNodeFormatFromClone","newName","wrapAndSplit","lastClone","firstClone","formatRootParent","removeFormatInternal","splitToFormatRoot","isRemoveBookmarkNode","removeFormatOnNode","removeNodeFormat","currentNodeMatches","removeRngStyle","removeFormat$1","each$6","mergeTextDecorationsAndColor","processTextDecorationsAndColor","parentTextDecoration","mergeBackgroundColorAndFontSize","hasFontSize","mergeSubSup","inverseTagDescendants","mergeWithChildren","mergeWithParents","each$5","canFormatBR","validBRParentElements","hasCaretNodeSibling","applyStyles","styleVal","applyFormatAction","isCollapsed","setElementFormat","applyNodeStyle","found","createWrapElement","wrapElm","applyRngStyle","nodeSpecific","isMatchingWrappingBlock","canRenameBlock","isEditableDescendant","isValidBlockFormatForNode","canWrapNode","isWrappableNoneditableElm","isValidWrapNode","isCaret","isCorrectFormatForNode","currentWrapElm","lastContentEditable","contentEditableValue","getChildCount","mergeStyles","childCount","fake","applyFormat$1","hasVars","setup$u","registeredFormatListeners","updateAndFireChangeCallbacks","nodeOrRange","fallbackElement","matchingNode","matchingFormat","registeredCallbacks","runIfChanged","spec","isSet","addListeners","formatChangeItems","getCurrent","toAppendTo","removeListeners","formatChangedInternal","toggle","explode$1","create$8","filters","newCallbacks","removeAttrs","addFontToSpansFilter","domParser","fontSizes","face","addStrikeFilter","convertToSTag","addFilters","register$5","addNodeFilter","htmlParser","blockElements","prevName","lastParent","blobUriToBlob","extractBase64Data","parseDataUri","uri","base64Encoded","extractedData","buildBlob","dataUriToBlob","uriToBlob","blobToDataUri","blob","reader","count$1","uniqueId$1","processDataUri","dataUri","base64Only","generateBlobInfo","base64","createBlobInfo$1","blobCache","blobInfo","dataUriToBlobInfo","imageToBlobInfo","imageSrc","invalidDataUri","isBogusImage","isInternalImageSource","registerBase64ImageFilter","processImage","inputSrc","isMimeType","mime","createSafeEmbed","src","sandboxIframes","embed","register$4","appendRel","rel","addNoOpener","newRel","classValue","validClassesMap","entries","setPrototypeOf","isFrozen","getPrototypeOf","getOwnPropertyDescriptor","freeze","seal","create$7","apply","construct","fun","thisValue","Func","arrayForEach","unapply","arrayPop","arrayPush","stringToLowerCase","stringToString","stringMatch","stringReplace","stringIndexOf","stringTrim","objectHasOwnProperty","regExpTest","typeErrorCreate","unconstruct","_len","_key","_len2","_key2","addToSet","transformCaseFunc","lcElement","cleanArray","object","newObject","lookupGetter","desc","fallbackValue","html$1","svg$1","svgFilters","svgDisallowed","mathMl$1","mathMlDisallowed","svg","mathMl","xml","MUSTACHE_EXPR","ERB_EXPR","TMPLIT_EXPR","DATA_ATTR","ARIA_ATTR","IS_ALLOWED_URI","IS_SCRIPT_OR_DATA","ATTR_WHITESPACE","DOCTYPE_NAME","CUSTOM_ELEMENT","EXPRESSIONS","NODE_TYPE","getGlobal","_createTrustedTypesPolicy","trustedTypes","purifyHostElement","ATTR_NAME","policyName","createDOMPurify","window","DOMPurify","document","originalDocument","currentScript","DocumentFragment","HTMLTemplateElement","Node","Element","NodeFilter","NamedNodeMap","HTMLFormElement","DOMParser","ElementPrototype","cloneNode","getNextSibling","getParentNode","template","trustedTypesPolicy","emptyHTML","implementation","createNodeIterator","createDocumentFragment","getElementsByTagName","hooks","IS_ALLOWED_URI$1","ALLOWED_TAGS","DEFAULT_ALLOWED_TAGS","ALLOWED_ATTR","DEFAULT_ALLOWED_ATTR","CUSTOM_ELEMENT_HANDLING","FORBID_TAGS","FORBID_ATTR","ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","ALLOW_SELF_CLOSE_IN_ATTR","SAFE_FOR_TEMPLATES","SAFE_FOR_XML","WHOLE_DOCUMENT","SET_CONFIG","FORCE_BODY","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_TRUSTED_TYPE","SANITIZE_DOM","SANITIZE_NAMED_PROPS","SANITIZE_NAMED_PROPS_PREFIX","KEEP_CONTENT","IN_PLACE","USE_PROFILES","FORBID_CONTENTS","DEFAULT_FORBID_CONTENTS","DATA_URI_TAGS","DEFAULT_DATA_URI_TAGS","URI_SAFE_ATTRIBUTES","DEFAULT_URI_SAFE_ATTRIBUTES","MATHML_NAMESPACE","SVG_NAMESPACE","HTML_NAMESPACE","NAMESPACE","IS_EMPTY_INPUT","ALLOWED_NAMESPACES","DEFAULT_ALLOWED_NAMESPACES","PARSER_MEDIA_TYPE","SUPPORTED_PARSER_MEDIA_TYPES","DEFAULT_PARSER_MEDIA_TYPE","CONFIG","formElement","isRegexOrFunction","testValue","_parseConfig","cfg","MATHML_TEXT_INTEGRATION_POINTS","HTML_INTEGRATION_POINTS","COMMON_SVG_AND_HTML_ELEMENTS","ALL_SVG_TAGS","ALL_MATHML_TAGS","_checkValidNamespace","tagName","parentTagName","_forceRemove","_removeAttribute","_initDocument","dirty","leadingWhitespace","dirtyPayload","_createNodeIterator","_isClobbered","_isNode","_executeHook","entryPoint","_sanitizeElements","_isBasicCustomElement","childClone","expr","_isValidAttribute","lcTag","_sanitizeAttributes","hookEvent","namespaceURI","initValue","_sanitizeShadowDOM","shadowNode","shadowIterator","importedNode","returnNode","nodeIterator","serializedHTML","hookFunction","purify","each$4","queryParts","DEFAULT_PORTS","safeSvgDataUrlElements","blockSvgDataUris","allowSvgDataUrls","decodeUri","encodedUri","isInvalidUri","decodedUri","URI","uriComponents","baseUri","isProtocolRelative","urlMatch","part","pathMatch","relativeUri","tu","uu","noHost","absoluteUri","defaultPort","breakPoint","normalizedBase","nb","tr","normalizedPath","baseParts","pathParts","outPath","noProtoHost","filteredUrlAttrs","internalElementAttr","processNode","_d","lcTagName","isInternalElement","bogus","processAttr","ele","shouldKeepAttribute","isBooleanAttribute","isRequiredAttributeOfInternalElement","filterAttributes","setupPurify","namespaceTracker","purify$1","getPurifyConfig","mimeType","config","sanitizeNamespaceElement","xlinkAttrs","getSanitizer","_mimeType","makeMap","extend$1","transferChildren","nativeParent","nsSanitizer","isSpecial","nativeChild","walkTree","preprocessors","postprocessors","traverseOrder","postprocess","whitespaceCleaner","textRootBlockElements","allWhiteSpaceRegExp","startWhiteSpaceRegExp","endWhiteSpaceRegExp","hasWhitespaceParent","isTextRootBlockEmpty","isAtEdgeOfBlock","neighbour","isNodeEmpty","getRootBlockName","DomParser","nodeFilterRegistry","attributeFilterRegistry","defaultedSettings","sanitizer","parseAndSanitizeWithContext","rootName","isSpecialRoot","wrappedHtml","getNodeFilters","removeNodeFilter","addAttributeFilter","getAttributeFilters","removeAttributeFilter","findInvalidChildren","isWrappableNode","addRootBlocks","rootBlockName","rootBlockNode","rootBlock","exports","whitespacePre","whitespacePost","invalidFinder","matchFinder","topLevelChildren","otherChildren","serializeContent","withSerializedContent","fireEvent","parserSettings","serializedContent","eventArgs","preProcessGetContent","postProcessGetContent","preProcessSetContent","processedEventArgs","postProcessSetContent","tableModel","tableRow","cellPosition","getSpan","td","fillout","rowspan","colspan","y2","x2","cellExists","skipCellsX","getWidth","row","findElementPos","extractRows","sx","sy","ex","ey","newRows","slice","subTable","createDomTable","tableElement","tableBody","modelRowsToDomRows","fromDom","tableElm","toDom","subsection","findParentListContainer","getFullySelectedListWrappers","_li","listCont","listElm","listStyles","_style","wrap","innerElm","directListWrappers","commonAnchorContainer","getWrapElements","wrapElements","listWrappers","allWrappers","emptyFragment","getFragmentFromRange","getParentTable","getTableFragment","selectedTableCells","firstCell","lastCell","fullTableModel","sectionedTableModel","getSelectionFragment","read$3","isCollapsibleWhitespace","getInnerText","bin","getContextNodeName","parentBlockOpt","getTextContent","contextNodeName","rangeContentClone","nonRenderedText","parentBlockText","textIndex","hasProceedingSpace","hasTrailingSpace","getSerializedContent","tmpElm","extractSelectedContent","setupArgs$3","getSelectedContentInternal","defaultedArgs","updatedArgs","KEEP","INSERT","DELETE","diff","vDown","vUp","snake","diag","buildScript","start1","end1","start2","end2","script","getMiddleSnake","j","i2","buildSnake","sum","getOuterHtml","insertAt","removeAt","applyDiff","read$2","trimZwsp","write","fragments","currentFragments","lazyTempDocument","hasIframes","createFragmentedLevel","createCompleteLevel","createFromEditor","applyToEditor","level","getLevelContent","getCleanLevelContent","hasEqualContent","level1","level2","hasEqualCleanedContent","isEq$1","isUnlocked","locks","setTyping","undoManager","typing","endTyping","endTypingLevelIgnoreLocks","beforeChange$1","beforeBookmark","addUndoLevel$1","currentLevel","newLevel","lastLevel","bm","customUndoRedoLevels","clear$1","extra$1","callback1","callback2","redo$1","undo$1","reset$1","hasUndo$1","hasRedo$1","transact$1","ignore$1","addVisualInternal","matchedElm","makePlainAdaptor","makeRtcAdaptor","rtcEditor","defaultVars","init","autocompleter","_undoManager","_locks","_index","_node","_similar","_rfl","_details","_format","makeNoopAdaptor","nul","isRtc","getRtcSetup","rtcPlugin","setup$t","editorCast","setup","getRtcInstanceWithFallback","getRtcInstanceWithError","rtcInstance","beforeChange","addUndoLevel","undo","redo","clear","reset","hasUndo","hasRedo","transact","ignore","extra","matchFormat","matchAllFormats","matchNodeFormat","canApplyFormat","closestFormat","applyFormat","removeFormat","toggleFormat","formatChanged","getContent$2","setContent$2","insertContent$1","getSelectedContent","addVisual$1","bindEvents","addAutocompleterDecoration","removeAutocompleterDecoration","getContent$1","removeEmpty","walkPastBookmark","merge$1","outer","inner","outerElm","oldLength","normalizeTextIfRequired","mergeAndNormalizeText","outerNode","rngSetContent","prevText","nextText","setupArgs$2","cleanContent","contextBlock","contextArgs","setContent$1","cleanedContent","deleteFromCallbackMap","SelectorChanged","selectorChangedData","currentSelectors","findMatchingNode","matchedSelectors","isAttachedToDom","isValidRange","EditorSelection","selectedRange","explicitRange","selectorChangedWithUnbind","setCursorLocation","setRng","getContent","setContent","getRng$1","bookmarkManager","select$1","getSel","isEditable","fakeSelectedElements","tryCompareBoundaryPoints","how","sourceRange","destinationRange","setNode","getSelectedBlocks$1","isForward","anchorNode","focusNode","anchorRange","focusRange","scrollContainer","controlSelection","register$3","trimTrailingBr","isBr","brNode1","brNode2","preProcess$1","oldDoc","clonedNode","impl","shouldFireEvent","process$1","addTempAttr","postProcess","getHtmlFromNode","parseHtml","serializeNode","toHtml","DomSerializerImpl","serialize","DomSerializer","domSerializer","defaultFormat$1","setupArgs$1","defaultFormat","setupArgs","removedOptions","deprecatedOptions","removedPlugins","deprecatedPlugins","getMatchingOptions","searchingFor","settingNames","setting","getRemovedOptions","getDeprecatedOptions","getMatchingPlugins","plugins","pluginNames","plugin","getRemovedPlugins","getDeprecatedPlugins","entry","logRemovedWarnings","rawOptions","normalizedOptions","hasRemovedPlugins","hasRemovedOptions","isLegacyMobileTheme","listJoiner","themesMessage","pluginsMessage","optionsMessage","getPluginDescription","logDeprecatedWarnings","hasDeprecatedPlugins","hasDeprecatedOptions","logWarnings","DOM$8","restoreOriginalStyles","safeDestroy","clearDomReferences","restoreForm","form","remove$1","_selectionOverrides","editorUpload","destroy","automatic","IconManager","iconPack","ModelManager","getProp","propName","getComputedSizeProp","getClientWidth","getClientHeight","getMarginTop","getMarginLeft","getBoundingClientRect","isInsideElementContentArea","bodyElm","clientWidth","clientHeight","transpose","isXYInContentArea","transposedPoint","fromDomSafe","isEditorAttachedToDom","rawContainer","NotificationManagerImpl","unimplemented","NotificationManager","notifications","getImplementation","theme","getTopNotification","notification","addNotification","closeNotification","otherNotification","open","close","getNotifications","registerEvents","serviceMessage","PluginManager","ThemeManager","WindowManagerImpl","WindowManager","dialogs","funcBind","fireOpenEvent","dialog","fireCloseEvent","addDialog","closeDialog","otherDialog","getTopDialog","storeSelectionAndOpenDialog","openDialog","params","openUrl","alert","windowManagerImpl","confirm","displayNotification","displayError","uploadError","logError","createLoadError","pluginLoadError","iconsLoadError","languageLoadError","themeLoadError","modelLoadError","pluginInitError","initError","console","isContentCssSkinName","toContentSkinResourceName","isBundledCssSkinName","getContentCssUrls","transformToUrls","getFontCssUrls","cssLinks","skinUrl","contentCssFile","appendContentCssFromSettings","getAllImages","ImageScanner","uploadStatus","cachedPromises","images","promises","imageInfo","newPromise","UploadStatus","blobUriStatuses","createStatus","resultUri","hasBlobUri","blobUri","seed","rnd","uuid","BlobCache","cache","mimeToExt","filename","toBlobInfo","findFirst","cachedBlobInfo","Uploader","pendingPromises","pathJoin","path1","path2","defaultHandler","progress","xhr","json","formData","uploadHandler","noUpload","handlerSuccess","handlerFailure","resolvePending","uploadBlobInfo","openNotification","percent","isDefaultHandler","pendingUploadBlobInfo","uploadBlobs","blobInfos","createUploader","ImageUploader","uploader","showNotification","isEmptyForPadding","addPaddingToEmpty","EditorUpload","imageScanner","urlFilters","aliveGuard","cacheInvalidator","replaceString","replaceImageUrl","targetUrl","replacementUrl","replacementString","replaceUrlInUndoStack","replaceImageUriInView","image","uploadImages","scanForImages","imageInfos","imagesToRemove","shouldDispatchChange","filteredResult","uploadInfo","removed","sugarElement","parentOpt","uploadImagesAuto","isValidDataUriImage","imgElm","addFilter","resultItem","replaceBlobUris","get$1","strike","_fmt","_itemName","genericBase","cellBase","cellFormats","FormatRegistry","register","unregister","each$3","isPreviewItem","parsedSelectorToHtml","ancestry","createElement","sItem","getRequiredParent","elmRule","parentsRequired","wrapInHtml","ancestors","parentCandidate","ancestorName","parentRequired","siblingElm","parentSiblings","parseSelectorItem","$0","$3","$4","parseSelector","getCssText","previewCss","previewStyles","removeVars","getComputedStyle","preview","previewFrag","previewElm","rawParentFontSize","parentFontSize","setup$s","Formatter","formatChangeState","shouldIgnoreCommand","isFirstTypedCharacter","addNonTypingUndoLevel","isMeta","modKey","isInsertReplacementText","isInsertTextDataNull","isInsertFromPasteOrDrop","addKeyboardShortcuts","UndoManager","nonTypingKeycodes","placeholderAttr","isKeyboardEvent","isDeleteEvent","isNonTypingKeyboardEvent","isTypingKeyboardEvent","isVisuallyEmpty","setup$r","placeholder","updatePlaceholder","showPlaceholder","blockPosition","blockBoundary","getBlockPosition","containerElm","isDifferentBlocks","getClosestHost","hasSameHost","isEditable$1","hasValidBlocks","isValidBlock","skipLastBr","lastPositionInBlock","readFromRange","fromBlockPos","toBlockPos","blockPos","read$1","getChildrenUntilBlockBoundary","extractChildren","removeEmptyRoot","isEmptyBefore","nestedBlockMerge","toBlock","insertionPoint","sidelongBlockMerge","newFromBlockDescendants","helper","findInsertionPoint","parentsAndSelf$1","getInsertionPoint","trimBr","mergeBlockInto","mergeBlocks","backspaceDelete$9","deleteRangeMergeBlocks","isRawNodeInTable","isSelectionInTable","isEverythingSelected","noPrevious","noNext","emptyEditor","deleteRange$2","backspaceDelete$8","_forward","showCaret","scrollIntoView","getNodeRange","selectNode","renderCaretAtRange","caretPositionNode","caretPositionBeforeNode","ceRoot","renderRangeCaret","isBeforeBoundary","isAfterBoundary","trimEmptyTextNode","deleteContentAndShowCaret","peekCaretPosition","caretRange","deleteRange","deleteBoundaryText","getNextPosFn","isBeforeFn","nextCaretPosition","normalizedNextCaretPosition","backspaceDelete$7","getEdgeCefPosition","atStart","isCefAtEdgeSelected","isCompoundElement","DeleteAction","isAtContentEditableBlockCaret","caretLocation","isDeleteFromCefDifferentBlocks","deleteEmptyBlockOrMoveToCef","toCefElm","blockElm","findCefPosition","getContentEditableBlockAction","skipMoveToActionFromInlineCefToContent","getContentEditableAction","read","deleteElement$1","moveToElement","moveToPosition","getAncestorCe","backspaceDeleteCaret","deleteOffscreenSelection","backspaceDeleteRange","paddEmptyElement","backspaceDelete$6","deleteCaret$2","backspaceDelete$5","isText$2","startsWithCaretContainer","endsWithCaretContainer","createZwsp","insertBefore$1","insertAfter$1","insertInline","insertInlineBefore","insertInlineAfter","insertInlinePos","isPosCaretContainer","caretNode","renderCaret","evaluateUntil","fns","Location","rescope$1","nPos","isNotInsideFormatCaretContainer","findInsideRootInline","start$1","isValidLocation","getElement","readLocation","getName","outside","inside","isEq","location1","location2","betweenInlines","fromInline","toInline","skipNoMovement","fromLocation","toLocation","findLocationTraverse","findLocationSimple","findLocation$1","hasSelectionModifyApi","moveRel","moveByWord","BreakType","flip","positions","walk$1","getBreakType","currentPos","getPositionsUntil","breakType","getAdjacentLinePositions","getPositionsUntilBreak","findClosestHorizontalPositionFromPoint","lastRect","newRect","lastDist","findClosestHorizontalPosition","targetRect","getPositionsUntilPreviousLine","getPositionsUntilNextLine","getPositionsAbove","getPositionsBelow","isAtFirstLine","isAtLastLine","getFirstLinePositions","getLastLinePositions","getClosestPositionAbove","getClosestPositionBelow","isContentEditableFalse$4","distanceToRectLeft$1","distanceToRectRight$1","isNodeClientRect","findClosestClientRect","oldClientRect","oldDistance","newDistance","getNodeClientRects","toArrayWithNode","VDirection","findUntil","walkUntil","isAboveFn","isBeflowFn","line","targetClientRect","aboveLineNumber","lineNumber","isLineNumber","upUntil","downUntil","getLastClientRect","positionsUntil","isBelowFn","isAboveLine","isLine","moveToRange","renderRangeCaretOpt","moveHorizontally","isBefore","isAfter","isElement","rangeIsInContainerBlock","moveVertically","caretClientRect","linePositions","nextLinePositions","nextLineRect","dist1","dist2","caretPositions","closestNextLineRect","getLineEndPoint","host","lineInfo","moveToLineEndPoint$3","isElementPosition","setCaretPosition","setSelected","renderCaretLocation","getPositionFromRange","findLocation","isInlineTarget$1","toggleInlines","inlineBoundaries","selectedInlines","targetInlines","safeRemoveCaretContainer","caretValue","renderInsideInlineCaret","inlines","_inline","move$3","moveWord","_caret","setupSelectedState","moveNextWord","movePrevWord","moveToLineEndPoint$2","linePoint","outsideLoc","rangeFromPositions","hasOnlyTwoOrLessPositionsLeft","setCaretLocation","deleteFromTo","rescope","backspaceDeleteCollapsed","toPosition","backspaceDelete$4","hasMultipleChildren","getParentsUntil","hasOnlyOneChild","getParentInlinesUntilMultichildInline","getParentInlines","getFormatNodes","parentInlines","isFormatElement$1","getFormatNodesAtStart","deleteLastPosition","deleteCaret$1","isBrInEmptyElement","isEmptyCaret","createCaretFormatAtStart","updateCaretFormat","updateFormats","missingFormats","rangeStartsAtTextContainer","rangeStartsAtStartOfTextContainer","rangeStartParentIsFormatElement","startParent","rangeStartAndEndHaveSameParent","endParent","rangeEndsAtEndOfEndContainer","rangeEndsAtEndOfStartContainer","rangeEndsAfterEndOfStartContainer","rangeEndsAtOrAfterEndOfStartContainer","requiresDeleteRangeOverride","deleteRange$1","backspaceDelete$3","hasAncestorInlineCaret","hasAncestorInlineCaretAtStart","requiresRefreshCaretOverride","refreshCaret","deleteElement","deleteCaret","isNearMedia","backspaceDelete$2","parseIndentValue","getIndentStyleName","useMargin","indentStyleName","indentElement","unit","parsedValue","validateBlocks","intentValue","canOutdent","getBlocksToIndent","isListComponent","parentIsListComponent","indentation","indentUnit","indentValue","outdent","backspaceDelete$1","findAction","deleteCommand","forwardDeleteCommand","setup$q","SIGNIFICANT_MOVE","LONGPRESS_DELAY","getTouch","isFarEnough","distX","distY","setup$p","startData","longpressFired","debounceLongpress","isBlockElement","isValidTarget","hasBlockParent","shouldRemoveTextNode","createRootBlock","rootNodeName","restoreSelection","insertEmptyLine","setup$o","checkClassName","replaceMatchWithSpan","prevChar","findStartTagIndex","convertRegExpsToNonEditable","nonEditableRegExps","isValidContent","re","setup$n","contentEditableAttrName","editClass","nonEditClass","hasEditClass","hasNonEditClass","findBlockCaretContainer","showBlockCaretContainer","blockCaretContainer","handleBlockContainer","setup$m","isContentEditableFalse$3","moveToCeFalseHorizontally","moveToCeFalseVertically","createTextBlock","textBlock","exitPreBlock","getVisualCaretPosition$1","newBlock","getHorizontalRange","getVerticalRange","down","flipDirection","moveH$2","moveV$4","moveToLineEndPoint$1","selectToEndPoint","curRng","isTarget","getClosestTargetBlock","isAtFirstOrLastLine","moveCaretToNewEmptyLine","moveV$3","moveUp","summary","moveDown","move$2","moveV$2","baseKeyPattern","defaultPatterns","defaultDelayedPatterns","matchesEvent","match$1","matchDelayed","execute","executeWithDelayedAction","moveH$1","moveV$1","moveToLineEndPoint","CellLocation","firstLayer","filterFirstLayer","lookup$1","tags","isRootOrUpperTable","isEligible","newIndex","detect","deflate","getCorners","getYAxisValue","tds","findClosestCorner","corners","newCorner","oldCorner","oldDist","newDist","getClosestCell","isTargetCorner","corner","getBottomValue","getTopValue","isAbove","isBelow","getClosestCellAbove","getClosestCellBelow","findClosestPositionInAboveCell","findClosestPositionInBelowCell","hasNextBreak","breakPos","startsWithWrapBreak","startsWithBrBreak","isAtTableCellLine","isAtFirstTableCellLine","isAtLastTableCellLine","isCaretAtStartOrEndOfTable","navigateHorizontally","_td","getClosestAbovePosition","getClosestBelowPosition","getTable","previous","renderBlock","insertFn","navigateVertically","move$1","mover","moveH","moveV","getCellFirstCursorPosition","tabGo","_current","tabForward","tabBackward","handleTab","rootElements","executeKeydownOverride$4","isMac","setup$l","DOM$7","alwaysNext","textBefore","textAfter","scanLeft","scanRight","repeatLeft","isValidTextRange","getText","isWhitespace","stripTrigger","trigger","findTrigger","firstChar","findStart","initRange","minChars","buffer","findTriggerIndex","spot","isText$1","toLast","toLeaf","isPreviousCharContent","leaf","_element","isStartOfWord","getTriggerContext","database","getDatabase","lookupWithContext","fetchOptions","startText","autocompleters","lookupData","ac","SimpleResultType","fold$1","partition","mapError","bind$1","bindError","svalue","serror","SimpleResult","formatObj","formatErrors","es","getErrorInfo","missingRequired","missingKey","missingBranch","branch","custom","chooseFrom","choose$1","chosen","old","deepMerge","baseMerge","merger","objects","curObject","required","defaultedThunk","fallbackThunk","defaulted$1","fallback","asOption","mergeValues","mergeErrors","ResultCombine","partitions","field$1","newKey","presence","customField$1","instantiator","fold","ifField","ifCustom","validator","extract","anyValue$1","requiredAccess","bundle","fallbackAccess","optionAccess","optionDefaultedAccess","opt","extractField","av","bundleAsOption","optValue","ov","extractFields","fields","objOf","_okey","_presence","_instantiator","arrOf","valueOf","extractValue","errs","asRaw","formatError","errInfo","choose","anyValue","typedValue","expectedType","actualType","number","string","boolean","functionProcessor","customField","validateEnum","requiredOf","requiredString","requiredFunction","requiredArrayOf","optionOf","optionString","optionFunction","defaulted","defaultedOf","defaultedNumber","defaultedString","defaultedStringEnum","defaultedBoolean","defaultedFunction","defaultedArrayOf","fetch$1","onAction","onSetup","optionalText","optionalIcon","optionalTooltip","optionalLabel","active","enabled","primary","defaultedColumns","defaultedType","autocompleterSchema","createAutocompleter","baseToolbarButtonFields","baseToolbarToggleButtonFields","contextBarFields","contextButtonFields","contextToggleButtonFields","launchButtonFields","launchToggleButtonFields","toggleOrNormal","register$2","popups","dataset","popup","triggers","datasetValues","dv","setupEditorInput","update","setup$k","activeAutocompleter","uiActive","isActive","cancelIfNecessary","commenceIfNecessary","getAutocompleters","doLookup","newContext","lookupInfo","_ui","isSafari","emptyNodeContents","isEntireNodeSelected","getParentDetailsElementAtPos","isInDetailsElement","getDetailsElements","startDetails","endDetails","startSummary","isCaretInTheBeginningOf","isCaretInTheEndOf","isCaretAtStartOfSummary","detailsElements","isCaretAtEndOfSummary","isCaretInFirstPositionInBody","isCaretInLastPositionInBody","setCaretToPosition","moveCaretToDetailsPos","isPartialDelete","containsStart","containsEnd","startInSummary","endInSummary","isPartiallySelectedDetailsElements","shouldPreventDeleteIntoDetails","granularity","parentDetailsAtCaret","inEmptyParentBlock","isFirstBlock","isLastBlock","parentDetailsAtNewPos","shouldPreventDeleteSummaryAction","detailElements","shouldPreventDeleteAction","handleDeleteActionSafari","anchorOffset","focusOffset","applySelection","updateSelection","appendAllChildNodes","backspaceDelete","createAndFireInputEvent","eventType","inputType","specifics","overrides","fireInputEvent","fireBeforeInputEvent","platform$2","isMacOSOriOS","isFirefox","executeKeydownOverride$3","unmodifiedGranularity","getModifiedGranularity","isWord","applyAction","executeKeyupOverride","isBackspaceKeydown","setup$j","firstNonWhiteSpaceNodeSibling","moveToCaretPosition","getEditableRoot","editableRoot","getParentBlock$1","getParentBlockName","isListItemParentBlock","applyAttributes","forcedRootBlockAttrs","attrStyles","newStyles","attrClassesOpt","attrClasses","currentClassesOpt","currentClasses","filteredClasses","newClasses","appliedAttrs","remainingAttrs","setForcedBlockAttrs","createNewBlock","keepStyles","newBlockName","parentBlockName","getDetailsRoot","isAtDetailsEdge","isLastEmptyBlockInDetails","shiftKey","insertNewLine","hasFirstChild","isFirstChild","hasParent","isListBlock","isListItem","isNestedList","getContainerBlock","containerBlock","containerBlockParent","isFirstOrLastLi","getStyles","insert$4","containerParent","parentBlockStyles","tmpRng","previousChildren","isWithinNonEditableList","parentList","isEmptyAnchor","containerAndSiblingName","canSplitBlock","trimInlineElementsOnLeftSideOfBlock","firstChilds","normalizeZwspOffset","includeZwspInRange","trimLeadingLineBreaks","wrapSelfAndSiblingsInDefaultBlock","startNodeName","startNodeParent","addBrToBlockIfNeeded","shouldEndContainer","optionValue","blockbreak","isAfterLastNodeInContainer","isCef","collapsedAndCef","createNewBlock$1","isCaretAtStartOrEndOfBlock","normalizedOffset","insertNewBlockAfter","containerBlockName","ctrlKey","liBlock","parentBlockParent","isNearChildren","hasRightSideContent","moveSelectionToBr","brElm","extraBr","insertBrAtCaret","isControlKey","insertBrBefore","insertBrAfter","hasBrAfter","isBeforeBr","isAnchorLink","isInsideAnchor","readInlineAnchorLocation","insertBrOutsideAnchor","linebreak","anchorLocation","matchesSelector","shouldInsertBr","shouldBlockNewLine$1","newLineAction","shouldBlockNewLine","_shiftKey","inListBlock","requiredState","inBlock","inCefBlock","inPreBlock","inSummaryBlock","shouldPutBrInPre","inBrContext","hasShiftKey","_editor","canInsertIntoEditableRoot","rootEditable","isInRootWithEmptyOrCEF","isCefOpt","predicates","getAction","insertBreak","insert$1","logicalAction","platform$1","isIOSSafari","handleEnterKeyEvent","isCaretAfterKoreanCharacter","koreanCharRegex","setup$i","iOSSafariKeydownBookmark","iOSSafariKeydownOverride","iOSSafariKeyupOverride","executeKeydownOverride$2","setup$h","setup$g","platform","executeKeyupAction","stopImmediatePropagation","isPageUpDown","setNodeChangeBlocker","blocked","setup$f","setup$e","insertTextAtPosition","insertNbspAtPosition","insertSpaceAtPosition","insertSpaceOrNbspAtPosition","locationToCaretPosition","insertInlineBoundarySpaceOrNbsp","checkPos","setSelection","isInsideSummary","domUtils","insertSpaceOrNbspAtSelection","insertSpaceInSummaryAtSelectionOnFirefox","insertSpaceThunk","executeKeydownOverride$1","setup$d","tableTabNavigation","executeKeydownOverride","setup$c","setup$b","NodeChange","lastRng","nativeRng","fakeRng","currentPath","imageId","getDragImage","transfer","dt","setDragImage","imageData","eventId","getEvent","mkSetEventFn","setEvent","setDragstartEvent","setDropEvent","setDragendEvent","isInDragStartEvent","createEmptyFileList","modeId","getMode","mkSetModeFn","setMode$1","setReadWriteMode","setReadOnlyMode","setProtectedMode","checkMode","expectedMode","isInReadWriteMode","isInProtectedMode","normalizeItems","dataTransfer","itemsImpl","validDropEffects","validEffectAlloweds","createDataTransfer","dataTransferImpl","dropEffect","effectAllowed","effect","allowed","cloneDataTransfer","originalMode","file","getHtmlData","setHtmlData","internalMimeType","internalHtmlMime","internalMark","mark","unmark","isMarked","isPlainText","openContainer","rootTag","rootAttrs","toBlockElements","tagOpen","tagClose","paragraphs","stitch","pasteBinDefaultContent","create$6","lastRngCell","pasteBinElm","getEl","pasteBinClone","isPasteBin","getHtml","copyAndRemove","toElm","fromElm","pasteBinClones","dirtyWrappers","cleanWrapper","isDefaultPasteBinContent","PasteBin","filter$1","innerText","voidElements","ignoreElements","trimHtml","s1","s2","createIdGenerator","getImageMimeType","lowerExt","mimeOverrides","preProcess","processResult","cancelled","postProcessFilter","tempBody","postProcessArgs","filterContent","preProcessArgs","filteredContent","pasteHtml$1","isAbsoluteUrl","isImageUrl","createImage","pasteHtmlFn","createLink","linkSelection","insertImage","smartInsertContent","insertContent","pasteAsText","createPasteDataTransfer","doPaste","shouldSimulateInputEvent","doPasteAction","pasteHtml","internalFlag","pasteText","encodedText","getDataTransferItems","contentType","hasContentType","clipboardContent","hasHtmlOrText","extractFilename","createBlobInfo","useFileName","pasteImage","imageItem","existingBlobInfo","isClipboardEvent","readFilesAsDataUris","allowedExtensions","extension","getImagesFromDataTransfer","pasteImageData","fileResults","isBrokenAndroidClipboardEvent","isKeyboardPasteEvent","insertClipboardContent","plainTextMode","isInternal","isPlainTextHtml","isAbsoluteUrl$1","registerEventHandlers","pasteBin","pasteFormat","keyboardPastePlainTextState","getLastRng","registerDataImageFilter","isWebKitFakeUrl","isDataUri","isPasteInsert","registerEventsAndFilters","togglePlainTextPaste","register$1","ui","setHtml5Clipboard","clipboardData","setClipboardData","offscreenRange","getData","isTableSelection","hasSelectedContent","cut","getCaretRangeFromEvent","isPlainTextFileUrl","plainTextContent","setFocusedRange","hasImage","needsCustomInternalDrop","dropContent","parentTransparent","setupSummaryDeleteByDragFix","hasNoSummary","brokenDetailElements","setup$a","draggingInternallyState","internalContent","needsInternalDrop","isInternalDrop","trimmedContent","setup$9","processEvent","addPreProcessFilter","filterFunc","rgbRegExp","rgbToHex","removeWebKitStyles","webKitStylesOption","webKitStyles","inputStyles","outputStyles","inputValue","compareInput","outputStyle","setup$8","setup$7","preventSummaryToggle","filterDetails","initialStateOption","serializedStateOption","setup$6","isText","isContentEditableFalse$2","isContentEditableTrue","getClosestScope","getClosestCef","findEdgeCaretCandidate","findClosestBlockRange","startRng","clickNode","cef","onTripleClickSelect","setup$5","FakeCaretPosition","distanceToRectLeft","distanceToRectRight","isInsideY","collidesY","isOverlapping","overlap","splitRectsPerAxis","intersectingRects","boundingRect","horizontal","vertical","clientInfo","horizontalDistance","_y","closestChildCaretCandidateNodeRect","findCloserTextNode","caretCandidateRect","tryFindSecondBestTextNode","sndClosest","distance","findClosestCaretCandidateNodeRect","sortedRects","horizontalRects","verticalRects","above","below","traverseUp","prevScope","isDragGhostContainer","childNodesWithoutGhost","uncheckedChildren","newScope","closestCaretCandidateNodeRect","ownerDoc","closestFakeCaretCandidate","getAbsolutePosition","docElem","getBodyPosition","getScrollPosition","getBodyScroll","inlineScroll","iframeScroll","getMousePosition","iframePosition","scrollPosition","calculatePosition","bodyPosition","mousePosition","calc","getTargetProps","makeDndEventFromMouseEvent","makeDndEvent","makeDataTransferCopyForDragEvent","makeDragEvent","dataTransferForDispatch","scrollPixelsPerInterval","scrollIntervalValue","mouseRangeToTriggerScrollInsideEditor","mouseRangeToTriggerScrollOutsideEditor","isContentEditableFalse$1","isDraggable","isValidDropTarget","dragElement","createGhost","clonedElm","appendGhostToBody","scrollEditor","amount","scrollRight","scrollUp","scrollDown","moveGhost","maxX","maxY","mouseY","mouseX","contentAreaContainer","mouseEventOriginatedFromWithinTheEditor","overflowX","outerMouseY","outerMouseX","removeElement","removeElementWithPadding","isLeftMouseButtonPressed","applyRelPos","ceElm","elmPos","placeCaretAt","caretInfo","dispatchDragEvent","move","throttledPlaceCaretAt","state_","movement","targetPos","getRawTarget","drop","dropTarget","removeDragState","stopDragging","bindFakeDragEvents","pageDom","dragStartHandler","dragHandler","dropHandler","dragEndHandler","blockUnsupportedFileDrop","preventFileDrop","preventFileDropIfUIElement","editorRoot","eventNames","init$2","setup$4","renderFocusCaret","setup$3","isContentEditableFalse","getContentEditableRoot","SelectionOverrides","realSelectionId","selectedElement","isFakeSelectionElement","isFakeSelectionTargetElement","setRange","removeElementSelection","contentEditableRoot","setElementSelection","hideFakeCaret","closestContentEditable","normalizeVoidElementSelection","isRangeInCaretContainer","isWithinCaretContainer","setupOffscreenSelection","targetClone","realSelectionContainer","selectElement","nodeElm","afterNode","getNormalizedTextOffset","generatePath","generatePathRange","resolvePath","nodePath","optNode","resolvePathRange","generatePathRangeFromRange","cleanEmptyNodes","deleteRng","clean","getParentBlock","resolveFromDynamicPatterns","patternSet","beforeText","dynamicPatterns","getBeforeText","startsWithSingleSpace","stripPattern","textContent","applyPattern$1","isBlockFormatName","formatSet","sortPatterns$1","findPattern$1","sortedPatterns","nuText","findPatterns$1","normalizedMatches","blockText","applyMatches$1","newMarker","rangeFromMarker","createMarker","markerPrefix","pathRange","textEnd","textStart","startParentNode","endParentNode","removeMarker","isReplacementPattern","matchesPattern","patternContent","searchText","startEndIndex","findPatternStartFromSpot","startPattern","startPatternIndex","nextSpot","findPatternStart","requireGap","startRange","findPattern","endPathRng","resultsOpt","findPatternsRec","startPathRng","endSpot","patternsWithoutCurrent","applyPattern","patternRange","applyReplacementPattern","markerRange","applyPatternWithContent","startMarker","endMarker","markerEndRange","markerStartRange","patternMarker","addMarkers","matchesWithEnds","sortPatterns","getBestMatches","matchesWithSortedPatterns","hasSameMatches","sortedMatch","findPatterns","applyMatches","matchesWithMarkers","handleEnter","dynamicPatternSet","inlineMatches","blockMatches","handleInlineKey","checkKeyEvent","codes","checkKeyCode","checkCharCode","setup$2","charCodes","keyCodes","getPatternSet","hasDynamicPatterns","handleInlineTrigger","setup$1","Quirks","each","BACKSPACE","isGecko","isWebKit","isiOS","setEditorCommandState","isDefaultPrevented","emptyEditorWhenDeleting","serializeRng","contents","allContentsSelected","allRng","allSelection","selectAll","documentElementEditingFocus","removeHrOnBackspace","previousSibling","selectControlElements","visualAidsAnchorClass","removeStylesWhenDeletingAcrossBlockElements","getAttributeApplyFunction","isSelectionAcrossElements","disableBackspaceIntoATable","removeBlockQuoteOnBackSpace","setGeckoEditingOptions","setOpts","addBrAfterLastLinks","fixLinks","setDefaultBlockType","isAllContentSelected","showBrokenImageIcon","restoreFocusOnKeyDown","bodyHeight","blockCmdArrowNavigation","tapLinksAndImages","blockFormSubmitInsideEditor","removeAppleInterchangeBrs","refreshContentEditable","setupRtc","dropDragEndEvent","DOM$6","appendStyle","getRootName","removeUndefined","mkParserSettings","mkSchemaSettings","mkSerializerSettings","createParser","autoFocus","moveSelectionToFirstCaretPosition","initEditor","initInstanceCallback","getStyleSheetLoader$1","makeStylesheetLoadingPromises","framedFonts","bundledCss","normalCss","loadContentCss","fontCss","removeCss","loaded","contentCssText","allStylesheets","contentStyle","preInit","directionality","protect","loadInitialContent","initEditorWithInitialContent","startProgress","canceled","progressTimeout","contentBodyLoaded","setupRtcThunk","cancelProgress","_rtcMode","DOM$5","createIframeElement","title","customAttrs","tabindex","iframe","getIframeHtml","iframeHTML","bodyId","bodyClass","translatedAriaText","createIframe","boxInfo","iframeTitle","ifr","setupIframeBody","ready","init$1","DOM$4","initPlugin","initializedPlugins","Plugin","pluginUrl","pluginInstance","trimLegacyPrefix","initPlugins","initIcons","iconPackName","currentIcons","loadIcons","svgData","icon","initTheme","Theme","initModel","model","Model","renderFromLoadedTheme","render","renderThemeFalse","renderFromThemeFunc","createThemeFalseResult","renderThemeFalseIframe","iframeContainer","renderThemeUi","augmentEditorUiApi","uiApiFacade","renderInfo","DOM$3","hasSkipLoadPrefix","loadLanguage","scriptLoader","languageCode","languageUrl","loadTheme","themeUrl","loadModel","modelUrl","getIconsUrlMetaFromUrl","getIconsUrlMetaFromName","defaultIconsUrl","customIconsUrl","urlMeta","loadPlugins","loadPlugin","isThemeLoaded","isModelLoaded","loadScripts","getStyleSheetLoader","snapshot","setEditableRoot","hasEditableRoot","sectionResult","sections","deviceDetection","normalizePlugins","trimmedPlugins","extractSections","getSection","defaults","sectionOptions","hasSection","getSectionConfig","getMobileOverrideOptions","mobileOptions","getExternalPlugins","overrideOptions","userDefinedExternalPlugins","combinePlugins","forcedPlugins","getPlatformPlugins","isMobileDevice","desktopPlugins","mobilePlugins","processPlugins","defaultOverrideOptions","mobileConfig","platformPlugins","combinedPlugins","isOnMobile","combineOptions","defaultOptions","deviceOverrideOptions","extendedOptions","normalizeOptions","addVisual","registerExecCommands$3","toggleAlign","align","registerQueryStateCommands$1","alignStates","registerCommands$b","registerCommands$a","trimOrPadLeftRight","processValue$1","trimOrPad","insertAtCaret","insertedContent","registerCommands$9","_command","legacyPropNames","isFont","getSpecifiedFontProp","getProperty","legacyPropName","normalizeFontFamily","fontFamily","getComputedFontProp","getFontProp","getFontSize","getFontFamily","findFirstCaretElement","getCaretElement","bindRange","mapRange","fromFontSizeNumber","fontSizeNumber","fontClasses","normalizeFontNames","font","fonts","fontNameAction","fontNameQuery","fontSizeAction","fontSizeQuery","lineHeightQuery","specifiedStyle","computedStyle","lineHeight","fontSize","lineHeightAction","registerExecCommands$2","lang","registerQueryValueCommands","isFormatMatch","registerCommands$8","registerCommands$7","registerCommands$6","registerCommands$5","applyLinkToSelection","linkDetails","anchor","registerExecCommands$1","listParent","registerQueryStateCommands","list","registerCommands$4","getTopParentBlock","topParentBlock","insert","insertBefore","registerCommands$3","registerCommands$2","registerCommands$1","registerExecCommands","registerCommands","selectionSafeCommands","isSelectionSafeCommand","EditorCommands","lowerCaseCommand","commandList","commands","internalContentEditableAttr","setContentEditable","switchOffContentEditableTrue","switchOnContentEditableTrue","removeFakeSelection","restoreFakeSelection","toggleReadOnly","isReadOnly","registerFilters","registerReadOnlyContentFilters","isClickEvent","allowedEvents","isReadOnlyAllowedEvent","getAnchorHrefOpt","processReadonlyEvents","href","targetEl","registerReadOnlySelectionBlockers","nativeEvents","EventDispatcher","wrappedCallback","currentName","bindingName","filteredHandlers","binding","getEventDispatcher","Observable","bubble","dispatcherArgs","DOM$2","customEventRootDelegates","getEventTarget","eventName","eventRoot","isListening","bindEventDelegate","eventRootElm","delegate","editors","EditorObservable","stringListProcessor","getBuiltInProcessor","processValue","isBuiltInSpec","getErrorMessage","additionalText","isValidResult","processor","processDefaultValue","create$5","initialOptions","setValue","isRegistered","registered","defaultModes","switchToMode","activeMode","availableModes","oldMode","newMode","setMode","registerMode","create$4","each$2","explode","keyCodeLookup","modifierNames","isModifier","parseShortcut","shortcut","Shortcuts","cmdFunc","shortcuts","create$3","buttons","menuItems","icons","contextMenus","contextToolbars","sidebars","views","addIcon","bridge","DOM$1","extend","each$1","Editor","setupCallback","loadArgs","getArgs","saveArgs","initialContent","oldState","urlConverterCallback","urlObject","DOM","boundGlobalEvents","beforeUnloadDelegate","globalEventDelegate","EditorManager","toggleGlobalEvents","removeEditorFromList","targetEditor","oldEditors","purgeDestroyedEditor","isQuirksMode","baseURL","documentBaseURL","srcScript","pluginBaseUrls","pluginBaseUrl","pluginName","invalidInlineTargets","isInvalidInlineTarget","createId","execCallback","findTargets","provideResults","initEditors","initCount","createEditor","existingEditor","editorId","editorOptions","FakeClipboard","dataValue","FakeClipboardItem","round","relativePosition","targetW","targetH","relChars","create$2","findBestRelativePosition","constrainRect","rels","inflate","intersect","cropRect","x1","y1","clamp","clampRect","fixedSize","cx2","cy2","underflowX1","underflowY1","overflowX2","overflowY2","Rect","awaiter","resolveCb","rejectCb","timeout","complete","completer","Resource","tasks","resultFns","resources","loadErrMsg","runErrMsg","task","waiter","storage","localStorage","LocalStorage","publicApi","tinymce$1","exportToModuleLoaders","tinymce","module"],"mappings":"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","x_google_ignoreList":[0]}