{"version":3,"file":"index-B73zBI8k.cjs","sources":["../node_modules/.pnpm/tinymce@6.8.6/node_modules/tinymce/plugins/searchreplace/plugin.js"],"sourcesContent":["/**\n * TinyMCE version 6.8.6 (TBD)\n */\n\n(function () {\n    'use strict';\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const isString = isType$1('string');\n    const isArray = isType$1('array');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isNumber = isSimpleType('number');\n\n    const noop = () => {\n    };\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const always = constant(true);\n\n    const punctuationStr = `[~\\u2116|!-*+-\\\\/:;?@\\\\[-\\`{}\\u00A1\\u00AB\\u00B7\\u00BB\\u00BF;\\u00B7\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1361-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u3008\\u3009\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30\\u2E31\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]`;\n\n    const punctuation$1 = constant(punctuationStr);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const punctuation = punctuation$1;\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.Env');\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const nativeSlice = Array.prototype.slice;\n    const nativePush = Array.prototype.push;\n    const map = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const groupBy = (xs, f) => {\n      if (xs.length === 0) {\n        return [];\n      } else {\n        let wasType = f(xs[0]);\n        const r = [];\n        let group = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n          const x = xs[i];\n          const type = f(x);\n          if (type !== wasType) {\n            r.push(group);\n            group = [];\n          }\n          wasType = type;\n          group.push(x);\n        }\n        if (group.length !== 0) {\n          r.push(group);\n        }\n        return r;\n      }\n    };\n    const foldl = (xs, f, acc) => {\n      each(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind = (xs, f) => flatten(map(xs, f));\n    const sort = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n\n    const hasOwnProperty = Object.hasOwnProperty;\n    const has = (obj, key) => hasOwnProperty.call(obj, key);\n\n    typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const type = element => element.dom.nodeType;\n    const isType = t => element => type(element) === t;\n    const isText$1 = isType(TEXT);\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom(node);\n    };\n    const fromDom = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\n    const SugarElement = {\n      fromHtml,\n      fromTag,\n      fromText,\n      fromDom,\n      fromPoint\n    };\n\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const children = element => map(element.dom.childNodes, SugarElement.fromDom);\n    const spot = (element, offset) => ({\n      element,\n      offset\n    });\n    const leaf = (element, offset) => {\n      const cs = children(element);\n      return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);\n    };\n\n    const before = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const append = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const wrap = (element, wrapper) => {\n      before(element, wrapper);\n      append(wrapper, element);\n    };\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api = NodeValue(isText$1, 'text');\n    const get$1 = element => api.get(element);\n\n    const compareDocumentPosition = (a, b, match) => {\n      return (a.compareDocumentPosition(b) & match) !== 0;\n    };\n    const documentPositionPreceding = (a, b) => {\n      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_PRECEDING);\n    };\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    var global = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n\n    const isSimpleBoundary = (dom, node) => dom.isBlock(node) || has(dom.schema.getVoidElements(), node.nodeName);\n    const isContentEditableFalse = (dom, node) => !dom.isEditable(node);\n    const isContentEditableTrueInCef = (dom, node) => dom.getContentEditable(node) === 'true' && node.parentNode && !dom.isEditable(node.parentNode);\n    const isHidden = (dom, node) => !dom.isBlock(node) && has(dom.schema.getWhitespaceElements(), node.nodeName);\n    const isBoundary = (dom, node) => isSimpleBoundary(dom, node) || isContentEditableFalse(dom, node) || isHidden(dom, node) || isContentEditableTrueInCef(dom, node);\n    const isText = node => node.nodeType === 3;\n    const nuSection = () => ({\n      sOffset: 0,\n      fOffset: 0,\n      elements: []\n    });\n    const toLeaf = (node, offset) => leaf(SugarElement.fromDom(node), offset);\n    const walk = (dom, walkerFn, startNode, callbacks, endNode, skipStart = true) => {\n      let next = skipStart ? walkerFn(false) : startNode;\n      while (next) {\n        const isCefNode = isContentEditableFalse(dom, next);\n        if (isCefNode || isHidden(dom, next)) {\n          const stopWalking = isCefNode ? callbacks.cef(next) : callbacks.boundary(next);\n          if (stopWalking) {\n            break;\n          } else {\n            next = walkerFn(true);\n            continue;\n          }\n        } else if (isSimpleBoundary(dom, next)) {\n          if (callbacks.boundary(next)) {\n            break;\n          }\n        } else if (isText(next)) {\n          callbacks.text(next);\n        }\n        if (next === endNode) {\n          break;\n        } else {\n          next = walkerFn(false);\n        }\n      }\n    };\n    const collectTextToBoundary = (dom, section, node, rootNode, forwards) => {\n      var _a;\n      if (isBoundary(dom, node)) {\n        return;\n      }\n      const rootBlock = (_a = dom.getParent(rootNode, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      const walker = new global(node, rootBlock);\n      const walkerFn = forwards ? walker.next.bind(walker) : walker.prev.bind(walker);\n      walk(dom, walkerFn, node, {\n        boundary: always,\n        cef: always,\n        text: next => {\n          if (forwards) {\n            section.fOffset += next.length;\n          } else {\n            section.sOffset += next.length;\n          }\n          section.elements.push(SugarElement.fromDom(next));\n        }\n      });\n    };\n    const collect = (dom, rootNode, startNode, endNode, callbacks, skipStart = true) => {\n      const walker = new global(startNode, rootNode);\n      const sections = [];\n      let current = nuSection();\n      collectTextToBoundary(dom, current, startNode, rootNode, false);\n      const finishSection = () => {\n        if (current.elements.length > 0) {\n          sections.push(current);\n          current = nuSection();\n        }\n        return false;\n      };\n      walk(dom, walker.next.bind(walker), startNode, {\n        boundary: finishSection,\n        cef: node => {\n          finishSection();\n          if (callbacks) {\n            sections.push(...callbacks.cef(node));\n          }\n          return false;\n        },\n        text: next => {\n          current.elements.push(SugarElement.fromDom(next));\n          if (callbacks) {\n            callbacks.text(next, current);\n          }\n        }\n      }, endNode, skipStart);\n      if (endNode) {\n        collectTextToBoundary(dom, current, endNode, rootNode, true);\n      }\n      finishSection();\n      return sections;\n    };\n    const collectRangeSections = (dom, rng) => {\n      const start = toLeaf(rng.startContainer, rng.startOffset);\n      const startNode = start.element.dom;\n      const end = toLeaf(rng.endContainer, rng.endOffset);\n      const endNode = end.element.dom;\n      return collect(dom, rng.commonAncestorContainer, startNode, endNode, {\n        text: (node, section) => {\n          if (node === endNode) {\n            section.fOffset += node.length - end.offset;\n          } else if (node === startNode) {\n            section.sOffset += start.offset;\n          }\n        },\n        cef: node => {\n          const sections = bind(descendants(SugarElement.fromDom(node), '*[contenteditable=true]'), e => {\n            const ceTrueNode = e.dom;\n            return collect(dom, ceTrueNode, ceTrueNode);\n          });\n          return sort(sections, (a, b) => documentPositionPreceding(a.elements[0].dom, b.elements[0].dom) ? 1 : -1);\n        }\n      }, false);\n    };\n    const fromRng = (dom, rng) => rng.collapsed ? [] : collectRangeSections(dom, rng);\n    const fromNode = (dom, node) => {\n      const rng = dom.createRng();\n      rng.selectNode(node);\n      return fromRng(dom, rng);\n    };\n    const fromNodes = (dom, nodes) => bind(nodes, node => fromNode(dom, node));\n\n    const find$2 = (text, pattern, start = 0, finish = text.length) => {\n      const regex = pattern.regex;\n      regex.lastIndex = start;\n      const results = [];\n      let match;\n      while (match = regex.exec(text)) {\n        const matchedText = match[pattern.matchIndex];\n        const matchStart = match.index + match[0].indexOf(matchedText);\n        const matchFinish = matchStart + matchedText.length;\n        if (matchFinish > finish) {\n          break;\n        }\n        results.push({\n          start: matchStart,\n          finish: matchFinish\n        });\n        regex.lastIndex = matchFinish;\n      }\n      return results;\n    };\n    const extract = (elements, matches) => {\n      const nodePositions = foldl(elements, (acc, element) => {\n        const content = get$1(element);\n        const start = acc.last;\n        const finish = start + content.length;\n        const positions = bind(matches, (match, matchIdx) => {\n          if (match.start < finish && match.finish > start) {\n            return [{\n                element,\n                start: Math.max(start, match.start) - start,\n                finish: Math.min(finish, match.finish) - start,\n                matchId: matchIdx\n              }];\n          } else {\n            return [];\n          }\n        });\n        return {\n          results: acc.results.concat(positions),\n          last: finish\n        };\n      }, {\n        results: [],\n        last: 0\n      }).results;\n      return groupBy(nodePositions, position => position.matchId);\n    };\n\n    const find$1 = (pattern, sections) => bind(sections, section => {\n      const elements = section.elements;\n      const content = map(elements, get$1).join('');\n      const positions = find$2(content, pattern, section.sOffset, content.length - section.fOffset);\n      return extract(elements, positions);\n    });\n    const mark = (matches, replacementNode) => {\n      eachr(matches, (match, idx) => {\n        eachr(match, pos => {\n          const wrapper = SugarElement.fromDom(replacementNode.cloneNode(false));\n          set(wrapper, 'data-mce-index', idx);\n          const textNode = pos.element.dom;\n          if (textNode.length === pos.finish && pos.start === 0) {\n            wrap(pos.element, wrapper);\n          } else {\n            if (textNode.length !== pos.finish) {\n              textNode.splitText(pos.finish);\n            }\n            const matchNode = textNode.splitText(pos.start);\n            wrap(SugarElement.fromDom(matchNode), wrapper);\n          }\n        });\n      });\n    };\n    const findAndMark = (dom, pattern, node, replacementNode) => {\n      const textSections = fromNode(dom, node);\n      const matches = find$1(pattern, textSections);\n      mark(matches, replacementNode);\n      return matches.length;\n    };\n    const findAndMarkInSelection = (dom, pattern, selection, replacementNode) => {\n      const bookmark = selection.getBookmark();\n      const nodes = dom.select('td[data-mce-selected],th[data-mce-selected]');\n      const textSections = nodes.length > 0 ? fromNodes(dom, nodes) : fromRng(dom, selection.getRng());\n      const matches = find$1(pattern, textSections);\n      mark(matches, replacementNode);\n      selection.moveToBookmark(bookmark);\n      return matches.length;\n    };\n\n    const getElmIndex = elm => {\n      return elm.getAttribute('data-mce-index');\n    };\n    const markAllMatches = (editor, currentSearchState, pattern, inSelection) => {\n      const marker = editor.dom.create('span', { 'data-mce-bogus': 1 });\n      marker.className = 'mce-match-marker';\n      const node = editor.getBody();\n      done(editor, currentSearchState, false);\n      if (inSelection) {\n        return findAndMarkInSelection(editor.dom, pattern, editor.selection, marker);\n      } else {\n        return findAndMark(editor.dom, pattern, node, marker);\n      }\n    };\n    const unwrap = node => {\n      var _a;\n      const parentNode = node.parentNode;\n      if (node.firstChild) {\n        parentNode.insertBefore(node.firstChild, node);\n      }\n      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);\n    };\n    const findSpansByIndex = (editor, index) => {\n      const spans = [];\n      const nodes = global$1.toArray(editor.getBody().getElementsByTagName('span'));\n      if (nodes.length) {\n        for (let i = 0; i < nodes.length; i++) {\n          const nodeIndex = getElmIndex(nodes[i]);\n          if (nodeIndex === null || !nodeIndex.length) {\n            continue;\n          }\n          if (nodeIndex === index.toString()) {\n            spans.push(nodes[i]);\n          }\n        }\n      }\n      return spans;\n    };\n    const moveSelection = (editor, currentSearchState, forward) => {\n      const searchState = currentSearchState.get();\n      let testIndex = searchState.index;\n      const dom = editor.dom;\n      if (forward) {\n        if (testIndex + 1 === searchState.count) {\n          testIndex = 0;\n        } else {\n          testIndex++;\n        }\n      } else {\n        if (testIndex - 1 === -1) {\n          testIndex = searchState.count - 1;\n        } else {\n          testIndex--;\n        }\n      }\n      dom.removeClass(findSpansByIndex(editor, searchState.index), 'mce-match-marker-selected');\n      const spans = findSpansByIndex(editor, testIndex);\n      if (spans.length) {\n        dom.addClass(findSpansByIndex(editor, testIndex), 'mce-match-marker-selected');\n        editor.selection.scrollIntoView(spans[0]);\n        return testIndex;\n      }\n      return -1;\n    };\n    const removeNode = (dom, node) => {\n      const parent = node.parentNode;\n      dom.remove(node);\n      if (parent && dom.isEmpty(parent)) {\n        dom.remove(parent);\n      }\n    };\n    const escapeSearchText = (text, wholeWord) => {\n      const escapedText = text.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&').replace(/\\s/g, '[^\\\\S\\\\r\\\\n\\\\uFEFF]');\n      const wordRegex = '(' + escapedText + ')';\n      return wholeWord ? `(?:^|\\\\s|${ punctuation() })` + wordRegex + `(?=$|\\\\s|${ punctuation() })` : wordRegex;\n    };\n    const find = (editor, currentSearchState, text, matchCase, wholeWord, inSelection) => {\n      const selection = editor.selection;\n      const escapedText = escapeSearchText(text, wholeWord);\n      const isForwardSelection = selection.isForward();\n      const pattern = {\n        regex: new RegExp(escapedText, matchCase ? 'g' : 'gi'),\n        matchIndex: 1\n      };\n      const count = markAllMatches(editor, currentSearchState, pattern, inSelection);\n      if (global$2.browser.isSafari()) {\n        selection.setRng(selection.getRng(), isForwardSelection);\n      }\n      if (count) {\n        const newIndex = moveSelection(editor, currentSearchState, true);\n        currentSearchState.set({\n          index: newIndex,\n          count,\n          text,\n          matchCase,\n          wholeWord,\n          inSelection\n        });\n      }\n      return count;\n    };\n    const next = (editor, currentSearchState) => {\n      const index = moveSelection(editor, currentSearchState, true);\n      currentSearchState.set({\n        ...currentSearchState.get(),\n        index\n      });\n    };\n    const prev = (editor, currentSearchState) => {\n      const index = moveSelection(editor, currentSearchState, false);\n      currentSearchState.set({\n        ...currentSearchState.get(),\n        index\n      });\n    };\n    const isMatchSpan = node => {\n      const matchIndex = getElmIndex(node);\n      return matchIndex !== null && matchIndex.length > 0;\n    };\n    const replace = (editor, currentSearchState, text, forward, all) => {\n      const searchState = currentSearchState.get();\n      const currentIndex = searchState.index;\n      let currentMatchIndex, nextIndex = currentIndex;\n      forward = forward !== false;\n      const node = editor.getBody();\n      const nodes = global$1.grep(global$1.toArray(node.getElementsByTagName('span')), isMatchSpan);\n      for (let i = 0; i < nodes.length; i++) {\n        const nodeIndex = getElmIndex(nodes[i]);\n        let matchIndex = currentMatchIndex = parseInt(nodeIndex, 10);\n        if (all || matchIndex === searchState.index) {\n          if (text.length) {\n            nodes[i].innerText = text;\n            unwrap(nodes[i]);\n          } else {\n            removeNode(editor.dom, nodes[i]);\n          }\n          while (nodes[++i]) {\n            matchIndex = parseInt(getElmIndex(nodes[i]), 10);\n            if (matchIndex === currentMatchIndex) {\n              removeNode(editor.dom, nodes[i]);\n            } else {\n              i--;\n              break;\n            }\n          }\n          if (forward) {\n            nextIndex--;\n          }\n        } else if (currentMatchIndex > currentIndex) {\n          nodes[i].setAttribute('data-mce-index', String(currentMatchIndex - 1));\n        }\n      }\n      currentSearchState.set({\n        ...searchState,\n        count: all ? 0 : searchState.count - 1,\n        index: nextIndex\n      });\n      if (forward) {\n        next(editor, currentSearchState);\n      } else {\n        prev(editor, currentSearchState);\n      }\n      return !all && currentSearchState.get().count > 0;\n    };\n    const done = (editor, currentSearchState, keepEditorSelection) => {\n      let startContainer;\n      let endContainer;\n      const searchState = currentSearchState.get();\n      const nodes = global$1.toArray(editor.getBody().getElementsByTagName('span'));\n      for (let i = 0; i < nodes.length; i++) {\n        const nodeIndex = getElmIndex(nodes[i]);\n        if (nodeIndex !== null && nodeIndex.length) {\n          if (nodeIndex === searchState.index.toString()) {\n            if (!startContainer) {\n              startContainer = nodes[i].firstChild;\n            }\n            endContainer = nodes[i].firstChild;\n          }\n          unwrap(nodes[i]);\n        }\n      }\n      currentSearchState.set({\n        ...searchState,\n        index: -1,\n        count: 0,\n        text: ''\n      });\n      if (startContainer && endContainer) {\n        const rng = editor.dom.createRng();\n        rng.setStart(startContainer, 0);\n        rng.setEnd(endContainer, endContainer.data.length);\n        if (keepEditorSelection !== false) {\n          editor.selection.setRng(rng);\n        }\n        return rng;\n      } else {\n        return undefined;\n      }\n    };\n    const hasNext = (editor, currentSearchState) => currentSearchState.get().count > 1;\n    const hasPrev = (editor, currentSearchState) => currentSearchState.get().count > 1;\n\n    const get = (editor, currentState) => {\n      const done$1 = keepEditorSelection => {\n        return done(editor, currentState, keepEditorSelection);\n      };\n      const find$1 = (text, matchCase, wholeWord, inSelection = false) => {\n        return find(editor, currentState, text, matchCase, wholeWord, inSelection);\n      };\n      const next$1 = () => {\n        return next(editor, currentState);\n      };\n      const prev$1 = () => {\n        return prev(editor, currentState);\n      };\n      const replace$1 = (text, forward, all) => {\n        return replace(editor, currentState, text, forward, all);\n      };\n      return {\n        done: done$1,\n        find: find$1,\n        next: next$1,\n        prev: prev$1,\n        replace: replace$1\n      };\n    };\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const open = (editor, currentSearchState) => {\n      const dialogApi = value();\n      editor.undoManager.add();\n      const selectedText = global$1.trim(editor.selection.getContent({ format: 'text' }));\n      const updateButtonStates = api => {\n        api.setEnabled('next', hasNext(editor, currentSearchState));\n        api.setEnabled('prev', hasPrev(editor, currentSearchState));\n      };\n      const updateSearchState = api => {\n        const data = api.getData();\n        const current = currentSearchState.get();\n        currentSearchState.set({\n          ...current,\n          matchCase: data.matchcase,\n          wholeWord: data.wholewords,\n          inSelection: data.inselection\n        });\n      };\n      const disableAll = (api, disable) => {\n        const buttons = [\n          'replace',\n          'replaceall',\n          'prev',\n          'next'\n        ];\n        const toggle = name => api.setEnabled(name, !disable);\n        each(buttons, toggle);\n      };\n      const toggleNotFoundAlert = (isVisible, api) => {\n        api.redial(getDialogSpec(isVisible, api.getData()));\n      };\n      const focusButtonIfRequired = (api, name) => {\n        if (global$2.browser.isSafari() && global$2.deviceType.isTouch() && (name === 'find' || name === 'replace' || name === 'replaceall')) {\n          api.focus(name);\n        }\n      };\n      const reset = api => {\n        done(editor, currentSearchState, false);\n        disableAll(api, true);\n        updateButtonStates(api);\n      };\n      const doFind = api => {\n        const data = api.getData();\n        const last = currentSearchState.get();\n        if (!data.findtext.length) {\n          reset(api);\n          return;\n        }\n        if (last.text === data.findtext && last.matchCase === data.matchcase && last.wholeWord === data.wholewords) {\n          next(editor, currentSearchState);\n        } else {\n          const count = find(editor, currentSearchState, data.findtext, data.matchcase, data.wholewords, data.inselection);\n          if (count <= 0) {\n            toggleNotFoundAlert(true, api);\n          }\n          disableAll(api, count === 0);\n        }\n        updateButtonStates(api);\n      };\n      const initialState = currentSearchState.get();\n      const initialData = {\n        findtext: selectedText,\n        replacetext: '',\n        wholewords: initialState.wholeWord,\n        matchcase: initialState.matchCase,\n        inselection: initialState.inSelection\n      };\n      const getPanelItems = error => {\n        const items = [\n          {\n            type: 'bar',\n            items: [\n              {\n                type: 'input',\n                name: 'findtext',\n                placeholder: 'Find',\n                maximized: true,\n                inputMode: 'search'\n              },\n              {\n                type: 'button',\n                name: 'prev',\n                text: 'Previous',\n                icon: 'action-prev',\n                enabled: false,\n                borderless: true\n              },\n              {\n                type: 'button',\n                name: 'next',\n                text: 'Next',\n                icon: 'action-next',\n                enabled: false,\n                borderless: true\n              }\n            ]\n          },\n          {\n            type: 'input',\n            name: 'replacetext',\n            placeholder: 'Replace with',\n            inputMode: 'search'\n          }\n        ];\n        if (error) {\n          items.push({\n            type: 'alertbanner',\n            level: 'error',\n            text: 'Could not find the specified string.',\n            icon: 'warning'\n          });\n        }\n        return items;\n      };\n      const getDialogSpec = (showNoMatchesAlertBanner, initialData) => ({\n        title: 'Find and Replace',\n        size: 'normal',\n        body: {\n          type: 'panel',\n          items: getPanelItems(showNoMatchesAlertBanner)\n        },\n        buttons: [\n          {\n            type: 'menu',\n            name: 'options',\n            icon: 'preferences',\n            tooltip: 'Preferences',\n            align: 'start',\n            items: [\n              {\n                type: 'togglemenuitem',\n                name: 'matchcase',\n                text: 'Match case'\n              },\n              {\n                type: 'togglemenuitem',\n                name: 'wholewords',\n                text: 'Find whole words only'\n              },\n              {\n                type: 'togglemenuitem',\n                name: 'inselection',\n                text: 'Find in selection'\n              }\n            ]\n          },\n          {\n            type: 'custom',\n            name: 'find',\n            text: 'Find',\n            primary: true\n          },\n          {\n            type: 'custom',\n            name: 'replace',\n            text: 'Replace',\n            enabled: false\n          },\n          {\n            type: 'custom',\n            name: 'replaceall',\n            text: 'Replace all',\n            enabled: false\n          }\n        ],\n        initialData,\n        onChange: (api, details) => {\n          if (showNoMatchesAlertBanner) {\n            toggleNotFoundAlert(false, api);\n          }\n          if (details.name === 'findtext' && currentSearchState.get().count > 0) {\n            reset(api);\n          }\n        },\n        onAction: (api, details) => {\n          const data = api.getData();\n          switch (details.name) {\n          case 'find':\n            doFind(api);\n            break;\n          case 'replace':\n            if (!replace(editor, currentSearchState, data.replacetext)) {\n              reset(api);\n            } else {\n              updateButtonStates(api);\n            }\n            break;\n          case 'replaceall':\n            replace(editor, currentSearchState, data.replacetext, true, true);\n            reset(api);\n            break;\n          case 'prev':\n            prev(editor, currentSearchState);\n            updateButtonStates(api);\n            break;\n          case 'next':\n            next(editor, currentSearchState);\n            updateButtonStates(api);\n            break;\n          case 'matchcase':\n          case 'wholewords':\n          case 'inselection':\n            toggleNotFoundAlert(false, api);\n            updateSearchState(api);\n            reset(api);\n            break;\n          }\n          focusButtonIfRequired(api, details.name);\n        },\n        onSubmit: api => {\n          doFind(api);\n          focusButtonIfRequired(api, 'find');\n        },\n        onClose: () => {\n          editor.focus();\n          done(editor, currentSearchState);\n          editor.undoManager.add();\n        }\n      });\n      dialogApi.set(editor.windowManager.open(getDialogSpec(false, initialData), { inline: 'toolbar' }));\n    };\n\n    const register$1 = (editor, currentSearchState) => {\n      editor.addCommand('SearchReplace', () => {\n        open(editor, currentSearchState);\n      });\n    };\n\n    const showDialog = (editor, currentSearchState) => () => {\n      open(editor, currentSearchState);\n    };\n    const register = (editor, currentSearchState) => {\n      editor.ui.registry.addMenuItem('searchreplace', {\n        text: 'Find and replace...',\n        shortcut: 'Meta+F',\n        onAction: showDialog(editor, currentSearchState),\n        icon: 'search'\n      });\n      editor.ui.registry.addButton('searchreplace', {\n        tooltip: 'Find and replace',\n        onAction: showDialog(editor, currentSearchState),\n        icon: 'search'\n      });\n      editor.shortcuts.add('Meta+F', '', showDialog(editor, currentSearchState));\n    };\n\n    var Plugin = () => {\n      global$3.add('searchreplace', editor => {\n        const currentSearchState = Cell({\n          index: -1,\n          count: 0,\n          text: '',\n          matchCase: false,\n          wholeWord: false,\n          inSelection: false\n        });\n        register$1(editor, currentSearchState);\n        register(editor, currentSearchState);\n        return get(editor, currentSearchState);\n      });\n    };\n\n    Plugin();\n\n})();\n"],"names":["Cell","initial","value","v","global$3","hasProto","constructor","predicate","_a","typeOf","x","o","proto","isType$1","type","isSimpleType","isString","isArray","isBoolean","isNullable","a","isNonNullable","isNumber","noop","constant","always","punctuation$1","Optional","tag","onNone","onSome","mapper","binder","replacement","thunk","message","worker","punctuation","global$2","global$1","nativeSlice","nativePush","map","xs","f","len","r","i","each","eachr","groupBy","wasType","group","foldl","acc","flatten","bind","sort","comparator","copy","hasOwnProperty","has","obj","key","DOCUMENT","DOCUMENT_FRAGMENT","ELEMENT","TEXT","element","isText$1","t","rawSet","dom","set","fromHtml","html","scope","div","fromDom","fromTag","node","fromText","text","SugarElement","docElm","y","bypassSelector","all","selector","base","parent","children","spot","offset","leaf","cs","before","marker","append","wrap","wrapper","api","is","name","get","getOption","get$1","compareDocumentPosition","b","match","documentPositionPreceding","descendants","global","isSimpleBoundary","isContentEditableFalse","isContentEditableTrueInCef","isHidden","isBoundary","isText","nuSection","toLeaf","walk","walkerFn","startNode","callbacks","endNode","skipStart","next","isCefNode","collectTextToBoundary","section","rootNode","forwards","rootBlock","walker","collect","sections","current","finishSection","collectRangeSections","rng","start","end","e","ceTrueNode","fromRng","fromNode","fromNodes","nodes","find$2","pattern","finish","regex","results","matchedText","matchStart","matchFinish","extract","elements","matches","nodePositions","content","positions","matchIdx","position","find$1","mark","replacementNode","idx","pos","textNode","matchNode","findAndMark","textSections","findAndMarkInSelection","selection","bookmark","getElmIndex","elm","markAllMatches","editor","currentSearchState","inSelection","done","unwrap","parentNode","findSpansByIndex","index","spans","nodeIndex","moveSelection","forward","searchState","testIndex","removeNode","escapeSearchText","wholeWord","wordRegex","find","matchCase","escapedText","isForwardSelection","count","newIndex","prev","isMatchSpan","matchIndex","replace","currentIndex","currentMatchIndex","nextIndex","keepEditorSelection","startContainer","endContainer","hasNext","hasPrev","currentState","singleton","doRevoke","subject","revoke","s","open","dialogApi","selectedText","updateButtonStates","updateSearchState","data","disableAll","disable","toggleNotFoundAlert","isVisible","getDialogSpec","focusButtonIfRequired","reset","doFind","last","initialState","initialData","getPanelItems","error","items","showNoMatchesAlertBanner","details","register$1","showDialog","register","Plugin"],"mappings":"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","x_google_ignoreList":[0]}