{"version":3,"file":"index-BF--wtrE.cjs","sources":["../node_modules/.pnpm/tinymce@6.8.6/node_modules/tinymce/plugins/lists/plugin.js"],"sourcesContent":["/**\n * TinyMCE version 6.8.6 (TBD)\n */\n\n(function () {\n    'use strict';\n\n    var global$7 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isArray = isType$1('array');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    const noop = () => {\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const never = constant(false);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains$1 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const map = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$1 = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const filter$1 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const groupBy = (xs, f) => {\n      if (xs.length === 0) {\n        return [];\n      } else {\n        let wasType = f(xs[0]);\n        const r = [];\n        let group = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n          const x = xs[i];\n          const type = f(x);\n          if (type !== wasType) {\n            r.push(group);\n            group = [];\n          }\n          wasType = type;\n          group.push(x);\n        }\n        if (group.length !== 0) {\n          r.push(group);\n        }\n        return r;\n      }\n    };\n    const foldl = (xs, f, acc) => {\n      each$1(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find = (xs, pred) => {\n      return findUntil(xs, pred, never);\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind = (xs, f) => flatten(map(xs, f));\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const get$1 = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$1(xs, 0);\n    const last = xs => get$1(xs, xs.length - 1);\n    const unique = (xs, comparator) => {\n      const r = [];\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$1(r, x);\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (!isDuplicated(x)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$1(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$1(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$1(node);\n    };\n    const fromDom$1 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);\n    const SugarElement = {\n      fromHtml,\n      fromTag,\n      fromText,\n      fromDom: fromDom$1,\n      fromPoint\n    };\n\n    const is$1 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n    const is = is$1;\n\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const path = (parts, scope) => {\n      let o = scope !== undefined && scope !== null ? scope : Global;\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n        o = o[parts[i]];\n      }\n      return o;\n    };\n    const resolve = (p, scope) => {\n      const parts = p.split('.');\n      return path(parts, scope);\n    };\n\n    const unsafe = (name, scope) => {\n      return resolve(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n      const actual = unsafe(name, scope);\n      if (actual === undefined || actual === null) {\n        throw new Error(name + ' not available on this browser');\n      }\n      return actual;\n    };\n\n    const getPrototypeOf = Object.getPrototypeOf;\n    const sandHTMLElement = scope => {\n      return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = x => {\n      const scope = resolve('ownerDocument.defaultView', x);\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf(x).constructor.name));\n    };\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type = element => element.dom.nodeType;\n    const isType = t => element => type(element) === t;\n    const isComment = element => type(element) === COMMENT || name(element) === '#comment';\n    const isHTMLElement = element => isElement$1(element) && isPrototypeOf(element.dom);\n    const isElement$1 = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocument = isType(DOCUMENT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement$1(e) && name(e) === tag;\n\n    const owner = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument(dos) ? dos : owner(dos);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const children = element => map(element.dom.childNodes, SugarElement.fromDom);\n    const child = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child(element, 0);\n    const lastChild = element => child(element, element.dom.childNodes.length - 1);\n\n    const isShadowRoot = dos => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n\n    const inBody = element => {\n      const dom = isText(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$3 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$2 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$3, scope, predicate, isRoot);\n    };\n\n    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, e => is$1(e, selector), isRoot);\n    const closest$1 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$1(element, selector);\n      return ClosestOrAncestor(is, ancestor$2, scope, selector, isRoot);\n    };\n\n    const closest = target => closest$1(target, '[contenteditable]');\n    const isEditable = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest(element).fold(constant(assumeEditable), editable => getRaw(editable) === 'true');\n      }\n    };\n    const getRaw = element => element.dom.contentEditable;\n\n    const before$1 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$1(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n\n    const before = (marker, elements) => {\n      each$1(elements, x => {\n        before$1(marker, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$1(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$1(children(element), rogue => {\n        remove(rogue);\n      });\n    };\n    const remove = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n\n    var global$6 = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils');\n\n    var global$5 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.util.VK');\n\n    const fromDom = nodes => map(nodes, SugarElement.fromDom);\n\n    const keys = Object.keys;\n    const each = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const filter = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const setAll = (element, attrs) => {\n      const dom = element.dom;\n      each(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const clone$1 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const clone = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const deep = original => clone(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$1(original);\n      setAll(nu, attributes);\n      return nu;\n    };\n    const mutate = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after(original, nu);\n      const children$1 = children(original);\n      append(nu, children$1);\n      remove(original);\n      return nu;\n    };\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const matchNodeName = name => node => isNonNullable(node) && node.nodeName.toLowerCase() === name;\n    const matchNodeNames = regex => node => isNonNullable(node) && regex.test(node.nodeName);\n    const isTextNode$1 = node => isNonNullable(node) && node.nodeType === 3;\n    const isElement = node => isNonNullable(node) && node.nodeType === 1;\n    const isListNode = matchNodeNames(/^(OL|UL|DL)$/);\n    const isOlUlNode = matchNodeNames(/^(OL|UL)$/);\n    const isOlNode = matchNodeName('ol');\n    const isListItemNode = matchNodeNames(/^(LI|DT|DD)$/);\n    const isDlItemNode = matchNodeNames(/^(DT|DD)$/);\n    const isTableCellNode = matchNodeNames(/^(TH|TD)$/);\n    const isBr = matchNodeName('br');\n    const isFirstChild = node => {\n      var _a;\n      return ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === node;\n    };\n    const isTextBlock = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getTextBlockElements();\n    const isBlock = (node, blockElements) => isNonNullable(node) && node.nodeName in blockElements;\n    const isVoid = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getVoidElements();\n    const isBogusBr = (dom, node) => {\n      if (!isBr(node)) {\n        return false;\n      }\n      return dom.isBlock(node.nextSibling) && !isBr(node.previousSibling);\n    };\n    const isEmpty$2 = (dom, elm, keepBookmarks) => {\n      const empty = dom.isEmpty(elm);\n      if (keepBookmarks && dom.select('span[data-mce-type=bookmark]', elm).length > 0) {\n        return false;\n      }\n      return empty;\n    };\n    const isChildOfBody = (dom, elm) => dom.isChildOf(elm, dom.getRoot());\n\n    const option = name => editor => editor.options.get(name);\n    const register$3 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('lists_indent_on_tab', {\n        processor: 'boolean',\n        default: true\n      });\n    };\n    const shouldIndentOnTab = option('lists_indent_on_tab');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n\n    const createTextBlock = (editor, contentNode) => {\n      const dom = editor.dom;\n      const blockElements = editor.schema.getBlockElements();\n      const fragment = dom.createFragment();\n      const blockName = getForcedRootBlock(editor);\n      const blockAttrs = getForcedRootBlockAttrs(editor);\n      let node;\n      let textBlock;\n      let hasContentNode = false;\n      textBlock = dom.create(blockName, blockAttrs);\n      if (!isBlock(contentNode.firstChild, blockElements)) {\n        fragment.appendChild(textBlock);\n      }\n      while (node = contentNode.firstChild) {\n        const nodeName = node.nodeName;\n        if (!hasContentNode && (nodeName !== 'SPAN' || node.getAttribute('data-mce-type') !== 'bookmark')) {\n          hasContentNode = true;\n        }\n        if (isBlock(node, blockElements)) {\n          fragment.appendChild(node);\n          textBlock = null;\n        } else {\n          if (!textBlock) {\n            textBlock = dom.create(blockName, blockAttrs);\n            fragment.appendChild(textBlock);\n          }\n          textBlock.appendChild(node);\n        }\n      }\n      if (!hasContentNode && textBlock) {\n        textBlock.appendChild(dom.create('br', { 'data-mce-bogus': '1' }));\n      }\n      return fragment;\n    };\n\n    const DOM$2 = global$3.DOM;\n    const splitList = (editor, list, li) => {\n      const removeAndKeepBookmarks = targetNode => {\n        const parent = targetNode.parentNode;\n        if (parent) {\n          global$2.each(bookmarks, node => {\n            parent.insertBefore(node, li.parentNode);\n          });\n        }\n        DOM$2.remove(targetNode);\n      };\n      const bookmarks = DOM$2.select('span[data-mce-type=\"bookmark\"]', list);\n      const newBlock = createTextBlock(editor, li);\n      const tmpRng = DOM$2.createRng();\n      tmpRng.setStartAfter(li);\n      tmpRng.setEndAfter(list);\n      const fragment = tmpRng.extractContents();\n      for (let node = fragment.firstChild; node; node = node.firstChild) {\n        if (node.nodeName === 'LI' && editor.dom.isEmpty(node)) {\n          DOM$2.remove(node);\n          break;\n        }\n      }\n      if (!editor.dom.isEmpty(fragment)) {\n        DOM$2.insertAfter(fragment, list);\n      }\n      DOM$2.insertAfter(newBlock, list);\n      const parent = li.parentElement;\n      if (parent && isEmpty$2(editor.dom, parent)) {\n        removeAndKeepBookmarks(parent);\n      }\n      DOM$2.remove(li);\n      if (isEmpty$2(editor.dom, list)) {\n        DOM$2.remove(list);\n      }\n    };\n\n    const isDescriptionDetail = isTag('dd');\n    const isDescriptionTerm = isTag('dt');\n    const outdentDlItem = (editor, item) => {\n      if (isDescriptionDetail(item)) {\n        mutate(item, 'dt');\n      } else if (isDescriptionTerm(item)) {\n        parentElement(item).each(dl => splitList(editor, dl.dom, item.dom));\n      }\n    };\n    const indentDlItem = item => {\n      if (isDescriptionTerm(item)) {\n        mutate(item, 'dd');\n      }\n    };\n    const dlIndentation = (editor, indentation, dlItems) => {\n      if (indentation === 'Indent') {\n        each$1(dlItems, indentDlItem);\n      } else {\n        each$1(dlItems, item => outdentDlItem(editor, item));\n      }\n    };\n\n    const getNormalizedPoint = (container, offset) => {\n      if (isTextNode$1(container)) {\n        return {\n          container,\n          offset\n        };\n      }\n      const node = global$6.getNode(container, offset);\n      if (isTextNode$1(node)) {\n        return {\n          container: node,\n          offset: offset >= container.childNodes.length ? node.data.length : 0\n        };\n      } else if (node.previousSibling && isTextNode$1(node.previousSibling)) {\n        return {\n          container: node.previousSibling,\n          offset: node.previousSibling.data.length\n        };\n      } else if (node.nextSibling && isTextNode$1(node.nextSibling)) {\n        return {\n          container: node.nextSibling,\n          offset: 0\n        };\n      }\n      return {\n        container,\n        offset\n      };\n    };\n    const normalizeRange = rng => {\n      const outRng = rng.cloneRange();\n      const rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);\n      outRng.setStart(rangeStart.container, rangeStart.offset);\n      const rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);\n      outRng.setEnd(rangeEnd.container, rangeEnd.offset);\n      return outRng;\n    };\n\n    const listNames = [\n      'OL',\n      'UL',\n      'DL'\n    ];\n    const listSelector = listNames.join(',');\n    const getParentList = (editor, node) => {\n      const selectionStart = node || editor.selection.getStart(true);\n      return editor.dom.getParent(selectionStart, listSelector, getClosestListHost(editor, selectionStart));\n    };\n    const isParentListSelected = (parentList, selectedBlocks) => isNonNullable(parentList) && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;\n    const findSubLists = parentList => filter$1(parentList.querySelectorAll(listSelector), isListNode);\n    const getSelectedSubLists = editor => {\n      const parentList = getParentList(editor);\n      const selectedBlocks = editor.selection.getSelectedBlocks();\n      if (isParentListSelected(parentList, selectedBlocks)) {\n        return findSubLists(parentList);\n      } else {\n        return filter$1(selectedBlocks, elm => {\n          return isListNode(elm) && parentList !== elm;\n        });\n      }\n    };\n    const findParentListItemsNodes = (editor, elms) => {\n      const listItemsElms = global$2.map(elms, elm => {\n        const parentLi = editor.dom.getParent(elm, 'li,dd,dt', getClosestListHost(editor, elm));\n        return parentLi ? parentLi : elm;\n      });\n      return unique(listItemsElms);\n    };\n    const getSelectedListItems = editor => {\n      const selectedBlocks = editor.selection.getSelectedBlocks();\n      return filter$1(findParentListItemsNodes(editor, selectedBlocks), isListItemNode);\n    };\n    const getSelectedDlItems = editor => filter$1(getSelectedListItems(editor), isDlItemNode);\n    const getClosestEditingHost = (editor, elm) => {\n      const parentTableCell = editor.dom.getParents(elm, 'TD,TH');\n      return parentTableCell.length > 0 ? parentTableCell[0] : editor.getBody();\n    };\n    const isListHost = (schema, node) => !isListNode(node) && !isListItemNode(node) && exists(listNames, listName => schema.isValidChild(node.nodeName, listName));\n    const getClosestListHost = (editor, elm) => {\n      const parentBlocks = editor.dom.getParents(elm, editor.dom.isBlock);\n      const parentBlock = find(parentBlocks, elm => isListHost(editor.schema, elm));\n      return parentBlock.getOr(editor.getBody());\n    };\n    const isListInsideAnLiWithFirstAndLastNotListElement = list => parent(list).exists(parent => isListItemNode(parent.dom) && firstChild(parent).exists(firstChild => !isListNode(firstChild.dom)) && lastChild(parent).exists(lastChild => !isListNode(lastChild.dom)));\n    const findLastParentListNode = (editor, elm) => {\n      const parentLists = editor.dom.getParents(elm, 'ol,ul', getClosestListHost(editor, elm));\n      return last(parentLists);\n    };\n    const getSelectedLists = editor => {\n      const firstList = findLastParentListNode(editor, editor.selection.getStart());\n      const subsequentLists = filter$1(editor.selection.getSelectedBlocks(), isOlUlNode);\n      return firstList.toArray().concat(subsequentLists);\n    };\n    const getParentLists = editor => {\n      const elm = editor.selection.getStart();\n      return editor.dom.getParents(elm, 'ol,ul', getClosestListHost(editor, elm));\n    };\n    const getSelectedListRoots = editor => {\n      const selectedLists = getSelectedLists(editor);\n      const parentLists = getParentLists(editor);\n      return find(parentLists, p => isListInsideAnLiWithFirstAndLastNotListElement(SugarElement.fromDom(p))).fold(() => getUniqueListRoots(editor, selectedLists), l => [l]);\n    };\n    const getUniqueListRoots = (editor, lists) => {\n      const listRoots = map(lists, list => findLastParentListNode(editor, list).getOr(list));\n      return unique(listRoots);\n    };\n\n    const isCustomList = list => /\\btox\\-/.test(list.className);\n    const inList = (parents, listName) => findUntil(parents, isListNode, isTableCellNode).exists(list => list.nodeName === listName && !isCustomList(list));\n    const isWithinNonEditable = (editor, element) => element !== null && !editor.dom.isEditable(element);\n    const selectionIsWithinNonEditableList = editor => {\n      const parentList = getParentList(editor);\n      return isWithinNonEditable(editor, parentList);\n    };\n    const isWithinNonEditableList = (editor, element) => {\n      const parentList = editor.dom.getParent(element, 'ol,ul,dl');\n      return isWithinNonEditable(editor, parentList);\n    };\n    const setNodeChangeHandler = (editor, nodeChangeHandler) => {\n      const initialNode = editor.selection.getNode();\n      nodeChangeHandler({\n        parents: editor.dom.getParents(initialNode),\n        element: initialNode\n      });\n      editor.on('NodeChange', nodeChangeHandler);\n      return () => editor.off('NodeChange', nodeChangeHandler);\n    };\n\n    const fromElements = (elements, scope) => {\n      const doc = scope || document;\n      const fragment = doc.createDocumentFragment();\n      each$1(elements, element => {\n        fragment.appendChild(element.dom);\n      });\n      return SugarElement.fromDom(fragment);\n    };\n\n    const fireListEvent = (editor, action, element) => editor.dispatch('ListMutation', {\n      action,\n      element\n    });\n\n    const blank = r => s => s.replace(r, '');\n    const trim = blank(/^\\s+|\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty$1 = s => !isNotEmpty(s);\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const set = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n\n    const isList = el => is(el, 'OL,UL');\n    const isListItem = el => is(el, 'LI');\n    const hasFirstChildList = el => firstChild(el).exists(isList);\n    const hasLastChildList = el => lastChild(el).exists(isList);\n\n    const isEntryList = entry => 'listAttributes' in entry;\n    const isEntryComment = entry => 'isComment' in entry;\n    const isEntryFragment = entry => 'isFragment' in entry;\n    const isIndented = entry => entry.depth > 0;\n    const isSelected = entry => entry.isSelected;\n    const cloneItemContent = li => {\n      const children$1 = children(li);\n      const content = hasLastChildList(li) ? children$1.slice(0, -1) : children$1;\n      return map(content, deep);\n    };\n    const createEntry = (li, depth, isSelected) => parent(li).filter(isElement$1).map(list => ({\n      depth,\n      dirty: false,\n      isSelected,\n      content: cloneItemContent(li),\n      itemAttributes: clone$1(li),\n      listAttributes: clone$1(list),\n      listType: name(list),\n      isInPreviousLi: false\n    }));\n\n    const joinSegment = (parent, child) => {\n      append$1(parent.item, child.list);\n    };\n    const joinSegments = segments => {\n      for (let i = 1; i < segments.length; i++) {\n        joinSegment(segments[i - 1], segments[i]);\n      }\n    };\n    const appendSegments = (head$1, tail) => {\n      lift2(last(head$1), head(tail), joinSegment);\n    };\n    const createSegment = (scope, listType) => {\n      const segment = {\n        list: SugarElement.fromTag(listType, scope),\n        item: SugarElement.fromTag('li', scope)\n      };\n      append$1(segment.list, segment.item);\n      return segment;\n    };\n    const createSegments = (scope, entry, size) => {\n      const segments = [];\n      for (let i = 0; i < size; i++) {\n        segments.push(createSegment(scope, isEntryList(entry) ? entry.listType : entry.parentListType));\n      }\n      return segments;\n    };\n    const populateSegments = (segments, entry) => {\n      for (let i = 0; i < segments.length - 1; i++) {\n        set(segments[i].item, 'list-style-type', 'none');\n      }\n      last(segments).each(segment => {\n        if (isEntryList(entry)) {\n          setAll(segment.list, entry.listAttributes);\n          setAll(segment.item, entry.itemAttributes);\n        }\n        append(segment.item, entry.content);\n      });\n    };\n    const normalizeSegment = (segment, entry) => {\n      if (name(segment.list) !== entry.listType) {\n        segment.list = mutate(segment.list, entry.listType);\n      }\n      setAll(segment.list, entry.listAttributes);\n    };\n    const createItem = (scope, attr, content) => {\n      const item = SugarElement.fromTag('li', scope);\n      setAll(item, attr);\n      append(item, content);\n      return item;\n    };\n    const appendItem = (segment, item) => {\n      append$1(segment.list, item);\n      segment.item = item;\n    };\n    const writeShallow = (scope, cast, entry) => {\n      const newCast = cast.slice(0, entry.depth);\n      last(newCast).each(segment => {\n        if (isEntryList(entry)) {\n          const item = createItem(scope, entry.itemAttributes, entry.content);\n          appendItem(segment, item);\n          normalizeSegment(segment, entry);\n        } else if (isEntryFragment(entry)) {\n          append(segment.item, entry.content);\n        } else {\n          const item = SugarElement.fromHtml(`<!--${ entry.content }-->`);\n          append$1(segment.list, item);\n        }\n      });\n      return newCast;\n    };\n    const writeDeep = (scope, cast, entry) => {\n      const segments = createSegments(scope, entry, entry.depth - cast.length);\n      joinSegments(segments);\n      populateSegments(segments, entry);\n      appendSegments(cast, segments);\n      return cast.concat(segments);\n    };\n    const composeList = (scope, entries) => {\n      let firstCommentEntryOpt = Optional.none();\n      const cast = foldl(entries, (cast, entry, i) => {\n        if (!isEntryComment(entry)) {\n          return entry.depth > cast.length ? writeDeep(scope, cast, entry) : writeShallow(scope, cast, entry);\n        } else {\n          if (i === 0) {\n            firstCommentEntryOpt = Optional.some(entry);\n            return cast;\n          }\n          return writeShallow(scope, cast, entry);\n        }\n      }, []);\n      firstCommentEntryOpt.each(firstCommentEntry => {\n        const item = SugarElement.fromHtml(`<!--${ firstCommentEntry.content }-->`);\n        head(cast).each(fistCast => {\n          prepend(fistCast.list, item);\n        });\n      });\n      return head(cast).map(segment => segment.list);\n    };\n\n    const indentEntry = (indentation, entry) => {\n      switch (indentation) {\n      case 'Indent':\n        entry.depth++;\n        break;\n      case 'Outdent':\n        entry.depth--;\n        break;\n      case 'Flatten':\n        entry.depth = 0;\n      }\n      entry.dirty = true;\n    };\n\n    const cloneListProperties = (target, source) => {\n      if (isEntryList(target) && isEntryList(source)) {\n        target.listType = source.listType;\n        target.listAttributes = { ...source.listAttributes };\n      }\n    };\n    const cleanListProperties = entry => {\n      entry.listAttributes = filter(entry.listAttributes, (_value, key) => key !== 'start');\n    };\n    const closestSiblingEntry = (entries, start) => {\n      const depth = entries[start].depth;\n      const matches = entry => entry.depth === depth && !entry.dirty;\n      const until = entry => entry.depth < depth;\n      return findUntil(reverse(entries.slice(0, start)), matches, until).orThunk(() => findUntil(entries.slice(start + 1), matches, until));\n    };\n    const normalizeEntries = entries => {\n      each$1(entries, (entry, i) => {\n        closestSiblingEntry(entries, i).fold(() => {\n          if (entry.dirty && isEntryList(entry)) {\n            cleanListProperties(entry);\n          }\n        }, matchingEntry => cloneListProperties(entry, matchingEntry));\n      });\n      return entries;\n    };\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const parseSingleItem = (depth, itemSelection, selectionState, item) => {\n      var _a;\n      if (isComment(item)) {\n        return [{\n            depth: depth + 1,\n            content: (_a = item.dom.nodeValue) !== null && _a !== void 0 ? _a : '',\n            dirty: false,\n            isSelected: false,\n            isComment: true\n          }];\n      }\n      itemSelection.each(selection => {\n        if (eq(selection.start, item)) {\n          selectionState.set(true);\n        }\n      });\n      const currentItemEntry = createEntry(item, depth, selectionState.get());\n      itemSelection.each(selection => {\n        if (eq(selection.end, item)) {\n          selectionState.set(false);\n        }\n      });\n      const childListEntries = lastChild(item).filter(isList).map(list => parseList(depth, itemSelection, selectionState, list)).getOr([]);\n      return currentItemEntry.toArray().concat(childListEntries);\n    };\n    const parseItem = (depth, itemSelection, selectionState, item) => firstChild(item).filter(isList).fold(() => parseSingleItem(depth, itemSelection, selectionState, item), list => {\n      const parsedSiblings = foldl(children(item), (acc, liChild, i) => {\n        if (i === 0) {\n          return acc;\n        } else {\n          if (isListItem(liChild)) {\n            return acc.concat(parseSingleItem(depth, itemSelection, selectionState, liChild));\n          } else {\n            const fragment = {\n              isFragment: true,\n              depth,\n              content: [liChild],\n              isSelected: false,\n              dirty: false,\n              parentListType: name(list)\n            };\n            return acc.concat(fragment);\n          }\n        }\n      }, []);\n      return parseList(depth, itemSelection, selectionState, list).concat(parsedSiblings);\n    });\n    const parseList = (depth, itemSelection, selectionState, list) => bind(children(list), element => {\n      const parser = isList(element) ? parseList : parseItem;\n      const newDepth = depth + 1;\n      return parser(newDepth, itemSelection, selectionState, element);\n    });\n    const parseLists = (lists, itemSelection) => {\n      const selectionState = Cell(false);\n      const initialDepth = 0;\n      return map(lists, list => ({\n        sourceList: list,\n        entries: parseList(initialDepth, itemSelection, selectionState, list)\n      }));\n    };\n\n    const outdentedComposer = (editor, entries) => {\n      const normalizedEntries = normalizeEntries(entries);\n      return map(normalizedEntries, entry => {\n        const content = !isEntryComment(entry) ? fromElements(entry.content) : fromElements([SugarElement.fromHtml(`<!--${ entry.content }-->`)]);\n        return SugarElement.fromDom(createTextBlock(editor, content.dom));\n      });\n    };\n    const indentedComposer = (editor, entries) => {\n      const normalizedEntries = normalizeEntries(entries);\n      return composeList(editor.contentDocument, normalizedEntries).toArray();\n    };\n    const composeEntries = (editor, entries) => bind(groupBy(entries, isIndented), entries => {\n      const groupIsIndented = head(entries).exists(isIndented);\n      return groupIsIndented ? indentedComposer(editor, entries) : outdentedComposer(editor, entries);\n    });\n    const indentSelectedEntries = (entries, indentation) => {\n      each$1(filter$1(entries, isSelected), entry => indentEntry(indentation, entry));\n    };\n    const getItemSelection = editor => {\n      const selectedListItems = map(getSelectedListItems(editor), SugarElement.fromDom);\n      return lift2(find(selectedListItems, not(hasFirstChildList)), find(reverse(selectedListItems), not(hasFirstChildList)), (start, end) => ({\n        start,\n        end\n      }));\n    };\n    const listIndentation = (editor, lists, indentation) => {\n      const entrySets = parseLists(lists, getItemSelection(editor));\n      each$1(entrySets, entrySet => {\n        indentSelectedEntries(entrySet.entries, indentation);\n        const composedLists = composeEntries(editor, entrySet.entries);\n        each$1(composedLists, composedList => {\n          fireListEvent(editor, indentation === 'Indent' ? 'IndentList' : 'OutdentList', composedList.dom);\n        });\n        before(entrySet.sourceList, composedLists);\n        remove(entrySet.sourceList);\n      });\n    };\n\n    const selectionIndentation = (editor, indentation) => {\n      const lists = fromDom(getSelectedListRoots(editor));\n      const dlItems = fromDom(getSelectedDlItems(editor));\n      let isHandled = false;\n      if (lists.length || dlItems.length) {\n        const bookmark = editor.selection.getBookmark();\n        listIndentation(editor, lists, indentation);\n        dlIndentation(editor, indentation, dlItems);\n        editor.selection.moveToBookmark(bookmark);\n        editor.selection.setRng(normalizeRange(editor.selection.getRng()));\n        editor.nodeChanged();\n        isHandled = true;\n      }\n      return isHandled;\n    };\n    const handleIndentation = (editor, indentation) => !selectionIsWithinNonEditableList(editor) && selectionIndentation(editor, indentation);\n    const indentListSelection = editor => handleIndentation(editor, 'Indent');\n    const outdentListSelection = editor => handleIndentation(editor, 'Outdent');\n    const flattenListSelection = editor => handleIndentation(editor, 'Flatten');\n\n    const zeroWidth = '\\uFEFF';\n    const isZwsp = char => char === zeroWidth;\n\n    const ancestor$1 = (scope, predicate, isRoot) => ancestor$3(scope, predicate, isRoot).isSome();\n\n    const ancestor = (element, target) => ancestor$1(element, curry(eq, target));\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.dom.BookmarkManager');\n\n    const DOM$1 = global$3.DOM;\n    const createBookmark = rng => {\n      const bookmark = {};\n      const setupEndPoint = start => {\n        let container = rng[start ? 'startContainer' : 'endContainer'];\n        let offset = rng[start ? 'startOffset' : 'endOffset'];\n        if (isElement(container)) {\n          const offsetNode = DOM$1.create('span', { 'data-mce-type': 'bookmark' });\n          if (container.hasChildNodes()) {\n            offset = Math.min(offset, container.childNodes.length - 1);\n            if (start) {\n              container.insertBefore(offsetNode, container.childNodes[offset]);\n            } else {\n              DOM$1.insertAfter(offsetNode, container.childNodes[offset]);\n            }\n          } else {\n            container.appendChild(offsetNode);\n          }\n          container = offsetNode;\n          offset = 0;\n        }\n        bookmark[start ? 'startContainer' : 'endContainer'] = container;\n        bookmark[start ? 'startOffset' : 'endOffset'] = offset;\n      };\n      setupEndPoint(true);\n      if (!rng.collapsed) {\n        setupEndPoint();\n      }\n      return bookmark;\n    };\n    const resolveBookmark = bookmark => {\n      const restoreEndPoint = start => {\n        const nodeIndex = container => {\n          var _a;\n          let node = (_a = container.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild;\n          let idx = 0;\n          while (node) {\n            if (node === container) {\n              return idx;\n            }\n            if (!isElement(node) || node.getAttribute('data-mce-type') !== 'bookmark') {\n              idx++;\n            }\n            node = node.nextSibling;\n          }\n          return -1;\n        };\n        let container = bookmark[start ? 'startContainer' : 'endContainer'];\n        let offset = bookmark[start ? 'startOffset' : 'endOffset'];\n        if (!container) {\n          return;\n        }\n        if (isElement(container) && container.parentNode) {\n          const node = container;\n          offset = nodeIndex(container);\n          container = container.parentNode;\n          DOM$1.remove(node);\n          if (!container.hasChildNodes() && DOM$1.isBlock(container)) {\n            container.appendChild(DOM$1.create('br'));\n          }\n        }\n        bookmark[start ? 'startContainer' : 'endContainer'] = container;\n        bookmark[start ? 'startOffset' : 'endOffset'] = offset;\n      };\n      restoreEndPoint(true);\n      restoreEndPoint();\n      const rng = DOM$1.createRng();\n      rng.setStart(bookmark.startContainer, bookmark.startOffset);\n      if (bookmark.endContainer) {\n        rng.setEnd(bookmark.endContainer, bookmark.endOffset);\n      }\n      return normalizeRange(rng);\n    };\n\n    const listToggleActionFromListName = listName => {\n      switch (listName) {\n      case 'UL':\n        return 'ToggleUlList';\n      case 'OL':\n        return 'ToggleOlList';\n      case 'DL':\n        return 'ToggleDLList';\n      }\n    };\n\n    const updateListStyle = (dom, el, detail) => {\n      const type = detail['list-style-type'] ? detail['list-style-type'] : null;\n      dom.setStyle(el, 'list-style-type', type);\n    };\n    const setAttribs = (elm, attrs) => {\n      global$2.each(attrs, (value, key) => {\n        elm.setAttribute(key, value);\n      });\n    };\n    const updateListAttrs = (dom, el, detail) => {\n      setAttribs(el, detail['list-attributes']);\n      global$2.each(dom.select('li', el), li => {\n        setAttribs(li, detail['list-item-attributes']);\n      });\n    };\n    const updateListWithDetails = (dom, el, detail) => {\n      updateListStyle(dom, el, detail);\n      updateListAttrs(dom, el, detail);\n    };\n    const removeStyles = (dom, element, styles) => {\n      global$2.each(styles, style => dom.setStyle(element, style, ''));\n    };\n    const isInline = (editor, node) => isNonNullable(node) && !isBlock(node, editor.schema.getBlockElements());\n    const getEndPointNode = (editor, rng, start, root) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      const offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement(container)) {\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n      }\n      if (!start && isBr(container.nextSibling)) {\n        container = container.nextSibling;\n      }\n      const findBlockAncestor = node => {\n        while (!editor.dom.isBlock(node) && node.parentNode && root !== node) {\n          node = node.parentNode;\n        }\n        return node;\n      };\n      const findBetterContainer = (container, forward) => {\n        var _a;\n        const walker = new global$5(container, findBlockAncestor(container));\n        const dir = forward ? 'next' : 'prev';\n        let node;\n        while (node = walker[dir]()) {\n          if (!(isVoid(editor, node) || isZwsp(node.textContent) || ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) === 0)) {\n            return Optional.some(node);\n          }\n        }\n        return Optional.none();\n      };\n      if (start && isTextNode$1(container)) {\n        if (isZwsp(container.textContent)) {\n          container = findBetterContainer(container, false).getOr(container);\n        } else {\n          if (container.parentNode !== null && isInline(editor, container.parentNode)) {\n            container = container.parentNode;\n          }\n          while (container.previousSibling !== null && (isInline(editor, container.previousSibling) || isTextNode$1(container.previousSibling))) {\n            container = container.previousSibling;\n          }\n        }\n      }\n      if (!start && isTextNode$1(container)) {\n        if (isZwsp(container.textContent)) {\n          container = findBetterContainer(container, true).getOr(container);\n        } else {\n          if (container.parentNode !== null && isInline(editor, container.parentNode)) {\n            container = container.parentNode;\n          }\n          while (container.nextSibling !== null && (isInline(editor, container.nextSibling) || isTextNode$1(container.nextSibling))) {\n            container = container.nextSibling;\n          }\n        }\n      }\n      while (container.parentNode !== root) {\n        const parent = container.parentNode;\n        if (isTextBlock(editor, container)) {\n          return container;\n        }\n        if (/^(TD|TH)$/.test(parent.nodeName)) {\n          return container;\n        }\n        container = parent;\n      }\n      return container;\n    };\n    const getSelectedTextBlocks = (editor, rng, root) => {\n      const textBlocks = [];\n      const dom = editor.dom;\n      const startNode = getEndPointNode(editor, rng, true, root);\n      const endNode = getEndPointNode(editor, rng, false, root);\n      let block;\n      const siblings = [];\n      for (let node = startNode; node; node = node.nextSibling) {\n        siblings.push(node);\n        if (node === endNode) {\n          break;\n        }\n      }\n      global$2.each(siblings, node => {\n        var _a;\n        if (isTextBlock(editor, node)) {\n          textBlocks.push(node);\n          block = null;\n          return;\n        }\n        if (dom.isBlock(node) || isBr(node)) {\n          if (isBr(node)) {\n            dom.remove(node);\n          }\n          block = null;\n          return;\n        }\n        const nextSibling = node.nextSibling;\n        if (global$1.isBookmarkNode(node)) {\n          if (isListNode(nextSibling) || isTextBlock(editor, nextSibling) || !nextSibling && node.parentNode === root) {\n            block = null;\n            return;\n          }\n        }\n        if (!block) {\n          block = dom.create('p');\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(block, node);\n          textBlocks.push(block);\n        }\n        block.appendChild(node);\n      });\n      return textBlocks;\n    };\n    const hasCompatibleStyle = (dom, sib, detail) => {\n      const sibStyle = dom.getStyle(sib, 'list-style-type');\n      let detailStyle = detail ? detail['list-style-type'] : '';\n      detailStyle = detailStyle === null ? '' : detailStyle;\n      return sibStyle === detailStyle;\n    };\n    const getRootSearchStart = (editor, range) => {\n      const start = editor.selection.getStart(true);\n      const startPoint = getEndPointNode(editor, range, true, editor.getBody());\n      if (ancestor(SugarElement.fromDom(startPoint), SugarElement.fromDom(range.commonAncestorContainer))) {\n        return range.commonAncestorContainer;\n      } else {\n        return start;\n      }\n    };\n    const applyList = (editor, listName, detail) => {\n      const rng = editor.selection.getRng();\n      let listItemName = 'LI';\n      const root = getClosestListHost(editor, getRootSearchStart(editor, rng));\n      const dom = editor.dom;\n      if (dom.getContentEditable(editor.selection.getNode()) === 'false') {\n        return;\n      }\n      listName = listName.toUpperCase();\n      if (listName === 'DL') {\n        listItemName = 'DT';\n      }\n      const bookmark = createBookmark(rng);\n      const selectedTextBlocks = filter$1(getSelectedTextBlocks(editor, rng, root), editor.dom.isEditable);\n      global$2.each(selectedTextBlocks, block => {\n        let listBlock;\n        const sibling = block.previousSibling;\n        const parent = block.parentNode;\n        if (!isListItemNode(parent)) {\n          if (sibling && isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {\n            listBlock = sibling;\n            block = dom.rename(block, listItemName);\n            sibling.appendChild(block);\n          } else {\n            listBlock = dom.create(listName);\n            parent.insertBefore(listBlock, block);\n            listBlock.appendChild(block);\n            block = dom.rename(block, listItemName);\n          }\n          removeStyles(dom, block, [\n            'margin',\n            'margin-right',\n            'margin-bottom',\n            'margin-left',\n            'margin-top',\n            'padding',\n            'padding-right',\n            'padding-bottom',\n            'padding-left',\n            'padding-top'\n          ]);\n          updateListWithDetails(dom, listBlock, detail);\n          mergeWithAdjacentLists(editor.dom, listBlock);\n        }\n      });\n      editor.selection.setRng(resolveBookmark(bookmark));\n    };\n    const isValidLists = (list1, list2) => {\n      return isListNode(list1) && list1.nodeName === (list2 === null || list2 === void 0 ? void 0 : list2.nodeName);\n    };\n    const hasSameListStyle = (dom, list1, list2) => {\n      const targetStyle = dom.getStyle(list1, 'list-style-type', true);\n      const style = dom.getStyle(list2, 'list-style-type', true);\n      return targetStyle === style;\n    };\n    const hasSameClasses = (elm1, elm2) => {\n      return elm1.className === elm2.className;\n    };\n    const shouldMerge = (dom, list1, list2) => {\n      return isValidLists(list1, list2) && hasSameListStyle(dom, list1, list2) && hasSameClasses(list1, list2);\n    };\n    const mergeWithAdjacentLists = (dom, listBlock) => {\n      let node;\n      let sibling = listBlock.nextSibling;\n      if (shouldMerge(dom, listBlock, sibling)) {\n        const liSibling = sibling;\n        while (node = liSibling.firstChild) {\n          listBlock.appendChild(node);\n        }\n        dom.remove(liSibling);\n      }\n      sibling = listBlock.previousSibling;\n      if (shouldMerge(dom, listBlock, sibling)) {\n        const liSibling = sibling;\n        while (node = liSibling.lastChild) {\n          listBlock.insertBefore(node, listBlock.firstChild);\n        }\n        dom.remove(liSibling);\n      }\n    };\n    const updateList$1 = (editor, list, listName, detail) => {\n      if (list.nodeName !== listName) {\n        const newList = editor.dom.rename(list, listName);\n        updateListWithDetails(editor.dom, newList, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), newList);\n      } else {\n        updateListWithDetails(editor.dom, list, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), list);\n      }\n    };\n    const updateCustomList = (editor, list, listName, detail) => {\n      list.classList.forEach((cls, _, classList) => {\n        if (cls.startsWith('tox-')) {\n          classList.remove(cls);\n          if (classList.length === 0) {\n            list.removeAttribute('class');\n          }\n        }\n      });\n      if (list.nodeName !== listName) {\n        const newList = editor.dom.rename(list, listName);\n        updateListWithDetails(editor.dom, newList, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), newList);\n      } else {\n        updateListWithDetails(editor.dom, list, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), list);\n      }\n    };\n    const toggleMultipleLists = (editor, parentList, lists, listName, detail) => {\n      const parentIsList = isListNode(parentList);\n      if (parentIsList && parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {\n        flattenListSelection(editor);\n      } else {\n        applyList(editor, listName, detail);\n        const bookmark = createBookmark(editor.selection.getRng());\n        const allLists = parentIsList ? [\n          parentList,\n          ...lists\n        ] : lists;\n        const updateFunction = parentIsList && isCustomList(parentList) ? updateCustomList : updateList$1;\n        global$2.each(allLists, elm => {\n          updateFunction(editor, elm, listName, detail);\n        });\n        editor.selection.setRng(resolveBookmark(bookmark));\n      }\n    };\n    const hasListStyleDetail = detail => {\n      return 'list-style-type' in detail;\n    };\n    const toggleSingleList = (editor, parentList, listName, detail) => {\n      if (parentList === editor.getBody()) {\n        return;\n      }\n      if (parentList) {\n        if (parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {\n          flattenListSelection(editor);\n        } else {\n          const bookmark = createBookmark(editor.selection.getRng());\n          if (isCustomList(parentList)) {\n            parentList.classList.forEach((cls, _, classList) => {\n              if (cls.startsWith('tox-')) {\n                classList.remove(cls);\n                if (classList.length === 0) {\n                  parentList.removeAttribute('class');\n                }\n              }\n            });\n          }\n          updateListWithDetails(editor.dom, parentList, detail);\n          const newList = editor.dom.rename(parentList, listName);\n          mergeWithAdjacentLists(editor.dom, newList);\n          editor.selection.setRng(resolveBookmark(bookmark));\n          applyList(editor, listName, detail);\n          fireListEvent(editor, listToggleActionFromListName(listName), newList);\n        }\n      } else {\n        applyList(editor, listName, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), parentList);\n      }\n    };\n    const toggleList = (editor, listName, _detail) => {\n      const parentList = getParentList(editor);\n      if (isWithinNonEditableList(editor, parentList)) {\n        return;\n      }\n      const selectedSubLists = getSelectedSubLists(editor);\n      const detail = isObject(_detail) ? _detail : {};\n      if (selectedSubLists.length > 0) {\n        toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);\n      } else {\n        toggleSingleList(editor, parentList, listName, detail);\n      }\n    };\n\n    const DOM = global$3.DOM;\n    const normalizeList = (dom, list) => {\n      const parentNode = list.parentElement;\n      if (parentNode && parentNode.nodeName === 'LI' && parentNode.firstChild === list) {\n        const sibling = parentNode.previousSibling;\n        if (sibling && sibling.nodeName === 'LI') {\n          sibling.appendChild(list);\n          if (isEmpty$2(dom, parentNode)) {\n            DOM.remove(parentNode);\n          }\n        } else {\n          DOM.setStyle(parentNode, 'listStyleType', 'none');\n        }\n      }\n      if (isListNode(parentNode)) {\n        const sibling = parentNode.previousSibling;\n        if (sibling && sibling.nodeName === 'LI') {\n          sibling.appendChild(list);\n        }\n      }\n    };\n    const normalizeLists = (dom, element) => {\n      const lists = global$2.grep(dom.select('ol,ul', element));\n      global$2.each(lists, list => {\n        normalizeList(dom, list);\n      });\n    };\n\n    const findNextCaretContainer = (editor, rng, isForward, root) => {\n      let node = rng.startContainer;\n      const offset = rng.startOffset;\n      if (isTextNode$1(node) && (isForward ? offset < node.data.length : offset > 0)) {\n        return node;\n      }\n      const nonEmptyBlocks = editor.schema.getNonEmptyElements();\n      if (isElement(node)) {\n        node = global$6.getNode(node, offset);\n      }\n      const walker = new global$5(node, root);\n      if (isForward) {\n        if (isBogusBr(editor.dom, node)) {\n          walker.next();\n        }\n      }\n      const walkFn = isForward ? walker.next.bind(walker) : walker.prev2.bind(walker);\n      while (node = walkFn()) {\n        if (node.nodeName === 'LI' && !node.hasChildNodes()) {\n          return node;\n        }\n        if (nonEmptyBlocks[node.nodeName]) {\n          return node;\n        }\n        if (isTextNode$1(node) && node.data.length > 0) {\n          return node;\n        }\n      }\n      return null;\n    };\n    const hasOnlyOneBlockChild = (dom, elm) => {\n      const childNodes = elm.childNodes;\n      return childNodes.length === 1 && !isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);\n    };\n    const isUnwrappable = node => Optional.from(node).map(SugarElement.fromDom).filter(isHTMLElement).exists(el => isEditable(el) && !contains$1(['details'], name(el)));\n    const unwrapSingleBlockChild = (dom, elm) => {\n      if (hasOnlyOneBlockChild(dom, elm) && isUnwrappable(elm.firstChild)) {\n        dom.remove(elm.firstChild, true);\n      }\n    };\n    const moveChildren = (dom, fromElm, toElm) => {\n      let node;\n      const targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;\n      unwrapSingleBlockChild(dom, fromElm);\n      if (!isEmpty$2(dom, fromElm, true)) {\n        while (node = fromElm.firstChild) {\n          targetElm.appendChild(node);\n        }\n      }\n    };\n    const mergeLiElements = (dom, fromElm, toElm) => {\n      let listNode;\n      const ul = fromElm.parentNode;\n      if (!isChildOfBody(dom, fromElm) || !isChildOfBody(dom, toElm)) {\n        return;\n      }\n      if (isListNode(toElm.lastChild)) {\n        listNode = toElm.lastChild;\n      }\n      if (ul === toElm.lastChild) {\n        if (isBr(ul.previousSibling)) {\n          dom.remove(ul.previousSibling);\n        }\n      }\n      const node = toElm.lastChild;\n      if (node && isBr(node) && fromElm.hasChildNodes()) {\n        dom.remove(node);\n      }\n      if (isEmpty$2(dom, toElm, true)) {\n        empty(SugarElement.fromDom(toElm));\n      }\n      moveChildren(dom, fromElm, toElm);\n      if (listNode) {\n        toElm.appendChild(listNode);\n      }\n      const contains$1 = contains(SugarElement.fromDom(toElm), SugarElement.fromDom(fromElm));\n      const nestedLists = contains$1 ? dom.getParents(fromElm, isListNode, toElm) : [];\n      dom.remove(fromElm);\n      each$1(nestedLists, list => {\n        if (isEmpty$2(dom, list) && list !== dom.getRoot()) {\n          dom.remove(list);\n        }\n      });\n    };\n    const mergeIntoEmptyLi = (editor, fromLi, toLi) => {\n      empty(SugarElement.fromDom(toLi));\n      mergeLiElements(editor.dom, fromLi, toLi);\n      editor.selection.setCursorLocation(toLi, 0);\n    };\n    const mergeForward = (editor, rng, fromLi, toLi) => {\n      const dom = editor.dom;\n      if (dom.isEmpty(toLi)) {\n        mergeIntoEmptyLi(editor, fromLi, toLi);\n      } else {\n        const bookmark = createBookmark(rng);\n        mergeLiElements(dom, fromLi, toLi);\n        editor.selection.setRng(resolveBookmark(bookmark));\n      }\n    };\n    const mergeBackward = (editor, rng, fromLi, toLi) => {\n      const bookmark = createBookmark(rng);\n      mergeLiElements(editor.dom, fromLi, toLi);\n      const resolvedBookmark = resolveBookmark(bookmark);\n      editor.selection.setRng(resolvedBookmark);\n    };\n    const backspaceDeleteFromListToListCaret = (editor, isForward) => {\n      const dom = editor.dom, selection = editor.selection;\n      const selectionStartElm = selection.getStart();\n      const root = getClosestEditingHost(editor, selectionStartElm);\n      const li = dom.getParent(selection.getStart(), 'LI', root);\n      if (li) {\n        const ul = li.parentElement;\n        if (ul === editor.getBody() && isEmpty$2(dom, ul)) {\n          return true;\n        }\n        const rng = normalizeRange(selection.getRng());\n        const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);\n        const willMergeParentIntoChild = otherLi && (isForward ? dom.isChildOf(li, otherLi) : dom.isChildOf(otherLi, li));\n        if (otherLi && otherLi !== li && !willMergeParentIntoChild) {\n          editor.undoManager.transact(() => {\n            if (isForward) {\n              mergeForward(editor, rng, otherLi, li);\n            } else {\n              if (isFirstChild(li)) {\n                outdentListSelection(editor);\n              } else {\n                mergeBackward(editor, rng, li, otherLi);\n              }\n            }\n          });\n          return true;\n        } else if (willMergeParentIntoChild && !isForward && otherLi !== li) {\n          editor.undoManager.transact(() => {\n            if (rng.commonAncestorContainer.parentElement) {\n              const bookmark = createBookmark(rng);\n              const oldParentElRef = rng.commonAncestorContainer.parentElement;\n              moveChildren(dom, rng.commonAncestorContainer.parentElement, otherLi);\n              oldParentElRef.remove();\n              const resolvedBookmark = resolveBookmark(bookmark);\n              editor.selection.setRng(resolvedBookmark);\n            }\n          });\n          return true;\n        } else if (!otherLi) {\n          if (!isForward && rng.startOffset === 0 && rng.endOffset === 0) {\n            editor.undoManager.transact(() => {\n              flattenListSelection(editor);\n            });\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const removeBlock = (dom, block, root) => {\n      const parentBlock = dom.getParent(block.parentNode, dom.isBlock, root);\n      dom.remove(block);\n      if (parentBlock && dom.isEmpty(parentBlock)) {\n        dom.remove(parentBlock);\n      }\n    };\n    const backspaceDeleteIntoListCaret = (editor, isForward) => {\n      const dom = editor.dom;\n      const selectionStartElm = editor.selection.getStart();\n      const root = getClosestEditingHost(editor, selectionStartElm);\n      const block = dom.getParent(selectionStartElm, dom.isBlock, root);\n      if (block && dom.isEmpty(block)) {\n        const rng = normalizeRange(editor.selection.getRng());\n        const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);\n        if (otherLi) {\n          const findValidElement = element => contains$1([\n            'td',\n            'th',\n            'caption'\n          ], name(element));\n          const findRoot = node => node.dom === root;\n          const otherLiCell = closest$2(SugarElement.fromDom(otherLi), findValidElement, findRoot);\n          const caretCell = closest$2(SugarElement.fromDom(rng.startContainer), findValidElement, findRoot);\n          if (!equals(otherLiCell, caretCell, eq)) {\n            return false;\n          }\n          editor.undoManager.transact(() => {\n            const parentNode = otherLi.parentNode;\n            removeBlock(dom, block, root);\n            mergeWithAdjacentLists(dom, parentNode);\n            editor.selection.select(otherLi, true);\n            editor.selection.collapse(isForward);\n          });\n          return true;\n        }\n      }\n      return false;\n    };\n    const backspaceDeleteCaret = (editor, isForward) => {\n      return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);\n    };\n    const hasListSelection = editor => {\n      const selectionStartElm = editor.selection.getStart();\n      const root = getClosestEditingHost(editor, selectionStartElm);\n      const startListParent = editor.dom.getParent(selectionStartElm, 'LI,DT,DD', root);\n      return startListParent || getSelectedListItems(editor).length > 0;\n    };\n    const backspaceDeleteRange = editor => {\n      if (hasListSelection(editor)) {\n        editor.undoManager.transact(() => {\n          editor.execCommand('Delete');\n          normalizeLists(editor.dom, editor.getBody());\n        });\n        return true;\n      }\n      return false;\n    };\n    const backspaceDelete = (editor, isForward) => {\n      const selection = editor.selection;\n      return !isWithinNonEditableList(editor, selection.getNode()) && (selection.isCollapsed() ? backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor));\n    };\n    const setup$2 = editor => {\n      editor.on('ExecCommand', e => {\n        const cmd = e.command.toLowerCase();\n        if ((cmd === 'delete' || cmd === 'forwarddelete') && hasListSelection(editor)) {\n          normalizeLists(editor.dom, editor.getBody());\n        }\n      });\n      editor.on('keydown', e => {\n        if (e.keyCode === global$4.BACKSPACE) {\n          if (backspaceDelete(editor, false)) {\n            e.preventDefault();\n          }\n        } else if (e.keyCode === global$4.DELETE) {\n          if (backspaceDelete(editor, true)) {\n            e.preventDefault();\n          }\n        }\n      });\n    };\n\n    const get = editor => ({\n      backspaceDelete: isForward => {\n        backspaceDelete(editor, isForward);\n      }\n    });\n\n    const updateList = (editor, update) => {\n      const parentList = getParentList(editor);\n      if (parentList === null || isWithinNonEditableList(editor, parentList)) {\n        return;\n      }\n      editor.undoManager.transact(() => {\n        if (isObject(update.styles)) {\n          editor.dom.setStyles(parentList, update.styles);\n        }\n        if (isObject(update.attrs)) {\n          each(update.attrs, (v, k) => editor.dom.setAttrib(parentList, k, v));\n        }\n      });\n    };\n\n    const parseAlphabeticBase26 = str => {\n      const chars = reverse(trim(str).split(''));\n      const values = map(chars, (char, i) => {\n        const charValue = char.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0) + 1;\n        return Math.pow(26, i) * charValue;\n      });\n      return foldl(values, (sum, v) => sum + v, 0);\n    };\n    const composeAlphabeticBase26 = value => {\n      value--;\n      if (value < 0) {\n        return '';\n      } else {\n        const remainder = value % 26;\n        const quotient = Math.floor(value / 26);\n        const rest = composeAlphabeticBase26(quotient);\n        const char = String.fromCharCode('A'.charCodeAt(0) + remainder);\n        return rest + char;\n      }\n    };\n    const isUppercase = str => /^[A-Z]+$/.test(str);\n    const isLowercase = str => /^[a-z]+$/.test(str);\n    const isNumeric = str => /^[0-9]+$/.test(str);\n    const deduceListType = start => {\n      if (isNumeric(start)) {\n        return 2;\n      } else if (isUppercase(start)) {\n        return 0;\n      } else if (isLowercase(start)) {\n        return 1;\n      } else if (isEmpty$1(start)) {\n        return 3;\n      } else {\n        return 4;\n      }\n    };\n    const parseStartValue = start => {\n      switch (deduceListType(start)) {\n      case 2:\n        return Optional.some({\n          listStyleType: Optional.none(),\n          start\n        });\n      case 0:\n        return Optional.some({\n          listStyleType: Optional.some('upper-alpha'),\n          start: parseAlphabeticBase26(start).toString()\n        });\n      case 1:\n        return Optional.some({\n          listStyleType: Optional.some('lower-alpha'),\n          start: parseAlphabeticBase26(start).toString()\n        });\n      case 3:\n        return Optional.some({\n          listStyleType: Optional.none(),\n          start: ''\n        });\n      case 4:\n        return Optional.none();\n      }\n    };\n    const parseDetail = detail => {\n      const start = parseInt(detail.start, 10);\n      if (is$2(detail.listStyleType, 'upper-alpha')) {\n        return composeAlphabeticBase26(start);\n      } else if (is$2(detail.listStyleType, 'lower-alpha')) {\n        return composeAlphabeticBase26(start).toLowerCase();\n      } else {\n        return detail.start;\n      }\n    };\n\n    const open = editor => {\n      const currentList = getParentList(editor);\n      if (!isOlNode(currentList) || isWithinNonEditableList(editor, currentList)) {\n        return;\n      }\n      editor.windowManager.open({\n        title: 'List Properties',\n        body: {\n          type: 'panel',\n          items: [{\n              type: 'input',\n              name: 'start',\n              label: 'Start list at number',\n              inputMode: 'numeric'\n            }]\n        },\n        initialData: {\n          start: parseDetail({\n            start: editor.dom.getAttrib(currentList, 'start', '1'),\n            listStyleType: Optional.from(editor.dom.getStyle(currentList, 'list-style-type'))\n          })\n        },\n        buttons: [\n          {\n            type: 'cancel',\n            name: 'cancel',\n            text: 'Cancel'\n          },\n          {\n            type: 'submit',\n            name: 'save',\n            text: 'Save',\n            primary: true\n          }\n        ],\n        onSubmit: api => {\n          const data = api.getData();\n          parseStartValue(data.start).each(detail => {\n            editor.execCommand('mceListUpdate', false, {\n              attrs: { start: detail.start === '1' ? '' : detail.start },\n              styles: { 'list-style-type': detail.listStyleType.getOr('') }\n            });\n          });\n          api.close();\n        }\n      });\n    };\n\n    const queryListCommandState = (editor, listName) => () => {\n      const parentList = getParentList(editor);\n      return isNonNullable(parentList) && parentList.nodeName === listName;\n    };\n    const registerDialog = editor => {\n      editor.addCommand('mceListProps', () => {\n        open(editor);\n      });\n    };\n    const register$2 = editor => {\n      editor.on('BeforeExecCommand', e => {\n        const cmd = e.command.toLowerCase();\n        if (cmd === 'indent') {\n          indentListSelection(editor);\n        } else if (cmd === 'outdent') {\n          outdentListSelection(editor);\n        }\n      });\n      editor.addCommand('InsertUnorderedList', (ui, detail) => {\n        toggleList(editor, 'UL', detail);\n      });\n      editor.addCommand('InsertOrderedList', (ui, detail) => {\n        toggleList(editor, 'OL', detail);\n      });\n      editor.addCommand('InsertDefinitionList', (ui, detail) => {\n        toggleList(editor, 'DL', detail);\n      });\n      editor.addCommand('RemoveList', () => {\n        flattenListSelection(editor);\n      });\n      registerDialog(editor);\n      editor.addCommand('mceListUpdate', (ui, detail) => {\n        if (isObject(detail)) {\n          updateList(editor, detail);\n        }\n      });\n      editor.addQueryStateHandler('InsertUnorderedList', queryListCommandState(editor, 'UL'));\n      editor.addQueryStateHandler('InsertOrderedList', queryListCommandState(editor, 'OL'));\n      editor.addQueryStateHandler('InsertDefinitionList', queryListCommandState(editor, 'DL'));\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.html.Node');\n\n    const isTextNode = node => node.type === 3;\n    const isEmpty = nodeBuffer => nodeBuffer.length === 0;\n    const wrapInvalidChildren = list => {\n      const insertListItem = (buffer, refNode) => {\n        const li = global.create('li');\n        each$1(buffer, node => li.append(node));\n        if (refNode) {\n          list.insert(li, refNode, true);\n        } else {\n          list.append(li);\n        }\n      };\n      const reducer = (buffer, node) => {\n        if (isTextNode(node)) {\n          return [\n            ...buffer,\n            node\n          ];\n        } else if (!isEmpty(buffer) && !isTextNode(node)) {\n          insertListItem(buffer, node);\n          return [];\n        } else {\n          return buffer;\n        }\n      };\n      const restBuffer = foldl(list.children(), reducer, []);\n      if (!isEmpty(restBuffer)) {\n        insertListItem(restBuffer);\n      }\n    };\n    const setup$1 = editor => {\n      editor.on('PreInit', () => {\n        const {parser} = editor;\n        parser.addNodeFilter('ul,ol', nodes => each$1(nodes, wrapInvalidChildren));\n      });\n    };\n\n    const setupTabKey = editor => {\n      editor.on('keydown', e => {\n        if (e.keyCode !== global$4.TAB || global$4.metaKeyPressed(e)) {\n          return;\n        }\n        editor.undoManager.transact(() => {\n          if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) {\n            e.preventDefault();\n          }\n        });\n      });\n    };\n    const setup = editor => {\n      if (shouldIndentOnTab(editor)) {\n        setupTabKey(editor);\n      }\n      setup$2(editor);\n    };\n\n    const setupToggleButtonHandler = (editor, listName) => api => {\n      const toggleButtonHandler = e => {\n        api.setActive(inList(e.parents, listName));\n        api.setEnabled(!isWithinNonEditableList(editor, e.element) && editor.selection.isEditable());\n      };\n      api.setEnabled(editor.selection.isEditable());\n      return setNodeChangeHandler(editor, toggleButtonHandler);\n    };\n    const register$1 = editor => {\n      const exec = command => () => editor.execCommand(command);\n      if (!editor.hasPlugin('advlist')) {\n        editor.ui.registry.addToggleButton('numlist', {\n          icon: 'ordered-list',\n          active: false,\n          tooltip: 'Numbered list',\n          onAction: exec('InsertOrderedList'),\n          onSetup: setupToggleButtonHandler(editor, 'OL')\n        });\n        editor.ui.registry.addToggleButton('bullist', {\n          icon: 'unordered-list',\n          active: false,\n          tooltip: 'Bullet list',\n          onAction: exec('InsertUnorderedList'),\n          onSetup: setupToggleButtonHandler(editor, 'UL')\n        });\n      }\n    };\n\n    const setupMenuButtonHandler = (editor, listName) => api => {\n      const menuButtonHandler = e => api.setEnabled(inList(e.parents, listName) && !isWithinNonEditableList(editor, e.element));\n      return setNodeChangeHandler(editor, menuButtonHandler);\n    };\n    const register = editor => {\n      const listProperties = {\n        text: 'List properties...',\n        icon: 'ordered-list',\n        onAction: () => editor.execCommand('mceListProps'),\n        onSetup: setupMenuButtonHandler(editor, 'OL')\n      };\n      editor.ui.registry.addMenuItem('listprops', listProperties);\n      editor.ui.registry.addContextMenu('lists', {\n        update: node => {\n          const parentList = getParentList(editor, node);\n          return isOlNode(parentList) ? ['listprops'] : [];\n        }\n      });\n    };\n\n    var Plugin = () => {\n      global$7.add('lists', editor => {\n        register$3(editor);\n        setup$1(editor);\n        if (!editor.hasPlugin('rtc', true)) {\n          setup(editor);\n          register$2(editor);\n        } else {\n          registerDialog(editor);\n        }\n        register$1(editor);\n        register(editor);\n        return get(editor);\n      });\n    };\n\n    Plugin();\n\n})();\n"],"names":["global$7","hasProto","v","constructor","predicate","_a","typeOf","x","t","o","proto","isType$1","type","value","isSimpleType","isString","isObject","isArray","isBoolean","isNullable","a","isNonNullable","isFunction","isNumber","noop","compose1","fbc","fab","constant","tripleEquals","b","curry","fn","initialArgs","restArgs","all","not","f","never","Optional","tag","onNone","onSome","mapper","binder","replacement","thunk","message","worker","nativeSlice","nativeIndexOf","nativePush","rawIndexOf","ts","contains$1","xs","exists","pred","i","len","map","r","each$1","filter$1","groupBy","wasType","group","foldl","acc","findUntil","until","find","flatten","bind","reverse","get$1","head","last","unique","comparator","isDuplicated","is$2","lhs","rhs","left","equals","lift2","oa","ob","COMMENT","DOCUMENT","DOCUMENT_FRAGMENT","ELEMENT","TEXT","fromHtml","html","scope","div","fromDom$1","fromTag","node","fromText","text","SugarElement","docElm","y","is$1","element","selector","dom","elem","eq","e1","e2","contains","d1","d2","is","Global","path","parts","resolve","p","unsafe","name","getOrDie","actual","getPrototypeOf","sandHTMLElement","isPrototypeOf","isType","isComment","isHTMLElement","isElement$1","isText","isDocument","isDocumentFragment","isTag","owner","documentOrOwner","dos","parent","parentElement","nextSibling","children","child","index","cs","firstChild","lastChild","isShadowRoot","getRootNode","e","getShadowRoot","getShadowHost","inBody","doc","ClosestOrAncestor","ancestor","isRoot","ancestor$3","stop","el","closest$2","s","test","ancestor$2","closest$1","closest","target","isEditable","assumeEditable","editable","getRaw","before$1","marker","after","append$1","prepend","before","elements","append","empty","rogue","remove","global$6","global$5","global$4","fromDom","nodes","keys","each","obj","props","k","objAcc","internalFilter","onTrue","onFalse","filter","rawSet","key","setAll","attrs","clone$1","attr","clone","original","isDeep","deep","shallowAs","nu","attributes","mutate","children$1","global$3","global$2","matchNodeName","matchNodeNames","regex","isTextNode$1","isElement","isListNode","isOlUlNode","isOlNode","isListItemNode","isDlItemNode","isTableCellNode","isBr","isFirstChild","isTextBlock","editor","isBlock","blockElements","isVoid","isBogusBr","isEmpty$2","elm","keepBookmarks","isChildOfBody","option","register$3","registerOption","shouldIndentOnTab","getForcedRootBlock","getForcedRootBlockAttrs","createTextBlock","contentNode","fragment","blockName","blockAttrs","textBlock","hasContentNode","nodeName","DOM$2","splitList","list","li","removeAndKeepBookmarks","targetNode","bookmarks","newBlock","tmpRng","isDescriptionDetail","isDescriptionTerm","outdentDlItem","item","dl","indentDlItem","dlIndentation","indentation","dlItems","getNormalizedPoint","container","offset","normalizeRange","rng","outRng","rangeStart","rangeEnd","listNames","listSelector","getParentList","selectionStart","getClosestListHost","isParentListSelected","parentList","selectedBlocks","findSubLists","getSelectedSubLists","findParentListItemsNodes","elms","listItemsElms","parentLi","getSelectedListItems","getSelectedDlItems","getClosestEditingHost","parentTableCell","isListHost","schema","listName","parentBlocks","isListInsideAnLiWithFirstAndLastNotListElement","findLastParentListNode","parentLists","getSelectedLists","firstList","subsequentLists","getParentLists","getSelectedListRoots","selectedLists","getUniqueListRoots","l","lists","listRoots","isCustomList","inList","parents","isWithinNonEditable","selectionIsWithinNonEditableList","isWithinNonEditableList","setNodeChangeHandler","nodeChangeHandler","initialNode","fromElements","fireListEvent","action","trim","isNotEmpty","isEmpty$1","isSupported","internalSet","property","set","isList","isListItem","hasFirstChildList","hasLastChildList","isEntryList","entry","isEntryComment","isEntryFragment","isIndented","isSelected","cloneItemContent","content","createEntry","depth","joinSegment","joinSegments","segments","appendSegments","head$1","tail","createSegment","listType","segment","createSegments","size","populateSegments","normalizeSegment","createItem","appendItem","writeShallow","cast","newCast","writeDeep","composeList","entries","firstCommentEntryOpt","firstCommentEntry","fistCast","indentEntry","cloneListProperties","source","cleanListProperties","_value","closestSiblingEntry","start","matches","normalizeEntries","matchingEntry","Cell","initial","parseSingleItem","itemSelection","selectionState","selection","currentItemEntry","childListEntries","parseList","parseItem","parsedSiblings","liChild","parser","newDepth","parseLists","initialDepth","outdentedComposer","normalizedEntries","indentedComposer","composeEntries","indentSelectedEntries","getItemSelection","selectedListItems","end","listIndentation","entrySets","entrySet","composedLists","composedList","selectionIndentation","isHandled","bookmark","handleIndentation","indentListSelection","outdentListSelection","flattenListSelection","zeroWidth","isZwsp","char","ancestor$1","global$1","DOM$1","createBookmark","setupEndPoint","offsetNode","resolveBookmark","restoreEndPoint","nodeIndex","idx","listToggleActionFromListName","updateListStyle","detail","setAttribs","updateListAttrs","updateListWithDetails","removeStyles","styles","style","isInline","getEndPointNode","root","findBlockAncestor","findBetterContainer","forward","walker","dir","getSelectedTextBlocks","textBlocks","startNode","endNode","block","siblings","hasCompatibleStyle","sib","sibStyle","detailStyle","getRootSearchStart","range","startPoint","applyList","listItemName","selectedTextBlocks","listBlock","sibling","mergeWithAdjacentLists","isValidLists","list1","list2","hasSameListStyle","targetStyle","hasSameClasses","elm1","elm2","shouldMerge","liSibling","updateList$1","newList","updateCustomList","cls","_","classList","toggleMultipleLists","parentIsList","hasListStyleDetail","allLists","updateFunction","toggleSingleList","toggleList","_detail","selectedSubLists","DOM","normalizeList","parentNode","normalizeLists","findNextCaretContainer","isForward","nonEmptyBlocks","walkFn","hasOnlyOneBlockChild","childNodes","isUnwrappable","unwrapSingleBlockChild","moveChildren","fromElm","toElm","targetElm","mergeLiElements","listNode","ul","nestedLists","mergeIntoEmptyLi","fromLi","toLi","mergeForward","mergeBackward","resolvedBookmark","backspaceDeleteFromListToListCaret","selectionStartElm","otherLi","willMergeParentIntoChild","oldParentElRef","removeBlock","parentBlock","backspaceDeleteIntoListCaret","findValidElement","findRoot","otherLiCell","caretCell","backspaceDeleteCaret","hasListSelection","backspaceDeleteRange","backspaceDelete","setup$2","cmd","get","updateList","update","parseAlphabeticBase26","str","chars","values","charValue","sum","composeAlphabeticBase26","remainder","quotient","rest","isUppercase","isLowercase","isNumeric","deduceListType","parseStartValue","parseDetail","open","currentList","api","data","queryListCommandState","registerDialog","register$2","ui","global","isTextNode","isEmpty","nodeBuffer","wrapInvalidChildren","insertListItem","buffer","refNode","reducer","restBuffer","setup$1","setupTabKey","setup","setupToggleButtonHandler","toggleButtonHandler","register$1","exec","command","setupMenuButtonHandler","register","listProperties","Plugin"],"mappings":"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","x_google_ignoreList":[0]}