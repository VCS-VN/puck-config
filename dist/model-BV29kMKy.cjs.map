{"version":3,"file":"model-BV29kMKy.cjs","sources":["../node_modules/.pnpm/tinymce@6.8.6/node_modules/tinymce/models/dom/model.js"],"sourcesContent":["/**\n * TinyMCE version 6.8.6 (TBD)\n */\n\n(function () {\n    'use strict';\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.ModelManager');\n\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$2 = t => a => t === a;\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isArray = isType$1('array');\n    const isNull = eq$2(null);\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$2(undefined);\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    const noop = () => {\n    };\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply = f => {\n      return f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const range$1 = (num, f) => {\n      const r = [];\n      for (let i = 0; i < num; i++) {\n        r.push(f(i));\n      }\n      return r;\n    };\n    const map$1 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$2 = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$2 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$2(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$1 = (xs, pred) => {\n      return findUntil(xs, pred, never);\n    };\n    const findIndex = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$2 = (xs, f) => flatten(map$1(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const sort$1 = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$d = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$d(xs, 0);\n    const last$2 = xs => get$d(xs, xs.length - 1);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty = Object.hasOwnProperty;\n    const each$1 = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each$1(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each$1(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const filter$1 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each$1(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$c = (obj, key) => {\n      return has$1(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$1 = (obj, key) => hasOwnProperty.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$1(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const isEmpty = r => {\n      for (const x in r) {\n        if (hasOwnProperty.call(r, x)) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const path = (parts, scope) => {\n      let o = scope !== undefined && scope !== null ? scope : Global;\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n        o = o[parts[i]];\n      }\n      return o;\n    };\n    const resolve$2 = (p, scope) => {\n      const parts = p.split('.');\n      return path(parts, scope);\n    };\n\n    const unsafe = (name, scope) => {\n      return resolve$2(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n      const actual = unsafe(name, scope);\n      if (actual === undefined || actual === null) {\n        throw new Error(name + ' not available on this browser');\n      }\n      return actual;\n    };\n\n    const getPrototypeOf = Object.getPrototypeOf;\n    const sandHTMLElement = scope => {\n      return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = x => {\n      const scope = resolve$2('ownerDocument.defaultView', x);\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf(x).constructor.name));\n    };\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type = element => element.dom.nodeType;\n    const isType = t => element => type(element) === t;\n    const isComment = element => type(element) === COMMENT || name(element) === '#comment';\n    const isHTMLElement = element => isElement(element) && isPrototypeOf(element.dom);\n    const isElement = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocument = isType(DOCUMENT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement(e) && name(e) === tag;\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$2 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each$1(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const setOptions = (element, attrs) => {\n      each$1(attrs, (v, k) => {\n        v.fold(() => {\n          remove$7(element, k);\n        }, value => {\n          rawSet(element.dom, k, value);\n        });\n      });\n    };\n    const get$b = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$b(element, key));\n    const remove$7 = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const clone$2 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$1(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$1(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$1(node);\n    };\n    const fromDom$1 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint$1 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);\n    const SugarElement = {\n      fromHtml: fromHtml$1,\n      fromTag,\n      fromText,\n      fromDom: fromDom$1,\n      fromPoint: fromPoint$1\n    };\n\n    const is$2 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all$1 = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$1(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq$1 = (e1, e2) => e1.dom === e2.dom;\n    const contains$1 = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n    const is$1 = is$2;\n\n    const owner = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument(dos) ? dos : owner(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const children$2 = element => map$1(element.dom.childNodes, SugarElement.fromDom);\n    const child$2 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$2(element, 0);\n\n    const before$3 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$5 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const appendAt = (parent, element, index) => {\n      child$2(parent, index).fold(() => {\n        append$1(parent, element);\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const wrap = (element, wrapper) => {\n      before$3(element, wrapper);\n      append$1(wrapper, element);\n    };\n\n    const after$4 = (marker, elements) => {\n      each$2(elements, (x, i) => {\n        const e = i === 0 ? marker : elements[i - 1];\n        after$5(e, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$2(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$2(children$2(element), rogue => {\n        remove$6(rogue);\n      });\n    };\n    const remove$6 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n    const unwrap = wrapper => {\n      const children = children$2(wrapper);\n      if (children.length > 0) {\n        after$4(wrapper, children);\n      }\n      remove$6(wrapper);\n    };\n\n    const clone$1 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow = original => clone$1(original, false);\n    const deep = original => clone$1(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$2(original);\n      setAll$1(nu, attributes);\n      return nu;\n    };\n    const copy$2 = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      const cloneChildren = children$2(deep(original));\n      append(nu, cloneChildren);\n      return nu;\n    };\n    const mutate$1 = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after$5(original, nu);\n      const children = children$2(original);\n      append(nu, children);\n      remove$6(original);\n      return nu;\n    };\n\n    const validSectionList = [\n      'tfoot',\n      'thead',\n      'tbody',\n      'colgroup'\n    ];\n    const isValidSection = parentName => contains$2(validSectionList, parentName);\n    const grid = (rows, columns) => ({\n      rows,\n      columns\n    });\n    const address = (row, column) => ({\n      row,\n      column\n    });\n    const detail = (element, rowspan, colspan) => ({\n      element,\n      rowspan,\n      colspan\n    });\n    const detailnew = (element, rowspan, colspan, isNew) => ({\n      element,\n      rowspan,\n      colspan,\n      isNew\n    });\n    const extended = (element, rowspan, colspan, row, column, isLocked) => ({\n      element,\n      rowspan,\n      colspan,\n      row,\n      column,\n      isLocked\n    });\n    const rowdetail = (element, cells, section) => ({\n      element,\n      cells,\n      section\n    });\n    const rowdetailnew = (element, cells, section, isNew) => ({\n      element,\n      cells,\n      section,\n      isNew\n    });\n    const elementnew = (element, isNew, isLocked) => ({\n      element,\n      isNew,\n      isLocked\n    });\n    const rowcells = (element, cells, section, isNew) => ({\n      element,\n      cells,\n      section,\n      isNew\n    });\n    const bounds = (startRow, startCol, finishRow, finishCol) => ({\n      startRow,\n      startCol,\n      finishRow,\n      finishCol\n    });\n    const columnext = (element, colspan, column) => ({\n      element,\n      colspan,\n      column\n    });\n    const colgroup = (element, columns) => ({\n      element,\n      columns\n    });\n\n    const isShadowRoot = dos => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const isSupported$1 = constant(supported);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isSupported$1() && isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n    const body$1 = () => getBody$1(SugarElement.fromDom(document));\n    const getBody$1 = doc => {\n      const b = doc.dom.body;\n      if (b === null || b === undefined) {\n        throw new Error('Body is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const ancestors$4 = (scope, predicate, isRoot) => filter$2(parents(scope, isRoot), predicate);\n    const children$1 = (scope, predicate) => filter$2(children$2(scope), predicate);\n    const descendants$1 = (scope, predicate) => {\n      let result = [];\n      each$2(children$2(scope), x => {\n        if (predicate(x)) {\n          result = result.concat([x]);\n        }\n        result = result.concat(descendants$1(x, predicate));\n      });\n      return result;\n    };\n\n    const ancestors$3 = (scope, selector, isRoot) => ancestors$4(scope, e => is$2(e, selector), isRoot);\n    const children = (scope, selector) => children$1(scope, e => is$2(e, selector));\n    const descendants = (scope, selector) => all$1(selector, scope);\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$2 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$2 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$2, scope, predicate, isRoot);\n    };\n    const child$1 = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$1(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$1 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const ancestor$1 = (scope, selector, isRoot) => ancestor$2(scope, e => is$2(e, selector), isRoot);\n    const child = (scope, selector) => child$1(scope, e => is$2(e, selector));\n    const descendant = (scope, selector) => one(selector, scope);\n    const closest$1 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$2(element, selector);\n      return ClosestOrAncestor(is, ancestor$1, scope, selector, isRoot);\n    };\n\n    const is = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const bindFrom = (a, f) => a !== undefined && a !== null ? f(a) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const contains = (str, substr, start = 0, end) => {\n      const idx = str.indexOf(substr, start);\n      if (idx !== -1) {\n        return isUndefined(end) ? true : idx + substr.length <= end;\n      } else {\n        return false;\n      }\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim = blank(/^\\s+|\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const toFloat = value => {\n      const num = parseFloat(value);\n      return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$1 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each$1(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const get$a = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw$2 = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const remove$5 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is(getOpt(element, 'style').map(trim), '')) {\n        remove$7(element, 'style');\n      }\n    };\n    const copy$1 = (source, target) => {\n      const sourceDom = source.dom;\n      const targetDom = target.dom;\n      if (isSupported(sourceDom) && isSupported(targetDom)) {\n        targetDom.style.cssText = sourceDom.style.cssText;\n      }\n    };\n\n    const getAttrValue = (cell, name, fallback = 0) => getOpt(cell, name).map(value => parseInt(value, 10)).getOr(fallback);\n    const getSpan = (cell, type) => getAttrValue(cell, type, 1);\n    const hasColspan = cellOrCol => {\n      if (isTag('col')(cellOrCol)) {\n        return getAttrValue(cellOrCol, 'span', 1) > 1;\n      } else {\n        return getSpan(cellOrCol, 'colspan') > 1;\n      }\n    };\n    const hasRowspan = cell => getSpan(cell, 'rowspan') > 1;\n    const getCssValue = (element, property) => parseInt(get$a(element, property), 10);\n    const minWidth = constant(10);\n    const minHeight = constant(10);\n\n    const firstLayer = (scope, selector) => {\n      return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n      return bind$2(children$2(scope), x => {\n        if (is$2(x, selector)) {\n          return predicate(x) ? [x] : [];\n        } else {\n          return filterFirstLayer(x, selector, predicate);\n        }\n      });\n    };\n\n    const lookup = (tags, element, isRoot = never) => {\n      if (isRoot(element)) {\n        return Optional.none();\n      }\n      if (contains$2(tags, name(element))) {\n        return Optional.some(element);\n      }\n      const isRootOrUpperTable = elm => is$2(elm, 'table') || isRoot(elm);\n      return ancestor$1(element, tags.join(','), isRootOrUpperTable);\n    };\n    const cell = (element, isRoot) => lookup([\n      'td',\n      'th'\n    ], element, isRoot);\n    const cells$1 = ancestor => firstLayer(ancestor, 'th,td');\n    const columns$1 = ancestor => {\n      if (is$2(ancestor, 'colgroup')) {\n        return children(ancestor, 'col');\n      } else {\n        return bind$2(columnGroups(ancestor), columnGroup => children(columnGroup, 'col'));\n      }\n    };\n    const table = (element, isRoot) => closest$1(element, 'table', isRoot);\n    const rows$1 = ancestor => firstLayer(ancestor, 'tr');\n    const columnGroups = ancestor => table(ancestor).fold(constant([]), table => children(table, 'colgroup'));\n\n    const fromRowsOrColGroups = (elems, getSection) => map$1(elems, row => {\n      if (name(row) === 'colgroup') {\n        const cells = map$1(columns$1(row), column => {\n          const colspan = getAttrValue(column, 'span', 1);\n          return detail(column, 1, colspan);\n        });\n        return rowdetail(row, cells, 'colgroup');\n      } else {\n        const cells = map$1(cells$1(row), cell => {\n          const rowspan = getAttrValue(cell, 'rowspan', 1);\n          const colspan = getAttrValue(cell, 'colspan', 1);\n          return detail(cell, rowspan, colspan);\n        });\n        return rowdetail(row, cells, getSection(row));\n      }\n    });\n    const getParentSection = group => parent(group).map(parent => {\n      const parentName = name(parent);\n      return isValidSection(parentName) ? parentName : 'tbody';\n    }).getOr('tbody');\n    const fromTable$1 = table => {\n      const rows = rows$1(table);\n      const columnGroups$1 = columnGroups(table);\n      const elems = [\n        ...columnGroups$1,\n        ...rows\n      ];\n      return fromRowsOrColGroups(elems, getParentSection);\n    };\n    const fromPastedRows = (elems, section) => fromRowsOrColGroups(elems, () => section);\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant(isiPad),\n        isiPhone: constant(isiPhone),\n        isTablet: constant(isTablet),\n        isPhone: constant(isPhone),\n        isTouch: constant(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant(iOSwebview),\n        isDesktop: constant(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$2(group(1), group(2));\n    };\n    const detect$5 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$2();\n      }\n      return find(versionRegexes, cleanedAgent);\n    };\n    const unknown$2 = () => {\n      return nu$2(0, 0);\n    };\n    const nu$2 = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$2,\n      detect: detect$5,\n      unknown: unknown$2\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$1(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$4 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$1(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$4(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$4(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains(uastring, 'edge/') && contains(uastring, 'chrome') && contains(uastring, 'safari') && contains(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains(uastring, 'chrome') && !contains(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains(uastring, 'msie') || contains(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains(uastring, 'safari') || contains(uastring, 'mobile/')) && contains(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains(uastring, 'iphone') || contains(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant(browsers),\n      oses: constant(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$1 = () => {\n      return nu$1({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$1 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$1,\n      nu: nu$1,\n      edge: constant(edge),\n      chromium: constant(chromium),\n      ie: constant(ie),\n      opera: constant(opera),\n      firefox: constant(firefox),\n      safari: constant(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown = () => {\n      return nu({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown,\n      nu,\n      windows: constant(windows),\n      ios: constant(ios),\n      android: constant(android),\n      linux: constant(linux),\n      macos: constant(macos),\n      solaris: constant(solaris),\n      freebsd: constant(freebsd),\n      chromeos: constant(chromeos)\n    };\n\n    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$3 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n    const detect$2 = () => platform();\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$a(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$a(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const toNumber = (px, fallback) => toFloat(px).getOr(fallback);\n    const getProp = (element, name, fallback) => toNumber(get$a(element, name), fallback);\n    const calcContentBoxSize = (element, size, upper, lower) => {\n      const paddingUpper = getProp(element, `padding-${ upper }`, 0);\n      const paddingLower = getProp(element, `padding-${ lower }`, 0);\n      const borderUpper = getProp(element, `border-${ upper }-width`, 0);\n      const borderLower = getProp(element, `border-${ lower }-width`, 0);\n      return size - paddingUpper - paddingLower - borderUpper - borderLower;\n    };\n    const getCalculatedWidth = (element, boxSizing) => {\n      const dom = element.dom;\n      const width = dom.getBoundingClientRect().width || dom.offsetWidth;\n      return boxSizing === 'border-box' ? width : calcContentBoxSize(element, width, 'left', 'right');\n    };\n    const getHeight$1 = element => getProp(element, 'height', element.dom.offsetHeight);\n    const getWidth = element => getProp(element, 'width', element.dom.offsetWidth);\n    const getInnerWidth = element => getCalculatedWidth(element, 'content-box');\n\n    const api$2 = Dimension('width', element => element.dom.offsetWidth);\n    const get$9 = element => api$2.get(element);\n    const getOuter$2 = element => api$2.getOuter(element);\n    const getInner = getInnerWidth;\n    const getRuntime$1 = getWidth;\n\n    const addCells = (gridRow, index, cells) => {\n      const existingCells = gridRow.cells;\n      const before = existingCells.slice(0, index);\n      const after = existingCells.slice(index);\n      const newCells = before.concat(cells).concat(after);\n      return setCells(gridRow, newCells);\n    };\n    const addCell = (gridRow, index, cell) => addCells(gridRow, index, [cell]);\n    const mutateCell = (gridRow, index, cell) => {\n      const cells = gridRow.cells;\n      cells[index] = cell;\n    };\n    const setCells = (gridRow, cells) => rowcells(gridRow.element, cells, gridRow.section, gridRow.isNew);\n    const mapCells = (gridRow, f) => {\n      const cells = gridRow.cells;\n      const r = map$1(cells, f);\n      return rowcells(gridRow.element, r, gridRow.section, gridRow.isNew);\n    };\n    const getCell = (gridRow, index) => gridRow.cells[index];\n    const getCellElement = (gridRow, index) => getCell(gridRow, index).element;\n    const cellLength = gridRow => gridRow.cells.length;\n    const extractGridDetails = grid => {\n      const result = partition(grid, row => row.section === 'colgroup');\n      return {\n        rows: result.fail,\n        cols: result.pass\n      };\n    };\n    const clone = (gridRow, cloneRow, cloneCell) => {\n      const newCells = map$1(gridRow.cells, cloneCell);\n      return rowcells(cloneRow(gridRow.element), newCells, gridRow.section, true);\n    };\n\n    const LOCKED_COL_ATTR = 'data-snooker-locked-cols';\n    const getLockedColumnsFromTable = table => getOpt(table, LOCKED_COL_ATTR).bind(lockedColStr => Optional.from(lockedColStr.match(/\\d+/g))).map(lockedCols => mapToObject(lockedCols, always));\n    const getLockedColumnsFromGrid = grid => {\n      const locked = foldl(extractGridDetails(grid).rows, (acc, row) => {\n        each$2(row.cells, (cell, idx) => {\n          if (cell.isLocked) {\n            acc[idx] = true;\n          }\n        });\n        return acc;\n      }, {});\n      const lockedArr = mapToArray(locked, (_val, key) => parseInt(key, 10));\n      return sort$1(lockedArr);\n    };\n\n    const key = (row, column) => {\n      return row + ',' + column;\n    };\n    const getAt = (warehouse, row, column) => Optional.from(warehouse.access[key(row, column)]);\n    const findItem = (warehouse, item, comparator) => {\n      const filtered = filterItems(warehouse, detail => {\n        return comparator(item, detail.element);\n      });\n      return filtered.length > 0 ? Optional.some(filtered[0]) : Optional.none();\n    };\n    const filterItems = (warehouse, predicate) => {\n      const all = bind$2(warehouse.all, r => {\n        return r.cells;\n      });\n      return filter$2(all, predicate);\n    };\n    const generateColumns = rowData => {\n      const columnsGroup = {};\n      let index = 0;\n      each$2(rowData.cells, column => {\n        const colspan = column.colspan;\n        range$1(colspan, columnIndex => {\n          const colIndex = index + columnIndex;\n          columnsGroup[colIndex] = columnext(column.element, colspan, colIndex);\n        });\n        index += colspan;\n      });\n      return columnsGroup;\n    };\n    const generate$1 = list => {\n      const access = {};\n      const cells = [];\n      const tableOpt = head(list).map(rowData => rowData.element).bind(table);\n      const lockedColumns = tableOpt.bind(getLockedColumnsFromTable).getOr({});\n      let maxRows = 0;\n      let maxColumns = 0;\n      let rowCount = 0;\n      const {\n        pass: colgroupRows,\n        fail: rows\n      } = partition(list, rowData => rowData.section === 'colgroup');\n      each$2(rows, rowData => {\n        const currentRow = [];\n        each$2(rowData.cells, rowCell => {\n          let start = 0;\n          while (access[key(rowCount, start)] !== undefined) {\n            start++;\n          }\n          const isLocked = hasNonNullableKey(lockedColumns, start.toString());\n          const current = extended(rowCell.element, rowCell.rowspan, rowCell.colspan, rowCount, start, isLocked);\n          for (let occupiedColumnPosition = 0; occupiedColumnPosition < rowCell.colspan; occupiedColumnPosition++) {\n            for (let occupiedRowPosition = 0; occupiedRowPosition < rowCell.rowspan; occupiedRowPosition++) {\n              const rowPosition = rowCount + occupiedRowPosition;\n              const columnPosition = start + occupiedColumnPosition;\n              const newpos = key(rowPosition, columnPosition);\n              access[newpos] = current;\n              maxColumns = Math.max(maxColumns, columnPosition + 1);\n            }\n          }\n          currentRow.push(current);\n        });\n        maxRows++;\n        cells.push(rowdetail(rowData.element, currentRow, rowData.section));\n        rowCount++;\n      });\n      const {columns, colgroups} = last$2(colgroupRows).map(rowData => {\n        const columns = generateColumns(rowData);\n        const colgroup$1 = colgroup(rowData.element, values(columns));\n        return {\n          colgroups: [colgroup$1],\n          columns\n        };\n      }).getOrThunk(() => ({\n        colgroups: [],\n        columns: {}\n      }));\n      const grid$1 = grid(maxRows, maxColumns);\n      return {\n        grid: grid$1,\n        access,\n        all: cells,\n        columns,\n        colgroups\n      };\n    };\n    const fromTable = table => {\n      const list = fromTable$1(table);\n      return generate$1(list);\n    };\n    const justCells = warehouse => bind$2(warehouse.all, w => w.cells);\n    const justColumns = warehouse => values(warehouse.columns);\n    const hasColumns = warehouse => keys(warehouse.columns).length > 0;\n    const getColumnAt = (warehouse, columnIndex) => Optional.from(warehouse.columns[columnIndex]);\n    const Warehouse = {\n      fromTable,\n      generate: generate$1,\n      getAt,\n      findItem,\n      filterItems,\n      justCells,\n      justColumns,\n      hasColumns,\n      getColumnAt\n    };\n\n    const columns = (warehouse, isValidCell = always) => {\n      const grid = warehouse.grid;\n      const cols = range$1(grid.columns, identity);\n      const rowsArr = range$1(grid.rows, identity);\n      return map$1(cols, col => {\n        const getBlock = () => bind$2(rowsArr, r => Warehouse.getAt(warehouse, r, col).filter(detail => detail.column === col).toArray());\n        const isValid = detail => detail.colspan === 1 && isValidCell(detail.element);\n        const getFallback = () => Warehouse.getAt(warehouse, 0, col);\n        return decide(getBlock, isValid, getFallback);\n      });\n    };\n    const decide = (getBlock, isValid, getFallback) => {\n      const inBlock = getBlock();\n      const validInBlock = find$1(inBlock, isValid);\n      const detailOption = validInBlock.orThunk(() => Optional.from(inBlock[0]).orThunk(getFallback));\n      return detailOption.map(detail => detail.element);\n    };\n    const rows = warehouse => {\n      const grid = warehouse.grid;\n      const rowsArr = range$1(grid.rows, identity);\n      const cols = range$1(grid.columns, identity);\n      return map$1(rowsArr, row => {\n        const getBlock = () => bind$2(cols, c => Warehouse.getAt(warehouse, row, c).filter(detail => detail.row === row).fold(constant([]), detail => [detail]));\n        const isSingle = detail => detail.rowspan === 1;\n        const getFallback = () => Warehouse.getAt(warehouse, row, 0);\n        return decide(getBlock, isSingle, getFallback);\n      });\n    };\n\n    const deduce = (xs, index) => {\n      if (index < 0 || index >= xs.length - 1) {\n        return Optional.none();\n      }\n      const current = xs[index].fold(() => {\n        const rest = reverse(xs.slice(0, index));\n        return findMap(rest, (a, i) => a.map(aa => ({\n          value: aa,\n          delta: i + 1\n        })));\n      }, c => Optional.some({\n        value: c,\n        delta: 0\n      }));\n      const next = xs[index + 1].fold(() => {\n        const rest = xs.slice(index + 1);\n        return findMap(rest, (a, i) => a.map(aa => ({\n          value: aa,\n          delta: i + 1\n        })));\n      }, n => Optional.some({\n        value: n,\n        delta: 1\n      }));\n      return current.bind(c => next.map(n => {\n        const extras = n.delta + c.delta;\n        return Math.abs(n.value - c.value) / extras;\n      }));\n    };\n\n    const onDirection = (isLtr, isRtl) => element => getDirection(element) === 'rtl' ? isRtl : isLtr;\n    const getDirection = element => get$a(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';\n\n    const api$1 = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$8 = element => api$1.get(element);\n    const getOuter$1 = element => api$1.getOuter(element);\n    const getRuntime = getHeight$1;\n\n    const r = (left, top) => {\n      const translate = (x, y) => r(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const rowInfo = (row, y) => ({\n      row,\n      y\n    });\n    const colInfo = (col, x) => ({\n      col,\n      x\n    });\n    const rtlEdge = cell => {\n      const pos = absolute(cell);\n      return pos.left + getOuter$2(cell);\n    };\n    const ltrEdge = cell => {\n      return absolute(cell).left;\n    };\n    const getLeftEdge = (index, cell) => {\n      return colInfo(index, ltrEdge(cell));\n    };\n    const getRightEdge = (index, cell) => {\n      return colInfo(index, rtlEdge(cell));\n    };\n    const getTop$1 = cell => {\n      return absolute(cell).top;\n    };\n    const getTopEdge = (index, cell) => {\n      return rowInfo(index, getTop$1(cell));\n    };\n    const getBottomEdge = (index, cell) => {\n      return rowInfo(index, getTop$1(cell) + getOuter$1(cell));\n    };\n    const findPositions = (getInnerEdge, getOuterEdge, array) => {\n      if (array.length === 0) {\n        return [];\n      }\n      const lines = map$1(array.slice(1), (cellOption, index) => {\n        return cellOption.map(cell => {\n          return getInnerEdge(index, cell);\n        });\n      });\n      const lastLine = array[array.length - 1].map(cell => {\n        return getOuterEdge(array.length - 1, cell);\n      });\n      return lines.concat([lastLine]);\n    };\n    const negate = step => {\n      return -step;\n    };\n    const height = {\n      delta: identity,\n      positions: optElements => findPositions(getTopEdge, getBottomEdge, optElements),\n      edge: getTop$1\n    };\n    const ltr$1 = {\n      delta: identity,\n      edge: ltrEdge,\n      positions: optElements => findPositions(getLeftEdge, getRightEdge, optElements)\n    };\n    const rtl$1 = {\n      delta: negate,\n      edge: rtlEdge,\n      positions: optElements => findPositions(getRightEdge, getLeftEdge, optElements)\n    };\n    const detect$1 = onDirection(ltr$1, rtl$1);\n    const width = {\n      delta: (amount, table) => detect$1(table).delta(amount, table),\n      positions: (cols, table) => detect$1(table).positions(cols, table),\n      edge: cell => detect$1(cell).edge(cell)\n    };\n\n    const units = {\n      unsupportedLength: [\n        'em',\n        'ex',\n        'cap',\n        'ch',\n        'ic',\n        'rem',\n        'lh',\n        'rlh',\n        'vw',\n        'vh',\n        'vi',\n        'vb',\n        'vmin',\n        'vmax',\n        'cm',\n        'mm',\n        'Q',\n        'in',\n        'pc',\n        'pt',\n        'px'\n      ],\n      fixed: [\n        'px',\n        'pt'\n      ],\n      relative: ['%'],\n      empty: ['']\n    };\n    const pattern = (() => {\n      const decimalDigits = '[0-9]+';\n      const signedInteger = '[+-]?' + decimalDigits;\n      const exponentPart = '[eE]' + signedInteger;\n      const dot = '\\\\.';\n      const opt = input => `(?:${ input })?`;\n      const unsignedDecimalLiteral = [\n        'Infinity',\n        decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),\n        dot + decimalDigits + opt(exponentPart),\n        decimalDigits + opt(exponentPart)\n      ].join('|');\n      const float = `[+-]?(?:${ unsignedDecimalLiteral })`;\n      return new RegExp(`^(${ float })(.*)$`);\n    })();\n    const isUnit = (unit, accepted) => exists(accepted, acc => exists(units[acc], check => unit === check));\n    const parse = (input, accepted) => {\n      const match = Optional.from(pattern.exec(input));\n      return match.bind(array => {\n        const value = Number(array[1]);\n        const unitRaw = array[2];\n        if (isUnit(unitRaw, accepted)) {\n          return Optional.some({\n            value,\n            unit: unitRaw\n          });\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n\n    const rPercentageBasedSizeRegex = /(\\d+(\\.\\d+)?)%/;\n    const rPixelBasedSizeRegex = /(\\d+(\\.\\d+)?)px|em/;\n    const isCol$2 = isTag('col');\n    const getPercentSize = (elm, outerGetter, innerGetter) => {\n      const relativeParent = parentElement(elm).getOrThunk(() => getBody$1(owner(elm)));\n      return outerGetter(elm) / innerGetter(relativeParent) * 100;\n    };\n    const setPixelWidth = (cell, amount) => {\n      set$1(cell, 'width', amount + 'px');\n    };\n    const setPercentageWidth = (cell, amount) => {\n      set$1(cell, 'width', amount + '%');\n    };\n    const setHeight = (cell, amount) => {\n      set$1(cell, 'height', amount + 'px');\n    };\n    const getHeightValue = cell => getRuntime(cell) + 'px';\n    const convert = (cell, number, getter, setter) => {\n      const newSize = table(cell).map(table => {\n        const total = getter(table);\n        return Math.floor(number / 100 * total);\n      }).getOr(number);\n      setter(cell, newSize);\n      return newSize;\n    };\n    const normalizePixelSize = (value, cell, getter, setter) => {\n      const number = parseFloat(value);\n      return endsWith(value, '%') && name(cell) !== 'table' ? convert(cell, number, getter, setter) : number;\n    };\n    const getTotalHeight = cell => {\n      const value = getHeightValue(cell);\n      if (!value) {\n        return get$8(cell);\n      }\n      return normalizePixelSize(value, cell, get$8, setHeight);\n    };\n    const get$7 = (cell, type, f) => {\n      const v = f(cell);\n      const span = getSpan(cell, type);\n      return v / span;\n    };\n    const getRaw$1 = (element, prop) => {\n      return getRaw$2(element, prop).orThunk(() => {\n        return getOpt(element, prop).map(val => val + 'px');\n      });\n    };\n    const getRawWidth$1 = element => getRaw$1(element, 'width');\n    const getRawHeight = element => getRaw$1(element, 'height');\n    const getPercentageWidth = cell => getPercentSize(cell, get$9, getInner);\n    const getPixelWidth$1 = cell => isCol$2(cell) ? get$9(cell) : getRuntime$1(cell);\n    const getHeight = cell => {\n      return get$7(cell, 'rowspan', getTotalHeight);\n    };\n    const getGenericWidth = cell => {\n      const width = getRawWidth$1(cell);\n      return width.bind(w => parse(w, [\n        'fixed',\n        'relative',\n        'empty'\n      ]));\n    };\n    const setGenericWidth = (cell, amount, unit) => {\n      set$1(cell, 'width', amount + unit);\n    };\n    const getPixelTableWidth = table => get$9(table) + 'px';\n    const getPercentTableWidth = table => getPercentSize(table, get$9, getInner) + '%';\n    const isPercentSizing$1 = table => getRawWidth$1(table).exists(size => rPercentageBasedSizeRegex.test(size));\n    const isPixelSizing$1 = table => getRawWidth$1(table).exists(size => rPixelBasedSizeRegex.test(size));\n    const isNoneSizing$1 = table => getRawWidth$1(table).isNone();\n    const percentageBasedSizeRegex = constant(rPercentageBasedSizeRegex);\n\n    const isCol$1 = isTag('col');\n    const getRawW = cell => {\n      return getRawWidth$1(cell).getOrThunk(() => getPixelWidth$1(cell) + 'px');\n    };\n    const getRawH = cell => {\n      return getRawHeight(cell).getOrThunk(() => getHeight(cell) + 'px');\n    };\n    const justCols = warehouse => map$1(Warehouse.justColumns(warehouse), column => Optional.from(column.element));\n    const isValidColumn = cell => {\n      const browser = detect$2().browser;\n      const supportsColWidths = browser.isChromium() || browser.isFirefox();\n      return isCol$1(cell) ? supportsColWidths : true;\n    };\n    const getDimension = (cellOpt, index, backups, filter, getter, fallback) => cellOpt.filter(filter).fold(() => fallback(deduce(backups, index)), cell => getter(cell));\n    const getWidthFrom = (warehouse, table, getWidth, fallback) => {\n      const columnCells = columns(warehouse);\n      const columns$1 = Warehouse.hasColumns(warehouse) ? justCols(warehouse) : columnCells;\n      const backups = [Optional.some(width.edge(table))].concat(map$1(width.positions(columnCells, table), pos => pos.map(p => p.x)));\n      const colFilter = not(hasColspan);\n      return map$1(columns$1, (cellOption, c) => {\n        return getDimension(cellOption, c, backups, colFilter, column => {\n          if (isValidColumn(column)) {\n            return getWidth(column);\n          } else {\n            const cell = bindFrom(columnCells[c], identity);\n            return getDimension(cell, c, backups, colFilter, cell => fallback(Optional.some(get$9(cell))), fallback);\n          }\n        }, fallback);\n      });\n    };\n    const getDeduced = deduced => {\n      return deduced.map(d => {\n        return d + 'px';\n      }).getOr('');\n    };\n    const getRawWidths = (warehouse, table) => {\n      return getWidthFrom(warehouse, table, getRawW, getDeduced);\n    };\n    const getPercentageWidths = (warehouse, table, tableSize) => {\n      return getWidthFrom(warehouse, table, getPercentageWidth, deduced => {\n        return deduced.fold(() => {\n          return tableSize.minCellWidth();\n        }, cellWidth => {\n          return cellWidth / tableSize.pixelWidth() * 100;\n        });\n      });\n    };\n    const getPixelWidths = (warehouse, table, tableSize) => {\n      return getWidthFrom(warehouse, table, getPixelWidth$1, deduced => {\n        return deduced.getOrThunk(tableSize.minCellWidth);\n      });\n    };\n    const getHeightFrom = (warehouse, table, direction, getHeight, fallback) => {\n      const rows$1 = rows(warehouse);\n      const backups = [Optional.some(direction.edge(table))].concat(map$1(direction.positions(rows$1, table), pos => pos.map(p => p.y)));\n      return map$1(rows$1, (cellOption, c) => {\n        return getDimension(cellOption, c, backups, not(hasRowspan), getHeight, fallback);\n      });\n    };\n    const getPixelHeights = (warehouse, table, direction) => {\n      return getHeightFrom(warehouse, table, direction, getHeight, deduced => {\n        return deduced.getOrThunk(minHeight);\n      });\n    };\n    const getRawHeights = (warehouse, table, direction) => {\n      return getHeightFrom(warehouse, table, direction, getRawH, getDeduced);\n    };\n\n    const widthLookup = (table, getter) => () => {\n      if (inBody(table)) {\n        return getter(table);\n      } else {\n        return parseFloat(getRaw$2(table, 'width').getOr('0'));\n      }\n    };\n    const noneSize = table => {\n      const getWidth = widthLookup(table, get$9);\n      const zero = constant(0);\n      const getWidths = (warehouse, tableSize) => getPixelWidths(warehouse, table, tableSize);\n      return {\n        width: getWidth,\n        pixelWidth: getWidth,\n        getWidths,\n        getCellDelta: zero,\n        singleColumnWidth: constant([0]),\n        minCellWidth: zero,\n        setElementWidth: noop,\n        adjustTableWidth: noop,\n        isRelative: true,\n        label: 'none'\n      };\n    };\n    const percentageSize = table => {\n      const getFloatWidth = widthLookup(table, elem => parseFloat(getPercentTableWidth(elem)));\n      const getWidth = widthLookup(table, get$9);\n      const getCellDelta = delta => delta / getWidth() * 100;\n      const singleColumnWidth = (w, _delta) => [100 - w];\n      const minCellWidth = () => minWidth() / getWidth() * 100;\n      const adjustTableWidth = delta => {\n        const currentWidth = getFloatWidth();\n        const change = delta / 100 * currentWidth;\n        const newWidth = currentWidth + change;\n        setPercentageWidth(table, newWidth);\n      };\n      const getWidths = (warehouse, tableSize) => getPercentageWidths(warehouse, table, tableSize);\n      return {\n        width: getFloatWidth,\n        pixelWidth: getWidth,\n        getWidths,\n        getCellDelta,\n        singleColumnWidth,\n        minCellWidth,\n        setElementWidth: setPercentageWidth,\n        adjustTableWidth,\n        isRelative: true,\n        label: 'percent'\n      };\n    };\n    const pixelSize = table => {\n      const getWidth = widthLookup(table, get$9);\n      const getCellDelta = identity;\n      const singleColumnWidth = (w, delta) => {\n        const newNext = Math.max(minWidth(), w + delta);\n        return [newNext - w];\n      };\n      const adjustTableWidth = delta => {\n        const newWidth = getWidth() + delta;\n        setPixelWidth(table, newWidth);\n      };\n      const getWidths = (warehouse, tableSize) => getPixelWidths(warehouse, table, tableSize);\n      return {\n        width: getWidth,\n        pixelWidth: getWidth,\n        getWidths,\n        getCellDelta,\n        singleColumnWidth,\n        minCellWidth: minWidth,\n        setElementWidth: setPixelWidth,\n        adjustTableWidth,\n        isRelative: false,\n        label: 'pixel'\n      };\n    };\n    const chooseSize = (element, width) => {\n      const percentMatch = percentageBasedSizeRegex().exec(width);\n      if (percentMatch !== null) {\n        return percentageSize(element);\n      } else {\n        return pixelSize(element);\n      }\n    };\n    const getTableSize = table => {\n      const width = getRawWidth$1(table);\n      return width.fold(() => noneSize(table), w => chooseSize(table, w));\n    };\n    const TableSize = {\n      getTableSize,\n      pixelSize,\n      percentageSize,\n      noneSize\n    };\n\n    const statsStruct = (minRow, minCol, maxRow, maxCol, allCells, selectedCells) => ({\n      minRow,\n      minCol,\n      maxRow,\n      maxCol,\n      allCells,\n      selectedCells\n    });\n    const findSelectedStats = (house, isSelected) => {\n      const totalColumns = house.grid.columns;\n      const totalRows = house.grid.rows;\n      let minRow = totalRows;\n      let minCol = totalColumns;\n      let maxRow = 0;\n      let maxCol = 0;\n      const allCells = [];\n      const selectedCells = [];\n      each$1(house.access, detail => {\n        allCells.push(detail);\n        if (isSelected(detail)) {\n          selectedCells.push(detail);\n          const startRow = detail.row;\n          const endRow = startRow + detail.rowspan - 1;\n          const startCol = detail.column;\n          const endCol = startCol + detail.colspan - 1;\n          if (startRow < minRow) {\n            minRow = startRow;\n          } else if (endRow > maxRow) {\n            maxRow = endRow;\n          }\n          if (startCol < minCol) {\n            minCol = startCol;\n          } else if (endCol > maxCol) {\n            maxCol = endCol;\n          }\n        }\n      });\n      return statsStruct(minRow, minCol, maxRow, maxCol, allCells, selectedCells);\n    };\n    const makeCell = (list, seenSelected, rowIndex) => {\n      const row = list[rowIndex].element;\n      const td = SugarElement.fromTag('td');\n      append$1(td, SugarElement.fromTag('br'));\n      const f = seenSelected ? append$1 : prepend;\n      f(row, td);\n    };\n    const fillInGaps = (list, house, stats, isSelected) => {\n      const rows = filter$2(list, row => row.section !== 'colgroup');\n      const totalColumns = house.grid.columns;\n      const totalRows = house.grid.rows;\n      for (let i = 0; i < totalRows; i++) {\n        let seenSelected = false;\n        for (let j = 0; j < totalColumns; j++) {\n          if (!(i < stats.minRow || i > stats.maxRow || j < stats.minCol || j > stats.maxCol)) {\n            const needCell = Warehouse.getAt(house, i, j).filter(isSelected).isNone();\n            if (needCell) {\n              makeCell(rows, seenSelected, i);\n            } else {\n              seenSelected = true;\n            }\n          }\n        }\n      }\n    };\n    const clean = (replica, stats, house, widthDelta) => {\n      each$1(house.columns, col => {\n        if (col.column < stats.minCol || col.column > stats.maxCol) {\n          remove$6(col.element);\n        }\n      });\n      const emptyRows = filter$2(firstLayer(replica, 'tr'), row => row.dom.childElementCount === 0);\n      each$2(emptyRows, remove$6);\n      if (stats.minCol === stats.maxCol || stats.minRow === stats.maxRow) {\n        each$2(firstLayer(replica, 'th,td'), cell => {\n          remove$7(cell, 'rowspan');\n          remove$7(cell, 'colspan');\n        });\n      }\n      remove$7(replica, LOCKED_COL_ATTR);\n      remove$7(replica, 'data-snooker-col-series');\n      const tableSize = TableSize.getTableSize(replica);\n      tableSize.adjustTableWidth(widthDelta);\n    };\n    const getTableWidthDelta = (table, warehouse, tableSize, stats) => {\n      if (stats.minCol === 0 && warehouse.grid.columns === stats.maxCol + 1) {\n        return 0;\n      }\n      const colWidths = getPixelWidths(warehouse, table, tableSize);\n      const allColsWidth = foldl(colWidths, (acc, width) => acc + width, 0);\n      const selectedColsWidth = foldl(colWidths.slice(stats.minCol, stats.maxCol + 1), (acc, width) => acc + width, 0);\n      const newWidth = selectedColsWidth / allColsWidth * tableSize.pixelWidth();\n      const delta = newWidth - tableSize.pixelWidth();\n      return tableSize.getCellDelta(delta);\n    };\n    const extract$1 = (table, selectedSelector) => {\n      const isSelected = detail => is$2(detail.element, selectedSelector);\n      const replica = deep(table);\n      const list = fromTable$1(replica);\n      const tableSize = TableSize.getTableSize(table);\n      const replicaHouse = Warehouse.generate(list);\n      const replicaStats = findSelectedStats(replicaHouse, isSelected);\n      const selector = 'th:not(' + selectedSelector + ')' + ',td:not(' + selectedSelector + ')';\n      const unselectedCells = filterFirstLayer(replica, 'th,td', cell => is$2(cell, selector));\n      each$2(unselectedCells, remove$6);\n      fillInGaps(list, replicaHouse, replicaStats, isSelected);\n      const house = Warehouse.fromTable(table);\n      const widthDelta = getTableWidthDelta(table, house, tableSize, replicaStats);\n      clean(replica, replicaStats, replicaHouse, widthDelta);\n      return replica;\n    };\n\n    const nbsp = '\\xA0';\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api = NodeValue(isText, 'text');\n    const get$6 = element => api.get(element);\n    const getOption = element => api.getOption(element);\n    const set = (element, value) => api.set(element, value);\n\n    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children$2(element).length, v => v.length);\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n    const isContentEditableFalse = elem => isHTMLElement(elem) && get$b(elem, 'contenteditable') === 'false';\n    const elementsWithCursorPosition = [\n      'img',\n      'br'\n    ];\n    const isCursorPosition = elem => {\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse(elem);\n    };\n\n    const first = element => descendant$1(element, isCursorPosition);\n    const last$1 = element => descendantRtl(element, isCursorPosition);\n    const descendantRtl = (scope, predicate) => {\n      const descend = element => {\n        const children = children$2(element);\n        for (let i = children.length - 1; i >= 0; i--) {\n          const child = children[i];\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(child);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope);\n    };\n\n    const transferableAttributes = {\n      scope: [\n        'row',\n        'col'\n      ]\n    };\n    const createCell = doc => () => {\n      const td = SugarElement.fromTag('td', doc.dom);\n      append$1(td, SugarElement.fromTag('br', doc.dom));\n      return td;\n    };\n    const createCol = doc => () => {\n      return SugarElement.fromTag('col', doc.dom);\n    };\n    const createColgroup = doc => () => {\n      return SugarElement.fromTag('colgroup', doc.dom);\n    };\n    const createRow$1 = doc => () => {\n      return SugarElement.fromTag('tr', doc.dom);\n    };\n    const replace$1 = (cell, tag, attrs) => {\n      const replica = copy$2(cell, tag);\n      each$1(attrs, (v, k) => {\n        if (v === null) {\n          remove$7(replica, k);\n        } else {\n          set$2(replica, k, v);\n        }\n      });\n      return replica;\n    };\n    const pasteReplace = cell => {\n      return cell;\n    };\n    const cloneFormats = (oldCell, newCell, formats) => {\n      const first$1 = first(oldCell);\n      return first$1.map(firstText => {\n        const formatSelector = formats.join(',');\n        const parents = ancestors$3(firstText, formatSelector, element => {\n          return eq$1(element, oldCell);\n        });\n        return foldr(parents, (last, parent) => {\n          const clonedFormat = shallow(parent);\n          append$1(last, clonedFormat);\n          return clonedFormat;\n        }, newCell);\n      }).getOr(newCell);\n    };\n    const cloneAppropriateAttributes = (original, clone) => {\n      each$1(transferableAttributes, (validAttributes, attributeName) => getOpt(original, attributeName).filter(attribute => contains$2(validAttributes, attribute)).each(attribute => set$2(clone, attributeName, attribute)));\n    };\n    const cellOperations = (mutate, doc, formatsToClone) => {\n      const cloneCss = (prev, clone) => {\n        copy$1(prev.element, clone);\n        remove$5(clone, 'height');\n        if (prev.colspan !== 1) {\n          remove$5(clone, 'width');\n        }\n      };\n      const newCell = prev => {\n        const td = SugarElement.fromTag(name(prev.element), doc.dom);\n        const formats = formatsToClone.getOr([\n          'strong',\n          'em',\n          'b',\n          'i',\n          'span',\n          'font',\n          'h1',\n          'h2',\n          'h3',\n          'h4',\n          'h5',\n          'h6',\n          'p',\n          'div'\n        ]);\n        const lastNode = formats.length > 0 ? cloneFormats(prev.element, td, formats) : td;\n        append$1(lastNode, SugarElement.fromTag('br'));\n        cloneCss(prev, td);\n        cloneAppropriateAttributes(prev.element, td);\n        mutate(prev.element, td);\n        return td;\n      };\n      const newCol = prev => {\n        const col = SugarElement.fromTag(name(prev.element), doc.dom);\n        cloneCss(prev, col);\n        mutate(prev.element, col);\n        return col;\n      };\n      return {\n        col: newCol,\n        colgroup: createColgroup(doc),\n        row: createRow$1(doc),\n        cell: newCell,\n        replace: replace$1,\n        colGap: createCol(doc),\n        gap: createCell(doc)\n      };\n    };\n    const paste$1 = doc => {\n      return {\n        col: createCol(doc),\n        colgroup: createColgroup(doc),\n        row: createRow$1(doc),\n        cell: createCell(doc),\n        replace: pasteReplace,\n        colGap: createCol(doc),\n        gap: createCell(doc)\n      };\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children$2(SugarElement.fromDom(div));\n    };\n    const fromDom = nodes => map$1(nodes, SugarElement.fromDom);\n\n    const option = name => editor => editor.options.get(name);\n    const defaultWidth = '100%';\n    const getPixelForcedWidth = editor => {\n      var _a;\n      const dom = editor.dom;\n      const parentBlock = (_a = dom.getParent(editor.selection.getStart(), dom.isBlock)) !== null && _a !== void 0 ? _a : editor.getBody();\n      return getInner(SugarElement.fromDom(parentBlock)) + 'px';\n    };\n    const determineDefaultTableStyles = (editor, defaultStyles) => {\n      if (isTableResponsiveForced(editor) || !shouldStyleWithCss(editor)) {\n        return defaultStyles;\n      } else if (isTablePixelsForced(editor)) {\n        return {\n          ...defaultStyles,\n          width: getPixelForcedWidth(editor)\n        };\n      } else {\n        return {\n          ...defaultStyles,\n          width: defaultWidth\n        };\n      }\n    };\n    const determineDefaultTableAttributes = (editor, defaultAttributes) => {\n      if (isTableResponsiveForced(editor) || shouldStyleWithCss(editor)) {\n        return defaultAttributes;\n      } else if (isTablePixelsForced(editor)) {\n        return {\n          ...defaultAttributes,\n          width: getPixelForcedWidth(editor)\n        };\n      } else {\n        return {\n          ...defaultAttributes,\n          width: defaultWidth\n        };\n      }\n    };\n    const register = editor => {\n      const registerOption = editor.options.register;\n      registerOption('table_clone_elements', { processor: 'string[]' });\n      registerOption('table_use_colgroups', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('table_header_type', {\n        processor: value => {\n          const valid = contains$2([\n            'section',\n            'cells',\n            'sectionCells',\n            'auto'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: section, cells, sectionCells or auto.'\n          };\n        },\n        default: 'section'\n      });\n      registerOption('table_sizing_mode', {\n        processor: 'string',\n        default: 'auto'\n      });\n      registerOption('table_default_attributes', {\n        processor: 'object',\n        default: { border: '1' }\n      });\n      registerOption('table_default_styles', {\n        processor: 'object',\n        default: { 'border-collapse': 'collapse' }\n      });\n      registerOption('table_column_resizing', {\n        processor: value => {\n          const valid = contains$2([\n            'preservetable',\n            'resizetable'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be preservetable, or resizetable.'\n          };\n        },\n        default: 'preservetable'\n      });\n      registerOption('table_resize_bars', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('table_style_by_css', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('table_merge_content_on_paste', {\n        processor: 'boolean',\n        default: true\n      });\n    };\n    const getTableCloneElements = editor => {\n      return Optional.from(editor.options.get('table_clone_elements'));\n    };\n    const hasTableObjectResizing = editor => {\n      const objectResizing = editor.options.get('object_resizing');\n      return contains$2(objectResizing.split(','), 'table');\n    };\n    const getTableHeaderType = option('table_header_type');\n    const getTableColumnResizingBehaviour = option('table_column_resizing');\n    const isPreserveTableColumnResizing = editor => getTableColumnResizingBehaviour(editor) === 'preservetable';\n    const isResizeTableColumnResizing = editor => getTableColumnResizingBehaviour(editor) === 'resizetable';\n    const getTableSizingMode = option('table_sizing_mode');\n    const isTablePercentagesForced = editor => getTableSizingMode(editor) === 'relative';\n    const isTablePixelsForced = editor => getTableSizingMode(editor) === 'fixed';\n    const isTableResponsiveForced = editor => getTableSizingMode(editor) === 'responsive';\n    const hasTableResizeBars = option('table_resize_bars');\n    const shouldStyleWithCss = option('table_style_by_css');\n    const shouldMergeContentOnPaste = option('table_merge_content_on_paste');\n    const getTableDefaultAttributes = editor => {\n      const options = editor.options;\n      const defaultAttributes = options.get('table_default_attributes');\n      return options.isSet('table_default_attributes') ? defaultAttributes : determineDefaultTableAttributes(editor, defaultAttributes);\n    };\n    const getTableDefaultStyles = editor => {\n      const options = editor.options;\n      const defaultStyles = options.get('table_default_styles');\n      return options.isSet('table_default_styles') ? defaultStyles : determineDefaultTableStyles(editor, defaultStyles);\n    };\n    const tableUseColumnGroup = option('table_use_colgroups');\n\n    const closest = target => closest$1(target, '[contenteditable]');\n    const isEditable$1 = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest(element).fold(constant(assumeEditable), editable => getRaw(editable) === 'true');\n      }\n    };\n    const getRaw = element => element.dom.contentEditable;\n\n    const getBody = editor => SugarElement.fromDom(editor.getBody());\n    const getIsRoot = editor => element => eq$1(element, getBody(editor));\n    const removeDataStyle = table => {\n      remove$7(table, 'data-mce-style');\n      const removeStyleAttribute = element => remove$7(element, 'data-mce-style');\n      each$2(cells$1(table), removeStyleAttribute);\n      each$2(columns$1(table), removeStyleAttribute);\n      each$2(rows$1(table), removeStyleAttribute);\n    };\n    const getSelectionStart = editor => SugarElement.fromDom(editor.selection.getStart());\n    const getPixelWidth = elm => elm.getBoundingClientRect().width;\n    const getPixelHeight = elm => elm.getBoundingClientRect().height;\n    const getRawWidth = (editor, elm) => {\n      const raw = editor.dom.getStyle(elm, 'width') || editor.dom.getAttrib(elm, 'width');\n      return Optional.from(raw).filter(isNotEmpty);\n    };\n    const isPercentage$1 = value => /^(\\d+(\\.\\d+)?)%$/.test(value);\n    const isPixel = value => /^(\\d+(\\.\\d+)?)px$/.test(value);\n    const isInEditableContext$1 = cell => closest$2(cell, isTag('table')).exists(isEditable$1);\n\n    const inSelection = (bounds, detail) => {\n      const leftEdge = detail.column;\n      const rightEdge = detail.column + detail.colspan - 1;\n      const topEdge = detail.row;\n      const bottomEdge = detail.row + detail.rowspan - 1;\n      return leftEdge <= bounds.finishCol && rightEdge >= bounds.startCol && (topEdge <= bounds.finishRow && bottomEdge >= bounds.startRow);\n    };\n    const isWithin = (bounds, detail) => {\n      return detail.column >= bounds.startCol && detail.column + detail.colspan - 1 <= bounds.finishCol && detail.row >= bounds.startRow && detail.row + detail.rowspan - 1 <= bounds.finishRow;\n    };\n    const isRectangular = (warehouse, bounds) => {\n      let isRect = true;\n      const detailIsWithin = curry(isWithin, bounds);\n      for (let i = bounds.startRow; i <= bounds.finishRow; i++) {\n        for (let j = bounds.startCol; j <= bounds.finishCol; j++) {\n          isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);\n        }\n      }\n      return isRect ? Optional.some(bounds) : Optional.none();\n    };\n\n    const getBounds = (detailA, detailB) => {\n      return bounds(Math.min(detailA.row, detailB.row), Math.min(detailA.column, detailB.column), Math.max(detailA.row + detailA.rowspan - 1, detailB.row + detailB.rowspan - 1), Math.max(detailA.column + detailA.colspan - 1, detailB.column + detailB.colspan - 1));\n    };\n    const getAnyBox = (warehouse, startCell, finishCell) => {\n      const startCoords = Warehouse.findItem(warehouse, startCell, eq$1);\n      const finishCoords = Warehouse.findItem(warehouse, finishCell, eq$1);\n      return startCoords.bind(sc => {\n        return finishCoords.map(fc => {\n          return getBounds(sc, fc);\n        });\n      });\n    };\n    const getBox$1 = (warehouse, startCell, finishCell) => {\n      return getAnyBox(warehouse, startCell, finishCell).bind(bounds => {\n        return isRectangular(warehouse, bounds);\n      });\n    };\n\n    const moveBy$1 = (warehouse, cell, row, column) => {\n      return Warehouse.findItem(warehouse, cell, eq$1).bind(detail => {\n        const startRow = row > 0 ? detail.row + detail.rowspan - 1 : detail.row;\n        const startCol = column > 0 ? detail.column + detail.colspan - 1 : detail.column;\n        const dest = Warehouse.getAt(warehouse, startRow + row, startCol + column);\n        return dest.map(d => {\n          return d.element;\n        });\n      });\n    };\n    const intercepts$1 = (warehouse, start, finish) => {\n      return getAnyBox(warehouse, start, finish).map(bounds => {\n        const inside = Warehouse.filterItems(warehouse, curry(inSelection, bounds));\n        return map$1(inside, detail => {\n          return detail.element;\n        });\n      });\n    };\n    const parentCell = (warehouse, innerCell) => {\n      const isContainedBy = (c1, c2) => {\n        return contains$1(c2, c1);\n      };\n      return Warehouse.findItem(warehouse, innerCell, isContainedBy).map(detail => {\n        return detail.element;\n      });\n    };\n\n    const moveBy = (cell, deltaRow, deltaColumn) => {\n      return table(cell).bind(table => {\n        const warehouse = getWarehouse(table);\n        return moveBy$1(warehouse, cell, deltaRow, deltaColumn);\n      });\n    };\n    const intercepts = (table, first, last) => {\n      const warehouse = getWarehouse(table);\n      return intercepts$1(warehouse, first, last);\n    };\n    const nestedIntercepts = (table, first, firstTable, last, lastTable) => {\n      const warehouse = getWarehouse(table);\n      const optStartCell = eq$1(table, firstTable) ? Optional.some(first) : parentCell(warehouse, first);\n      const optLastCell = eq$1(table, lastTable) ? Optional.some(last) : parentCell(warehouse, last);\n      return optStartCell.bind(startCell => optLastCell.bind(lastCell => intercepts$1(warehouse, startCell, lastCell)));\n    };\n    const getBox = (table, first, last) => {\n      const warehouse = getWarehouse(table);\n      return getBox$1(warehouse, first, last);\n    };\n    const getWarehouse = Warehouse.fromTable;\n\n    var TagBoundaries = [\n      'body',\n      'p',\n      'div',\n      'article',\n      'aside',\n      'figcaption',\n      'figure',\n      'footer',\n      'header',\n      'nav',\n      'section',\n      'ol',\n      'ul',\n      'li',\n      'table',\n      'thead',\n      'tbody',\n      'tfoot',\n      'caption',\n      'tr',\n      'td',\n      'th',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'blockquote',\n      'pre',\n      'address'\n    ];\n\n    var DomUniverse = () => {\n      const clone = element => {\n        return SugarElement.fromDom(element.dom.cloneNode(false));\n      };\n      const document = element => documentOrOwner(element).dom;\n      const isBoundary = element => {\n        if (!isElement(element)) {\n          return false;\n        }\n        if (name(element) === 'body') {\n          return true;\n        }\n        return contains$2(TagBoundaries, name(element));\n      };\n      const isEmptyTag = element => {\n        if (!isElement(element)) {\n          return false;\n        }\n        return contains$2([\n          'br',\n          'img',\n          'hr',\n          'input'\n        ], name(element));\n      };\n      const isNonEditable = element => isElement(element) && get$b(element, 'contenteditable') === 'false';\n      const comparePosition = (element, other) => {\n        return element.dom.compareDocumentPosition(other.dom);\n      };\n      const copyAttributesTo = (source, destination) => {\n        const as = clone$2(source);\n        setAll$1(destination, as);\n      };\n      const isSpecial = element => {\n        const tag = name(element);\n        return contains$2([\n          'script',\n          'noscript',\n          'iframe',\n          'noframes',\n          'noembed',\n          'title',\n          'style',\n          'textarea',\n          'xmp'\n        ], tag);\n      };\n      const getLanguage = element => isElement(element) ? getOpt(element, 'lang') : Optional.none();\n      return {\n        up: constant({\n          selector: ancestor$1,\n          closest: closest$1,\n          predicate: ancestor$2,\n          all: parents\n        }),\n        down: constant({\n          selector: descendants,\n          predicate: descendants$1\n        }),\n        styles: constant({\n          get: get$a,\n          getRaw: getRaw$2,\n          set: set$1,\n          remove: remove$5\n        }),\n        attrs: constant({\n          get: get$b,\n          set: set$2,\n          remove: remove$7,\n          copyTo: copyAttributesTo\n        }),\n        insert: constant({\n          before: before$3,\n          after: after$5,\n          afterAll: after$4,\n          append: append$1,\n          appendAll: append,\n          prepend: prepend,\n          wrap: wrap\n        }),\n        remove: constant({\n          unwrap: unwrap,\n          remove: remove$6\n        }),\n        create: constant({\n          nu: SugarElement.fromTag,\n          clone,\n          text: SugarElement.fromText\n        }),\n        query: constant({\n          comparePosition,\n          prevSibling: prevSibling,\n          nextSibling: nextSibling\n        }),\n        property: constant({\n          children: children$2,\n          name: name,\n          parent: parent,\n          document,\n          isText: isText,\n          isComment: isComment,\n          isElement: isElement,\n          isSpecial,\n          getLanguage,\n          getText: get$6,\n          setText: set,\n          isBoundary,\n          isEmptyTag,\n          isNonEditable\n        }),\n        eq: eq$1,\n        is: is$1\n      };\n    };\n\n    const all = (universe, look, elements, f) => {\n      const head = elements[0];\n      const tail = elements.slice(1);\n      return f(universe, look, head, tail);\n    };\n    const oneAll = (universe, look, elements) => {\n      return elements.length > 0 ? all(universe, look, elements, unsafeOne) : Optional.none();\n    };\n    const unsafeOne = (universe, look, head, tail) => {\n      const start = look(universe, head);\n      return foldr(tail, (b, a) => {\n        const current = look(universe, a);\n        return commonElement(universe, b, current);\n      }, start);\n    };\n    const commonElement = (universe, start, end) => {\n      return start.bind(s => {\n        return end.filter(curry(universe.eq, s));\n      });\n    };\n\n    const eq = (universe, item) => {\n      return curry(universe.eq, item);\n    };\n    const ancestors$2 = (universe, start, end, isRoot = never) => {\n      const ps1 = [start].concat(universe.up().all(start));\n      const ps2 = [end].concat(universe.up().all(end));\n      const prune = path => {\n        const index = findIndex(path, isRoot);\n        return index.fold(() => {\n          return path;\n        }, ind => {\n          return path.slice(0, ind + 1);\n        });\n      };\n      const pruned1 = prune(ps1);\n      const pruned2 = prune(ps2);\n      const shared = find$1(pruned1, x => {\n        return exists(pruned2, eq(universe, x));\n      });\n      return {\n        firstpath: pruned1,\n        secondpath: pruned2,\n        shared\n      };\n    };\n\n    const sharedOne$1 = oneAll;\n    const ancestors$1 = ancestors$2;\n\n    const universe$3 = DomUniverse();\n    const sharedOne = (look, elements) => {\n      return sharedOne$1(universe$3, (_universe, element) => {\n        return look(element);\n      }, elements);\n    };\n    const ancestors = (start, finish, isRoot) => {\n      return ancestors$1(universe$3, start, finish, isRoot);\n    };\n\n    const lookupTable = container => {\n      return ancestor$1(container, 'table');\n    };\n    const identify = (start, finish, isRoot) => {\n      const getIsRoot = rootTable => {\n        return element => {\n          return isRoot !== undefined && isRoot(element) || eq$1(element, rootTable);\n        };\n      };\n      if (eq$1(start, finish)) {\n        return Optional.some({\n          boxes: Optional.some([start]),\n          start,\n          finish\n        });\n      } else {\n        return lookupTable(start).bind(startTable => {\n          return lookupTable(finish).bind(finishTable => {\n            if (eq$1(startTable, finishTable)) {\n              return Optional.some({\n                boxes: intercepts(startTable, start, finish),\n                start,\n                finish\n              });\n            } else if (contains$1(startTable, finishTable)) {\n              const ancestorCells = ancestors$3(finish, 'td,th', getIsRoot(startTable));\n              const finishCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : finish;\n              return Optional.some({\n                boxes: nestedIntercepts(startTable, start, startTable, finish, finishTable),\n                start,\n                finish: finishCell\n              });\n            } else if (contains$1(finishTable, startTable)) {\n              const ancestorCells = ancestors$3(start, 'td,th', getIsRoot(finishTable));\n              const startCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : start;\n              return Optional.some({\n                boxes: nestedIntercepts(finishTable, start, startTable, finish, finishTable),\n                start,\n                finish: startCell\n              });\n            } else {\n              return ancestors(start, finish).shared.bind(lca => {\n                return closest$1(lca, 'table', isRoot).bind(lcaTable => {\n                  const finishAncestorCells = ancestors$3(finish, 'td,th', getIsRoot(lcaTable));\n                  const finishCell = finishAncestorCells.length > 0 ? finishAncestorCells[finishAncestorCells.length - 1] : finish;\n                  const startAncestorCells = ancestors$3(start, 'td,th', getIsRoot(lcaTable));\n                  const startCell = startAncestorCells.length > 0 ? startAncestorCells[startAncestorCells.length - 1] : start;\n                  return Optional.some({\n                    boxes: nestedIntercepts(lcaTable, start, startTable, finish, finishTable),\n                    start: startCell,\n                    finish: finishCell\n                  });\n                });\n              });\n            }\n          });\n        });\n      }\n    };\n    const retrieve$1 = (container, selector) => {\n      const sels = descendants(container, selector);\n      return sels.length > 0 ? Optional.some(sels) : Optional.none();\n    };\n    const getLast = (boxes, lastSelectedSelector) => {\n      return find$1(boxes, box => {\n        return is$2(box, lastSelectedSelector);\n      });\n    };\n    const getEdges = (container, firstSelectedSelector, lastSelectedSelector) => {\n      return descendant(container, firstSelectedSelector).bind(first => {\n        return descendant(container, lastSelectedSelector).bind(last => {\n          return sharedOne(lookupTable, [\n            first,\n            last\n          ]).map(table => {\n            return {\n              first,\n              last,\n              table\n            };\n          });\n        });\n      });\n    };\n    const expandTo = (finish, firstSelectedSelector) => {\n      return ancestor$1(finish, 'table').bind(table => {\n        return descendant(table, firstSelectedSelector).bind(start => {\n          return identify(start, finish).bind(identified => {\n            return identified.boxes.map(boxes => {\n              return {\n                boxes,\n                start: identified.start,\n                finish: identified.finish\n              };\n            });\n          });\n        });\n      });\n    };\n    const shiftSelection = (boxes, deltaRow, deltaColumn, firstSelectedSelector, lastSelectedSelector) => {\n      return getLast(boxes, lastSelectedSelector).bind(last => {\n        return moveBy(last, deltaRow, deltaColumn).bind(finish => {\n          return expandTo(finish, firstSelectedSelector);\n        });\n      });\n    };\n\n    const retrieve = (container, selector) => {\n      return retrieve$1(container, selector);\n    };\n    const retrieveBox = (container, firstSelectedSelector, lastSelectedSelector) => {\n      return getEdges(container, firstSelectedSelector, lastSelectedSelector).bind(edges => {\n        const isRoot = ancestor => {\n          return eq$1(container, ancestor);\n        };\n        const sectionSelector = 'thead,tfoot,tbody,table';\n        const firstAncestor = ancestor$1(edges.first, sectionSelector, isRoot);\n        const lastAncestor = ancestor$1(edges.last, sectionSelector, isRoot);\n        return firstAncestor.bind(fA => {\n          return lastAncestor.bind(lA => {\n            return eq$1(fA, lA) ? getBox(edges.table, edges.first, edges.last) : Optional.none();\n          });\n        });\n      });\n    };\n\n    const selection = identity;\n    const unmergable = selectedCells => {\n      const hasSpan = (elem, type) => getOpt(elem, type).exists(span => parseInt(span, 10) > 1);\n      const hasRowOrColSpan = elem => hasSpan(elem, 'rowspan') || hasSpan(elem, 'colspan');\n      return selectedCells.length > 0 && forall(selectedCells, hasRowOrColSpan) ? Optional.some(selectedCells) : Optional.none();\n    };\n    const mergable = (table, selectedCells, ephemera) => {\n      if (selectedCells.length <= 1) {\n        return Optional.none();\n      } else {\n        return retrieveBox(table, ephemera.firstSelectedSelector, ephemera.lastSelectedSelector).map(bounds => ({\n          bounds,\n          cells: selectedCells\n        }));\n      }\n    };\n\n    const strSelected = 'data-mce-selected';\n    const strSelectedSelector = 'td[' + strSelected + '],th[' + strSelected + ']';\n    const strAttributeSelector = '[' + strSelected + ']';\n    const strFirstSelected = 'data-mce-first-selected';\n    const strFirstSelectedSelector = 'td[' + strFirstSelected + '],th[' + strFirstSelected + ']';\n    const strLastSelected = 'data-mce-last-selected';\n    const strLastSelectedSelector = 'td[' + strLastSelected + '],th[' + strLastSelected + ']';\n    const attributeSelector = strAttributeSelector;\n    const ephemera = {\n      selected: strSelected,\n      selectedSelector: strSelectedSelector,\n      firstSelected: strFirstSelected,\n      firstSelectedSelector: strFirstSelectedSelector,\n      lastSelected: strLastSelected,\n      lastSelectedSelector: strLastSelectedSelector\n    };\n\n    const forMenu = (selectedCells, table, cell) => ({\n      element: cell,\n      mergable: mergable(table, selectedCells, ephemera),\n      unmergable: unmergable(selectedCells),\n      selection: selection(selectedCells)\n    });\n    const paste = (element, clipboard, generators) => ({\n      element,\n      clipboard,\n      generators\n    });\n    const pasteRows = (selectedCells, _cell, clipboard, generators) => ({\n      selection: selection(selectedCells),\n      clipboard,\n      generators\n    });\n\n    const getSelectionCellFallback = element => table(element).bind(table => retrieve(table, ephemera.firstSelectedSelector)).fold(constant(element), cells => cells[0]);\n    const getSelectionFromSelector = selector => (initCell, isRoot) => {\n      const cellName = name(initCell);\n      const cell = cellName === 'col' || cellName === 'colgroup' ? getSelectionCellFallback(initCell) : initCell;\n      return closest$1(cell, selector, isRoot);\n    };\n    const getSelectionCellOrCaption = getSelectionFromSelector('th,td,caption');\n    const getSelectionCell = getSelectionFromSelector('th,td');\n    const getCellsFromSelection = editor => fromDom(editor.model.table.getSelectedCells());\n    const getCellsFromFakeSelection = editor => filter$2(getCellsFromSelection(editor), cell => is$2(cell, ephemera.selectedSelector));\n\n    const extractSelected = cells => {\n      return table(cells[0]).map(table => {\n        const replica = extract$1(table, attributeSelector);\n        removeDataStyle(replica);\n        return [replica];\n      });\n    };\n    const serializeElements = (editor, elements) => map$1(elements, elm => editor.selection.serializer.serialize(elm.dom, {})).join('');\n    const getTextContent = elements => map$1(elements, element => element.dom.innerText).join('');\n    const registerEvents = (editor, actions) => {\n      editor.on('BeforeGetContent', e => {\n        const multiCellContext = cells => {\n          e.preventDefault();\n          extractSelected(cells).each(elements => {\n            e.content = e.format === 'text' ? getTextContent(elements) : serializeElements(editor, elements);\n          });\n        };\n        if (e.selection === true) {\n          const cells = getCellsFromFakeSelection(editor);\n          if (cells.length >= 1) {\n            multiCellContext(cells);\n          }\n        }\n      });\n      editor.on('BeforeSetContent', e => {\n        if (e.selection === true && e.paste === true) {\n          const selectedCells = getCellsFromSelection(editor);\n          head(selectedCells).each(cell => {\n            table(cell).each(table => {\n              const elements = filter$2(fromHtml(e.content), content => {\n                return name(content) !== 'meta';\n              });\n              const isTable = isTag('table');\n              if (shouldMergeContentOnPaste(editor) && elements.length === 1 && isTable(elements[0])) {\n                e.preventDefault();\n                const doc = SugarElement.fromDom(editor.getDoc());\n                const generators = paste$1(doc);\n                const targets = paste(cell, elements[0], generators);\n                actions.pasteCells(table, targets).each(() => {\n                  editor.focus();\n                });\n              }\n            });\n          });\n        }\n      });\n    };\n\n    const point = (element, offset) => ({\n      element,\n      offset\n    });\n\n    const scan$1 = (universe, element, direction) => {\n      if (universe.property().isText(element) && universe.property().getText(element).trim().length === 0 || universe.property().isComment(element)) {\n        return direction(element).bind(elem => {\n          return scan$1(universe, elem, direction).orThunk(() => {\n            return Optional.some(elem);\n          });\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const toEnd = (universe, element) => {\n      if (universe.property().isText(element)) {\n        return universe.property().getText(element).length;\n      }\n      const children = universe.property().children(element);\n      return children.length;\n    };\n    const freefallRtl$2 = (universe, element) => {\n      const candidate = scan$1(universe, element, universe.query().prevSibling).getOr(element);\n      if (universe.property().isText(candidate)) {\n        return point(candidate, toEnd(universe, candidate));\n      }\n      const children = universe.property().children(candidate);\n      return children.length > 0 ? freefallRtl$2(universe, children[children.length - 1]) : point(candidate, toEnd(universe, candidate));\n    };\n\n    const freefallRtl$1 = freefallRtl$2;\n\n    const universe$2 = DomUniverse();\n    const freefallRtl = element => {\n      return freefallRtl$1(universe$2, element);\n    };\n\n    const halve = (main, other) => {\n      if (!hasColspan(main)) {\n        const width = getGenericWidth(main);\n        width.each(w => {\n          const newWidth = w.value / 2;\n          setGenericWidth(main, newWidth, w.unit);\n          setGenericWidth(other, newWidth, w.unit);\n        });\n      }\n    };\n\n    const zero = array => map$1(array, constant(0));\n    const surround = (sizes, startIndex, endIndex, results, f) => f(sizes.slice(0, startIndex)).concat(results).concat(f(sizes.slice(endIndex)));\n    const clampDeltaHelper = predicate => (sizes, index, delta, minCellSize) => {\n      if (!predicate(delta)) {\n        return delta;\n      } else {\n        const newSize = Math.max(minCellSize, sizes[index] - Math.abs(delta));\n        const diff = Math.abs(newSize - sizes[index]);\n        return delta >= 0 ? diff : -diff;\n      }\n    };\n    const clampNegativeDelta = clampDeltaHelper(delta => delta < 0);\n    const clampDelta = clampDeltaHelper(always);\n    const resizeTable = () => {\n      const calcFixedDeltas = (sizes, index, next, delta, minCellSize) => {\n        const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);\n        return surround(sizes, index, next + 1, [\n          clampedDelta,\n          0\n        ], zero);\n      };\n      const calcRelativeDeltas = (sizes, index, delta, minCellSize) => {\n        const ratio = (100 + delta) / 100;\n        const newThis = Math.max(minCellSize, (sizes[index] + delta) / ratio);\n        return map$1(sizes, (size, idx) => {\n          const newSize = idx === index ? newThis : size / ratio;\n          return newSize - size;\n        });\n      };\n      const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize, isRelative) => {\n        if (isRelative) {\n          return calcRelativeDeltas(sizes, index, delta, minCellSize);\n        } else {\n          return calcFixedDeltas(sizes, index, next, delta, minCellSize);\n        }\n      };\n      const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize, isRelative) => calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize, isRelative);\n      const resizeTable = (resizer, delta) => resizer(delta);\n      const calcRightEdgeDeltas = (sizes, _prev, index, delta, minCellSize, isRelative) => {\n        if (isRelative) {\n          return calcRelativeDeltas(sizes, index, delta, minCellSize);\n        } else {\n          const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);\n          return zero(sizes.slice(0, index)).concat([clampedDelta]);\n        }\n      };\n      const calcRedestributedWidths = (sizes, totalWidth, pixelDelta, isRelative) => {\n        if (isRelative) {\n          const tableWidth = totalWidth + pixelDelta;\n          const ratio = tableWidth / totalWidth;\n          const newSizes = map$1(sizes, size => size / ratio);\n          return {\n            delta: ratio * 100 - 100,\n            newSizes\n          };\n        } else {\n          return {\n            delta: pixelDelta,\n            newSizes: sizes\n          };\n        }\n      };\n      return {\n        resizeTable,\n        clampTableDelta: clampNegativeDelta,\n        calcLeftEdgeDeltas,\n        calcMiddleDeltas,\n        calcRightEdgeDeltas,\n        calcRedestributedWidths\n      };\n    };\n    const preserveTable = () => {\n      const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize) => {\n        const idx = delta >= 0 ? next : index;\n        const clampedDelta = clampDelta(sizes, idx, delta, minCellSize);\n        return surround(sizes, index, next + 1, [\n          clampedDelta,\n          -clampedDelta\n        ], zero);\n      };\n      const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize) => calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize);\n      const resizeTable = (resizer, delta, isLastColumn) => {\n        if (isLastColumn) {\n          resizer(delta);\n        }\n      };\n      const calcRightEdgeDeltas = (sizes, _prev, _index, delta, _minCellSize, isRelative) => {\n        if (isRelative) {\n          return zero(sizes);\n        } else {\n          const diff = delta / sizes.length;\n          return map$1(sizes, constant(diff));\n        }\n      };\n      const clampTableDelta = (sizes, index, delta, minCellSize, isLastColumn) => {\n        if (isLastColumn) {\n          if (delta >= 0) {\n            return delta;\n          } else {\n            const maxDelta = foldl(sizes, (a, b) => a + b - minCellSize, 0);\n            return Math.max(-maxDelta, delta);\n          }\n        } else {\n          return clampNegativeDelta(sizes, index, delta, minCellSize);\n        }\n      };\n      const calcRedestributedWidths = (sizes, _totalWidth, _pixelDelta, _isRelative) => ({\n        delta: 0,\n        newSizes: sizes\n      });\n      return {\n        resizeTable,\n        clampTableDelta,\n        calcLeftEdgeDeltas,\n        calcMiddleDeltas,\n        calcRightEdgeDeltas,\n        calcRedestributedWidths\n      };\n    };\n\n    const getGridSize = table => {\n      const warehouse = Warehouse.fromTable(table);\n      return warehouse.grid;\n    };\n\n    const isHeaderCell = isTag('th');\n    const isHeaderCells = cells => forall(cells, cell => isHeaderCell(cell.element));\n    const getRowHeaderType = (isHeaderRow, isHeaderCells) => {\n      if (isHeaderRow && isHeaderCells) {\n        return 'sectionCells';\n      } else if (isHeaderRow) {\n        return 'section';\n      } else {\n        return 'cells';\n      }\n    };\n    const getRowType = row => {\n      const isHeaderRow = row.section === 'thead';\n      const isHeaderCells = is(findCommonCellType(row.cells), 'th');\n      if (row.section === 'tfoot') {\n        return { type: 'footer' };\n      } else if (isHeaderRow || isHeaderCells) {\n        return {\n          type: 'header',\n          subType: getRowHeaderType(isHeaderRow, isHeaderCells)\n        };\n      } else {\n        return { type: 'body' };\n      }\n    };\n    const findCommonCellType = cells => {\n      const headerCells = filter$2(cells, cell => isHeaderCell(cell.element));\n      if (headerCells.length === 0) {\n        return Optional.some('td');\n      } else if (headerCells.length === cells.length) {\n        return Optional.some('th');\n      } else {\n        return Optional.none();\n      }\n    };\n    const findCommonRowType = rows => {\n      const rowTypes = map$1(rows, row => getRowType(row).type);\n      const hasHeader = contains$2(rowTypes, 'header');\n      const hasFooter = contains$2(rowTypes, 'footer');\n      if (!hasHeader && !hasFooter) {\n        return Optional.some('body');\n      } else {\n        const hasBody = contains$2(rowTypes, 'body');\n        if (hasHeader && !hasBody && !hasFooter) {\n          return Optional.some('header');\n        } else if (!hasHeader && !hasBody && hasFooter) {\n          return Optional.some('footer');\n        } else {\n          return Optional.none();\n        }\n      }\n    };\n    const findTableRowHeaderType = warehouse => findMap(warehouse.all, row => {\n      const rowType = getRowType(row);\n      return rowType.type === 'header' ? Optional.from(rowType.subType) : Optional.none();\n    });\n\n    const transformCell = (cell, comparator, substitution) => elementnew(substitution(cell.element, comparator), true, cell.isLocked);\n    const transformRow = (row, section) => row.section !== section ? rowcells(row.element, row.cells, section, row.isNew) : row;\n    const section = () => ({\n      transformRow,\n      transformCell: (cell, comparator, substitution) => {\n        const newCell = substitution(cell.element, comparator);\n        const fixedCell = name(newCell) !== 'td' ? mutate$1(newCell, 'td') : newCell;\n        return elementnew(fixedCell, cell.isNew, cell.isLocked);\n      }\n    });\n    const sectionCells = () => ({\n      transformRow,\n      transformCell\n    });\n    const cells = () => ({\n      transformRow: (row, section) => {\n        const newSection = section === 'thead' ? 'tbody' : section;\n        return transformRow(row, newSection);\n      },\n      transformCell\n    });\n    const fallback = () => ({\n      transformRow: identity,\n      transformCell\n    });\n    const getTableSectionType = (table, fallback) => {\n      const warehouse = Warehouse.fromTable(table);\n      const type = findTableRowHeaderType(warehouse).getOr(fallback);\n      switch (type) {\n      case 'section':\n        return section();\n      case 'sectionCells':\n        return sectionCells();\n      case 'cells':\n        return cells();\n      }\n    };\n    const TableSection = {\n      getTableSectionType,\n      section,\n      sectionCells,\n      cells,\n      fallback\n    };\n\n    const setIfNot = (element, property, value, ignore) => {\n      if (value === ignore) {\n        remove$7(element, property);\n      } else {\n        set$2(element, property, value);\n      }\n    };\n    const insert$1 = (table, selector, element) => {\n      last$2(children(table, selector)).fold(() => prepend(table, element), child => after$5(child, element));\n    };\n    const generateSection = (table, sectionName) => {\n      const section = child(table, sectionName).getOrThunk(() => {\n        const newSection = SugarElement.fromTag(sectionName, owner(table).dom);\n        if (sectionName === 'thead') {\n          insert$1(table, 'caption,colgroup', newSection);\n        } else if (sectionName === 'colgroup') {\n          insert$1(table, 'caption', newSection);\n        } else {\n          append$1(table, newSection);\n        }\n        return newSection;\n      });\n      empty(section);\n      return section;\n    };\n    const render$1 = (table, grid) => {\n      const newRows = [];\n      const newCells = [];\n      const syncRows = gridSection => map$1(gridSection, row => {\n        if (row.isNew) {\n          newRows.push(row.element);\n        }\n        const tr = row.element;\n        empty(tr);\n        each$2(row.cells, cell => {\n          if (cell.isNew) {\n            newCells.push(cell.element);\n          }\n          setIfNot(cell.element, 'colspan', cell.colspan, 1);\n          setIfNot(cell.element, 'rowspan', cell.rowspan, 1);\n          append$1(tr, cell.element);\n        });\n        return tr;\n      });\n      const syncColGroup = gridSection => bind$2(gridSection, colGroup => map$1(colGroup.cells, col => {\n        setIfNot(col.element, 'span', col.colspan, 1);\n        return col.element;\n      }));\n      const renderSection = (gridSection, sectionName) => {\n        const section = generateSection(table, sectionName);\n        const sync = sectionName === 'colgroup' ? syncColGroup : syncRows;\n        const sectionElems = sync(gridSection);\n        append(section, sectionElems);\n      };\n      const removeSection = sectionName => {\n        child(table, sectionName).each(remove$6);\n      };\n      const renderOrRemoveSection = (gridSection, sectionName) => {\n        if (gridSection.length > 0) {\n          renderSection(gridSection, sectionName);\n        } else {\n          removeSection(sectionName);\n        }\n      };\n      const headSection = [];\n      const bodySection = [];\n      const footSection = [];\n      const columnGroupsSection = [];\n      each$2(grid, row => {\n        switch (row.section) {\n        case 'thead':\n          headSection.push(row);\n          break;\n        case 'tbody':\n          bodySection.push(row);\n          break;\n        case 'tfoot':\n          footSection.push(row);\n          break;\n        case 'colgroup':\n          columnGroupsSection.push(row);\n          break;\n        }\n      });\n      renderOrRemoveSection(columnGroupsSection, 'colgroup');\n      renderOrRemoveSection(headSection, 'thead');\n      renderOrRemoveSection(bodySection, 'tbody');\n      renderOrRemoveSection(footSection, 'tfoot');\n      return {\n        newRows,\n        newCells\n      };\n    };\n    const copy = grid => map$1(grid, row => {\n      const tr = shallow(row.element);\n      each$2(row.cells, cell => {\n        const clonedCell = deep(cell.element);\n        setIfNot(clonedCell, 'colspan', cell.colspan, 1);\n        setIfNot(clonedCell, 'rowspan', cell.rowspan, 1);\n        append$1(tr, clonedCell);\n      });\n      return tr;\n    });\n\n    const getColumn = (grid, index) => {\n      return map$1(grid, row => {\n        return getCell(row, index);\n      });\n    };\n    const getRow = (grid, index) => {\n      return grid[index];\n    };\n    const findDiff = (xs, comp) => {\n      if (xs.length === 0) {\n        return 0;\n      }\n      const first = xs[0];\n      const index = findIndex(xs, x => {\n        return !comp(first.element, x.element);\n      });\n      return index.getOr(xs.length);\n    };\n    const subgrid = (grid, row, column, comparator) => {\n      const gridRow = getRow(grid, row);\n      const isColRow = gridRow.section === 'colgroup';\n      const colspan = findDiff(gridRow.cells.slice(column), comparator);\n      const rowspan = isColRow ? 1 : findDiff(getColumn(grid.slice(row), column), comparator);\n      return {\n        colspan,\n        rowspan\n      };\n    };\n\n    const toDetails = (grid, comparator) => {\n      const seen = map$1(grid, row => map$1(row.cells, never));\n      const updateSeen = (rowIndex, columnIndex, rowspan, colspan) => {\n        for (let row = rowIndex; row < rowIndex + rowspan; row++) {\n          for (let column = columnIndex; column < columnIndex + colspan; column++) {\n            seen[row][column] = true;\n          }\n        }\n      };\n      return map$1(grid, (row, rowIndex) => {\n        const details = bind$2(row.cells, (cell, columnIndex) => {\n          if (seen[rowIndex][columnIndex] === false) {\n            const result = subgrid(grid, rowIndex, columnIndex, comparator);\n            updateSeen(rowIndex, columnIndex, result.rowspan, result.colspan);\n            return [detailnew(cell.element, result.rowspan, result.colspan, cell.isNew)];\n          } else {\n            return [];\n          }\n        });\n        return rowdetailnew(row.element, details, row.section, row.isNew);\n      });\n    };\n    const toGrid = (warehouse, generators, isNew) => {\n      const grid = [];\n      each$2(warehouse.colgroups, colgroup => {\n        const colgroupCols = [];\n        for (let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {\n          const element = Warehouse.getColumnAt(warehouse, columnIndex).map(column => elementnew(column.element, isNew, false)).getOrThunk(() => elementnew(generators.colGap(), true, false));\n          colgroupCols.push(element);\n        }\n        grid.push(rowcells(colgroup.element, colgroupCols, 'colgroup', isNew));\n      });\n      for (let rowIndex = 0; rowIndex < warehouse.grid.rows; rowIndex++) {\n        const rowCells = [];\n        for (let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {\n          const element = Warehouse.getAt(warehouse, rowIndex, columnIndex).map(item => elementnew(item.element, isNew, item.isLocked)).getOrThunk(() => elementnew(generators.gap(), true, false));\n          rowCells.push(element);\n        }\n        const rowDetail = warehouse.all[rowIndex];\n        const row = rowcells(rowDetail.element, rowCells, rowDetail.section, isNew);\n        grid.push(row);\n      }\n      return grid;\n    };\n\n    const fromWarehouse = (warehouse, generators) => toGrid(warehouse, generators, false);\n    const toDetailList = grid => toDetails(grid, eq$1);\n    const findInWarehouse = (warehouse, element) => findMap(warehouse.all, r => find$1(r.cells, e => eq$1(element, e.element)));\n    const extractCells = (warehouse, target, predicate) => {\n      const details = map$1(target.selection, cell$1 => {\n        return cell(cell$1).bind(lc => findInWarehouse(warehouse, lc)).filter(predicate);\n      });\n      const cells = cat(details);\n      return someIf(cells.length > 0, cells);\n    };\n    const run = (operation, extract, adjustment, postAction, genWrappers) => (table, target, generators, behaviours) => {\n      const warehouse = Warehouse.fromTable(table);\n      const tableSection = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.section).getOrThunk(TableSection.fallback);\n      const output = extract(warehouse, target).map(info => {\n        const model = fromWarehouse(warehouse, generators);\n        const result = operation(model, info, eq$1, genWrappers(generators), tableSection);\n        const lockedColumns = getLockedColumnsFromGrid(result.grid);\n        const grid = toDetailList(result.grid);\n        return {\n          info,\n          grid,\n          cursor: result.cursor,\n          lockedColumns\n        };\n      });\n      return output.bind(out => {\n        const newElements = render$1(table, out.grid);\n        const tableSizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.sizing).getOrThunk(() => TableSize.getTableSize(table));\n        const resizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.resize).getOrThunk(preserveTable);\n        adjustment(table, out.grid, out.info, {\n          sizing: tableSizing,\n          resize: resizing,\n          section: tableSection\n        });\n        postAction(table);\n        remove$7(table, LOCKED_COL_ATTR);\n        if (out.lockedColumns.length > 0) {\n          set$2(table, LOCKED_COL_ATTR, out.lockedColumns.join(','));\n        }\n        return Optional.some({\n          cursor: out.cursor,\n          newRows: newElements.newRows,\n          newCells: newElements.newCells\n        });\n      });\n    };\n    const onPaste = (warehouse, target) => cell(target.element).bind(cell => findInWarehouse(warehouse, cell).map(details => {\n      const value = {\n        ...details,\n        generators: target.generators,\n        clipboard: target.clipboard\n      };\n      return value;\n    }));\n    const onPasteByEditor = (warehouse, target) => extractCells(warehouse, target, always).map(cells => ({\n      cells,\n      generators: target.generators,\n      clipboard: target.clipboard\n    }));\n    const onMergable = (_warehouse, target) => target.mergable;\n    const onUnmergable = (_warehouse, target) => target.unmergable;\n    const onCells = (warehouse, target) => extractCells(warehouse, target, always);\n    const onUnlockedCells = (warehouse, target) => extractCells(warehouse, target, detail => !detail.isLocked);\n    const isUnlockedTableCell = (warehouse, cell) => findInWarehouse(warehouse, cell).exists(detail => !detail.isLocked);\n    const allUnlocked = (warehouse, cells) => forall(cells, cell => isUnlockedTableCell(warehouse, cell));\n    const onUnlockedMergable = (warehouse, target) => onMergable(warehouse, target).filter(mergeable => allUnlocked(warehouse, mergeable.cells));\n    const onUnlockedUnmergable = (warehouse, target) => onUnmergable(warehouse, target).filter(cells => allUnlocked(warehouse, cells));\n\n    const merge$2 = (grid, bounds, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      if (rows.length === 0) {\n        return grid;\n      }\n      for (let i = bounds.startRow; i <= bounds.finishRow; i++) {\n        for (let j = bounds.startCol; j <= bounds.finishCol; j++) {\n          const row = rows[i];\n          const isLocked = getCell(row, j).isLocked;\n          mutateCell(row, j, elementnew(substitution(), false, isLocked));\n        }\n      }\n      return grid;\n    };\n    const unmerge = (grid, target, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      let first = true;\n      for (let i = 0; i < rows.length; i++) {\n        for (let j = 0; j < cellLength(rows[0]); j++) {\n          const row = rows[i];\n          const currentCell = getCell(row, j);\n          const currentCellElm = currentCell.element;\n          const isToReplace = comparator(currentCellElm, target);\n          if (isToReplace && !first) {\n            mutateCell(row, j, elementnew(substitution(), true, currentCell.isLocked));\n          } else if (isToReplace) {\n            first = false;\n          }\n        }\n      }\n      return grid;\n    };\n    const uniqueCells = (row, comparator) => {\n      return foldl(row, (rest, cell) => {\n        return exists(rest, currentCell => {\n          return comparator(currentCell.element, cell.element);\n        }) ? rest : rest.concat([cell]);\n      }, []);\n    };\n    const splitCols = (grid, index, comparator, substitution) => {\n      if (index > 0 && index < grid[0].cells.length) {\n        each$2(grid, row => {\n          const prevCell = row.cells[index - 1];\n          let offset = 0;\n          const substitute = substitution();\n          while (row.cells.length > index + offset && comparator(prevCell.element, row.cells[index + offset].element)) {\n            mutateCell(row, index + offset, elementnew(substitute, true, row.cells[index + offset].isLocked));\n            offset++;\n          }\n        });\n      }\n      return grid;\n    };\n    const splitRows = (grid, index, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      if (index > 0 && index < rows.length) {\n        const rowPrevCells = rows[index - 1].cells;\n        const cells = uniqueCells(rowPrevCells, comparator);\n        each$2(cells, cell => {\n          let replacement = Optional.none();\n          for (let i = index; i < rows.length; i++) {\n            for (let j = 0; j < cellLength(rows[0]); j++) {\n              const row = rows[i];\n              const current = getCell(row, j);\n              const isToReplace = comparator(current.element, cell.element);\n              if (isToReplace) {\n                if (replacement.isNone()) {\n                  replacement = Optional.some(substitution());\n                }\n                replacement.each(sub => {\n                  mutateCell(row, j, elementnew(sub, true, current.isLocked));\n                });\n              }\n            }\n          }\n        });\n      }\n      return grid;\n    };\n\n    const value$1 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply,\n        orThunk: apply,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n    const Result = {\n      value: value$1,\n      error,\n      fromOption\n    };\n\n    const measure = (startAddress, gridA, gridB) => {\n      if (startAddress.row >= gridA.length || startAddress.column > cellLength(gridA[0])) {\n        return Result.error('invalid start address out of table bounds, row: ' + startAddress.row + ', column: ' + startAddress.column);\n      }\n      const rowRemainder = gridA.slice(startAddress.row);\n      const colRemainder = rowRemainder[0].cells.slice(startAddress.column);\n      const colRequired = cellLength(gridB[0]);\n      const rowRequired = gridB.length;\n      return Result.value({\n        rowDelta: rowRemainder.length - rowRequired,\n        colDelta: colRemainder.length - colRequired\n      });\n    };\n    const measureWidth = (gridA, gridB) => {\n      const colLengthA = cellLength(gridA[0]);\n      const colLengthB = cellLength(gridB[0]);\n      return {\n        rowDelta: 0,\n        colDelta: colLengthA - colLengthB\n      };\n    };\n    const measureHeight = (gridA, gridB) => {\n      const rowLengthA = gridA.length;\n      const rowLengthB = gridB.length;\n      return {\n        rowDelta: rowLengthA - rowLengthB,\n        colDelta: 0\n      };\n    };\n    const generateElements = (amount, row, generators, isLocked) => {\n      const generator = row.section === 'colgroup' ? generators.col : generators.cell;\n      return range$1(amount, idx => elementnew(generator(), true, isLocked(idx)));\n    };\n    const rowFill = (grid, amount, generators, lockedColumns) => {\n      const exampleRow = grid[grid.length - 1];\n      return grid.concat(range$1(amount, () => {\n        const generator = exampleRow.section === 'colgroup' ? generators.colgroup : generators.row;\n        const row = clone(exampleRow, generator, identity);\n        const elements = generateElements(row.cells.length, row, generators, idx => has$1(lockedColumns, idx.toString()));\n        return setCells(row, elements);\n      }));\n    };\n    const colFill = (grid, amount, generators, startIndex) => map$1(grid, row => {\n      const newChildren = generateElements(amount, row, generators, never);\n      return addCells(row, startIndex, newChildren);\n    });\n    const lockedColFill = (grid, generators, lockedColumns) => map$1(grid, row => {\n      return foldl(lockedColumns, (acc, colNum) => {\n        const newChild = generateElements(1, row, generators, always)[0];\n        return addCell(acc, colNum, newChild);\n      }, row);\n    });\n    const tailor = (gridA, delta, generators) => {\n      const fillCols = delta.colDelta < 0 ? colFill : identity;\n      const fillRows = delta.rowDelta < 0 ? rowFill : identity;\n      const lockedColumns = getLockedColumnsFromGrid(gridA);\n      const gridWidth = cellLength(gridA[0]);\n      const isLastColLocked = exists(lockedColumns, locked => locked === gridWidth - 1);\n      const modifiedCols = fillCols(gridA, Math.abs(delta.colDelta), generators, isLastColLocked ? gridWidth - 1 : gridWidth);\n      const newLockedColumns = getLockedColumnsFromGrid(modifiedCols);\n      return fillRows(modifiedCols, Math.abs(delta.rowDelta), generators, mapToObject(newLockedColumns, always));\n    };\n\n    const isSpanning = (grid, row, col, comparator) => {\n      const candidate = getCell(grid[row], col);\n      const matching = curry(comparator, candidate.element);\n      const currentRow = grid[row];\n      return grid.length > 1 && cellLength(currentRow) > 1 && (col > 0 && matching(getCellElement(currentRow, col - 1)) || col < currentRow.cells.length - 1 && matching(getCellElement(currentRow, col + 1)) || row > 0 && matching(getCellElement(grid[row - 1], col)) || row < grid.length - 1 && matching(getCellElement(grid[row + 1], col)));\n    };\n    const mergeTables = (startAddress, gridA, gridBRows, generator, comparator, lockedColumns) => {\n      const startRow = startAddress.row;\n      const startCol = startAddress.column;\n      const mergeHeight = gridBRows.length;\n      const mergeWidth = cellLength(gridBRows[0]);\n      const endRow = startRow + mergeHeight;\n      const endCol = startCol + mergeWidth + lockedColumns.length;\n      const lockedColumnObj = mapToObject(lockedColumns, always);\n      for (let r = startRow; r < endRow; r++) {\n        let skippedCol = 0;\n        for (let c = startCol; c < endCol; c++) {\n          if (lockedColumnObj[c]) {\n            skippedCol++;\n            continue;\n          }\n          if (isSpanning(gridA, r, c, comparator)) {\n            unmerge(gridA, getCellElement(gridA[r], c), comparator, generator.cell);\n          }\n          const gridBColIndex = c - startCol - skippedCol;\n          const newCell = getCell(gridBRows[r - startRow], gridBColIndex);\n          const newCellElm = newCell.element;\n          const replacement = generator.replace(newCellElm);\n          mutateCell(gridA[r], c, elementnew(replacement, true, newCell.isLocked));\n        }\n      }\n      return gridA;\n    };\n    const getValidStartAddress = (currentStartAddress, grid, lockedColumns) => {\n      const gridColLength = cellLength(grid[0]);\n      const adjustedRowAddress = extractGridDetails(grid).cols.length + currentStartAddress.row;\n      const possibleColAddresses = range$1(gridColLength - currentStartAddress.column, num => num + currentStartAddress.column);\n      const validColAddress = find$1(possibleColAddresses, num => forall(lockedColumns, col => col !== num)).getOr(gridColLength - 1);\n      return {\n        row: adjustedRowAddress,\n        column: validColAddress\n      };\n    };\n    const getLockedColumnsWithinBounds = (startAddress, rows, lockedColumns) => filter$2(lockedColumns, colNum => colNum >= startAddress.column && colNum <= cellLength(rows[0]) + startAddress.column);\n    const merge$1 = (startAddress, gridA, gridB, generator, comparator) => {\n      const lockedColumns = getLockedColumnsFromGrid(gridA);\n      const validStartAddress = getValidStartAddress(startAddress, gridA, lockedColumns);\n      const gridBRows = extractGridDetails(gridB).rows;\n      const lockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, lockedColumns);\n      const result = measure(validStartAddress, gridA, gridBRows);\n      return result.map(diff => {\n        const delta = {\n          ...diff,\n          colDelta: diff.colDelta - lockedColumnsWithinBounds.length\n        };\n        const fittedGrid = tailor(gridA, delta, generator);\n        const newLockedColumns = getLockedColumnsFromGrid(fittedGrid);\n        const newLockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, newLockedColumns);\n        return mergeTables(validStartAddress, fittedGrid, gridBRows, generator, comparator, newLockedColumnsWithinBounds);\n      });\n    };\n    const insertCols = (index, gridA, gridB, generator, comparator) => {\n      splitCols(gridA, index, comparator, generator.cell);\n      const delta = measureHeight(gridB, gridA);\n      const fittedNewGrid = tailor(gridB, delta, generator);\n      const secondDelta = measureHeight(gridA, fittedNewGrid);\n      const fittedOldGrid = tailor(gridA, secondDelta, generator);\n      return map$1(fittedOldGrid, (gridRow, i) => {\n        return addCells(gridRow, index, fittedNewGrid[i].cells);\n      });\n    };\n    const insertRows = (index, gridA, gridB, generator, comparator) => {\n      splitRows(gridA, index, comparator, generator.cell);\n      const locked = getLockedColumnsFromGrid(gridA);\n      const diff = measureWidth(gridA, gridB);\n      const delta = {\n        ...diff,\n        colDelta: diff.colDelta - locked.length\n      };\n      const fittedOldGrid = tailor(gridA, delta, generator);\n      const {\n        cols: oldCols,\n        rows: oldRows\n      } = extractGridDetails(fittedOldGrid);\n      const newLocked = getLockedColumnsFromGrid(fittedOldGrid);\n      const secondDiff = measureWidth(gridB, gridA);\n      const secondDelta = {\n        ...secondDiff,\n        colDelta: secondDiff.colDelta + newLocked.length\n      };\n      const fittedGridB = lockedColFill(gridB, generator, newLocked);\n      const fittedNewGrid = tailor(fittedGridB, secondDelta, generator);\n      return [\n        ...oldCols,\n        ...oldRows.slice(0, index),\n        ...fittedNewGrid,\n        ...oldRows.slice(index, oldRows.length)\n      ];\n    };\n\n    const cloneRow = (row, cloneCell, comparator, substitution) => clone(row, elem => substitution(elem, comparator), cloneCell);\n    const insertRowAt = (grid, index, example, comparator, substitution) => {\n      const {rows, cols} = extractGridDetails(grid);\n      const before = rows.slice(0, index);\n      const after = rows.slice(index);\n      const newRow = cloneRow(rows[example], (ex, c) => {\n        const withinSpan = index > 0 && index < rows.length && comparator(getCellElement(rows[index - 1], c), getCellElement(rows[index], c));\n        const ret = withinSpan ? getCell(rows[index], c) : elementnew(substitution(ex.element, comparator), true, ex.isLocked);\n        return ret;\n      }, comparator, substitution);\n      return [\n        ...cols,\n        ...before,\n        newRow,\n        ...after\n      ];\n    };\n    const getElementFor = (row, column, section, withinSpan, example, comparator, substitution) => {\n      if (section === 'colgroup' || !withinSpan) {\n        const cell = getCell(row, example);\n        return elementnew(substitution(cell.element, comparator), true, false);\n      } else {\n        return getCell(row, column);\n      }\n    };\n    const insertColumnAt = (grid, index, example, comparator, substitution) => map$1(grid, row => {\n      const withinSpan = index > 0 && index < cellLength(row) && comparator(getCellElement(row, index - 1), getCellElement(row, index));\n      const sub = getElementFor(row, index, row.section, withinSpan, example, comparator, substitution);\n      return addCell(row, index, sub);\n    });\n    const deleteColumnsAt = (grid, columns) => bind$2(grid, row => {\n      const existingCells = row.cells;\n      const cells = foldr(columns, (acc, column) => column >= 0 && column < acc.length ? acc.slice(0, column).concat(acc.slice(column + 1)) : acc, existingCells);\n      return cells.length > 0 ? [rowcells(row.element, cells, row.section, row.isNew)] : [];\n    });\n    const deleteRowsAt = (grid, start, finish) => {\n      const {rows, cols} = extractGridDetails(grid);\n      return [\n        ...cols,\n        ...rows.slice(0, start),\n        ...rows.slice(finish + 1)\n      ];\n    };\n\n    const notInStartRow = (grid, rowIndex, colIndex, comparator) => getCellElement(grid[rowIndex], colIndex) !== undefined && (rowIndex > 0 && comparator(getCellElement(grid[rowIndex - 1], colIndex), getCellElement(grid[rowIndex], colIndex)));\n    const notInStartColumn = (row, index, comparator) => index > 0 && comparator(getCellElement(row, index - 1), getCellElement(row, index));\n    const isDuplicatedCell = (grid, rowIndex, colIndex, comparator) => notInStartRow(grid, rowIndex, colIndex, comparator) || notInStartColumn(grid[rowIndex], colIndex, comparator);\n    const rowReplacerPredicate = (targetRow, columnHeaders) => {\n      const entireTableIsHeader = forall(columnHeaders, identity) && isHeaderCells(targetRow.cells);\n      return entireTableIsHeader ? always : (cell, _rowIndex, colIndex) => {\n        const type = name(cell.element);\n        return !(type === 'th' && columnHeaders[colIndex]);\n      };\n    };\n    const columnReplacePredicate = (targetColumn, rowHeaders) => {\n      const entireTableIsHeader = forall(rowHeaders, identity) && isHeaderCells(targetColumn);\n      return entireTableIsHeader ? always : (cell, rowIndex, _colIndex) => {\n        const type = name(cell.element);\n        return !(type === 'th' && rowHeaders[rowIndex]);\n      };\n    };\n    const determineScope = (applyScope, cell, newScope, isInHeader) => {\n      const hasSpan = scope => scope === 'row' ? hasRowspan(cell) : hasColspan(cell);\n      const getScope = scope => hasSpan(scope) ? `${ scope }group` : scope;\n      if (applyScope) {\n        return isHeaderCell(cell) ? getScope(newScope) : null;\n      } else if (isInHeader && isHeaderCell(cell)) {\n        const oppositeScope = newScope === 'row' ? 'col' : 'row';\n        return getScope(oppositeScope);\n      } else {\n        return null;\n      }\n    };\n    const rowScopeGenerator = (applyScope, columnHeaders) => (cell, rowIndex, columnIndex) => Optional.some(determineScope(applyScope, cell.element, 'col', columnHeaders[columnIndex]));\n    const columnScopeGenerator = (applyScope, rowHeaders) => (cell, rowIndex) => Optional.some(determineScope(applyScope, cell.element, 'row', rowHeaders[rowIndex]));\n    const replace = (cell, comparator, substitute) => elementnew(substitute(cell.element, comparator), true, cell.isLocked);\n    const replaceIn = (grid, targets, comparator, substitute, replacer, genScope, shouldReplace) => {\n      const isTarget = cell => {\n        return exists(targets, target => {\n          return comparator(cell.element, target.element);\n        });\n      };\n      return map$1(grid, (row, rowIndex) => {\n        return mapCells(row, (cell, colIndex) => {\n          if (isTarget(cell)) {\n            const newCell = shouldReplace(cell, rowIndex, colIndex) ? replacer(cell, comparator, substitute) : cell;\n            genScope(newCell, rowIndex, colIndex).each(scope => {\n              setOptions(newCell.element, { scope: Optional.from(scope) });\n            });\n            return newCell;\n          } else {\n            return cell;\n          }\n        });\n      });\n    };\n    const getColumnCells = (rows, columnIndex, comparator) => bind$2(rows, (row, i) => {\n      return isDuplicatedCell(rows, i, columnIndex, comparator) ? [] : [getCell(row, columnIndex)];\n    });\n    const getRowCells = (rows, rowIndex, comparator) => {\n      const targetRow = rows[rowIndex];\n      return bind$2(targetRow.cells, (item, i) => {\n        return isDuplicatedCell(rows, rowIndex, i, comparator) ? [] : [item];\n      });\n    };\n    const replaceColumns = (grid, indexes, applyScope, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      const targets = bind$2(indexes, index => getColumnCells(rows, index, comparator));\n      const rowHeaders = map$1(rows, row => isHeaderCells(row.cells));\n      const shouldReplaceCell = columnReplacePredicate(targets, rowHeaders);\n      const scopeGenerator = columnScopeGenerator(applyScope, rowHeaders);\n      return replaceIn(grid, targets, comparator, substitution, replace, scopeGenerator, shouldReplaceCell);\n    };\n    const replaceRows = (grid, indexes, section, applyScope, comparator, substitution, tableSection) => {\n      const {cols, rows} = extractGridDetails(grid);\n      const targetRow = rows[indexes[0]];\n      const targets = bind$2(indexes, index => getRowCells(rows, index, comparator));\n      const columnHeaders = map$1(targetRow.cells, (_cell, index) => isHeaderCells(getColumnCells(rows, index, comparator)));\n      const newRows = [...rows];\n      each$2(indexes, index => {\n        newRows[index] = tableSection.transformRow(rows[index], section);\n      });\n      const newGrid = [\n        ...cols,\n        ...newRows\n      ];\n      const shouldReplaceCell = rowReplacerPredicate(targetRow, columnHeaders);\n      const scopeGenerator = rowScopeGenerator(applyScope, columnHeaders);\n      return replaceIn(newGrid, targets, comparator, substitution, tableSection.transformCell, scopeGenerator, shouldReplaceCell);\n    };\n    const replaceCells = (grid, details, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      const targetCells = map$1(details, detail => getCell(rows[detail.row], detail.column));\n      return replaceIn(grid, targetCells, comparator, substitution, replace, Optional.none, always);\n    };\n\n    const generate = cases => {\n      if (!isArray(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$2(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate };\n\n    const adt$6 = Adt.generate([\n      { none: [] },\n      { only: ['index'] },\n      {\n        left: [\n          'index',\n          'next'\n        ]\n      },\n      {\n        middle: [\n          'prev',\n          'index',\n          'next'\n        ]\n      },\n      {\n        right: [\n          'prev',\n          'index'\n        ]\n      }\n    ]);\n    const ColumnContext = { ...adt$6 };\n\n    const neighbours = (input, index) => {\n      if (input.length === 0) {\n        return ColumnContext.none();\n      }\n      if (input.length === 1) {\n        return ColumnContext.only(0);\n      }\n      if (index === 0) {\n        return ColumnContext.left(0, 1);\n      }\n      if (index === input.length - 1) {\n        return ColumnContext.right(index - 1, index);\n      }\n      if (index > 0 && index < input.length - 1) {\n        return ColumnContext.middle(index - 1, index, index + 1);\n      }\n      return ColumnContext.none();\n    };\n    const determine = (input, column, step, tableSize, resize) => {\n      const result = input.slice(0);\n      const context = neighbours(input, column);\n      const onNone = constant(map$1(result, constant(0)));\n      const onOnly = index => tableSize.singleColumnWidth(result[index], step);\n      const onLeft = (index, next) => resize.calcLeftEdgeDeltas(result, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);\n      const onMiddle = (prev, index, next) => resize.calcMiddleDeltas(result, prev, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);\n      const onRight = (prev, index) => resize.calcRightEdgeDeltas(result, prev, index, step, tableSize.minCellWidth(), tableSize.isRelative);\n      return context.fold(onNone, onOnly, onLeft, onMiddle, onRight);\n    };\n\n    const total = (start, end, measures) => {\n      let r = 0;\n      for (let i = start; i < end; i++) {\n        r += measures[i] !== undefined ? measures[i] : 0;\n      }\n      return r;\n    };\n    const recalculateWidthForCells = (warehouse, widths) => {\n      const all = Warehouse.justCells(warehouse);\n      return map$1(all, cell => {\n        const width = total(cell.column, cell.column + cell.colspan, widths);\n        return {\n          element: cell.element,\n          width,\n          colspan: cell.colspan\n        };\n      });\n    };\n    const recalculateWidthForColumns = (warehouse, widths) => {\n      const groups = Warehouse.justColumns(warehouse);\n      return map$1(groups, (column, index) => ({\n        element: column.element,\n        width: widths[index],\n        colspan: column.colspan\n      }));\n    };\n    const recalculateHeightForCells = (warehouse, heights) => {\n      const all = Warehouse.justCells(warehouse);\n      return map$1(all, cell => {\n        const height = total(cell.row, cell.row + cell.rowspan, heights);\n        return {\n          element: cell.element,\n          height,\n          rowspan: cell.rowspan\n        };\n      });\n    };\n    const matchRowHeight = (warehouse, heights) => {\n      return map$1(warehouse.all, (row, i) => {\n        return {\n          element: row.element,\n          height: heights[i]\n        };\n      });\n    };\n\n    const sumUp = newSize => foldr(newSize, (b, a) => b + a, 0);\n    const recalculate = (warehouse, widths) => {\n      if (Warehouse.hasColumns(warehouse)) {\n        return recalculateWidthForColumns(warehouse, widths);\n      } else {\n        return recalculateWidthForCells(warehouse, widths);\n      }\n    };\n    const recalculateAndApply = (warehouse, widths, tableSize) => {\n      const newSizes = recalculate(warehouse, widths);\n      each$2(newSizes, cell => {\n        tableSize.setElementWidth(cell.element, cell.width);\n      });\n    };\n    const adjustWidth = (table, delta, index, resizing, tableSize) => {\n      const warehouse = Warehouse.fromTable(table);\n      const step = tableSize.getCellDelta(delta);\n      const widths = tableSize.getWidths(warehouse, tableSize);\n      const isLastColumn = index === warehouse.grid.columns - 1;\n      const clampedStep = resizing.clampTableDelta(widths, index, step, tableSize.minCellWidth(), isLastColumn);\n      const deltas = determine(widths, index, clampedStep, tableSize, resizing);\n      const newWidths = map$1(deltas, (dx, i) => dx + widths[i]);\n      recalculateAndApply(warehouse, newWidths, tableSize);\n      resizing.resizeTable(tableSize.adjustTableWidth, clampedStep, isLastColumn);\n    };\n    const adjustHeight = (table, delta, index, direction) => {\n      const warehouse = Warehouse.fromTable(table);\n      const heights = getPixelHeights(warehouse, table, direction);\n      const newHeights = map$1(heights, (dy, i) => index === i ? Math.max(delta + dy, minHeight()) : dy);\n      const newCellSizes = recalculateHeightForCells(warehouse, newHeights);\n      const newRowSizes = matchRowHeight(warehouse, newHeights);\n      each$2(newRowSizes, row => {\n        setHeight(row.element, row.height);\n      });\n      each$2(newCellSizes, cell => {\n        setHeight(cell.element, cell.height);\n      });\n      const total = sumUp(newHeights);\n      setHeight(table, total);\n    };\n    const adjustAndRedistributeWidths$1 = (_table, list, details, tableSize, resizeBehaviour) => {\n      const warehouse = Warehouse.generate(list);\n      const sizes = tableSize.getWidths(warehouse, tableSize);\n      const tablePixelWidth = tableSize.pixelWidth();\n      const {newSizes, delta} = resizeBehaviour.calcRedestributedWidths(sizes, tablePixelWidth, details.pixelDelta, tableSize.isRelative);\n      recalculateAndApply(warehouse, newSizes, tableSize);\n      tableSize.adjustTableWidth(delta);\n    };\n    const adjustWidthTo = (_table, list, _info, tableSize) => {\n      const warehouse = Warehouse.generate(list);\n      const widths = tableSize.getWidths(warehouse, tableSize);\n      recalculateAndApply(warehouse, widths, tableSize);\n    };\n\n    const uniqueColumns = details => {\n      const uniqueCheck = (rest, detail) => {\n        const columnExists = exists(rest, currentDetail => currentDetail.column === detail.column);\n        return columnExists ? rest : rest.concat([detail]);\n      };\n      return foldl(details, uniqueCheck, []).sort((detailA, detailB) => detailA.column - detailB.column);\n    };\n\n    const isCol = isTag('col');\n    const isColgroup = isTag('colgroup');\n    const isRow$1 = element => name(element) === 'tr' || isColgroup(element);\n    const elementToData = element => {\n      const colspan = getAttrValue(element, 'colspan', 1);\n      const rowspan = getAttrValue(element, 'rowspan', 1);\n      return {\n        element,\n        colspan,\n        rowspan\n      };\n    };\n    const modification = (generators, toData = elementToData) => {\n      const nuCell = data => isCol(data.element) ? generators.col(data) : generators.cell(data);\n      const nuRow = data => isColgroup(data.element) ? generators.colgroup(data) : generators.row(data);\n      const add = element => {\n        if (isRow$1(element)) {\n          return nuRow({ element });\n        } else {\n          const cell = element;\n          const replacement = nuCell(toData(cell));\n          recent = Optional.some({\n            item: cell,\n            replacement\n          });\n          return replacement;\n        }\n      };\n      let recent = Optional.none();\n      const getOrInit = (element, comparator) => {\n        return recent.fold(() => {\n          return add(element);\n        }, p => {\n          return comparator(element, p.item) ? p.replacement : add(element);\n        });\n      };\n      return { getOrInit };\n    };\n    const transform$1 = tag => {\n      return generators => {\n        const list = [];\n        const find = (element, comparator) => {\n          return find$1(list, x => {\n            return comparator(x.item, element);\n          });\n        };\n        const makeNew = element => {\n          const attrs = tag === 'td' ? { scope: null } : {};\n          const cell = generators.replace(element, tag, attrs);\n          list.push({\n            item: element,\n            sub: cell\n          });\n          return cell;\n        };\n        const replaceOrInit = (element, comparator) => {\n          if (isRow$1(element) || isCol(element)) {\n            return element;\n          } else {\n            const cell = element;\n            return find(cell, comparator).fold(() => {\n              return makeNew(cell);\n            }, p => {\n              return comparator(element, p.item) ? p.sub : makeNew(cell);\n            });\n          }\n        };\n        return { replaceOrInit };\n      };\n    };\n    const getScopeAttribute = cell => getOpt(cell, 'scope').map(attribute => attribute.substr(0, 3));\n    const merging = generators => {\n      const unmerge = cell => {\n        const scope = getScopeAttribute(cell);\n        scope.each(attribute => set$2(cell, 'scope', attribute));\n        return () => {\n          const raw = generators.cell({\n            element: cell,\n            colspan: 1,\n            rowspan: 1\n          });\n          remove$5(raw, 'width');\n          remove$5(cell, 'width');\n          scope.each(attribute => set$2(raw, 'scope', attribute));\n          return raw;\n        };\n      };\n      const merge = cells => {\n        const getScopeProperty = () => {\n          const stringAttributes = cat(map$1(cells, getScopeAttribute));\n          if (stringAttributes.length === 0) {\n            return Optional.none();\n          } else {\n            const baseScope = stringAttributes[0];\n            const scopes = [\n              'row',\n              'col'\n            ];\n            const isMixed = exists(stringAttributes, attribute => {\n              return attribute !== baseScope && contains$2(scopes, attribute);\n            });\n            return isMixed ? Optional.none() : Optional.from(baseScope);\n          }\n        };\n        remove$5(cells[0], 'width');\n        getScopeProperty().fold(() => remove$7(cells[0], 'scope'), attribute => set$2(cells[0], 'scope', attribute + 'group'));\n        return constant(cells[0]);\n      };\n      return {\n        unmerge,\n        merge\n      };\n    };\n    const Generators = {\n      modification,\n      transform: transform$1,\n      merging\n    };\n\n    const blockList = [\n      'body',\n      'p',\n      'div',\n      'article',\n      'aside',\n      'figcaption',\n      'figure',\n      'footer',\n      'header',\n      'nav',\n      'section',\n      'ol',\n      'ul',\n      'table',\n      'thead',\n      'tfoot',\n      'tbody',\n      'caption',\n      'tr',\n      'td',\n      'th',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'blockquote',\n      'pre',\n      'address'\n    ];\n    const isList$1 = (universe, item) => {\n      const tagName = universe.property().name(item);\n      return contains$2([\n        'ol',\n        'ul'\n      ], tagName);\n    };\n    const isBlock$1 = (universe, item) => {\n      const tagName = universe.property().name(item);\n      return contains$2(blockList, tagName);\n    };\n    const isEmptyTag$1 = (universe, item) => {\n      return contains$2([\n        'br',\n        'img',\n        'hr',\n        'input'\n      ], universe.property().name(item));\n    };\n\n    const universe$1 = DomUniverse();\n    const isBlock = element => {\n      return isBlock$1(universe$1, element);\n    };\n    const isList = element => {\n      return isList$1(universe$1, element);\n    };\n    const isEmptyTag = element => {\n      return isEmptyTag$1(universe$1, element);\n    };\n\n    const merge = cells => {\n      const isBr = isTag('br');\n      const advancedBr = children => {\n        return forall(children, c => {\n          return isBr(c) || isText(c) && get$6(c).trim().length === 0;\n        });\n      };\n      const isListItem = el => {\n        return name(el) === 'li' || ancestor$2(el, isList).isSome();\n      };\n      const siblingIsBlock = el => {\n        return nextSibling(el).map(rightSibling => {\n          if (isBlock(rightSibling)) {\n            return true;\n          }\n          if (isEmptyTag(rightSibling)) {\n            return name(rightSibling) === 'img' ? false : true;\n          }\n          return false;\n        }).getOr(false);\n      };\n      const markCell = cell => {\n        return last$1(cell).bind(rightEdge => {\n          const rightSiblingIsBlock = siblingIsBlock(rightEdge);\n          return parent(rightEdge).map(parent => {\n            return rightSiblingIsBlock === true || isListItem(parent) || isBr(rightEdge) || isBlock(parent) && !eq$1(cell, parent) ? [] : [SugarElement.fromTag('br')];\n          });\n        }).getOr([]);\n      };\n      const markContent = () => {\n        const content = bind$2(cells, cell => {\n          const children = children$2(cell);\n          return advancedBr(children) ? [] : children.concat(markCell(cell));\n        });\n        return content.length === 0 ? [SugarElement.fromTag('br')] : content;\n      };\n      const contents = markContent();\n      empty(cells[0]);\n      append(cells[0], contents);\n    };\n\n    const isEditable = elem => isEditable$1(elem, true);\n    const prune = table => {\n      const cells = cells$1(table);\n      if (cells.length === 0) {\n        remove$6(table);\n      }\n    };\n    const outcome = (grid, cursor) => ({\n      grid,\n      cursor\n    });\n    const findEditableCursorPosition = rows => findMap(rows, row => findMap(row.cells, cell => {\n      const elem = cell.element;\n      return someIf(isEditable(elem), elem);\n    }));\n    const elementFromGrid = (grid, row, column) => {\n      var _a, _b;\n      const rows = extractGridDetails(grid).rows;\n      return Optional.from((_b = (_a = rows[row]) === null || _a === void 0 ? void 0 : _a.cells[column]) === null || _b === void 0 ? void 0 : _b.element).filter(isEditable).orThunk(() => findEditableCursorPosition(rows));\n    };\n    const bundle = (grid, row, column) => {\n      const cursorElement = elementFromGrid(grid, row, column);\n      return outcome(grid, cursorElement);\n    };\n    const uniqueRows = details => {\n      const rowCompilation = (rest, detail) => {\n        const rowExists = exists(rest, currentDetail => currentDetail.row === detail.row);\n        return rowExists ? rest : rest.concat([detail]);\n      };\n      return foldl(details, rowCompilation, []).sort((detailA, detailB) => detailA.row - detailB.row);\n    };\n    const opInsertRowsBefore = (grid, details, comparator, genWrappers) => {\n      const targetIndex = details[0].row;\n      const rows = uniqueRows(details);\n      const newGrid = foldr(rows, (acc, row) => {\n        const newG = insertRowAt(acc.grid, targetIndex, row.row + acc.delta, comparator, genWrappers.getOrInit);\n        return {\n          grid: newG,\n          delta: acc.delta + 1\n        };\n      }, {\n        grid,\n        delta: 0\n      }).grid;\n      return bundle(newGrid, targetIndex, details[0].column);\n    };\n    const opInsertRowsAfter = (grid, details, comparator, genWrappers) => {\n      const rows = uniqueRows(details);\n      const target = rows[rows.length - 1];\n      const targetIndex = target.row + target.rowspan;\n      const newGrid = foldr(rows, (newG, row) => {\n        return insertRowAt(newG, targetIndex, row.row, comparator, genWrappers.getOrInit);\n      }, grid);\n      return bundle(newGrid, targetIndex, details[0].column);\n    };\n    const opInsertColumnsBefore = (grid, extractDetail, comparator, genWrappers) => {\n      const details = extractDetail.details;\n      const columns = uniqueColumns(details);\n      const targetIndex = columns[0].column;\n      const newGrid = foldr(columns, (acc, col) => {\n        const newG = insertColumnAt(acc.grid, targetIndex, col.column + acc.delta, comparator, genWrappers.getOrInit);\n        return {\n          grid: newG,\n          delta: acc.delta + 1\n        };\n      }, {\n        grid,\n        delta: 0\n      }).grid;\n      return bundle(newGrid, details[0].row, targetIndex);\n    };\n    const opInsertColumnsAfter = (grid, extractDetail, comparator, genWrappers) => {\n      const details = extractDetail.details;\n      const target = details[details.length - 1];\n      const targetIndex = target.column + target.colspan;\n      const columns = uniqueColumns(details);\n      const newGrid = foldr(columns, (newG, col) => {\n        return insertColumnAt(newG, targetIndex, col.column, comparator, genWrappers.getOrInit);\n      }, grid);\n      return bundle(newGrid, details[0].row, targetIndex);\n    };\n    const opMakeColumnsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const columns = uniqueColumns(details);\n      const columnIndexes = map$1(columns, detail => detail.column);\n      const newGrid = replaceColumns(initialGrid, columnIndexes, true, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opMakeCellsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opUnmakeColumnsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const columns = uniqueColumns(details);\n      const columnIndexes = map$1(columns, detail => detail.column);\n      const newGrid = replaceColumns(initialGrid, columnIndexes, false, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opUnmakeCellsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const makeRowsSection = (section, applyScope) => (initialGrid, details, comparator, genWrappers, tableSection) => {\n      const rows = uniqueRows(details);\n      const rowIndexes = map$1(rows, detail => detail.row);\n      const newGrid = replaceRows(initialGrid, rowIndexes, section, applyScope, comparator, genWrappers.replaceOrInit, tableSection);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opMakeRowsHeader = makeRowsSection('thead', true);\n    const opMakeRowsBody = makeRowsSection('tbody', false);\n    const opMakeRowsFooter = makeRowsSection('tfoot', false);\n    const opEraseColumns = (grid, extractDetail, _comparator, _genWrappers) => {\n      const columns = uniqueColumns(extractDetail.details);\n      const newGrid = deleteColumnsAt(grid, map$1(columns, column => column.column));\n      const maxColIndex = newGrid.length > 0 ? newGrid[0].cells.length - 1 : 0;\n      return bundle(newGrid, columns[0].row, Math.min(columns[0].column, maxColIndex));\n    };\n    const opEraseRows = (grid, details, _comparator, _genWrappers) => {\n      const rows = uniqueRows(details);\n      const newGrid = deleteRowsAt(grid, rows[0].row, rows[rows.length - 1].row);\n      const maxRowIndex = newGrid.length > 0 ? newGrid.length - 1 : 0;\n      return bundle(newGrid, Math.min(details[0].row, maxRowIndex), details[0].column);\n    };\n    const opMergeCells = (grid, mergable, comparator, genWrappers) => {\n      const cells = mergable.cells;\n      merge(cells);\n      const newGrid = merge$2(grid, mergable.bounds, comparator, genWrappers.merge(cells));\n      return outcome(newGrid, Optional.from(cells[0]));\n    };\n    const opUnmergeCells = (grid, unmergable, comparator, genWrappers) => {\n      const unmerge$1 = (b, cell) => unmerge(b, cell, comparator, genWrappers.unmerge(cell));\n      const newGrid = foldr(unmergable, unmerge$1, grid);\n      return outcome(newGrid, Optional.from(unmergable[0]));\n    };\n    const opPasteCells = (grid, pasteDetails, comparator, _genWrappers) => {\n      const gridify = (table, generators) => {\n        const wh = Warehouse.fromTable(table);\n        return toGrid(wh, generators, true);\n      };\n      const gridB = gridify(pasteDetails.clipboard, pasteDetails.generators);\n      const startAddress = address(pasteDetails.row, pasteDetails.column);\n      const mergedGrid = merge$1(startAddress, grid, gridB, pasteDetails.generators, comparator);\n      return mergedGrid.fold(() => outcome(grid, Optional.some(pasteDetails.element)), newGrid => {\n        return bundle(newGrid, pasteDetails.row, pasteDetails.column);\n      });\n    };\n    const gridifyRows = (rows, generators, context) => {\n      const pasteDetails = fromPastedRows(rows, context.section);\n      const wh = Warehouse.generate(pasteDetails);\n      return toGrid(wh, generators, true);\n    };\n    const opPasteColsBefore = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[0].column;\n      const context = rows[pasteDetails.cells[0].row];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertCols(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opPasteColsAfter = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[pasteDetails.cells.length - 1].column + pasteDetails.cells[pasteDetails.cells.length - 1].colspan;\n      const context = rows[pasteDetails.cells[0].row];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertCols(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opPasteRowsBefore = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[0].row;\n      const context = rows[index];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertRows(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opPasteRowsAfter = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[pasteDetails.cells.length - 1].row + pasteDetails.cells[pasteDetails.cells.length - 1].rowspan;\n      const context = rows[pasteDetails.cells[0].row];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertRows(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opGetColumnsType = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onCells(house, target);\n      return details.bind(selectedCells => {\n        const lastSelectedCell = selectedCells[selectedCells.length - 1];\n        const minColRange = selectedCells[0].column;\n        const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;\n        const selectedColumnCells = flatten(map$1(house.all, row => filter$2(row.cells, cell => cell.column >= minColRange && cell.column < maxColRange)));\n        return findCommonCellType(selectedColumnCells);\n      }).getOr('');\n    };\n    const opGetCellsType = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onCells(house, target);\n      return details.bind(findCommonCellType).getOr('');\n    };\n    const opGetRowsType = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onCells(house, target);\n      return details.bind(selectedCells => {\n        const lastSelectedCell = selectedCells[selectedCells.length - 1];\n        const minRowRange = selectedCells[0].row;\n        const maxRowRange = lastSelectedCell.row + lastSelectedCell.rowspan;\n        const selectedRows = house.all.slice(minRowRange, maxRowRange);\n        return findCommonRowType(selectedRows);\n      }).getOr('');\n    };\n    const resize = (table, list, details, behaviours) => adjustWidthTo(table, list, details, behaviours.sizing);\n    const adjustAndRedistributeWidths = (table, list, details, behaviours) => adjustAndRedistributeWidths$1(table, list, details, behaviours.sizing, behaviours.resize);\n    const firstColumnIsLocked = (_warehouse, details) => exists(details, detail => detail.column === 0 && detail.isLocked);\n    const lastColumnIsLocked = (warehouse, details) => exists(details, detail => detail.column + detail.colspan >= warehouse.grid.columns && detail.isLocked);\n    const getColumnsWidth = (warehouse, details) => {\n      const columns$1 = columns(warehouse);\n      const uniqueCols = uniqueColumns(details);\n      return foldl(uniqueCols, (acc, detail) => {\n        const column = columns$1[detail.column];\n        const colWidth = column.map(getOuter$2).getOr(0);\n        return acc + colWidth;\n      }, 0);\n    };\n    const insertColumnsExtractor = before => (warehouse, target) => onCells(warehouse, target).filter(details => {\n      const checkLocked = before ? firstColumnIsLocked : lastColumnIsLocked;\n      return !checkLocked(warehouse, details);\n    }).map(details => ({\n      details,\n      pixelDelta: getColumnsWidth(warehouse, details)\n    }));\n    const eraseColumnsExtractor = (warehouse, target) => onUnlockedCells(warehouse, target).map(details => ({\n      details,\n      pixelDelta: -getColumnsWidth(warehouse, details)\n    }));\n    const pasteColumnsExtractor = before => (warehouse, target) => onPasteByEditor(warehouse, target).filter(details => {\n      const checkLocked = before ? firstColumnIsLocked : lastColumnIsLocked;\n      return !checkLocked(warehouse, details.cells);\n    });\n    const headerCellGenerator = Generators.transform('th');\n    const bodyCellGenerator = Generators.transform('td');\n    const insertRowsBefore = run(opInsertRowsBefore, onCells, noop, noop, Generators.modification);\n    const insertRowsAfter = run(opInsertRowsAfter, onCells, noop, noop, Generators.modification);\n    const insertColumnsBefore = run(opInsertColumnsBefore, insertColumnsExtractor(true), adjustAndRedistributeWidths, noop, Generators.modification);\n    const insertColumnsAfter = run(opInsertColumnsAfter, insertColumnsExtractor(false), adjustAndRedistributeWidths, noop, Generators.modification);\n    const eraseColumns = run(opEraseColumns, eraseColumnsExtractor, adjustAndRedistributeWidths, prune, Generators.modification);\n    const eraseRows = run(opEraseRows, onCells, noop, prune, Generators.modification);\n    const makeColumnsHeader = run(opMakeColumnsHeader, onUnlockedCells, noop, noop, headerCellGenerator);\n    const unmakeColumnsHeader = run(opUnmakeColumnsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const makeRowsHeader = run(opMakeRowsHeader, onUnlockedCells, noop, noop, headerCellGenerator);\n    const makeRowsBody = run(opMakeRowsBody, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const makeRowsFooter = run(opMakeRowsFooter, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const makeCellsHeader = run(opMakeCellsHeader, onUnlockedCells, noop, noop, headerCellGenerator);\n    const unmakeCellsHeader = run(opUnmakeCellsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const mergeCells = run(opMergeCells, onUnlockedMergable, resize, noop, Generators.merging);\n    const unmergeCells = run(opUnmergeCells, onUnlockedUnmergable, resize, noop, Generators.merging);\n    const pasteCells = run(opPasteCells, onPaste, resize, noop, Generators.modification);\n    const pasteColsBefore = run(opPasteColsBefore, pasteColumnsExtractor(true), noop, noop, Generators.modification);\n    const pasteColsAfter = run(opPasteColsAfter, pasteColumnsExtractor(false), noop, noop, Generators.modification);\n    const pasteRowsBefore = run(opPasteRowsBefore, onPasteByEditor, noop, noop, Generators.modification);\n    const pasteRowsAfter = run(opPasteRowsAfter, onPasteByEditor, noop, noop, Generators.modification);\n    const getColumnsType = opGetColumnsType;\n    const getCellsType = opGetCellsType;\n    const getRowsType = opGetRowsType;\n\n    const fireNewRow = (editor, row) => editor.dispatch('NewRow', { node: row });\n    const fireNewCell = (editor, cell) => editor.dispatch('NewCell', { node: cell });\n    const fireTableModified = (editor, table, data) => {\n      editor.dispatch('TableModified', {\n        ...data,\n        table\n      });\n    };\n    const fireTableSelectionChange = (editor, cells, start, finish, otherCells) => {\n      editor.dispatch('TableSelectionChange', {\n        cells,\n        start,\n        finish,\n        otherCells\n      });\n    };\n    const fireTableSelectionClear = editor => {\n      editor.dispatch('TableSelectionClear');\n    };\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResizeStart', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const fireObjectResized = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResized', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const styleModified = {\n      structure: false,\n      style: true\n    };\n    const structureModified = {\n      structure: true,\n      style: false\n    };\n    const styleAndStructureModified = {\n      structure: true,\n      style: true\n    };\n\n    const get$5 = (editor, table) => {\n      if (isTablePercentagesForced(editor)) {\n        return TableSize.percentageSize(table);\n      } else if (isTablePixelsForced(editor)) {\n        return TableSize.pixelSize(table);\n      } else {\n        return TableSize.getTableSize(table);\n      }\n    };\n\n    const TableActions = (editor, resizeHandler, cellSelectionHandler) => {\n      const isTableBody = editor => name(getBody(editor)) === 'table';\n      const lastRowGuard = table => !isTableBody(editor) || getGridSize(table).rows > 1;\n      const lastColumnGuard = table => !isTableBody(editor) || getGridSize(table).columns > 1;\n      const cloneFormats = getTableCloneElements(editor);\n      const colMutationOp = isResizeTableColumnResizing(editor) ? noop : halve;\n      const getTableSectionType = table => {\n        switch (getTableHeaderType(editor)) {\n        case 'section':\n          return TableSection.section();\n        case 'sectionCells':\n          return TableSection.sectionCells();\n        case 'cells':\n          return TableSection.cells();\n        default:\n          return TableSection.getTableSectionType(table, 'section');\n        }\n      };\n      const setSelectionFromAction = (table, result) => result.cursor.fold(() => {\n        const cells = cells$1(table);\n        return head(cells).filter(inBody).map(firstCell => {\n          cellSelectionHandler.clearSelectedCells(table.dom);\n          const rng = editor.dom.createRng();\n          rng.selectNode(firstCell.dom);\n          editor.selection.setRng(rng);\n          set$2(firstCell, 'data-mce-selected', '1');\n          return rng;\n        });\n      }, cell => {\n        const des = freefallRtl(cell);\n        const rng = editor.dom.createRng();\n        rng.setStart(des.element.dom, des.offset);\n        rng.setEnd(des.element.dom, des.offset);\n        editor.selection.setRng(rng);\n        cellSelectionHandler.clearSelectedCells(table.dom);\n        return Optional.some(rng);\n      });\n      const execute = (operation, guard, mutate, effect) => (table, target, noEvents = false) => {\n        removeDataStyle(table);\n        const doc = SugarElement.fromDom(editor.getDoc());\n        const generators = cellOperations(mutate, doc, cloneFormats);\n        const behaviours = {\n          sizing: get$5(editor, table),\n          resize: isResizeTableColumnResizing(editor) ? resizeTable() : preserveTable(),\n          section: getTableSectionType(table)\n        };\n        return guard(table) ? operation(table, target, generators, behaviours).bind(result => {\n          resizeHandler.refresh(table.dom);\n          each$2(result.newRows, row => {\n            fireNewRow(editor, row.dom);\n          });\n          each$2(result.newCells, cell => {\n            fireNewCell(editor, cell.dom);\n          });\n          const range = setSelectionFromAction(table, result);\n          if (inBody(table)) {\n            removeDataStyle(table);\n            if (!noEvents) {\n              fireTableModified(editor, table.dom, effect);\n            }\n          }\n          return range.map(rng => ({\n            rng,\n            effect\n          }));\n        }) : Optional.none();\n      };\n      const deleteRow = execute(eraseRows, lastRowGuard, noop, structureModified);\n      const deleteColumn = execute(eraseColumns, lastColumnGuard, noop, structureModified);\n      const insertRowsBefore$1 = execute(insertRowsBefore, always, noop, structureModified);\n      const insertRowsAfter$1 = execute(insertRowsAfter, always, noop, structureModified);\n      const insertColumnsBefore$1 = execute(insertColumnsBefore, always, colMutationOp, structureModified);\n      const insertColumnsAfter$1 = execute(insertColumnsAfter, always, colMutationOp, structureModified);\n      const mergeCells$1 = execute(mergeCells, always, noop, structureModified);\n      const unmergeCells$1 = execute(unmergeCells, always, noop, structureModified);\n      const pasteColsBefore$1 = execute(pasteColsBefore, always, noop, structureModified);\n      const pasteColsAfter$1 = execute(pasteColsAfter, always, noop, structureModified);\n      const pasteRowsBefore$1 = execute(pasteRowsBefore, always, noop, structureModified);\n      const pasteRowsAfter$1 = execute(pasteRowsAfter, always, noop, structureModified);\n      const pasteCells$1 = execute(pasteCells, always, noop, styleAndStructureModified);\n      const makeCellsHeader$1 = execute(makeCellsHeader, always, noop, structureModified);\n      const unmakeCellsHeader$1 = execute(unmakeCellsHeader, always, noop, structureModified);\n      const makeColumnsHeader$1 = execute(makeColumnsHeader, always, noop, structureModified);\n      const unmakeColumnsHeader$1 = execute(unmakeColumnsHeader, always, noop, structureModified);\n      const makeRowsHeader$1 = execute(makeRowsHeader, always, noop, structureModified);\n      const makeRowsBody$1 = execute(makeRowsBody, always, noop, structureModified);\n      const makeRowsFooter$1 = execute(makeRowsFooter, always, noop, structureModified);\n      const getTableCellType = getCellsType;\n      const getTableColType = getColumnsType;\n      const getTableRowType = getRowsType;\n      return {\n        deleteRow,\n        deleteColumn,\n        insertRowsBefore: insertRowsBefore$1,\n        insertRowsAfter: insertRowsAfter$1,\n        insertColumnsBefore: insertColumnsBefore$1,\n        insertColumnsAfter: insertColumnsAfter$1,\n        mergeCells: mergeCells$1,\n        unmergeCells: unmergeCells$1,\n        pasteColsBefore: pasteColsBefore$1,\n        pasteColsAfter: pasteColsAfter$1,\n        pasteRowsBefore: pasteRowsBefore$1,\n        pasteRowsAfter: pasteRowsAfter$1,\n        pasteCells: pasteCells$1,\n        makeCellsHeader: makeCellsHeader$1,\n        unmakeCellsHeader: unmakeCellsHeader$1,\n        makeColumnsHeader: makeColumnsHeader$1,\n        unmakeColumnsHeader: unmakeColumnsHeader$1,\n        makeRowsHeader: makeRowsHeader$1,\n        makeRowsBody: makeRowsBody$1,\n        makeRowsFooter: makeRowsFooter$1,\n        getTableRowType,\n        getTableCellType,\n        getTableColType\n      };\n    };\n\n    const constrainSpan = (element, property, value) => {\n      const currentColspan = getAttrValue(element, property, 1);\n      if (value === 1 || currentColspan <= 1) {\n        remove$7(element, property);\n      } else {\n        set$2(element, property, Math.min(value, currentColspan));\n      }\n    };\n    const isColInRange = (minColRange, maxColRange) => cell => {\n      const endCol = cell.column + cell.colspan - 1;\n      const startCol = cell.column;\n      return endCol >= minColRange && startCol < maxColRange;\n    };\n    const generateColGroup = (house, minColRange, maxColRange) => {\n      if (Warehouse.hasColumns(house)) {\n        const colsToCopy = filter$2(Warehouse.justColumns(house), isColInRange(minColRange, maxColRange));\n        const copiedCols = map$1(colsToCopy, c => {\n          const clonedCol = deep(c.element);\n          constrainSpan(clonedCol, 'span', maxColRange - minColRange);\n          return clonedCol;\n        });\n        const fakeColgroup = SugarElement.fromTag('colgroup');\n        append(fakeColgroup, copiedCols);\n        return [fakeColgroup];\n      } else {\n        return [];\n      }\n    };\n    const generateRows = (house, minColRange, maxColRange) => map$1(house.all, row => {\n      const cellsToCopy = filter$2(row.cells, isColInRange(minColRange, maxColRange));\n      const copiedCells = map$1(cellsToCopy, cell => {\n        const clonedCell = deep(cell.element);\n        constrainSpan(clonedCell, 'colspan', maxColRange - minColRange);\n        return clonedCell;\n      });\n      const fakeTR = SugarElement.fromTag('tr');\n      append(fakeTR, copiedCells);\n      return fakeTR;\n    });\n    const copyCols = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onUnlockedCells(house, target);\n      return details.map(selectedCells => {\n        const lastSelectedCell = selectedCells[selectedCells.length - 1];\n        const minColRange = selectedCells[0].column;\n        const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;\n        const fakeColGroups = generateColGroup(house, minColRange, maxColRange);\n        const fakeRows = generateRows(house, minColRange, maxColRange);\n        return [\n          ...fakeColGroups,\n          ...fakeRows\n        ];\n      });\n    };\n\n    const copyRows = (table, target, generators) => {\n      const warehouse = Warehouse.fromTable(table);\n      const details = onCells(warehouse, target);\n      return details.bind(selectedCells => {\n        const grid = toGrid(warehouse, generators, false);\n        const rows = extractGridDetails(grid).rows;\n        const slicedGrid = rows.slice(selectedCells[0].row, selectedCells[selectedCells.length - 1].row + selectedCells[selectedCells.length - 1].rowspan);\n        const filteredGrid = bind$2(slicedGrid, row => {\n          const newCells = filter$2(row.cells, cell => !cell.isLocked);\n          return newCells.length > 0 ? [{\n              ...row,\n              cells: newCells\n            }] : [];\n        });\n        const slicedDetails = toDetailList(filteredGrid);\n        return someIf(slicedDetails.length > 0, slicedDetails);\n      }).map(slicedDetails => copy(slicedDetails));\n    };\n\n    const adt$5 = Adt.generate([\n      { invalid: ['raw'] },\n      { pixels: ['value'] },\n      { percent: ['value'] }\n    ]);\n    const validateFor = (suffix, type, value) => {\n      const rawAmount = value.substring(0, value.length - suffix.length);\n      const amount = parseFloat(rawAmount);\n      return rawAmount === amount.toString() ? type(amount) : adt$5.invalid(value);\n    };\n    const from = value => {\n      if (endsWith(value, '%')) {\n        return validateFor('%', adt$5.percent, value);\n      }\n      if (endsWith(value, 'px')) {\n        return validateFor('px', adt$5.pixels, value);\n      }\n      return adt$5.invalid(value);\n    };\n    const Size = {\n      ...adt$5,\n      from\n    };\n\n    const redistributeToPercent = (widths, totalWidth) => {\n      return map$1(widths, w => {\n        const colType = Size.from(w);\n        return colType.fold(() => {\n          return w;\n        }, px => {\n          const ratio = px / totalWidth * 100;\n          return ratio + '%';\n        }, pc => {\n          return pc + '%';\n        });\n      });\n    };\n    const redistributeToPx = (widths, totalWidth, newTotalWidth) => {\n      const scale = newTotalWidth / totalWidth;\n      return map$1(widths, w => {\n        const colType = Size.from(w);\n        return colType.fold(() => {\n          return w;\n        }, px => {\n          return px * scale + 'px';\n        }, pc => {\n          return pc / 100 * newTotalWidth + 'px';\n        });\n      });\n    };\n    const redistributeEmpty = (newWidthType, columns) => {\n      const f = newWidthType.fold(() => constant(''), pixels => {\n        const num = pixels / columns;\n        return constant(num + 'px');\n      }, () => {\n        const num = 100 / columns;\n        return constant(num + '%');\n      });\n      return range$1(columns, f);\n    };\n    const redistributeValues = (newWidthType, widths, totalWidth) => {\n      return newWidthType.fold(() => {\n        return widths;\n      }, px => {\n        return redistributeToPx(widths, totalWidth, px);\n      }, _pc => {\n        return redistributeToPercent(widths, totalWidth);\n      });\n    };\n    const redistribute$1 = (widths, totalWidth, newWidth) => {\n      const newType = Size.from(newWidth);\n      const floats = forall(widths, s => {\n        return s === '0px';\n      }) ? redistributeEmpty(newType, widths.length) : redistributeValues(newType, widths, totalWidth);\n      return normalize(floats);\n    };\n    const sum = (values, fallback) => {\n      if (values.length === 0) {\n        return fallback;\n      }\n      return foldr(values, (rest, v) => {\n        return Size.from(v).fold(constant(0), identity, identity) + rest;\n      }, 0);\n    };\n    const roundDown = (num, unit) => {\n      const floored = Math.floor(num);\n      return {\n        value: floored + unit,\n        remainder: num - floored\n      };\n    };\n    const add$3 = (value, amount) => {\n      return Size.from(value).fold(constant(value), px => {\n        return px + amount + 'px';\n      }, pc => {\n        return pc + amount + '%';\n      });\n    };\n    const normalize = values => {\n      if (values.length === 0) {\n        return values;\n      }\n      const scan = foldr(values, (rest, value) => {\n        const info = Size.from(value).fold(() => ({\n          value,\n          remainder: 0\n        }), num => roundDown(num, 'px'), num => ({\n          value: num + '%',\n          remainder: 0\n        }));\n        return {\n          output: [info.value].concat(rest.output),\n          remainder: rest.remainder + info.remainder\n        };\n      }, {\n        output: [],\n        remainder: 0\n      });\n      const r = scan.output;\n      return r.slice(0, r.length - 1).concat([add$3(r[r.length - 1], Math.round(scan.remainder))]);\n    };\n    const validate = Size.from;\n\n    const redistributeToW = (newWidths, cells, unit) => {\n      each$2(cells, cell => {\n        const widths = newWidths.slice(cell.column, cell.colspan + cell.column);\n        const w = sum(widths, minWidth());\n        set$1(cell.element, 'width', w + unit);\n      });\n    };\n    const redistributeToColumns = (newWidths, columns, unit) => {\n      each$2(columns, (column, index) => {\n        const width = sum([newWidths[index]], minWidth());\n        set$1(column.element, 'width', width + unit);\n      });\n    };\n    const redistributeToH = (newHeights, rows, cells, unit) => {\n      each$2(cells, cell => {\n        const heights = newHeights.slice(cell.row, cell.rowspan + cell.row);\n        const h = sum(heights, minHeight());\n        set$1(cell.element, 'height', h + unit);\n      });\n      each$2(rows, (row, i) => {\n        set$1(row.element, 'height', newHeights[i]);\n      });\n    };\n    const getUnit = newSize => {\n      return validate(newSize).fold(constant('px'), constant('px'), constant('%'));\n    };\n    const redistribute = (table, optWidth, optHeight) => {\n      const warehouse = Warehouse.fromTable(table);\n      const rows = warehouse.all;\n      const cells = Warehouse.justCells(warehouse);\n      const columns = Warehouse.justColumns(warehouse);\n      optWidth.each(newWidth => {\n        const widthUnit = getUnit(newWidth);\n        const totalWidth = get$9(table);\n        const oldWidths = getRawWidths(warehouse, table);\n        const nuWidths = redistribute$1(oldWidths, totalWidth, newWidth);\n        if (Warehouse.hasColumns(warehouse)) {\n          redistributeToColumns(nuWidths, columns, widthUnit);\n        } else {\n          redistributeToW(nuWidths, cells, widthUnit);\n        }\n        set$1(table, 'width', newWidth);\n      });\n      optHeight.each(newHeight => {\n        const hUnit = getUnit(newHeight);\n        const totalHeight = get$8(table);\n        const oldHeights = getRawHeights(warehouse, table, height);\n        const nuHeights = redistribute$1(oldHeights, totalHeight, newHeight);\n        redistributeToH(nuHeights, rows, cells, hUnit);\n        set$1(table, 'height', newHeight);\n      });\n    };\n    const isPercentSizing = isPercentSizing$1;\n    const isPixelSizing = isPixelSizing$1;\n    const isNoneSizing = isNoneSizing$1;\n\n    const cleanupLegacyAttributes = element => {\n      remove$7(element, 'width');\n    };\n    const convertToPercentSize = table => {\n      const newWidth = getPercentTableWidth(table);\n      redistribute(table, Optional.some(newWidth), Optional.none());\n      cleanupLegacyAttributes(table);\n    };\n    const convertToPixelSize = table => {\n      const newWidth = getPixelTableWidth(table);\n      redistribute(table, Optional.some(newWidth), Optional.none());\n      cleanupLegacyAttributes(table);\n    };\n    const convertToNoneSize = table => {\n      remove$5(table, 'width');\n      const columns = columns$1(table);\n      const rowElements = columns.length > 0 ? columns : cells$1(table);\n      each$2(rowElements, cell => {\n        remove$5(cell, 'width');\n        cleanupLegacyAttributes(cell);\n      });\n      cleanupLegacyAttributes(table);\n    };\n\n    const DefaultRenderOptions = {\n      styles: {\n        'border-collapse': 'collapse',\n        'width': '100%'\n      },\n      attributes: { border: '1' },\n      colGroups: false\n    };\n    const tableHeaderCell = () => SugarElement.fromTag('th');\n    const tableCell = () => SugarElement.fromTag('td');\n    const tableColumn = () => SugarElement.fromTag('col');\n    const createRow = (columns, rowHeaders, columnHeaders, rowIndex) => {\n      const tr = SugarElement.fromTag('tr');\n      for (let j = 0; j < columns; j++) {\n        const td = rowIndex < rowHeaders || j < columnHeaders ? tableHeaderCell() : tableCell();\n        if (j < columnHeaders) {\n          set$2(td, 'scope', 'row');\n        }\n        if (rowIndex < rowHeaders) {\n          set$2(td, 'scope', 'col');\n        }\n        append$1(td, SugarElement.fromTag('br'));\n        append$1(tr, td);\n      }\n      return tr;\n    };\n    const createGroupRow = columns => {\n      const columnGroup = SugarElement.fromTag('colgroup');\n      range$1(columns, () => append$1(columnGroup, tableColumn()));\n      return columnGroup;\n    };\n    const createRows = (rows, columns, rowHeaders, columnHeaders) => range$1(rows, r => createRow(columns, rowHeaders, columnHeaders, r));\n    const render = (rows, columns, rowHeaders, columnHeaders, headerType, renderOpts = DefaultRenderOptions) => {\n      const table = SugarElement.fromTag('table');\n      const rowHeadersGoInThead = headerType !== 'cells';\n      setAll(table, renderOpts.styles);\n      setAll$1(table, renderOpts.attributes);\n      if (renderOpts.colGroups) {\n        append$1(table, createGroupRow(columns));\n      }\n      const actualRowHeaders = Math.min(rows, rowHeaders);\n      if (rowHeadersGoInThead && rowHeaders > 0) {\n        const thead = SugarElement.fromTag('thead');\n        append$1(table, thead);\n        const theadRowHeaders = headerType === 'sectionCells' ? actualRowHeaders : 0;\n        const theadRows = createRows(rowHeaders, columns, theadRowHeaders, columnHeaders);\n        append(thead, theadRows);\n      }\n      const tbody = SugarElement.fromTag('tbody');\n      append$1(table, tbody);\n      const numRows = rowHeadersGoInThead ? rows - actualRowHeaders : rows;\n      const numRowHeaders = rowHeadersGoInThead ? 0 : rowHeaders;\n      const tbodyRows = createRows(numRows, columns, numRowHeaders, columnHeaders);\n      append(tbody, tbodyRows);\n      return table;\n    };\n\n    const get$4 = element => element.dom.innerHTML;\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$1(container, clone);\n      return get$4(container);\n    };\n\n    const placeCaretInCell = (editor, cell) => {\n      editor.selection.select(cell.dom, true);\n      editor.selection.collapse(true);\n    };\n    const selectFirstCellInTable = (editor, tableElm) => {\n      descendant(tableElm, 'td,th').each(curry(placeCaretInCell, editor));\n    };\n    const fireEvents = (editor, table) => {\n      each$2(descendants(table, 'tr'), row => {\n        fireNewRow(editor, row.dom);\n        each$2(descendants(row, 'th,td'), cell => {\n          fireNewCell(editor, cell.dom);\n        });\n      });\n    };\n    const isPercentage = width => isString(width) && width.indexOf('%') !== -1;\n    const insert = (editor, columns, rows, colHeaders, rowHeaders) => {\n      const defaultStyles = getTableDefaultStyles(editor);\n      const options = {\n        styles: defaultStyles,\n        attributes: getTableDefaultAttributes(editor),\n        colGroups: tableUseColumnGroup(editor)\n      };\n      editor.undoManager.ignore(() => {\n        const table = render(rows, columns, rowHeaders, colHeaders, getTableHeaderType(editor), options);\n        set$2(table, 'data-mce-id', '__mce');\n        const html = getOuter(table);\n        editor.insertContent(html);\n        editor.addVisual();\n      });\n      return descendant(getBody(editor), 'table[data-mce-id=\"__mce\"]').map(table => {\n        if (isTablePixelsForced(editor)) {\n          convertToPixelSize(table);\n        } else if (isTableResponsiveForced(editor)) {\n          convertToNoneSize(table);\n        } else if (isTablePercentagesForced(editor) || isPercentage(defaultStyles.width)) {\n          convertToPercentSize(table);\n        }\n        removeDataStyle(table);\n        remove$7(table, 'data-mce-id');\n        fireEvents(editor, table);\n        selectFirstCellInTable(editor, table);\n        return table.dom;\n      }).getOrNull();\n    };\n    const insertTable = (editor, rows, columns, options = {}) => {\n      const checkInput = val => isNumber(val) && val > 0;\n      if (checkInput(rows) && checkInput(columns)) {\n        const headerRows = options.headerRows || 0;\n        const headerColumns = options.headerColumns || 0;\n        return insert(editor, columns, rows, headerColumns, headerRows);\n      } else {\n        console.error('Invalid values for mceInsertTable - rows and columns values are required to insert a table.');\n        return null;\n      }\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.FakeClipboard');\n\n    const tableTypeBase = 'x-tinymce/dom-table-';\n    const tableTypeRow = tableTypeBase + 'rows';\n    const tableTypeColumn = tableTypeBase + 'columns';\n    const setData = items => {\n      const fakeClipboardItem = global.FakeClipboardItem(items);\n      global.write([fakeClipboardItem]);\n    };\n    const getData = type => {\n      var _a;\n      const items = (_a = global.read()) !== null && _a !== void 0 ? _a : [];\n      return findMap(items, item => Optional.from(item.getType(type)));\n    };\n    const clearData = type => {\n      if (getData(type).isSome()) {\n        global.clear();\n      }\n    };\n    const setRows = rowsOpt => {\n      rowsOpt.fold(clearRows, rows => setData({ [tableTypeRow]: rows }));\n    };\n    const getRows = () => getData(tableTypeRow);\n    const clearRows = () => clearData(tableTypeRow);\n    const setColumns = columnsOpt => {\n      columnsOpt.fold(clearColumns, columns => setData({ [tableTypeColumn]: columns }));\n    };\n    const getColumns = () => getData(tableTypeColumn);\n    const clearColumns = () => clearData(tableTypeColumn);\n\n    const getSelectionStartCellOrCaption = editor => getSelectionCellOrCaption(getSelectionStart(editor), getIsRoot(editor)).filter(isInEditableContext$1);\n    const getSelectionStartCell = editor => getSelectionCell(getSelectionStart(editor), getIsRoot(editor)).filter(isInEditableContext$1);\n    const registerCommands = (editor, actions) => {\n      const isRoot = getIsRoot(editor);\n      const eraseTable = () => getSelectionStartCellOrCaption(editor).each(cellOrCaption => {\n        table(cellOrCaption, isRoot).filter(not(isRoot)).each(table => {\n          const cursor = SugarElement.fromText('');\n          after$5(table, cursor);\n          remove$6(table);\n          if (editor.dom.isEmpty(editor.getBody())) {\n            editor.setContent('');\n            editor.selection.setCursorLocation();\n          } else {\n            const rng = editor.dom.createRng();\n            rng.setStart(cursor.dom, 0);\n            rng.setEnd(cursor.dom, 0);\n            editor.selection.setRng(rng);\n            editor.nodeChanged();\n          }\n        });\n      });\n      const setSizingMode = sizing => getSelectionStartCellOrCaption(editor).each(cellOrCaption => {\n        const isForcedSizing = isTableResponsiveForced(editor) || isTablePixelsForced(editor) || isTablePercentagesForced(editor);\n        if (!isForcedSizing) {\n          table(cellOrCaption, isRoot).each(table => {\n            if (sizing === 'relative' && !isPercentSizing(table)) {\n              convertToPercentSize(table);\n            } else if (sizing === 'fixed' && !isPixelSizing(table)) {\n              convertToPixelSize(table);\n            } else if (sizing === 'responsive' && !isNoneSizing(table)) {\n              convertToNoneSize(table);\n            }\n            removeDataStyle(table);\n            fireTableModified(editor, table.dom, structureModified);\n          });\n        }\n      });\n      const getTableFromCell = cell => table(cell, isRoot);\n      const performActionOnSelection = action => getSelectionStartCell(editor).bind(cell => getTableFromCell(cell).map(table => action(table, cell)));\n      const toggleTableClass = (_ui, clazz) => {\n        performActionOnSelection(table => {\n          editor.formatter.toggle('tableclass', { value: clazz }, table.dom);\n          fireTableModified(editor, table.dom, styleModified);\n        });\n      };\n      const toggleTableCellClass = (_ui, clazz) => {\n        performActionOnSelection(table => {\n          const selectedCells = getCellsFromSelection(editor);\n          const allHaveClass = forall(selectedCells, cell => editor.formatter.match('tablecellclass', { value: clazz }, cell.dom));\n          const formatterAction = allHaveClass ? editor.formatter.remove : editor.formatter.apply;\n          each$2(selectedCells, cell => formatterAction('tablecellclass', { value: clazz }, cell.dom));\n          fireTableModified(editor, table.dom, styleModified);\n        });\n      };\n      const toggleCaption = () => {\n        getSelectionStartCellOrCaption(editor).each(cellOrCaption => {\n          table(cellOrCaption, isRoot).each(table => {\n            child(table, 'caption').fold(() => {\n              const caption = SugarElement.fromTag('caption');\n              append$1(caption, SugarElement.fromText('Caption'));\n              appendAt(table, caption, 0);\n              editor.selection.setCursorLocation(caption.dom, 0);\n            }, caption => {\n              if (isTag('caption')(cellOrCaption)) {\n                one('td', table).each(td => editor.selection.setCursorLocation(td.dom, 0));\n              }\n              remove$6(caption);\n            });\n            fireTableModified(editor, table.dom, structureModified);\n          });\n        });\n      };\n      const postExecute = _data => {\n        editor.focus();\n      };\n      const actOnSelection = (execute, noEvents = false) => performActionOnSelection((table, startCell) => {\n        const targets = forMenu(getCellsFromSelection(editor), table, startCell);\n        execute(table, targets, noEvents).each(postExecute);\n      });\n      const copyRowSelection = () => performActionOnSelection((table, startCell) => {\n        const targets = forMenu(getCellsFromSelection(editor), table, startCell);\n        const generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), Optional.none());\n        return copyRows(table, targets, generators);\n      });\n      const copyColSelection = () => performActionOnSelection((table, startCell) => {\n        const targets = forMenu(getCellsFromSelection(editor), table, startCell);\n        return copyCols(table, targets);\n      });\n      const pasteOnSelection = (execute, getRows) => getRows().each(rows => {\n        const clonedRows = map$1(rows, row => deep(row));\n        performActionOnSelection((table, startCell) => {\n          const generators = paste$1(SugarElement.fromDom(editor.getDoc()));\n          const targets = pasteRows(getCellsFromSelection(editor), startCell, clonedRows, generators);\n          execute(table, targets).each(postExecute);\n        });\n      });\n      const actOnType = getAction => (_ui, args) => get$c(args, 'type').each(type => {\n        actOnSelection(getAction(type), args.no_events);\n      });\n      each$1({\n        mceTableSplitCells: () => actOnSelection(actions.unmergeCells),\n        mceTableMergeCells: () => actOnSelection(actions.mergeCells),\n        mceTableInsertRowBefore: () => actOnSelection(actions.insertRowsBefore),\n        mceTableInsertRowAfter: () => actOnSelection(actions.insertRowsAfter),\n        mceTableInsertColBefore: () => actOnSelection(actions.insertColumnsBefore),\n        mceTableInsertColAfter: () => actOnSelection(actions.insertColumnsAfter),\n        mceTableDeleteCol: () => actOnSelection(actions.deleteColumn),\n        mceTableDeleteRow: () => actOnSelection(actions.deleteRow),\n        mceTableCutCol: () => copyColSelection().each(selection => {\n          setColumns(selection);\n          actOnSelection(actions.deleteColumn);\n        }),\n        mceTableCutRow: () => copyRowSelection().each(selection => {\n          setRows(selection);\n          actOnSelection(actions.deleteRow);\n        }),\n        mceTableCopyCol: () => copyColSelection().each(selection => setColumns(selection)),\n        mceTableCopyRow: () => copyRowSelection().each(selection => setRows(selection)),\n        mceTablePasteColBefore: () => pasteOnSelection(actions.pasteColsBefore, getColumns),\n        mceTablePasteColAfter: () => pasteOnSelection(actions.pasteColsAfter, getColumns),\n        mceTablePasteRowBefore: () => pasteOnSelection(actions.pasteRowsBefore, getRows),\n        mceTablePasteRowAfter: () => pasteOnSelection(actions.pasteRowsAfter, getRows),\n        mceTableDelete: eraseTable,\n        mceTableCellToggleClass: toggleTableCellClass,\n        mceTableToggleClass: toggleTableClass,\n        mceTableToggleCaption: toggleCaption,\n        mceTableSizingMode: (_ui, sizing) => setSizingMode(sizing),\n        mceTableCellType: actOnType(type => type === 'th' ? actions.makeCellsHeader : actions.unmakeCellsHeader),\n        mceTableColType: actOnType(type => type === 'th' ? actions.makeColumnsHeader : actions.unmakeColumnsHeader),\n        mceTableRowType: actOnType(type => {\n          switch (type) {\n          case 'header':\n            return actions.makeRowsHeader;\n          case 'footer':\n            return actions.makeRowsFooter;\n          default:\n            return actions.makeRowsBody;\n          }\n        })\n      }, (func, name) => editor.addCommand(name, func));\n      editor.addCommand('mceInsertTable', (_ui, args) => {\n        insertTable(editor, args.rows, args.columns, args.options);\n      });\n      editor.addCommand('mceTableApplyCellStyle', (_ui, args) => {\n        const getFormatName = style => 'tablecell' + style.toLowerCase().replace('-', '');\n        if (!isObject(args)) {\n          return;\n        }\n        const cells = filter$2(getCellsFromSelection(editor), isInEditableContext$1);\n        if (cells.length === 0) {\n          return;\n        }\n        const validArgs = filter$1(args, (value, style) => editor.formatter.has(getFormatName(style)) && isString(value));\n        if (isEmpty(validArgs)) {\n          return;\n        }\n        each$1(validArgs, (value, style) => {\n          const formatName = getFormatName(style);\n          each$2(cells, cell => {\n            if (value === '') {\n              editor.formatter.remove(formatName, { value: null }, cell.dom, true);\n            } else {\n              editor.formatter.apply(formatName, { value }, cell.dom);\n            }\n          });\n        });\n        getTableFromCell(cells[0]).each(table => fireTableModified(editor, table.dom, styleModified));\n      });\n    };\n\n    const registerQueryCommands = (editor, actions) => {\n      const isRoot = getIsRoot(editor);\n      const lookupOnSelection = action => getSelectionCell(getSelectionStart(editor)).bind(cell => table(cell, isRoot).map(table => {\n        const targets = forMenu(getCellsFromSelection(editor), table, cell);\n        return action(table, targets);\n      })).getOr('');\n      each$1({\n        mceTableRowType: () => lookupOnSelection(actions.getTableRowType),\n        mceTableCellType: () => lookupOnSelection(actions.getTableCellType),\n        mceTableColType: () => lookupOnSelection(actions.getTableColType)\n      }, (func, name) => editor.addQueryValueHandler(name, func));\n    };\n\n    const adt$4 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata$1 = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$1 = situ => situ.fold(identity, identity, identity);\n    const before$2 = adt$4.before;\n    const on = adt$4.on;\n    const after$3 = adt$4.after;\n    const Situ = {\n      before: before$2,\n      on,\n      after: after$3,\n      cata: cata$1,\n      getStart: getStart$1\n    };\n\n    const create$4 = (selection, kill) => ({\n      selection,\n      kill\n    });\n    const Response = { create: create$4 };\n\n    const selectNode = (win, element) => {\n      const rng = win.document.createRange();\n      rng.selectNode(element.dom);\n      return rng;\n    };\n    const selectNodeContents = (win, element) => {\n      const rng = win.document.createRange();\n      selectNodeContentsUsing(rng, element);\n      return rng;\n    };\n    const selectNodeContentsUsing = (rng, element) => rng.selectNodeContents(element.dom);\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n    const toRect = rect => ({\n      left: rect.left,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      width: rect.width,\n      height: rect.height\n    });\n    const getFirstRect$1 = rng => {\n      const rects = rng.getClientRects();\n      const rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();\n      return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();\n    };\n\n    const adt$3 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n      } else {\n        return fromRange(win, adt$3.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    const asLtrRange = (win, selection) => {\n      const diagnosis = diagnose(win, selection);\n      return diagnosis.match({\n        ltr: (start, soffset, finish, foffset) => {\n          const rng = win.document.createRange();\n          rng.setStart(start.dom, soffset);\n          rng.setEnd(finish.dom, foffset);\n          return rng;\n        },\n        rtl: (start, soffset, finish, foffset) => {\n          const rng = win.document.createRange();\n          rng.setStart(finish.dom, foffset);\n          rng.setEnd(start.dom, soffset);\n          return rng;\n        }\n      });\n    };\n    adt$3.ltr;\n    adt$3.rtl;\n\n    const create$3 = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$3 };\n\n    const create$2 = (start, soffset, finish, foffset) => {\n      return {\n        start: Situ.on(start, soffset),\n        finish: Situ.on(finish, foffset)\n      };\n    };\n    const Situs = { create: create$2 };\n\n    const convertToRange = (win, selection) => {\n      const rng = asLtrRange(win, selection);\n      return SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset);\n    };\n    const makeSitus = Situs.create;\n\n    const sync = (container, isRoot, start, soffset, finish, foffset, selectRange) => {\n      if (!(eq$1(start, finish) && soffset === foffset)) {\n        return closest$1(start, 'td,th', isRoot).bind(s => {\n          return closest$1(finish, 'td,th', isRoot).bind(f => {\n            return detect(container, isRoot, s, f, selectRange);\n          });\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const detect = (container, isRoot, start, finish, selectRange) => {\n      if (!eq$1(start, finish)) {\n        return identify(start, finish, isRoot).bind(cellSel => {\n          const boxes = cellSel.boxes.getOr([]);\n          if (boxes.length > 1) {\n            selectRange(container, boxes, cellSel.start, cellSel.finish);\n            return Optional.some(Response.create(Optional.some(makeSitus(start, 0, start, getEnd(start))), true));\n          } else {\n            return Optional.none();\n          }\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const update = (rows, columns, container, selected, annotations) => {\n      const updateSelection = newSels => {\n        annotations.clearBeforeUpdate(container);\n        annotations.selectRange(container, newSels.boxes, newSels.start, newSels.finish);\n        return newSels.boxes;\n      };\n      return shiftSelection(selected, rows, columns, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(updateSelection);\n    };\n\n    const traverse = (item, mode) => ({\n      item,\n      mode\n    });\n    const backtrack = (universe, item, _direction, transition = sidestep) => {\n      return universe.property().parent(item).map(p => {\n        return traverse(p, transition);\n      });\n    };\n    const sidestep = (universe, item, direction, transition = advance) => {\n      return direction.sibling(universe, item).map(p => {\n        return traverse(p, transition);\n      });\n    };\n    const advance = (universe, item, direction, transition = advance) => {\n      const children = universe.property().children(item);\n      const result = direction.first(children);\n      return result.map(r => {\n        return traverse(r, transition);\n      });\n    };\n    const successors = [\n      {\n        current: backtrack,\n        next: sidestep,\n        fallback: Optional.none()\n      },\n      {\n        current: sidestep,\n        next: advance,\n        fallback: Optional.some(backtrack)\n      },\n      {\n        current: advance,\n        next: advance,\n        fallback: Optional.some(sidestep)\n      }\n    ];\n    const go = (universe, item, mode, direction, rules = successors) => {\n      const ruleOpt = find$1(rules, succ => {\n        return succ.current === mode;\n      });\n      return ruleOpt.bind(rule => {\n        return rule.current(universe, item, direction, rule.next).orThunk(() => {\n          return rule.fallback.bind(fb => {\n            return go(universe, item, fb, direction);\n          });\n        });\n      });\n    };\n\n    const left$1 = () => {\n      const sibling = (universe, item) => {\n        return universe.query().prevSibling(item);\n      };\n      const first = children => {\n        return children.length > 0 ? Optional.some(children[children.length - 1]) : Optional.none();\n      };\n      return {\n        sibling,\n        first\n      };\n    };\n    const right$1 = () => {\n      const sibling = (universe, item) => {\n        return universe.query().nextSibling(item);\n      };\n      const first = children => {\n        return children.length > 0 ? Optional.some(children[0]) : Optional.none();\n      };\n      return {\n        sibling,\n        first\n      };\n    };\n    const Walkers = {\n      left: left$1,\n      right: right$1\n    };\n\n    const hone = (universe, item, predicate, mode, direction, isRoot) => {\n      const next = go(universe, item, mode, direction);\n      return next.bind(n => {\n        if (isRoot(n.item)) {\n          return Optional.none();\n        } else {\n          return predicate(n.item) ? Optional.some(n.item) : hone(universe, n.item, predicate, n.mode, direction, isRoot);\n        }\n      });\n    };\n    const left = (universe, item, predicate, isRoot) => {\n      return hone(universe, item, predicate, sidestep, Walkers.left(), isRoot);\n    };\n    const right = (universe, item, predicate, isRoot) => {\n      return hone(universe, item, predicate, sidestep, Walkers.right(), isRoot);\n    };\n\n    const isLeaf = universe => element => universe.property().children(element).length === 0;\n    const before$1 = (universe, item, isRoot) => {\n      return seekLeft$1(universe, item, isLeaf(universe), isRoot);\n    };\n    const after$2 = (universe, item, isRoot) => {\n      return seekRight$1(universe, item, isLeaf(universe), isRoot);\n    };\n    const seekLeft$1 = left;\n    const seekRight$1 = right;\n\n    const universe = DomUniverse();\n    const before = (element, isRoot) => {\n      return before$1(universe, element, isRoot);\n    };\n    const after$1 = (element, isRoot) => {\n      return after$2(universe, element, isRoot);\n    };\n    const seekLeft = (element, predicate, isRoot) => {\n      return seekLeft$1(universe, element, predicate, isRoot);\n    };\n    const seekRight = (element, predicate, isRoot) => {\n      return seekRight$1(universe, element, predicate, isRoot);\n    };\n\n    const ancestor = (scope, predicate, isRoot) => ancestor$2(scope, predicate, isRoot).isSome();\n\n    const adt$2 = Adt.generate([\n      { none: ['message'] },\n      { success: [] },\n      { failedUp: ['cell'] },\n      { failedDown: ['cell'] }\n    ]);\n    const isOverlapping = (bridge, before, after) => {\n      const beforeBounds = bridge.getRect(before);\n      const afterBounds = bridge.getRect(after);\n      return afterBounds.right > beforeBounds.left && afterBounds.left < beforeBounds.right;\n    };\n    const isRow = elem => {\n      return closest$1(elem, 'tr');\n    };\n    const verify = (bridge, before, beforeOffset, after, afterOffset, failure, isRoot) => {\n      return closest$1(after, 'td,th', isRoot).bind(afterCell => {\n        return closest$1(before, 'td,th', isRoot).map(beforeCell => {\n          if (!eq$1(afterCell, beforeCell)) {\n            return sharedOne(isRow, [\n              afterCell,\n              beforeCell\n            ]).fold(() => {\n              return isOverlapping(bridge, beforeCell, afterCell) ? adt$2.success() : failure(beforeCell);\n            }, _sharedRow => {\n              return failure(beforeCell);\n            });\n          } else {\n            return eq$1(after, afterCell) && getEnd(afterCell) === afterOffset ? failure(beforeCell) : adt$2.none('in same cell');\n          }\n        });\n      }).getOr(adt$2.none('default'));\n    };\n    const cata = (subject, onNone, onSuccess, onFailedUp, onFailedDown) => {\n      return subject.fold(onNone, onSuccess, onFailedUp, onFailedDown);\n    };\n    const BeforeAfter = {\n      ...adt$2,\n      verify,\n      cata\n    };\n\n    const inParent = (parent, children, element, index) => ({\n      parent,\n      children,\n      element,\n      index\n    });\n    const indexInParent = element => parent(element).bind(parent => {\n      const children = children$2(parent);\n      return indexOf(children, element).map(index => inParent(parent, children, element, index));\n    });\n    const indexOf = (elements, element) => findIndex(elements, curry(eq$1, element));\n\n    const isBr = isTag('br');\n    const gatherer = (cand, gather, isRoot) => {\n      return gather(cand, isRoot).bind(target => {\n        return isText(target) && get$6(target).trim().length === 0 ? gatherer(target, gather, isRoot) : Optional.some(target);\n      });\n    };\n    const handleBr = (isRoot, element, direction) => {\n      return direction.traverse(element).orThunk(() => {\n        return gatherer(element, direction.gather, isRoot);\n      }).map(direction.relative);\n    };\n    const findBr = (element, offset) => {\n      return child$2(element, offset).filter(isBr).orThunk(() => {\n        return child$2(element, offset - 1).filter(isBr);\n      });\n    };\n    const handleParent = (isRoot, element, offset, direction) => {\n      return findBr(element, offset).bind(br => {\n        return direction.traverse(br).fold(() => {\n          return gatherer(br, direction.gather, isRoot).map(direction.relative);\n        }, adjacent => {\n          return indexInParent(adjacent).map(info => {\n            return Situ.on(info.parent, info.index);\n          });\n        });\n      });\n    };\n    const tryBr = (isRoot, element, offset, direction) => {\n      const target = isBr(element) ? handleBr(isRoot, element, direction) : handleParent(isRoot, element, offset, direction);\n      return target.map(tgt => {\n        return {\n          start: tgt,\n          finish: tgt\n        };\n      });\n    };\n    const process = analysis => {\n      return BeforeAfter.cata(analysis, _message => {\n        return Optional.none();\n      }, () => {\n        return Optional.none();\n      }, cell => {\n        return Optional.some(point(cell, 0));\n      }, cell => {\n        return Optional.some(point(cell, getEnd(cell)));\n      });\n    };\n\n    const moveDown = (caret, amount) => {\n      return {\n        left: caret.left,\n        top: caret.top + amount,\n        right: caret.right,\n        bottom: caret.bottom + amount\n      };\n    };\n    const moveUp = (caret, amount) => {\n      return {\n        left: caret.left,\n        top: caret.top - amount,\n        right: caret.right,\n        bottom: caret.bottom - amount\n      };\n    };\n    const translate = (caret, xDelta, yDelta) => {\n      return {\n        left: caret.left + xDelta,\n        top: caret.top + yDelta,\n        right: caret.right + xDelta,\n        bottom: caret.bottom + yDelta\n      };\n    };\n    const getTop = caret => {\n      return caret.top;\n    };\n    const getBottom = caret => {\n      return caret.bottom;\n    };\n\n    const getPartialBox = (bridge, element, offset) => {\n      if (offset >= 0 && offset < getEnd(element)) {\n        return bridge.getRangedRect(element, offset, element, offset + 1);\n      } else if (offset > 0) {\n        return bridge.getRangedRect(element, offset - 1, element, offset);\n      }\n      return Optional.none();\n    };\n    const toCaret = rect => ({\n      left: rect.left,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom\n    });\n    const getElemBox = (bridge, element) => {\n      return Optional.some(bridge.getRect(element));\n    };\n    const getBoxAt = (bridge, element, offset) => {\n      if (isElement(element)) {\n        return getElemBox(bridge, element).map(toCaret);\n      } else if (isText(element)) {\n        return getPartialBox(bridge, element, offset).map(toCaret);\n      } else {\n        return Optional.none();\n      }\n    };\n    const getEntireBox = (bridge, element) => {\n      if (isElement(element)) {\n        return getElemBox(bridge, element).map(toCaret);\n      } else if (isText(element)) {\n        return bridge.getRangedRect(element, 0, element, getEnd(element)).map(toCaret);\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const JUMP_SIZE = 5;\n    const NUM_RETRIES = 100;\n    const adt$1 = Adt.generate([\n      { none: [] },\n      { retry: ['caret'] }\n    ]);\n    const isOutside = (caret, box) => {\n      return caret.left < box.left || Math.abs(box.right - caret.left) < 1 || caret.left > box.right;\n    };\n    const inOutsideBlock = (bridge, element, caret) => {\n      return closest$2(element, isBlock).fold(never, cell => {\n        return getEntireBox(bridge, cell).exists(box => {\n          return isOutside(caret, box);\n        });\n      });\n    };\n    const adjustDown = (bridge, element, guessBox, original, caret) => {\n      const lowerCaret = moveDown(caret, JUMP_SIZE);\n      if (Math.abs(guessBox.bottom - original.bottom) < 1) {\n        return adt$1.retry(lowerCaret);\n      } else if (guessBox.top > caret.bottom) {\n        return adt$1.retry(lowerCaret);\n      } else if (guessBox.top === caret.bottom) {\n        return adt$1.retry(moveDown(caret, 1));\n      } else {\n        return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate(lowerCaret, JUMP_SIZE, 0)) : adt$1.none();\n      }\n    };\n    const adjustUp = (bridge, element, guessBox, original, caret) => {\n      const higherCaret = moveUp(caret, JUMP_SIZE);\n      if (Math.abs(guessBox.top - original.top) < 1) {\n        return adt$1.retry(higherCaret);\n      } else if (guessBox.bottom < caret.top) {\n        return adt$1.retry(higherCaret);\n      } else if (guessBox.bottom === caret.top) {\n        return adt$1.retry(moveUp(caret, 1));\n      } else {\n        return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate(higherCaret, JUMP_SIZE, 0)) : adt$1.none();\n      }\n    };\n    const upMovement = {\n      point: getTop,\n      adjuster: adjustUp,\n      move: moveUp,\n      gather: before\n    };\n    const downMovement = {\n      point: getBottom,\n      adjuster: adjustDown,\n      move: moveDown,\n      gather: after$1\n    };\n    const isAtTable = (bridge, x, y) => {\n      return bridge.elementFromPoint(x, y).filter(elm => {\n        return name(elm) === 'table';\n      }).isSome();\n    };\n    const adjustForTable = (bridge, movement, original, caret, numRetries) => {\n      return adjustTil(bridge, movement, original, movement.move(caret, JUMP_SIZE), numRetries);\n    };\n    const adjustTil = (bridge, movement, original, caret, numRetries) => {\n      if (numRetries === 0) {\n        return Optional.some(caret);\n      }\n      if (isAtTable(bridge, caret.left, movement.point(caret))) {\n        return adjustForTable(bridge, movement, original, caret, numRetries - 1);\n      }\n      return bridge.situsFromPoint(caret.left, movement.point(caret)).bind(guess => {\n        return guess.start.fold(Optional.none, element => {\n          return getEntireBox(bridge, element).bind(guessBox => {\n            return movement.adjuster(bridge, element, guessBox, original, caret).fold(Optional.none, newCaret => {\n              return adjustTil(bridge, movement, original, newCaret, numRetries - 1);\n            });\n          }).orThunk(() => {\n            return Optional.some(caret);\n          });\n        }, Optional.none);\n      });\n    };\n    const checkScroll = (movement, adjusted, bridge) => {\n      if (movement.point(adjusted) > bridge.getInnerHeight()) {\n        return Optional.some(movement.point(adjusted) - bridge.getInnerHeight());\n      } else if (movement.point(adjusted) < 0) {\n        return Optional.some(-movement.point(adjusted));\n      } else {\n        return Optional.none();\n      }\n    };\n    const retry = (movement, bridge, caret) => {\n      const moved = movement.move(caret, JUMP_SIZE);\n      const adjusted = adjustTil(bridge, movement, caret, moved, NUM_RETRIES).getOr(moved);\n      return checkScroll(movement, adjusted, bridge).fold(() => {\n        return bridge.situsFromPoint(adjusted.left, movement.point(adjusted));\n      }, delta => {\n        bridge.scrollBy(0, delta);\n        return bridge.situsFromPoint(adjusted.left, movement.point(adjusted) - delta);\n      });\n    };\n    const Retries = {\n      tryUp: curry(retry, upMovement),\n      tryDown: curry(retry, downMovement),\n      getJumpSize: constant(JUMP_SIZE)\n    };\n\n    const MAX_RETRIES = 20;\n    const findSpot = (bridge, isRoot, direction) => {\n      return bridge.getSelection().bind(sel => {\n        return tryBr(isRoot, sel.finish, sel.foffset, direction).fold(() => {\n          return Optional.some(point(sel.finish, sel.foffset));\n        }, brNeighbour => {\n          const range = bridge.fromSitus(brNeighbour);\n          const analysis = BeforeAfter.verify(bridge, sel.finish, sel.foffset, range.finish, range.foffset, direction.failure, isRoot);\n          return process(analysis);\n        });\n      });\n    };\n    const scan = (bridge, isRoot, element, offset, direction, numRetries) => {\n      if (numRetries === 0) {\n        return Optional.none();\n      }\n      return tryCursor(bridge, isRoot, element, offset, direction).bind(situs => {\n        const range = bridge.fromSitus(situs);\n        const analysis = BeforeAfter.verify(bridge, element, offset, range.finish, range.foffset, direction.failure, isRoot);\n        return BeforeAfter.cata(analysis, () => {\n          return Optional.none();\n        }, () => {\n          return Optional.some(situs);\n        }, cell => {\n          if (eq$1(element, cell) && offset === 0) {\n            return tryAgain(bridge, element, offset, moveUp, direction);\n          } else {\n            return scan(bridge, isRoot, cell, 0, direction, numRetries - 1);\n          }\n        }, cell => {\n          if (eq$1(element, cell) && offset === getEnd(cell)) {\n            return tryAgain(bridge, element, offset, moveDown, direction);\n          } else {\n            return scan(bridge, isRoot, cell, getEnd(cell), direction, numRetries - 1);\n          }\n        });\n      });\n    };\n    const tryAgain = (bridge, element, offset, move, direction) => {\n      return getBoxAt(bridge, element, offset).bind(box => {\n        return tryAt(bridge, direction, move(box, Retries.getJumpSize()));\n      });\n    };\n    const tryAt = (bridge, direction, box) => {\n      const browser = detect$2().browser;\n      if (browser.isChromium() || browser.isSafari() || browser.isFirefox()) {\n        return direction.retry(bridge, box);\n      } else {\n        return Optional.none();\n      }\n    };\n    const tryCursor = (bridge, isRoot, element, offset, direction) => {\n      return getBoxAt(bridge, element, offset).bind(box => {\n        return tryAt(bridge, direction, box);\n      });\n    };\n    const handle$1 = (bridge, isRoot, direction) => {\n      return findSpot(bridge, isRoot, direction).bind(spot => {\n        return scan(bridge, isRoot, spot.element, spot.offset, direction, MAX_RETRIES).map(bridge.fromSitus);\n      });\n    };\n\n    const inSameTable = (elem, table) => {\n      return ancestor(elem, e => {\n        return parent(e).exists(p => {\n          return eq$1(p, table);\n        });\n      });\n    };\n    const simulate = (bridge, isRoot, direction, initial, anchor) => {\n      return closest$1(initial, 'td,th', isRoot).bind(start => {\n        return closest$1(start, 'table', isRoot).bind(table => {\n          if (!inSameTable(anchor, table)) {\n            return Optional.none();\n          }\n          return handle$1(bridge, isRoot, direction).bind(range => {\n            return closest$1(range.finish, 'td,th', isRoot).map(finish => {\n              return {\n                start,\n                finish,\n                range\n              };\n            });\n          });\n        });\n      });\n    };\n    const navigate = (bridge, isRoot, direction, initial, anchor, precheck) => {\n      return precheck(initial, isRoot).orThunk(() => {\n        return simulate(bridge, isRoot, direction, initial, anchor).map(info => {\n          const range = info.range;\n          return Response.create(Optional.some(makeSitus(range.start, range.soffset, range.finish, range.foffset)), true);\n        });\n      });\n    };\n    const firstUpCheck = (initial, isRoot) => {\n      return closest$1(initial, 'tr', isRoot).bind(startRow => {\n        return closest$1(startRow, 'table', isRoot).bind(table => {\n          const rows = descendants(table, 'tr');\n          if (eq$1(startRow, rows[0])) {\n            return seekLeft(table, element => {\n              return last$1(element).isSome();\n            }, isRoot).map(last => {\n              const lastOffset = getEnd(last);\n              return Response.create(Optional.some(makeSitus(last, lastOffset, last, lastOffset)), true);\n            });\n          } else {\n            return Optional.none();\n          }\n        });\n      });\n    };\n    const lastDownCheck = (initial, isRoot) => {\n      return closest$1(initial, 'tr', isRoot).bind(startRow => {\n        return closest$1(startRow, 'table', isRoot).bind(table => {\n          const rows = descendants(table, 'tr');\n          if (eq$1(startRow, rows[rows.length - 1])) {\n            return seekRight(table, element => {\n              return first(element).isSome();\n            }, isRoot).map(first => {\n              return Response.create(Optional.some(makeSitus(first, 0, first, 0)), true);\n            });\n          } else {\n            return Optional.none();\n          }\n        });\n      });\n    };\n    const select = (bridge, container, isRoot, direction, initial, anchor, selectRange) => {\n      return simulate(bridge, isRoot, direction, initial, anchor).bind(info => {\n        return detect(container, isRoot, info.start, info.finish, selectRange);\n      });\n    };\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const findCell = (target, isRoot) => closest$1(target, 'td,th', isRoot);\n    const isInEditableContext = cell => parentElement(cell).exists(isEditable$1);\n    const MouseSelection = (bridge, container, isRoot, annotations) => {\n      const cursor = value();\n      const clearstate = cursor.clear;\n      const applySelection = event => {\n        cursor.on(start => {\n          annotations.clearBeforeUpdate(container);\n          findCell(event.target, isRoot).each(finish => {\n            identify(start, finish, isRoot).each(cellSel => {\n              const boxes = cellSel.boxes.getOr([]);\n              if (boxes.length === 1) {\n                const singleCell = boxes[0];\n                const isNonEditableCell = getRaw(singleCell) === 'false';\n                const isCellClosestContentEditable = is(closest(event.target), singleCell, eq$1);\n                if (isNonEditableCell && isCellClosestContentEditable) {\n                  annotations.selectRange(container, boxes, singleCell, singleCell);\n                  bridge.selectContents(singleCell);\n                }\n              } else if (boxes.length > 1) {\n                annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);\n                bridge.selectContents(finish);\n              }\n            });\n          });\n        });\n      };\n      const mousedown = event => {\n        annotations.clear(container);\n        findCell(event.target, isRoot).filter(isInEditableContext).each(cursor.set);\n      };\n      const mouseover = event => {\n        applySelection(event);\n      };\n      const mouseup = event => {\n        applySelection(event);\n        clearstate();\n      };\n      return {\n        clearstate,\n        mousedown,\n        mouseover,\n        mouseup\n      };\n    };\n\n    const down = {\n      traverse: nextSibling,\n      gather: after$1,\n      relative: Situ.before,\n      retry: Retries.tryDown,\n      failure: BeforeAfter.failedDown\n    };\n    const up = {\n      traverse: prevSibling,\n      gather: before,\n      relative: Situ.before,\n      retry: Retries.tryUp,\n      failure: BeforeAfter.failedUp\n    };\n\n    const isKey = key => {\n      return keycode => {\n        return keycode === key;\n      };\n    };\n    const isUp = isKey(38);\n    const isDown = isKey(40);\n    const isNavigation = keycode => {\n      return keycode >= 37 && keycode <= 40;\n    };\n    const ltr = {\n      isBackward: isKey(37),\n      isForward: isKey(39)\n    };\n    const rtl = {\n      isBackward: isKey(39),\n      isForward: isKey(37)\n    };\n\n    const get$3 = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const by = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollBy(x, y);\n      }\n    };\n\n    const adt = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt.domRange;\n    const relative = adt.relative;\n    const exact = adt.exact;\n    const getWin = selection => {\n      const start = getStart(selection);\n      return defaultView(start);\n    };\n    const range = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range\n    };\n\n    const caretPositionFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n        if (pos.offsetNode === null) {\n          return Optional.none();\n        }\n        const r = doc.dom.createRange();\n        r.setStart(pos.offsetNode, pos.offset);\n        r.collapse();\n        return Optional.some(r);\n      });\n    };\n    const caretRangeFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n    };\n    const availableSearch = (() => {\n      if (document.caretPositionFromPoint) {\n        return caretPositionFromPoint;\n      } else if (document.caretRangeFromPoint) {\n        return caretRangeFromPoint;\n      } else {\n        return Optional.none;\n      }\n    })();\n    const fromPoint = (win, x, y) => {\n      const doc = SugarElement.fromDom(win.document);\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n    };\n\n    const beforeSpecial = (element, offset) => {\n      const name$1 = name(element);\n      if ('input' === name$1) {\n        return Situ.after(element);\n      } else if (!contains$2([\n          'br',\n          'img'\n        ], name$1)) {\n        return Situ.on(element, offset);\n      } else {\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\n      }\n    };\n    const preprocessRelative = (startSitu, finishSitu) => {\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      return SimSelection.relative(start, finish);\n    };\n    const preprocessExact = (start, soffset, finish, foffset) => {\n      const startSitu = beforeSpecial(start, soffset);\n      const finishSitu = beforeSpecial(finish, foffset);\n      return SimSelection.relative(startSitu, finishSitu);\n    };\n\n    const makeRange = (start, soffset, finish, foffset) => {\n      const doc = owner(start);\n      const rng = doc.dom.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n    const after = (start, soffset, finish, foffset) => {\n      const r = makeRange(start, soffset, finish, foffset);\n      const same = eq$1(start, finish) && soffset === foffset;\n      return r.collapsed && !same;\n    };\n\n    const getNativeSelection = win => Optional.from(win.getSelection());\n    const doSetNativeRange = (win, rng) => {\n      getNativeSelection(win).each(selection => {\n        selection.removeAllRanges();\n        selection.addRange(rng);\n      });\n    };\n    const doSetRange = (win, start, soffset, finish, foffset) => {\n      const rng = exactToNative(win, start, soffset, finish, foffset);\n      doSetNativeRange(win, rng);\n    };\n    const setLegacyRtlRange = (win, selection, start, soffset, finish, foffset) => {\n      selection.collapse(start.dom, soffset);\n      selection.extend(finish.dom, foffset);\n    };\n    const setRangeFromRelative = (win, relative) => diagnose(win, relative).match({\n      ltr: (start, soffset, finish, foffset) => {\n        doSetRange(win, start, soffset, finish, foffset);\n      },\n      rtl: (start, soffset, finish, foffset) => {\n        getNativeSelection(win).each(selection => {\n          if (selection.setBaseAndExtent) {\n            selection.setBaseAndExtent(start.dom, soffset, finish.dom, foffset);\n          } else if (selection.extend) {\n            try {\n              setLegacyRtlRange(win, selection, start, soffset, finish, foffset);\n            } catch (e) {\n              doSetRange(win, finish, foffset, start, soffset);\n            }\n          } else {\n            doSetRange(win, finish, foffset, start, soffset);\n          }\n        });\n      }\n    });\n    const setExact = (win, start, soffset, finish, foffset) => {\n      const relative = preprocessExact(start, soffset, finish, foffset);\n      setRangeFromRelative(win, relative);\n    };\n    const setRelative = (win, startSitu, finishSitu) => {\n      const relative = preprocessRelative(startSitu, finishSitu);\n      setRangeFromRelative(win, relative);\n    };\n    const readRange = selection => {\n      if (selection.rangeCount > 0) {\n        const firstRng = selection.getRangeAt(0);\n        const lastRng = selection.getRangeAt(selection.rangeCount - 1);\n        return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const doGetExact = selection => {\n      if (selection.anchorNode === null || selection.focusNode === null) {\n        return readRange(selection);\n      } else {\n        const anchor = SugarElement.fromDom(selection.anchorNode);\n        const focus = SugarElement.fromDom(selection.focusNode);\n        return after(anchor, selection.anchorOffset, focus, selection.focusOffset) ? Optional.some(SimRange.create(anchor, selection.anchorOffset, focus, selection.focusOffset)) : readRange(selection);\n      }\n    };\n    const setToElement = (win, element, selectNodeContents$1 = true) => {\n      const rngGetter = selectNodeContents$1 ? selectNodeContents : selectNode;\n      const rng = rngGetter(win, element);\n      doSetNativeRange(win, rng);\n    };\n    const getExact = win => getNativeSelection(win).filter(sel => sel.rangeCount > 0).bind(doGetExact);\n    const get$2 = win => getExact(win).map(range => SimSelection.exact(range.start, range.soffset, range.finish, range.foffset));\n    const getFirstRect = (win, selection) => {\n      const rng = asLtrRange(win, selection);\n      return getFirstRect$1(rng);\n    };\n    const getAtPoint = (win, x, y) => fromPoint(win, x, y);\n    const clear = win => {\n      getNativeSelection(win).each(selection => selection.removeAllRanges());\n    };\n\n    const WindowBridge = win => {\n      const elementFromPoint = (x, y) => {\n        return SugarElement.fromPoint(SugarElement.fromDom(win.document), x, y);\n      };\n      const getRect = element => {\n        return element.dom.getBoundingClientRect();\n      };\n      const getRangedRect = (start, soffset, finish, foffset) => {\n        const sel = SimSelection.exact(start, soffset, finish, foffset);\n        return getFirstRect(win, sel);\n      };\n      const getSelection = () => {\n        return get$2(win).map(exactAdt => {\n          return convertToRange(win, exactAdt);\n        });\n      };\n      const fromSitus = situs => {\n        const relative = SimSelection.relative(situs.start, situs.finish);\n        return convertToRange(win, relative);\n      };\n      const situsFromPoint = (x, y) => {\n        return getAtPoint(win, x, y).map(exact => {\n          return Situs.create(exact.start, exact.soffset, exact.finish, exact.foffset);\n        });\n      };\n      const clearSelection = () => {\n        clear(win);\n      };\n      const collapseSelection = (toStart = false) => {\n        get$2(win).each(sel => sel.fold(rng => rng.collapse(toStart), (startSitu, finishSitu) => {\n          const situ = toStart ? startSitu : finishSitu;\n          setRelative(win, situ, situ);\n        }, (start, soffset, finish, foffset) => {\n          const node = toStart ? start : finish;\n          const offset = toStart ? soffset : foffset;\n          setExact(win, node, offset, node, offset);\n        }));\n      };\n      const selectNode = element => {\n        setToElement(win, element, false);\n      };\n      const selectContents = element => {\n        setToElement(win, element);\n      };\n      const setSelection = sel => {\n        setExact(win, sel.start, sel.soffset, sel.finish, sel.foffset);\n      };\n      const setRelativeSelection = (start, finish) => {\n        setRelative(win, start, finish);\n      };\n      const getInnerHeight = () => {\n        return win.innerHeight;\n      };\n      const getScrollY = () => {\n        const pos = get$3(SugarElement.fromDom(win.document));\n        return pos.top;\n      };\n      const scrollBy = (x, y) => {\n        by(x, y, SugarElement.fromDom(win.document));\n      };\n      return {\n        elementFromPoint,\n        getRect,\n        getRangedRect,\n        getSelection,\n        fromSitus,\n        situsFromPoint,\n        clearSelection,\n        collapseSelection,\n        setSelection,\n        setRelativeSelection,\n        selectNode,\n        selectContents,\n        getInnerHeight,\n        getScrollY,\n        scrollBy\n      };\n    };\n\n    const rc = (rows, cols) => ({\n      rows,\n      cols\n    });\n    const mouse = (win, container, isRoot, annotations) => {\n      const bridge = WindowBridge(win);\n      const handlers = MouseSelection(bridge, container, isRoot, annotations);\n      return {\n        clearstate: handlers.clearstate,\n        mousedown: handlers.mousedown,\n        mouseover: handlers.mouseover,\n        mouseup: handlers.mouseup\n      };\n    };\n    const isEditableNode = node => closest$2(node, isHTMLElement).exists(isEditable$1);\n    const isEditableSelection = (start, finish) => isEditableNode(start) || isEditableNode(finish);\n    const keyboard = (win, container, isRoot, annotations) => {\n      const bridge = WindowBridge(win);\n      const clearToNavigate = () => {\n        annotations.clear(container);\n        return Optional.none();\n      };\n      const keydown = (event, start, soffset, finish, foffset, direction) => {\n        const realEvent = event.raw;\n        const keycode = realEvent.which;\n        const shiftKey = realEvent.shiftKey === true;\n        const handler = retrieve$1(container, annotations.selectedSelector).fold(() => {\n          if (isNavigation(keycode) && !shiftKey) {\n            annotations.clearBeforeUpdate(container);\n          }\n          if (isNavigation(keycode) && shiftKey && !isEditableSelection(start, finish)) {\n            return Optional.none;\n          } else if (isDown(keycode) && shiftKey) {\n            return curry(select, bridge, container, isRoot, down, finish, start, annotations.selectRange);\n          } else if (isUp(keycode) && shiftKey) {\n            return curry(select, bridge, container, isRoot, up, finish, start, annotations.selectRange);\n          } else if (isDown(keycode)) {\n            return curry(navigate, bridge, isRoot, down, finish, start, lastDownCheck);\n          } else if (isUp(keycode)) {\n            return curry(navigate, bridge, isRoot, up, finish, start, firstUpCheck);\n          } else {\n            return Optional.none;\n          }\n        }, selected => {\n          const update$1 = attempts => {\n            return () => {\n              const navigation = findMap(attempts, delta => {\n                return update(delta.rows, delta.cols, container, selected, annotations);\n              });\n              return navigation.fold(() => {\n                return getEdges(container, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(edges => {\n                  const relative = isDown(keycode) || direction.isForward(keycode) ? Situ.after : Situ.before;\n                  bridge.setRelativeSelection(Situ.on(edges.first, 0), relative(edges.table));\n                  annotations.clear(container);\n                  return Response.create(Optional.none(), true);\n                });\n              }, _ => {\n                return Optional.some(Response.create(Optional.none(), true));\n              });\n            };\n          };\n          if (isNavigation(keycode) && shiftKey && !isEditableSelection(start, finish)) {\n            return Optional.none;\n          } else if (isDown(keycode) && shiftKey) {\n            return update$1([rc(+1, 0)]);\n          } else if (isUp(keycode) && shiftKey) {\n            return update$1([rc(-1, 0)]);\n          } else if (direction.isBackward(keycode) && shiftKey) {\n            return update$1([\n              rc(0, -1),\n              rc(-1, 0)\n            ]);\n          } else if (direction.isForward(keycode) && shiftKey) {\n            return update$1([\n              rc(0, +1),\n              rc(+1, 0)\n            ]);\n          } else if (isNavigation(keycode) && !shiftKey) {\n            return clearToNavigate;\n          } else {\n            return Optional.none;\n          }\n        });\n        return handler();\n      };\n      const keyup = (event, start, soffset, finish, foffset) => {\n        return retrieve$1(container, annotations.selectedSelector).fold(() => {\n          const realEvent = event.raw;\n          const keycode = realEvent.which;\n          const shiftKey = realEvent.shiftKey === true;\n          if (!shiftKey) {\n            return Optional.none();\n          }\n          if (isNavigation(keycode) && isEditableSelection(start, finish)) {\n            return sync(container, isRoot, start, soffset, finish, foffset, annotations.selectRange);\n          } else {\n            return Optional.none();\n          }\n        }, Optional.none);\n      };\n      return {\n        keydown,\n        keyup\n      };\n    };\n    const external = (win, container, isRoot, annotations) => {\n      const bridge = WindowBridge(win);\n      return (start, finish) => {\n        annotations.clearBeforeUpdate(container);\n        identify(start, finish, isRoot).each(cellSel => {\n          const boxes = cellSel.boxes.getOr([]);\n          annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);\n          bridge.selectContents(finish);\n          bridge.collapseSelection();\n        });\n      };\n    };\n\n    const read = (element, attr) => {\n      const value = get$b(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$2 = (element, attr, id) => {\n      const old = read(element, attr);\n      const nu = old.concat([id]);\n      set$2(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$4 = (element, attr, id) => {\n      const nu = filter$2(read(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$2(element, attr, nu.join(' '));\n      } else {\n        remove$7(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$1 = element => read(element, 'class');\n    const add$1 = (element, clazz) => add$2(element, 'class', clazz);\n    const remove$3 = (element, clazz) => remove$4(element, 'class', clazz);\n\n    const add = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$1(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$1(element);\n      if (classList.length === 0) {\n        remove$7(element, 'class');\n      }\n    };\n    const remove$2 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$3(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const remove$1 = (element, classes) => {\n      each$2(classes, x => {\n        remove$2(element, x);\n      });\n    };\n\n    const addClass = clazz => element => {\n      add(element, clazz);\n    };\n    const removeClasses = classes => element => {\n      remove$1(element, classes);\n    };\n\n    const byClass = ephemera => {\n      const addSelectionClass = addClass(ephemera.selected);\n      const removeSelectionClasses = removeClasses([\n        ephemera.selected,\n        ephemera.lastSelected,\n        ephemera.firstSelected\n      ]);\n      const clear = container => {\n        const sels = descendants(container, ephemera.selectedSelector);\n        each$2(sels, removeSelectionClasses);\n      };\n      const selectRange = (container, cells, start, finish) => {\n        clear(container);\n        each$2(cells, addSelectionClass);\n        add(start, ephemera.firstSelected);\n        add(finish, ephemera.lastSelected);\n      };\n      return {\n        clearBeforeUpdate: clear,\n        clear,\n        selectRange,\n        selectedSelector: ephemera.selectedSelector,\n        firstSelectedSelector: ephemera.firstSelectedSelector,\n        lastSelectedSelector: ephemera.lastSelectedSelector\n      };\n    };\n    const byAttr = (ephemera, onSelection, onClear) => {\n      const removeSelectionAttributes = element => {\n        remove$7(element, ephemera.selected);\n        remove$7(element, ephemera.firstSelected);\n        remove$7(element, ephemera.lastSelected);\n      };\n      const addSelectionAttribute = element => {\n        set$2(element, ephemera.selected, '1');\n      };\n      const clear = container => {\n        clearBeforeUpdate(container);\n        onClear();\n      };\n      const clearBeforeUpdate = container => {\n        const sels = descendants(container, `${ ephemera.selectedSelector },${ ephemera.firstSelectedSelector },${ ephemera.lastSelectedSelector }`);\n        each$2(sels, removeSelectionAttributes);\n      };\n      const selectRange = (container, cells, start, finish) => {\n        clear(container);\n        each$2(cells, addSelectionAttribute);\n        set$2(start, ephemera.firstSelected, '1');\n        set$2(finish, ephemera.lastSelected, '1');\n        onSelection(cells, start, finish);\n      };\n      return {\n        clearBeforeUpdate,\n        clear,\n        selectRange,\n        selectedSelector: ephemera.selectedSelector,\n        firstSelectedSelector: ephemera.firstSelectedSelector,\n        lastSelectedSelector: ephemera.lastSelectedSelector\n      };\n    };\n    const SelectionAnnotation = {\n      byClass,\n      byAttr\n    };\n\n    const fold = (subject, onNone, onMultiple, onSingle) => {\n      switch (subject.tag) {\n      case 'none':\n        return onNone();\n      case 'single':\n        return onSingle(subject.element);\n      case 'multiple':\n        return onMultiple(subject.elements);\n      }\n    };\n    const none = () => ({ tag: 'none' });\n    const multiple = elements => ({\n      tag: 'multiple',\n      elements\n    });\n    const single = element => ({\n      tag: 'single',\n      element\n    });\n\n    const Selections = (lazyRoot, getStart, selectedSelector) => {\n      const get = () => retrieve(lazyRoot(), selectedSelector).fold(() => getStart().fold(none, single), multiple);\n      return { get };\n    };\n\n    const getUpOrLeftCells = (grid, selectedCells) => {\n      const upGrid = grid.slice(0, selectedCells[selectedCells.length - 1].row + 1);\n      const upDetails = toDetailList(upGrid);\n      return bind$2(upDetails, detail => {\n        const slicedCells = detail.cells.slice(0, selectedCells[selectedCells.length - 1].column + 1);\n        return map$1(slicedCells, cell => cell.element);\n      });\n    };\n    const getDownOrRightCells = (grid, selectedCells) => {\n      const downGrid = grid.slice(selectedCells[0].row + selectedCells[0].rowspan - 1, grid.length);\n      const downDetails = toDetailList(downGrid);\n      return bind$2(downDetails, detail => {\n        const slicedCells = detail.cells.slice(selectedCells[0].column + selectedCells[0].colspan - 1, detail.cells.length);\n        return map$1(slicedCells, cell => cell.element);\n      });\n    };\n    const getOtherCells = (table, target, generators) => {\n      const warehouse = Warehouse.fromTable(table);\n      const details = onCells(warehouse, target);\n      return details.map(selectedCells => {\n        const grid = toGrid(warehouse, generators, false);\n        const {rows} = extractGridDetails(grid);\n        const upOrLeftCells = getUpOrLeftCells(rows, selectedCells);\n        const downOrRightCells = getDownOrRightCells(rows, selectedCells);\n        return {\n          upOrLeftCells,\n          downOrRightCells\n        };\n      });\n    };\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent$1 = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent$1(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$1 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const filter = always;\n    const bind = (element, event, handler) => bind$1(element, event, filter, handler);\n    const fromRawEvent = fromRawEvent$1;\n\n    const hasInternalTarget = e => !has(SugarElement.fromDom(e.target), 'ephox-snooker-resizer-bar');\n    const TableCellSelectionHandler = (editor, resizeHandler) => {\n      const cellSelection = Selections(() => SugarElement.fromDom(editor.getBody()), () => getSelectionCell(getSelectionStart(editor), getIsRoot(editor)), ephemera.selectedSelector);\n      const onSelection = (cells, start, finish) => {\n        const tableOpt = table(start);\n        tableOpt.each(table => {\n          const cloneFormats = getTableCloneElements(editor);\n          const generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), cloneFormats);\n          const selectedCells = getCellsFromSelection(editor);\n          const otherCells = getOtherCells(table, { selection: selectedCells }, generators);\n          fireTableSelectionChange(editor, cells, start, finish, otherCells);\n        });\n      };\n      const onClear = () => fireTableSelectionClear(editor);\n      const annotations = SelectionAnnotation.byAttr(ephemera, onSelection, onClear);\n      editor.on('init', _e => {\n        const win = editor.getWin();\n        const body = getBody(editor);\n        const isRoot = getIsRoot(editor);\n        const syncSelection = () => {\n          const sel = editor.selection;\n          const start = SugarElement.fromDom(sel.getStart());\n          const end = SugarElement.fromDom(sel.getEnd());\n          const shared = sharedOne(table, [\n            start,\n            end\n          ]);\n          shared.fold(() => annotations.clear(body), noop);\n        };\n        const mouseHandlers = mouse(win, body, isRoot, annotations);\n        const keyHandlers = keyboard(win, body, isRoot, annotations);\n        const external$1 = external(win, body, isRoot, annotations);\n        const hasShiftKey = event => event.raw.shiftKey === true;\n        editor.on('TableSelectorChange', e => external$1(e.start, e.finish));\n        const handleResponse = (event, response) => {\n          if (!hasShiftKey(event)) {\n            return;\n          }\n          if (response.kill) {\n            event.kill();\n          }\n          response.selection.each(ns => {\n            const relative = SimSelection.relative(ns.start, ns.finish);\n            const rng = asLtrRange(win, relative);\n            editor.selection.setRng(rng);\n          });\n        };\n        const keyup = event => {\n          const wrappedEvent = fromRawEvent(event);\n          if (wrappedEvent.raw.shiftKey && isNavigation(wrappedEvent.raw.which)) {\n            const rng = editor.selection.getRng();\n            const start = SugarElement.fromDom(rng.startContainer);\n            const end = SugarElement.fromDom(rng.endContainer);\n            keyHandlers.keyup(wrappedEvent, start, rng.startOffset, end, rng.endOffset).each(response => {\n              handleResponse(wrappedEvent, response);\n            });\n          }\n        };\n        const keydown = event => {\n          const wrappedEvent = fromRawEvent(event);\n          resizeHandler.hide();\n          const rng = editor.selection.getRng();\n          const start = SugarElement.fromDom(rng.startContainer);\n          const end = SugarElement.fromDom(rng.endContainer);\n          const direction = onDirection(ltr, rtl)(SugarElement.fromDom(editor.selection.getStart()));\n          keyHandlers.keydown(wrappedEvent, start, rng.startOffset, end, rng.endOffset, direction).each(response => {\n            handleResponse(wrappedEvent, response);\n          });\n          resizeHandler.show();\n        };\n        const isLeftMouse = raw => raw.button === 0;\n        const isLeftButtonPressed = raw => {\n          if (raw.buttons === undefined) {\n            return true;\n          }\n          return (raw.buttons & 1) !== 0;\n        };\n        const dragStart = _e => {\n          mouseHandlers.clearstate();\n        };\n        const mouseDown = e => {\n          if (isLeftMouse(e) && hasInternalTarget(e)) {\n            mouseHandlers.mousedown(fromRawEvent(e));\n          }\n        };\n        const mouseOver = e => {\n          if (isLeftButtonPressed(e) && hasInternalTarget(e)) {\n            mouseHandlers.mouseover(fromRawEvent(e));\n          }\n        };\n        const mouseUp = e => {\n          if (isLeftMouse(e) && hasInternalTarget(e)) {\n            mouseHandlers.mouseup(fromRawEvent(e));\n          }\n        };\n        const getDoubleTap = () => {\n          const lastTarget = Cell(SugarElement.fromDom(body));\n          const lastTimeStamp = Cell(0);\n          const touchEnd = t => {\n            const target = SugarElement.fromDom(t.target);\n            if (isTag('td')(target) || isTag('th')(target)) {\n              const lT = lastTarget.get();\n              const lTS = lastTimeStamp.get();\n              if (eq$1(lT, target) && t.timeStamp - lTS < 300) {\n                t.preventDefault();\n                external$1(target, target);\n              }\n            }\n            lastTarget.set(target);\n            lastTimeStamp.set(t.timeStamp);\n          };\n          return { touchEnd };\n        };\n        const doubleTap = getDoubleTap();\n        editor.on('dragstart', dragStart);\n        editor.on('mousedown', mouseDown);\n        editor.on('mouseover', mouseOver);\n        editor.on('mouseup', mouseUp);\n        editor.on('touchend', doubleTap.touchEnd);\n        editor.on('keyup', keyup);\n        editor.on('keydown', keydown);\n        editor.on('NodeChange', syncSelection);\n      });\n      editor.on('PreInit', () => {\n        editor.serializer.addTempAttr(ephemera.firstSelected);\n        editor.serializer.addTempAttr(ephemera.lastSelected);\n      });\n      const clearSelectedCells = container => annotations.clear(SugarElement.fromDom(container));\n      const getSelectedCells = () => fold(cellSelection.get(), constant([]), cells => {\n        return map$1(cells, cell => cell.dom);\n      }, cell => [cell.dom]);\n      return {\n        getSelectedCells,\n        clearSelectedCells\n      };\n    };\n\n    const Event = fields => {\n      let handlers = [];\n      const bind = handler => {\n        if (handler === undefined) {\n          throw new Error('Event bind error: undefined handler');\n        }\n        handlers.push(handler);\n      };\n      const unbind = handler => {\n        handlers = filter$2(handlers, h => {\n          return h !== handler;\n        });\n      };\n      const trigger = (...args) => {\n        const event = {};\n        each$2(fields, (name, i) => {\n          event[name] = args[i];\n        });\n        each$2(handlers, handler => {\n          handler(event);\n        });\n      };\n      return {\n        bind,\n        unbind,\n        trigger\n      };\n    };\n\n    const create$1 = typeDefs => {\n      const registry = map(typeDefs, event => {\n        return {\n          bind: event.bind,\n          unbind: event.unbind\n        };\n      });\n      const trigger = map(typeDefs, event => {\n        return event.trigger;\n      });\n      return {\n        registry,\n        trigger\n      };\n    };\n\n    const last = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const sort = arr => {\n      return arr.slice(0).sort();\n    };\n    const reqMessage = (required, keys) => {\n      throw new Error('All required keys (' + sort(required).join(', ') + ') were not specified. Specified keys were: ' + sort(keys).join(', ') + '.');\n    };\n    const unsuppMessage = unsupported => {\n      throw new Error('Unsupported keys for object: ' + sort(unsupported).join(', '));\n    };\n    const validateStrArr = (label, array) => {\n      if (!isArray(array)) {\n        throw new Error('The ' + label + ' fields must be an array. Was: ' + array + '.');\n      }\n      each$2(array, a => {\n        if (!isString(a)) {\n          throw new Error('The value ' + a + ' in the ' + label + ' fields was not a string.');\n        }\n      });\n    };\n    const invalidTypeMessage = (incorrect, type) => {\n      throw new Error('All values need to be of type: ' + type + '. Keys (' + sort(incorrect).join(', ') + ') were not.');\n    };\n    const checkDupes = everything => {\n      const sorted = sort(everything);\n      const dupe = find$1(sorted, (s, i) => {\n        return i < sorted.length - 1 && s === sorted[i + 1];\n      });\n      dupe.each(d => {\n        throw new Error('The field: ' + d + ' occurs more than once in the combined fields: [' + sorted.join(', ') + '].');\n      });\n    };\n\n    const base = (handleUnsupported, required) => {\n      return baseWith(handleUnsupported, required, {\n        validate: isFunction,\n        label: 'function'\n      });\n    };\n    const baseWith = (handleUnsupported, required, pred) => {\n      if (required.length === 0) {\n        throw new Error('You must specify at least one required field.');\n      }\n      validateStrArr('required', required);\n      checkDupes(required);\n      return obj => {\n        const keys$1 = keys(obj);\n        const allReqd = forall(required, req => {\n          return contains$2(keys$1, req);\n        });\n        if (!allReqd) {\n          reqMessage(required, keys$1);\n        }\n        handleUnsupported(required, keys$1);\n        const invalidKeys = filter$2(required, key => {\n          return !pred.validate(obj[key], key);\n        });\n        if (invalidKeys.length > 0) {\n          invalidTypeMessage(invalidKeys, pred.label);\n        }\n        return obj;\n      };\n    };\n    const handleExact = (required, keys) => {\n      const unsupported = filter$2(keys, key => {\n        return !contains$2(required, key);\n      });\n      if (unsupported.length > 0) {\n        unsuppMessage(unsupported);\n      }\n    };\n    const exactly = required => base(handleExact, required);\n\n    const DragMode = exactly([\n      'compare',\n      'extract',\n      'mutate',\n      'sink'\n    ]);\n    const DragSink = exactly([\n      'element',\n      'start',\n      'stop',\n      'destroy'\n    ]);\n    const DragApi = exactly([\n      'forceDrop',\n      'drop',\n      'move',\n      'delayDrop'\n    ]);\n\n    const InDrag = () => {\n      let previous = Optional.none();\n      const reset = () => {\n        previous = Optional.none();\n      };\n      const update = (mode, nu) => {\n        const result = previous.map(old => {\n          return mode.compare(old, nu);\n        });\n        previous = Optional.some(nu);\n        return result;\n      };\n      const onEvent = (event, mode) => {\n        const dataOption = mode.extract(event);\n        dataOption.each(data => {\n          const offset = update(mode, data);\n          offset.each(d => {\n            events.trigger.move(d);\n          });\n        });\n      };\n      const events = create$1({ move: Event(['info']) });\n      return {\n        onEvent,\n        reset,\n        events: events.registry\n      };\n    };\n\n    const NoDrag = () => {\n      const events = create$1({ move: Event(['info']) });\n      return {\n        onEvent: noop,\n        reset: noop,\n        events: events.registry\n      };\n    };\n\n    const Movement = () => {\n      const noDragState = NoDrag();\n      const inDragState = InDrag();\n      let dragState = noDragState;\n      const on = () => {\n        dragState.reset();\n        dragState = inDragState;\n      };\n      const off = () => {\n        dragState.reset();\n        dragState = noDragState;\n      };\n      const onEvent = (event, mode) => {\n        dragState.onEvent(event, mode);\n      };\n      const isOn = () => {\n        return dragState === inDragState;\n      };\n      return {\n        on,\n        off,\n        isOn,\n        onEvent,\n        events: inDragState.events\n      };\n    };\n\n    const setup = (mutation, mode, settings) => {\n      let active = false;\n      const events = create$1({\n        start: Event([]),\n        stop: Event([])\n      });\n      const movement = Movement();\n      const drop = () => {\n        sink.stop();\n        if (movement.isOn()) {\n          movement.off();\n          events.trigger.stop();\n        }\n      };\n      const throttledDrop = last(drop, 200);\n      const go = parent => {\n        sink.start(parent);\n        movement.on();\n        events.trigger.start();\n      };\n      const mousemove = event => {\n        throttledDrop.cancel();\n        movement.onEvent(event, mode);\n      };\n      movement.events.move.bind(event => {\n        mode.mutate(mutation, event.info);\n      });\n      const on = () => {\n        active = true;\n      };\n      const off = () => {\n        active = false;\n      };\n      const isActive = () => active;\n      const runIfActive = f => {\n        return (...args) => {\n          if (active) {\n            f.apply(null, args);\n          }\n        };\n      };\n      const sink = mode.sink(DragApi({\n        forceDrop: drop,\n        drop: runIfActive(drop),\n        move: runIfActive(mousemove),\n        delayDrop: runIfActive(throttledDrop.throttle)\n      }), settings);\n      const destroy = () => {\n        sink.destroy();\n      };\n      return {\n        element: sink.element,\n        go,\n        on,\n        off,\n        isActive,\n        destroy,\n        events: events.registry\n      };\n    };\n\n    const css = namespace => {\n      const dashNamespace = namespace.replace(/\\./g, '-');\n      const resolve = str => {\n        return dashNamespace + '-' + str;\n      };\n      return { resolve };\n    };\n\n    const styles$1 = css('ephox-dragster');\n    const resolve$1 = styles$1.resolve;\n\n    const Blocker = options => {\n      const settings = {\n        layerClass: resolve$1('blocker'),\n        ...options\n      };\n      const div = SugarElement.fromTag('div');\n      set$2(div, 'role', 'presentation');\n      setAll(div, {\n        position: 'fixed',\n        left: '0px',\n        top: '0px',\n        width: '100%',\n        height: '100%'\n      });\n      add(div, resolve$1('blocker'));\n      add(div, settings.layerClass);\n      const element = constant(div);\n      const destroy = () => {\n        remove$6(div);\n      };\n      return {\n        element,\n        destroy\n      };\n    };\n\n    const compare = (old, nu) => {\n      return SugarPosition(nu.left - old.left, nu.top - old.top);\n    };\n    const extract = event => {\n      return Optional.some(SugarPosition(event.x, event.y));\n    };\n    const mutate = (mutation, info) => {\n      mutation.mutate(info.left, info.top);\n    };\n    const sink = (dragApi, settings) => {\n      const blocker = Blocker(settings);\n      const mdown = bind(blocker.element(), 'mousedown', dragApi.forceDrop);\n      const mup = bind(blocker.element(), 'mouseup', dragApi.drop);\n      const mmove = bind(blocker.element(), 'mousemove', dragApi.move);\n      const mout = bind(blocker.element(), 'mouseout', dragApi.delayDrop);\n      const destroy = () => {\n        blocker.destroy();\n        mup.unbind();\n        mmove.unbind();\n        mout.unbind();\n        mdown.unbind();\n      };\n      const start = parent => {\n        append$1(parent, blocker.element());\n      };\n      const stop = () => {\n        remove$6(blocker.element());\n      };\n      return DragSink({\n        element: blocker.element,\n        start,\n        stop,\n        destroy\n      });\n    };\n    var MouseDrag = DragMode({\n      compare,\n      extract,\n      sink,\n      mutate\n    });\n\n    const transform = (mutation, settings = {}) => {\n      var _a;\n      const mode = (_a = settings.mode) !== null && _a !== void 0 ? _a : MouseDrag;\n      return setup(mutation, mode, settings);\n    };\n\n    const styles = css('ephox-snooker');\n    const resolve = styles.resolve;\n\n    const Mutation = () => {\n      const events = create$1({\n        drag: Event([\n          'xDelta',\n          'yDelta'\n        ])\n      });\n      const mutate = (x, y) => {\n        events.trigger.drag(x, y);\n      };\n      return {\n        mutate,\n        events: events.registry\n      };\n    };\n\n    const BarMutation = () => {\n      const events = create$1({\n        drag: Event([\n          'xDelta',\n          'yDelta',\n          'target'\n        ])\n      });\n      let target = Optional.none();\n      const delegate = Mutation();\n      delegate.events.drag.bind(event => {\n        target.each(t => {\n          events.trigger.drag(event.xDelta, event.yDelta, t);\n        });\n      });\n      const assign = t => {\n        target = Optional.some(t);\n      };\n      const get = () => {\n        return target;\n      };\n      return {\n        assign,\n        get,\n        mutate: delegate.mutate,\n        events: events.registry\n      };\n    };\n\n    const col = (column, x, y, w, h) => {\n      const bar = SugarElement.fromTag('div');\n      setAll(bar, {\n        position: 'absolute',\n        left: x - w / 2 + 'px',\n        top: y + 'px',\n        height: h + 'px',\n        width: w + 'px'\n      });\n      setAll$1(bar, {\n        'data-column': column,\n        'role': 'presentation'\n      });\n      return bar;\n    };\n    const row = (r, x, y, w, h) => {\n      const bar = SugarElement.fromTag('div');\n      setAll(bar, {\n        position: 'absolute',\n        left: x + 'px',\n        top: y - h / 2 + 'px',\n        height: h + 'px',\n        width: w + 'px'\n      });\n      setAll$1(bar, {\n        'data-row': r,\n        'role': 'presentation'\n      });\n      return bar;\n    };\n\n    const resizeBar = resolve('resizer-bar');\n    const resizeRowBar = resolve('resizer-rows');\n    const resizeColBar = resolve('resizer-cols');\n    const BAR_THICKNESS = 7;\n    const resizableRows = (warehouse, isResizable) => bind$2(warehouse.all, (row, i) => isResizable(row.element) ? [i] : []);\n    const resizableColumns = (warehouse, isResizable) => {\n      const resizableCols = [];\n      range$1(warehouse.grid.columns, index => {\n        const colElmOpt = Warehouse.getColumnAt(warehouse, index).map(col => col.element);\n        if (colElmOpt.forall(isResizable)) {\n          resizableCols.push(index);\n        }\n      });\n      return filter$2(resizableCols, colIndex => {\n        const columnCells = Warehouse.filterItems(warehouse, cell => cell.column === colIndex);\n        return forall(columnCells, cell => isResizable(cell.element));\n      });\n    };\n    const destroy = wire => {\n      const previous = descendants(wire.parent(), '.' + resizeBar);\n      each$2(previous, remove$6);\n    };\n    const drawBar = (wire, positions, create) => {\n      const origin = wire.origin();\n      each$2(positions, cpOption => {\n        cpOption.each(cp => {\n          const bar = create(origin, cp);\n          add(bar, resizeBar);\n          append$1(wire.parent(), bar);\n        });\n      });\n    };\n    const refreshCol = (wire, colPositions, position, tableHeight) => {\n      drawBar(wire, colPositions, (origin, cp) => {\n        const colBar = col(cp.col, cp.x - origin.left, position.top - origin.top, BAR_THICKNESS, tableHeight);\n        add(colBar, resizeColBar);\n        return colBar;\n      });\n    };\n    const refreshRow = (wire, rowPositions, position, tableWidth) => {\n      drawBar(wire, rowPositions, (origin, cp) => {\n        const rowBar = row(cp.row, position.left - origin.left, cp.y - origin.top, tableWidth, BAR_THICKNESS);\n        add(rowBar, resizeRowBar);\n        return rowBar;\n      });\n    };\n    const refreshGrid = (warhouse, wire, table, rows, cols) => {\n      const position = absolute(table);\n      const isResizable = wire.isResizable;\n      const rowPositions = rows.length > 0 ? height.positions(rows, table) : [];\n      const resizableRowBars = rowPositions.length > 0 ? resizableRows(warhouse, isResizable) : [];\n      const resizableRowPositions = filter$2(rowPositions, (_pos, i) => exists(resizableRowBars, barIndex => i === barIndex));\n      refreshRow(wire, resizableRowPositions, position, getOuter$2(table));\n      const colPositions = cols.length > 0 ? width.positions(cols, table) : [];\n      const resizableColBars = colPositions.length > 0 ? resizableColumns(warhouse, isResizable) : [];\n      const resizableColPositions = filter$2(colPositions, (_pos, i) => exists(resizableColBars, barIndex => i === barIndex));\n      refreshCol(wire, resizableColPositions, position, getOuter$1(table));\n    };\n    const refresh = (wire, table) => {\n      destroy(wire);\n      if (wire.isResizable(table)) {\n        const warehouse = Warehouse.fromTable(table);\n        const rows$1 = rows(warehouse);\n        const cols = columns(warehouse);\n        refreshGrid(warehouse, wire, table, rows$1, cols);\n      }\n    };\n    const each = (wire, f) => {\n      const bars = descendants(wire.parent(), '.' + resizeBar);\n      each$2(bars, f);\n    };\n    const hide = wire => {\n      each(wire, bar => {\n        set$1(bar, 'display', 'none');\n      });\n    };\n    const show = wire => {\n      each(wire, bar => {\n        set$1(bar, 'display', 'block');\n      });\n    };\n    const isRowBar = element => {\n      return has(element, resizeRowBar);\n    };\n    const isColBar = element => {\n      return has(element, resizeColBar);\n    };\n\n    const resizeBarDragging = resolve('resizer-bar-dragging');\n    const BarManager = wire => {\n      const mutation = BarMutation();\n      const resizing = transform(mutation, {});\n      let hoverTable = Optional.none();\n      const getResizer = (element, type) => {\n        return Optional.from(get$b(element, type));\n      };\n      mutation.events.drag.bind(event => {\n        getResizer(event.target, 'data-row').each(_dataRow => {\n          const currentRow = getCssValue(event.target, 'top');\n          set$1(event.target, 'top', currentRow + event.yDelta + 'px');\n        });\n        getResizer(event.target, 'data-column').each(_dataCol => {\n          const currentCol = getCssValue(event.target, 'left');\n          set$1(event.target, 'left', currentCol + event.xDelta + 'px');\n        });\n      });\n      const getDelta = (target, dir) => {\n        const newX = getCssValue(target, dir);\n        const oldX = getAttrValue(target, 'data-initial-' + dir, 0);\n        return newX - oldX;\n      };\n      resizing.events.stop.bind(() => {\n        mutation.get().each(target => {\n          hoverTable.each(table => {\n            getResizer(target, 'data-row').each(row => {\n              const delta = getDelta(target, 'top');\n              remove$7(target, 'data-initial-top');\n              events.trigger.adjustHeight(table, delta, parseInt(row, 10));\n            });\n            getResizer(target, 'data-column').each(column => {\n              const delta = getDelta(target, 'left');\n              remove$7(target, 'data-initial-left');\n              events.trigger.adjustWidth(table, delta, parseInt(column, 10));\n            });\n            refresh(wire, table);\n          });\n        });\n      });\n      const handler = (target, dir) => {\n        events.trigger.startAdjust();\n        mutation.assign(target);\n        set$2(target, 'data-initial-' + dir, getCssValue(target, dir));\n        add(target, resizeBarDragging);\n        set$1(target, 'opacity', '0.2');\n        resizing.go(wire.parent());\n      };\n      const mousedown = bind(wire.parent(), 'mousedown', event => {\n        if (isRowBar(event.target)) {\n          handler(event.target, 'top');\n        }\n        if (isColBar(event.target)) {\n          handler(event.target, 'left');\n        }\n      });\n      const isRoot = e => {\n        return eq$1(e, wire.view());\n      };\n      const findClosestEditableTable = target => closest$1(target, 'table', isRoot).filter(isEditable$1);\n      const mouseover = bind(wire.view(), 'mouseover', event => {\n        findClosestEditableTable(event.target).fold(() => {\n          if (inBody(event.target)) {\n            destroy(wire);\n          }\n        }, table => {\n          if (resizing.isActive()) {\n            hoverTable = Optional.some(table);\n            refresh(wire, table);\n          }\n        });\n      });\n      const destroy$1 = () => {\n        mousedown.unbind();\n        mouseover.unbind();\n        resizing.destroy();\n        destroy(wire);\n      };\n      const refresh$1 = tbl => {\n        refresh(wire, tbl);\n      };\n      const events = create$1({\n        adjustHeight: Event([\n          'table',\n          'delta',\n          'row'\n        ]),\n        adjustWidth: Event([\n          'table',\n          'delta',\n          'column'\n        ]),\n        startAdjust: Event([])\n      });\n      return {\n        destroy: destroy$1,\n        refresh: refresh$1,\n        on: resizing.on,\n        off: resizing.off,\n        hideBars: curry(hide, wire),\n        showBars: curry(show, wire),\n        events: events.registry\n      };\n    };\n\n    const create = (wire, resizing, lazySizing) => {\n      const hdirection = height;\n      const vdirection = width;\n      const manager = BarManager(wire);\n      const events = create$1({\n        beforeResize: Event([\n          'table',\n          'type'\n        ]),\n        afterResize: Event([\n          'table',\n          'type'\n        ]),\n        startDrag: Event([])\n      });\n      manager.events.adjustHeight.bind(event => {\n        const table = event.table;\n        events.trigger.beforeResize(table, 'row');\n        const delta = hdirection.delta(event.delta, table);\n        adjustHeight(table, delta, event.row, hdirection);\n        events.trigger.afterResize(table, 'row');\n      });\n      manager.events.startAdjust.bind(_event => {\n        events.trigger.startDrag();\n      });\n      manager.events.adjustWidth.bind(event => {\n        const table = event.table;\n        events.trigger.beforeResize(table, 'col');\n        const delta = vdirection.delta(event.delta, table);\n        const tableSize = lazySizing(table);\n        adjustWidth(table, delta, event.column, resizing, tableSize);\n        events.trigger.afterResize(table, 'col');\n      });\n      return {\n        on: manager.on,\n        off: manager.off,\n        refreshBars: manager.refresh,\n        hideBars: manager.hideBars,\n        showBars: manager.showBars,\n        destroy: manager.destroy,\n        events: events.registry\n      };\n    };\n    const TableResize = { create };\n\n    const only = (element, isResizable) => {\n      const parent = isDocument(element) ? documentElement(element) : element;\n      return {\n        parent: constant(parent),\n        view: constant(element),\n        origin: constant(SugarPosition(0, 0)),\n        isResizable\n      };\n    };\n    const detached = (editable, chrome, isResizable) => {\n      const origin = () => absolute(chrome);\n      return {\n        parent: constant(chrome),\n        view: constant(editable),\n        origin,\n        isResizable\n      };\n    };\n    const body = (editable, chrome, isResizable) => {\n      return {\n        parent: constant(chrome),\n        view: constant(editable),\n        origin: constant(SugarPosition(0, 0)),\n        isResizable\n      };\n    };\n    const ResizeWire = {\n      only,\n      detached,\n      body\n    };\n\n    const createContainer = () => {\n      const container = SugarElement.fromTag('div');\n      setAll(container, {\n        position: 'static',\n        height: '0',\n        width: '0',\n        padding: '0',\n        margin: '0',\n        border: '0'\n      });\n      append$1(body$1(), container);\n      return container;\n    };\n    const get = (editor, isResizable) => {\n      return editor.inline ? ResizeWire.body(SugarElement.fromDom(editor.getBody()), createContainer(), isResizable) : ResizeWire.only(SugarElement.fromDom(editor.getDoc()), isResizable);\n    };\n    const remove = (editor, wire) => {\n      if (editor.inline) {\n        remove$6(wire.parent());\n      }\n    };\n\n    const isTable = node => isNonNullable(node) && node.nodeName === 'TABLE';\n    const barResizerPrefix = 'bar-';\n    const isResizable = elm => get$b(elm, 'data-mce-resize') !== 'false';\n    const syncPixels = table => {\n      const warehouse = Warehouse.fromTable(table);\n      if (!Warehouse.hasColumns(warehouse)) {\n        each$2(cells$1(table), cell => {\n          const computedWidth = get$a(cell, 'width');\n          set$1(cell, 'width', computedWidth);\n          remove$7(cell, 'width');\n        });\n      }\n    };\n    const TableResizeHandler = editor => {\n      const selectionRng = value();\n      const tableResize = value();\n      const resizeWire = value();\n      let startW;\n      let startRawW;\n      const lazySizing = table => get$5(editor, table);\n      const lazyResizingBehaviour = () => isPreserveTableColumnResizing(editor) ? preserveTable() : resizeTable();\n      const getNumColumns = table => getGridSize(table).columns;\n      const afterCornerResize = (table, origin, width) => {\n        const isRightEdgeResize = endsWith(origin, 'e');\n        if (startRawW === '') {\n          convertToPercentSize(table);\n        }\n        if (width !== startW && startRawW !== '') {\n          set$1(table, 'width', startRawW);\n          const resizing = lazyResizingBehaviour();\n          const tableSize = lazySizing(table);\n          const col = isPreserveTableColumnResizing(editor) || isRightEdgeResize ? getNumColumns(table) - 1 : 0;\n          adjustWidth(table, width - startW, col, resizing, tableSize);\n        } else if (isPercentage$1(startRawW)) {\n          const percentW = parseFloat(startRawW.replace('%', ''));\n          const targetPercentW = width * percentW / startW;\n          set$1(table, 'width', targetPercentW + '%');\n        }\n        if (isPixel(startRawW)) {\n          syncPixels(table);\n        }\n      };\n      const destroy = () => {\n        tableResize.on(sz => {\n          sz.destroy();\n        });\n        resizeWire.on(w => {\n          remove(editor, w);\n        });\n      };\n      editor.on('init', () => {\n        const rawWire = get(editor, isResizable);\n        resizeWire.set(rawWire);\n        if (hasTableObjectResizing(editor) && hasTableResizeBars(editor)) {\n          const resizing = lazyResizingBehaviour();\n          const sz = TableResize.create(rawWire, resizing, lazySizing);\n          sz.on();\n          sz.events.startDrag.bind(_event => {\n            selectionRng.set(editor.selection.getRng());\n          });\n          sz.events.beforeResize.bind(event => {\n            const rawTable = event.table.dom;\n            fireObjectResizeStart(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);\n          });\n          sz.events.afterResize.bind(event => {\n            const table = event.table;\n            const rawTable = table.dom;\n            removeDataStyle(table);\n            selectionRng.on(rng => {\n              editor.selection.setRng(rng);\n              editor.focus();\n            });\n            fireObjectResized(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);\n            editor.undoManager.add();\n          });\n          tableResize.set(sz);\n        }\n      });\n      editor.on('ObjectResizeStart', e => {\n        const targetElm = e.target;\n        if (isTable(targetElm)) {\n          const table = SugarElement.fromDom(targetElm);\n          each$2(editor.dom.select('.mce-clonedresizable'), clone => {\n            editor.dom.addClass(clone, 'mce-' + getTableColumnResizingBehaviour(editor) + '-columns');\n          });\n          if (!isPixelSizing(table) && isTablePixelsForced(editor)) {\n            convertToPixelSize(table);\n          } else if (!isPercentSizing(table) && isTablePercentagesForced(editor)) {\n            convertToPercentSize(table);\n          }\n          if (isNoneSizing(table) && startsWith(e.origin, barResizerPrefix)) {\n            convertToPercentSize(table);\n          }\n          startW = e.width;\n          startRawW = isTableResponsiveForced(editor) ? '' : getRawWidth(editor, targetElm).getOr('');\n        }\n      });\n      editor.on('ObjectResized', e => {\n        const targetElm = e.target;\n        if (isTable(targetElm)) {\n          const table = SugarElement.fromDom(targetElm);\n          const origin = e.origin;\n          if (startsWith(origin, 'corner-')) {\n            afterCornerResize(table, origin, e.width);\n          }\n          removeDataStyle(table);\n          fireTableModified(editor, table.dom, styleModified);\n        }\n      });\n      editor.on('SwitchMode', () => {\n        tableResize.on(resize => {\n          if (editor.mode.isReadOnly()) {\n            resize.hideBars();\n          } else {\n            resize.showBars();\n          }\n        });\n      });\n      editor.on('dragstart dragend', e => {\n        tableResize.on(resize => {\n          if (e.type === 'dragstart') {\n            resize.hideBars();\n            resize.off();\n          } else {\n            resize.on();\n            resize.showBars();\n          }\n        });\n      });\n      editor.on('remove', () => {\n        destroy();\n      });\n      const refresh = table => {\n        tableResize.on(resize => resize.refreshBars(SugarElement.fromDom(table)));\n      };\n      const hide = () => {\n        tableResize.on(resize => resize.hideBars());\n      };\n      const show = () => {\n        tableResize.on(resize => resize.showBars());\n      };\n      return {\n        refresh,\n        hide,\n        show\n      };\n    };\n\n    const setupTable = editor => {\n      register(editor);\n      const resizeHandler = TableResizeHandler(editor);\n      const cellSelectionHandler = TableCellSelectionHandler(editor, resizeHandler);\n      const actions = TableActions(editor, resizeHandler, cellSelectionHandler);\n      registerCommands(editor, actions);\n      registerQueryCommands(editor, actions);\n      registerEvents(editor, actions);\n      return {\n        getSelectedCells: cellSelectionHandler.getSelectedCells,\n        clearSelectedCells: cellSelectionHandler.clearSelectedCells\n      };\n    };\n\n    const DomModel = editor => {\n      const table = setupTable(editor);\n      return { table };\n    };\n    var Model = () => {\n      global$1.add('dom', DomModel);\n    };\n\n    Model();\n\n})();\n"],"names":["global$1","hasProto","v","constructor","predicate","_a","typeOf","x","t","o","proto","isType$1","type","value","isSimpleType","eq$2","a","isString","isObject","isArray","isNull","isBoolean","isUndefined","isNullable","isNonNullable","isFunction","isNumber","noop","compose","fa","fb","args","compose1","fbc","fab","constant","identity","tripleEquals","b","curry","fn","initialArgs","restArgs","all","not","f","die","msg","apply","never","always","Optional","tag","onNone","onSome","mapper","binder","replacement","thunk","message","worker","nativeSlice","nativeIndexOf","nativePush","rawIndexOf","ts","contains$2","xs","exists","pred","i","len","range$1","num","r","map$1","each$2","eachr","partition","pass","fail","filter$2","foldr","acc","foldl","findUntil","until","find$1","findIndex","flatten","bind$2","forall","reverse","mapToObject","sort$1","comparator","copy","get$d","head","last$2","findMap","arr","keys","hasOwnProperty","each$1","obj","props","k","map","tupleMap","tuple","objAcc","internalFilter","onTrue","onFalse","filter$1","mapToArray","name","values","get$c","key","has$1","hasNonNullableKey","isEmpty","Global","path","parts","scope","resolve$2","p","unsafe","getOrDie","actual","getPrototypeOf","sandHTMLElement","isPrototypeOf","COMMENT","DOCUMENT","DOCUMENT_FRAGMENT","ELEMENT","TEXT","element","isType","isComment","isHTMLElement","isElement","isText","isDocument","isDocumentFragment","isTag","rawSet","dom","set$2","setAll$1","attrs","setOptions","remove$7","get$b","getOpt","clone$2","attr","fromHtml$1","html","div","fromDom$1","fromTag","node","fromText","text","SugarElement","docElm","y","is$2","selector","elem","bypassSelector","all$1","base","one","eq$1","e1","e2","contains$1","d1","d2","is$1","owner","documentOrOwner","dos","documentElement","defaultView","parent","parentElement","parents","isRoot","stop","ret","rawParent","prevSibling","nextSibling","children$2","child$2","index","cs","firstChild","before$3","marker","after$5","append$1","prepend","appendAt","wrap","wrapper","after$4","elements","e","append","empty","rogue","remove$6","unwrap","children","clone$1","original","isDeep","shallow","deep","shallowAs","nu","attributes","copy$2","cloneChildren","mutate$1","validSectionList","isValidSection","parentName","grid","rows","columns","address","row","column","detail","rowspan","colspan","detailnew","isNew","extended","isLocked","rowdetail","cells","section","rowdetailnew","elementnew","rowcells","bounds","startRow","startCol","finishRow","finishCol","columnext","colgroup","isShadowRoot","supported","isSupported$1","getRootNode","getShadowRoot","getShadowHost","getOriginalEventTarget","event","el","isOpenShadowHost","composedPath","inBody","doc","body$1","getBody$1","ancestors$4","children$1","descendants$1","result","ancestors$3","descendants","ClosestOrAncestor","is","ancestor","ancestor$2","closest$2","test","child$1","descendant$1","descend","child","res","ancestor$1","descendant","closest$1","lhs","rhs","left","cat","push","bindFrom","someIf","checkRange","str","substr","start","contains","end","idx","startsWith","prefix","endsWith","suffix","trim","s","isNotEmpty","toFloat","isSupported","internalSet","property","internalRemove","set$1","setAll","css","get$a","getUnsafeProperty","getRaw$2","raw","remove$5","copy$1","source","target","sourceDom","targetDom","getAttrValue","cell","fallback","getSpan","hasColspan","cellOrCol","hasRowspan","getCssValue","minWidth","minHeight","firstLayer","filterFirstLayer","lookup","tags","isRootOrUpperTable","elm","cells$1","columns$1","columnGroups","columnGroup","table","rows$1","fromRowsOrColGroups","elems","getSection","getParentSection","group","fromTable$1","fromPastedRows","cached","called","DeviceType","os","browser","userAgent","mediaMatch","isiPad","isiPhone","isMobile","isTouch","isTablet","isPhone","iOSwebview","isDesktop","firstMatch","regexes","find","agent","nu$2","detect$5","versionRegexes","cleanedAgent","unknown$2","major","minor","Version","detectBrowser$1","browsers","userAgentData","uaBrand","lcBrand","info","detect$4","candidates","candidate","detectBrowser","version","detectOs","oses","normalVersionRegex","checkContains","uastring","PlatformInfo","edge","chromium","ie","opera","firefox","safari","unknown$1","nu$1","current","isBrowser","Browser","windows","ios","android","linux","macos","solaris","freebsd","chromeos","unknown","isOS","OperatingSystem","PlatformDetection","userAgentDataOpt","deviceType","query","platform","detect$2","Dimension","getOffset","set","h","get","getOuter","aggregate","properties","val","cumulativeInclusions","toNumber","px","getProp","calcContentBoxSize","size","upper","lower","paddingUpper","paddingLower","borderUpper","borderLower","getCalculatedWidth","boxSizing","width","getHeight$1","getWidth","getInnerWidth","api$2","get$9","getOuter$2","getInner","getRuntime$1","addCells","gridRow","existingCells","before","after","newCells","setCells","addCell","mutateCell","mapCells","getCell","getCellElement","cellLength","extractGridDetails","clone","cloneRow","cloneCell","LOCKED_COL_ATTR","getLockedColumnsFromTable","lockedColStr","lockedCols","getLockedColumnsFromGrid","locked","lockedArr","_val","getAt","warehouse","findItem","item","filtered","filterItems","generateColumns","rowData","columnsGroup","columnIndex","colIndex","generate$1","list","access","lockedColumns","maxRows","maxColumns","rowCount","colgroupRows","currentRow","rowCell","occupiedColumnPosition","occupiedRowPosition","rowPosition","columnPosition","newpos","colgroups","Warehouse","w","isValidCell","cols","rowsArr","col","decide","getBlock","isValid","getFallback","inBlock","c","deduce","rest","aa","next","n","extras","onDirection","isLtr","isRtl","getDirection","api$1","get$8","getOuter$1","getRuntime","top","SugarPosition","boxPosition","box","firstDefinedOrZero","absolute","body","win","scrollTop","scrollLeft","clientTop","clientLeft","viewport","rowInfo","colInfo","rtlEdge","ltrEdge","getLeftEdge","getRightEdge","getTop$1","getTopEdge","getBottomEdge","findPositions","getInnerEdge","getOuterEdge","array","lines","cellOption","lastLine","negate","step","height","optElements","detect$1","amount","units","pattern","decimalDigits","exponentPart","dot","opt","input","float","isUnit","unit","accepted","check","parse","unitRaw","rPercentageBasedSizeRegex","rPixelBasedSizeRegex","isCol$2","getPercentSize","outerGetter","innerGetter","relativeParent","setPixelWidth","setPercentageWidth","setHeight","getHeightValue","convert","number","getter","setter","newSize","total","normalizePixelSize","getTotalHeight","get$7","span","getRaw$1","prop","getRawWidth$1","getRawHeight","getPercentageWidth","getPixelWidth$1","getHeight","getGenericWidth","setGenericWidth","getPixelTableWidth","getPercentTableWidth","isPercentSizing$1","isPixelSizing$1","isNoneSizing$1","percentageBasedSizeRegex","isCol$1","getRawW","getRawH","justCols","isValidColumn","supportsColWidths","getDimension","cellOpt","backups","filter","getWidthFrom","columnCells","pos","colFilter","getDeduced","deduced","d","getRawWidths","getPercentageWidths","tableSize","cellWidth","getPixelWidths","getHeightFrom","direction","getPixelHeights","getRawHeights","widthLookup","noneSize","zero","percentageSize","getFloatWidth","delta","_delta","currentWidth","change","newWidth","pixelSize","chooseSize","TableSize","statsStruct","minRow","minCol","maxRow","maxCol","allCells","selectedCells","findSelectedStats","house","isSelected","totalColumns","endRow","endCol","makeCell","seenSelected","rowIndex","td","fillInGaps","stats","totalRows","j","clean","replica","widthDelta","emptyRows","getTableWidthDelta","colWidths","allColsWidth","extract$1","selectedSelector","replicaHouse","replicaStats","unselectedCells","nbsp","api","getOption","get$6","getEnd","isTextNodeWithCursorPosition","isContentEditableFalse","elementsWithCursorPosition","isCursorPosition","first","last$1","descendantRtl","transferableAttributes","createCell","createCol","createColgroup","createRow$1","replace$1","pasteReplace","cloneFormats","oldCell","newCell","formats","firstText","formatSelector","last","clonedFormat","cloneAppropriateAttributes","validAttributes","attributeName","attribute","cellOperations","mutate","formatsToClone","cloneCss","prev","lastNode","paste$1","fromHtml","fromDom","nodes","option","editor","defaultWidth","getPixelForcedWidth","parentBlock","determineDefaultTableStyles","defaultStyles","isTableResponsiveForced","shouldStyleWithCss","isTablePixelsForced","determineDefaultTableAttributes","defaultAttributes","register","registerOption","valid","getTableCloneElements","hasTableObjectResizing","objectResizing","getTableHeaderType","getTableColumnResizingBehaviour","isPreserveTableColumnResizing","isResizeTableColumnResizing","getTableSizingMode","isTablePercentagesForced","hasTableResizeBars","shouldMergeContentOnPaste","getTableDefaultAttributes","options","getTableDefaultStyles","tableUseColumnGroup","closest","isEditable$1","assumeEditable","editable","getRaw","getBody","getIsRoot","removeDataStyle","removeStyleAttribute","getSelectionStart","getPixelWidth","getPixelHeight","getRawWidth","isPercentage$1","isPixel","isInEditableContext$1","inSelection","leftEdge","rightEdge","topEdge","bottomEdge","isWithin","isRectangular","isRect","detailIsWithin","getBounds","detailA","detailB","getAnyBox","startCell","finishCell","startCoords","finishCoords","sc","fc","getBox$1","moveBy$1","intercepts$1","finish","inside","parentCell","innerCell","isContainedBy","c1","c2","moveBy","deltaRow","deltaColumn","getWarehouse","intercepts","nestedIntercepts","firstTable","lastTable","optStartCell","optLastCell","lastCell","getBox","TagBoundaries","DomUniverse","document","isBoundary","isEmptyTag","isNonEditable","comparePosition","other","copyAttributesTo","destination","as","isSpecial","getLanguage","universe","look","tail","oneAll","unsafeOne","commonElement","eq","ancestors$2","ps1","ps2","prune","ind","pruned1","pruned2","shared","sharedOne$1","ancestors$1","universe$3","sharedOne","_universe","ancestors","lookupTable","container","identify","rootTable","startTable","finishTable","ancestorCells","lca","lcaTable","finishAncestorCells","startAncestorCells","retrieve$1","sels","getLast","boxes","lastSelectedSelector","getEdges","firstSelectedSelector","expandTo","identified","shiftSelection","retrieve","retrieveBox","edges","sectionSelector","firstAncestor","lastAncestor","fA","lA","selection","unmergable","hasSpan","hasRowOrColSpan","mergable","ephemera","strSelected","strSelectedSelector","strAttributeSelector","strFirstSelected","strFirstSelectedSelector","strLastSelected","strLastSelectedSelector","attributeSelector","forMenu","paste","clipboard","generators","pasteRows","_cell","getSelectionCellFallback","getSelectionFromSelector","initCell","cellName","getSelectionCellOrCaption","getSelectionCell","getCellsFromSelection","getCellsFromFakeSelection","extractSelected","serializeElements","getTextContent","registerEvents","actions","multiCellContext","content","isTable","targets","point","offset","scan$1","toEnd","freefallRtl$2","freefallRtl$1","universe$2","freefallRtl","halve","main","surround","sizes","startIndex","endIndex","results","clampDeltaHelper","minCellSize","diff","clampNegativeDelta","clampDelta","resizeTable","calcFixedDeltas","clampedDelta","calcRelativeDeltas","ratio","newThis","calcLeftEdgeDeltas","isRelative","resizer","_prev","totalWidth","pixelDelta","newSizes","preserveTable","isLastColumn","maxDelta","_index","_minCellSize","_totalWidth","_pixelDelta","_isRelative","getGridSize","isHeaderCell","isHeaderCells","getRowHeaderType","isHeaderRow","getRowType","findCommonCellType","headerCells","findCommonRowType","rowTypes","hasHeader","hasFooter","hasBody","findTableRowHeaderType","rowType","transformCell","substitution","transformRow","fixedCell","sectionCells","TableSection","setIfNot","ignore","insert$1","generateSection","sectionName","newSection","render$1","newRows","syncRows","gridSection","tr","syncColGroup","colGroup","renderSection","sectionElems","removeSection","renderOrRemoveSection","headSection","bodySection","footSection","columnGroupsSection","clonedCell","getColumn","getRow","findDiff","comp","subgrid","isColRow","toDetails","seen","updateSeen","details","toGrid","colgroupCols","rowCells","rowDetail","fromWarehouse","toDetailList","findInWarehouse","extractCells","cell$1","lc","run","operation","extract","adjustment","postAction","genWrappers","behaviours","tableSection","model","out","newElements","tableSizing","resizing","onPaste","onPasteByEditor","onMergable","_warehouse","onUnmergable","onCells","onUnlockedCells","isUnlockedTableCell","allUnlocked","onUnlockedMergable","mergeable","onUnlockedUnmergable","merge$2","unmerge","currentCell","currentCellElm","isToReplace","uniqueCells","splitCols","prevCell","substitute","splitRows","rowPrevCells","sub","value$1","applyHelper","constHelper","outputHelper","output","_onError","onValue","Result","error","onError","_onValue","optional","err","measure","startAddress","gridA","gridB","rowRemainder","colRemainder","colRequired","rowRequired","measureWidth","colLengthA","colLengthB","measureHeight","rowLengthA","rowLengthB","generateElements","generator","rowFill","exampleRow","colFill","newChildren","lockedColFill","colNum","newChild","tailor","fillCols","fillRows","gridWidth","isLastColLocked","modifiedCols","newLockedColumns","isSpanning","matching","mergeTables","gridBRows","mergeHeight","mergeWidth","lockedColumnObj","skippedCol","gridBColIndex","newCellElm","getValidStartAddress","currentStartAddress","gridColLength","adjustedRowAddress","possibleColAddresses","validColAddress","getLockedColumnsWithinBounds","merge$1","validStartAddress","lockedColumnsWithinBounds","fittedGrid","newLockedColumnsWithinBounds","insertCols","fittedNewGrid","secondDelta","fittedOldGrid","insertRows","oldCols","oldRows","newLocked","secondDiff","fittedGridB","insertRowAt","example","newRow","ex","getElementFor","withinSpan","insertColumnAt","deleteColumnsAt","deleteRowsAt","notInStartRow","notInStartColumn","isDuplicatedCell","rowReplacerPredicate","targetRow","columnHeaders","_rowIndex","columnReplacePredicate","targetColumn","rowHeaders","_colIndex","determineScope","applyScope","newScope","isInHeader","getScope","rowScopeGenerator","columnScopeGenerator","replace","replaceIn","replacer","genScope","shouldReplace","isTarget","getColumnCells","getRowCells","replaceColumns","indexes","shouldReplaceCell","scopeGenerator","replaceRows","newGrid","replaceCells","targetCells","Adt","cases","constructors","adt","acase","count","keys$1","argLength","foldArgs","branches","branchKeys","reqKey","label","ColumnContext","neighbours","determine","resize","context","onOnly","onLeft","onMiddle","onRight","measures","recalculateWidthForCells","widths","recalculateWidthForColumns","groups","recalculateHeightForCells","heights","matchRowHeight","sumUp","recalculate","recalculateAndApply","adjustWidth","clampedStep","deltas","newWidths","dx","adjustHeight","newHeights","dy","newCellSizes","newRowSizes","adjustAndRedistributeWidths$1","_table","resizeBehaviour","tablePixelWidth","adjustWidthTo","_info","uniqueColumns","currentDetail","isCol","isColgroup","isRow$1","elementToData","modification","toData","nuCell","data","nuRow","add","recent","transform$1","makeNew","getScopeAttribute","Generators","getScopeProperty","stringAttributes","baseScope","scopes","blockList","isList$1","tagName","isBlock$1","isEmptyTag$1","universe$1","isBlock","isList","merge","isBr","advancedBr","isListItem","siblingIsBlock","rightSibling","markCell","rightSiblingIsBlock","contents","isEditable","outcome","cursor","findEditableCursorPosition","elementFromGrid","_b","bundle","cursorElement","uniqueRows","opInsertRowsBefore","targetIndex","opInsertRowsAfter","newG","opInsertColumnsBefore","extractDetail","opInsertColumnsAfter","opMakeColumnsHeader","initialGrid","columnIndexes","opMakeCellsHeader","opUnmakeColumnsHeader","opUnmakeCellsHeader","makeRowsSection","rowIndexes","opMakeRowsHeader","opMakeRowsBody","opMakeRowsFooter","opEraseColumns","_comparator","_genWrappers","maxColIndex","opEraseRows","maxRowIndex","opMergeCells","opUnmergeCells","opPasteCells","pasteDetails","wh","gridifyRows","opPasteColsBefore","mergedGrid","opPasteColsAfter","opPasteRowsBefore","opPasteRowsAfter","opGetColumnsType","lastSelectedCell","minColRange","maxColRange","selectedColumnCells","opGetCellsType","opGetRowsType","minRowRange","maxRowRange","selectedRows","adjustAndRedistributeWidths","firstColumnIsLocked","lastColumnIsLocked","getColumnsWidth","uniqueCols","colWidth","insertColumnsExtractor","eraseColumnsExtractor","pasteColumnsExtractor","headerCellGenerator","bodyCellGenerator","insertRowsBefore","insertRowsAfter","insertColumnsBefore","insertColumnsAfter","eraseColumns","eraseRows","makeColumnsHeader","unmakeColumnsHeader","makeRowsHeader","makeRowsBody","makeRowsFooter","makeCellsHeader","unmakeCellsHeader","mergeCells","unmergeCells","pasteCells","pasteColsBefore","pasteColsAfter","pasteRowsBefore","pasteRowsAfter","getColumnsType","getCellsType","getRowsType","fireNewRow","fireNewCell","fireTableModified","fireTableSelectionChange","otherCells","fireTableSelectionClear","fireObjectResizeStart","origin","fireObjectResized","styleModified","structureModified","styleAndStructureModified","get$5","TableActions","resizeHandler","cellSelectionHandler","isTableBody","lastRowGuard","lastColumnGuard","colMutationOp","getTableSectionType","setSelectionFromAction","firstCell","rng","des","execute","guard","effect","noEvents","range","deleteRow","deleteColumn","insertRowsBefore$1","insertRowsAfter$1","insertColumnsBefore$1","insertColumnsAfter$1","mergeCells$1","unmergeCells$1","pasteColsBefore$1","pasteColsAfter$1","pasteRowsBefore$1","pasteRowsAfter$1","pasteCells$1","makeCellsHeader$1","unmakeCellsHeader$1","makeColumnsHeader$1","unmakeColumnsHeader$1","makeRowsHeader$1","makeRowsBody$1","makeRowsFooter$1","constrainSpan","currentColspan","isColInRange","generateColGroup","colsToCopy","copiedCols","clonedCol","fakeColgroup","generateRows","cellsToCopy","copiedCells","fakeTR","copyCols","fakeColGroups","fakeRows","copyRows","slicedGrid","filteredGrid","slicedDetails","adt$5","validateFor","rawAmount","Size","redistributeToPercent","pc","redistributeToPx","newTotalWidth","scale","redistributeEmpty","newWidthType","pixels","redistributeValues","_pc","redistribute$1","newType","floats","normalize","sum","roundDown","floored","add$3","scan","validate","redistributeToW","redistributeToColumns","redistributeToH","getUnit","redistribute","optWidth","optHeight","widthUnit","oldWidths","nuWidths","newHeight","hUnit","totalHeight","oldHeights","nuHeights","isPercentSizing","isPixelSizing","isNoneSizing","cleanupLegacyAttributes","convertToPercentSize","convertToPixelSize","convertToNoneSize","rowElements","DefaultRenderOptions","tableHeaderCell","tableCell","tableColumn","createRow","createGroupRow","createRows","render","headerType","renderOpts","rowHeadersGoInThead","actualRowHeaders","thead","theadRows","tbody","numRows","tbodyRows","get$4","placeCaretInCell","selectFirstCellInTable","tableElm","fireEvents","isPercentage","insert","colHeaders","insertTable","checkInput","headerRows","headerColumns","global","tableTypeBase","tableTypeRow","tableTypeColumn","setData","items","fakeClipboardItem","getData","clearData","setRows","rowsOpt","clearRows","getRows","setColumns","columnsOpt","clearColumns","getColumns","getSelectionStartCellOrCaption","getSelectionStartCell","registerCommands","eraseTable","cellOrCaption","setSizingMode","sizing","getTableFromCell","performActionOnSelection","action","toggleTableClass","_ui","clazz","toggleTableCellClass","formatterAction","toggleCaption","caption","postExecute","_data","actOnSelection","copyRowSelection","copyColSelection","pasteOnSelection","clonedRows","actOnType","getAction","func","getFormatName","style","validArgs","formatName","registerQueryCommands","lookupOnSelection","adt$4","cata$1","subject","onBefore","onOn","onAfter","getStart$1","situ","before$2","on","after$3","Situ","Response","kill","selectNode","selectNodeContents","selectNodeContentsUsing","setStart","setFinish","relativeToNative","startSitu","finishSitu","exactToNative","soffset","foffset","toRect","rect","getFirstRect$1","rects","adt$3","fromRange","getRanges","doDiagnose","ranges","rev","diagnose","asLtrRange","SimRange","Situs","convertToRange","makeSitus","sync","selectRange","detect","cellSel","update","selected","annotations","updateSelection","newSels","traverse","mode","backtrack","_direction","transition","sidestep","advance","successors","go","rules","succ","rule","Walkers","hone","right","isLeaf","before$1","seekLeft$1","after$2","seekRight$1","after$1","seekLeft","seekRight","adt$2","isOverlapping","bridge","beforeBounds","afterBounds","isRow","BeforeAfter","beforeOffset","afterOffset","failure","afterCell","beforeCell","_sharedRow","onSuccess","onFailedUp","onFailedDown","inParent","indexInParent","indexOf","gatherer","cand","gather","handleBr","findBr","handleParent","br","adjacent","tryBr","tgt","process","analysis","_message","moveDown","caret","moveUp","translate","xDelta","yDelta","getTop","getBottom","getPartialBox","toCaret","getElemBox","getBoxAt","getEntireBox","JUMP_SIZE","NUM_RETRIES","adt$1","isOutside","inOutsideBlock","adjustDown","guessBox","lowerCaret","upMovement","higherCaret","downMovement","isAtTable","adjustForTable","movement","numRetries","adjustTil","guess","newCaret","checkScroll","adjusted","retry","moved","Retries","MAX_RETRIES","findSpot","sel","brNeighbour","tryCursor","situs","tryAgain","move","tryAt","handle$1","spot","inSameTable","simulate","initial","anchor","navigate","precheck","firstUpCheck","lastOffset","lastDownCheck","select","Cell","singleton","doRevoke","revoke","findCell","isInEditableContext","MouseSelection","clearstate","applySelection","singleCell","isNonEditableCell","isCellClosestContentEditable","down","up","isKey","keycode","isUp","isDown","isNavigation","ltr","rtl","get$3","_DOC","by","exactFromRange","simRange","getStart","_finishSitu","_soffset","_finish","_foffset","domRange","relative","exact","getWin","SimSelection","caretPositionFromPoint","caretRangeFromPoint","availableSearch","fromPoint","beforeSpecial","name$1","preprocessRelative","preprocessExact","makeRange","same","getNativeSelection","doSetNativeRange","doSetRange","setLegacyRtlRange","setRangeFromRelative","setExact","setRelative","readRange","firstRng","lastRng","doGetExact","focus","setToElement","selectNodeContents$1","getExact","get$2","getFirstRect","getAtPoint","clear","WindowBridge","exactAdt","toStart","rc","mouse","handlers","isEditableNode","isEditableSelection","keyboard","clearToNavigate","realEvent","shiftKey","update$1","attempts","_","external","read","add$2","id","remove$4","supports","get$1","add$1","remove$3","cleanClass","remove$2","has","remove$1","classes","addClass","removeClasses","SelectionAnnotation","addSelectionClass","removeSelectionClasses","onSelection","onClear","removeSelectionAttributes","addSelectionAttribute","clearBeforeUpdate","fold","onMultiple","onSingle","none","multiple","single","Selections","lazyRoot","getUpOrLeftCells","upGrid","upDetails","slicedCells","getDownOrRightCells","downGrid","downDetails","getOtherCells","upOrLeftCells","downOrRightCells","mkEvent","prevent","fromRawEvent$1","rawEvent","handle","handler","useCapture","wrapped","unbind","bind$1","bind","fromRawEvent","hasInternalTarget","TableCellSelectionHandler","cellSelection","_e","syncSelection","mouseHandlers","keyHandlers","external$1","hasShiftKey","handleResponse","response","ns","keyup","wrappedEvent","keydown","isLeftMouse","isLeftButtonPressed","dragStart","mouseDown","mouseOver","mouseUp","doubleTap","lastTarget","lastTimeStamp","lT","lTS","Event","fields","create$1","typeDefs","registry","trigger","rate","timer","cancel","sort","reqMessage","required","unsuppMessage","unsupported","validateStrArr","invalidTypeMessage","incorrect","checkDupes","everything","sorted","handleUnsupported","baseWith","req","invalidKeys","handleExact","exactly","DragMode","DragSink","DragApi","InDrag","previous","reset","old","onEvent","events","NoDrag","Movement","noDragState","inDragState","dragState","setup","mutation","settings","active","drop","sink","throttledDrop","mousemove","off","isActive","runIfActive","destroy","namespace","dashNamespace","resolve","resolve$1","Blocker","MouseDrag","dragApi","blocker","mdown","mup","mmove","mout","transform","Mutation","BarMutation","delegate","bar","resizeBar","resizeRowBar","resizeColBar","BAR_THICKNESS","resizableRows","isResizable","resizableColumns","resizableCols","wire","drawBar","positions","create","cpOption","cp","refreshCol","colPositions","position","tableHeight","colBar","refreshRow","rowPositions","tableWidth","rowBar","refreshGrid","warhouse","resizableRowBars","resizableRowPositions","_pos","barIndex","resizableColBars","resizableColPositions","refresh","each","bars","hide","show","isRowBar","isColBar","resizeBarDragging","BarManager","hoverTable","getResizer","_dataRow","_dataCol","currentCol","getDelta","dir","newX","oldX","mousedown","findClosestEditableTable","mouseover","destroy$1","refresh$1","tbl","TableResize","lazySizing","hdirection","vdirection","manager","_event","ResizeWire","chrome","createContainer","remove","barResizerPrefix","syncPixels","computedWidth","TableResizeHandler","selectionRng","tableResize","resizeWire","startW","startRawW","lazyResizingBehaviour","getNumColumns","afterCornerResize","isRightEdgeResize","percentW","targetPercentW","sz","rawWire","rawTable","targetElm","setupTable","DomModel","Model"],"mappings":"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","x_google_ignoreList":[0]}