{"version":3,"file":"model-CbmpUU9W.js","sources":["../node_modules/.pnpm/tinymce@6.8.6/node_modules/tinymce/models/dom/model.js"],"sourcesContent":["/**\n * TinyMCE version 6.8.6 (TBD)\n */\n\n(function () {\n    'use strict';\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.ModelManager');\n\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$2 = t => a => t === a;\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isArray = isType$1('array');\n    const isNull = eq$2(null);\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$2(undefined);\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    const noop = () => {\n    };\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply = f => {\n      return f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const range$1 = (num, f) => {\n      const r = [];\n      for (let i = 0; i < num; i++) {\n        r.push(f(i));\n      }\n      return r;\n    };\n    const map$1 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$2 = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$2 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$2(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$1 = (xs, pred) => {\n      return findUntil(xs, pred, never);\n    };\n    const findIndex = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$2 = (xs, f) => flatten(map$1(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const sort$1 = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$d = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$d(xs, 0);\n    const last$2 = xs => get$d(xs, xs.length - 1);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty = Object.hasOwnProperty;\n    const each$1 = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each$1(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each$1(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const filter$1 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each$1(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$c = (obj, key) => {\n      return has$1(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$1 = (obj, key) => hasOwnProperty.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$1(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const isEmpty = r => {\n      for (const x in r) {\n        if (hasOwnProperty.call(r, x)) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const path = (parts, scope) => {\n      let o = scope !== undefined && scope !== null ? scope : Global;\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n        o = o[parts[i]];\n      }\n      return o;\n    };\n    const resolve$2 = (p, scope) => {\n      const parts = p.split('.');\n      return path(parts, scope);\n    };\n\n    const unsafe = (name, scope) => {\n      return resolve$2(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n      const actual = unsafe(name, scope);\n      if (actual === undefined || actual === null) {\n        throw new Error(name + ' not available on this browser');\n      }\n      return actual;\n    };\n\n    const getPrototypeOf = Object.getPrototypeOf;\n    const sandHTMLElement = scope => {\n      return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = x => {\n      const scope = resolve$2('ownerDocument.defaultView', x);\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf(x).constructor.name));\n    };\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type = element => element.dom.nodeType;\n    const isType = t => element => type(element) === t;\n    const isComment = element => type(element) === COMMENT || name(element) === '#comment';\n    const isHTMLElement = element => isElement(element) && isPrototypeOf(element.dom);\n    const isElement = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocument = isType(DOCUMENT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement(e) && name(e) === tag;\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$2 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each$1(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const setOptions = (element, attrs) => {\n      each$1(attrs, (v, k) => {\n        v.fold(() => {\n          remove$7(element, k);\n        }, value => {\n          rawSet(element.dom, k, value);\n        });\n      });\n    };\n    const get$b = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$b(element, key));\n    const remove$7 = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const clone$2 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$1(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$1(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$1(node);\n    };\n    const fromDom$1 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint$1 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);\n    const SugarElement = {\n      fromHtml: fromHtml$1,\n      fromTag,\n      fromText,\n      fromDom: fromDom$1,\n      fromPoint: fromPoint$1\n    };\n\n    const is$2 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all$1 = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$1(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq$1 = (e1, e2) => e1.dom === e2.dom;\n    const contains$1 = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n    const is$1 = is$2;\n\n    const owner = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument(dos) ? dos : owner(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const children$2 = element => map$1(element.dom.childNodes, SugarElement.fromDom);\n    const child$2 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$2(element, 0);\n\n    const before$3 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$5 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const appendAt = (parent, element, index) => {\n      child$2(parent, index).fold(() => {\n        append$1(parent, element);\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const wrap = (element, wrapper) => {\n      before$3(element, wrapper);\n      append$1(wrapper, element);\n    };\n\n    const after$4 = (marker, elements) => {\n      each$2(elements, (x, i) => {\n        const e = i === 0 ? marker : elements[i - 1];\n        after$5(e, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$2(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$2(children$2(element), rogue => {\n        remove$6(rogue);\n      });\n    };\n    const remove$6 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n    const unwrap = wrapper => {\n      const children = children$2(wrapper);\n      if (children.length > 0) {\n        after$4(wrapper, children);\n      }\n      remove$6(wrapper);\n    };\n\n    const clone$1 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow = original => clone$1(original, false);\n    const deep = original => clone$1(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$2(original);\n      setAll$1(nu, attributes);\n      return nu;\n    };\n    const copy$2 = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      const cloneChildren = children$2(deep(original));\n      append(nu, cloneChildren);\n      return nu;\n    };\n    const mutate$1 = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after$5(original, nu);\n      const children = children$2(original);\n      append(nu, children);\n      remove$6(original);\n      return nu;\n    };\n\n    const validSectionList = [\n      'tfoot',\n      'thead',\n      'tbody',\n      'colgroup'\n    ];\n    const isValidSection = parentName => contains$2(validSectionList, parentName);\n    const grid = (rows, columns) => ({\n      rows,\n      columns\n    });\n    const address = (row, column) => ({\n      row,\n      column\n    });\n    const detail = (element, rowspan, colspan) => ({\n      element,\n      rowspan,\n      colspan\n    });\n    const detailnew = (element, rowspan, colspan, isNew) => ({\n      element,\n      rowspan,\n      colspan,\n      isNew\n    });\n    const extended = (element, rowspan, colspan, row, column, isLocked) => ({\n      element,\n      rowspan,\n      colspan,\n      row,\n      column,\n      isLocked\n    });\n    const rowdetail = (element, cells, section) => ({\n      element,\n      cells,\n      section\n    });\n    const rowdetailnew = (element, cells, section, isNew) => ({\n      element,\n      cells,\n      section,\n      isNew\n    });\n    const elementnew = (element, isNew, isLocked) => ({\n      element,\n      isNew,\n      isLocked\n    });\n    const rowcells = (element, cells, section, isNew) => ({\n      element,\n      cells,\n      section,\n      isNew\n    });\n    const bounds = (startRow, startCol, finishRow, finishCol) => ({\n      startRow,\n      startCol,\n      finishRow,\n      finishCol\n    });\n    const columnext = (element, colspan, column) => ({\n      element,\n      colspan,\n      column\n    });\n    const colgroup = (element, columns) => ({\n      element,\n      columns\n    });\n\n    const isShadowRoot = dos => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const isSupported$1 = constant(supported);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isSupported$1() && isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n    const body$1 = () => getBody$1(SugarElement.fromDom(document));\n    const getBody$1 = doc => {\n      const b = doc.dom.body;\n      if (b === null || b === undefined) {\n        throw new Error('Body is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const ancestors$4 = (scope, predicate, isRoot) => filter$2(parents(scope, isRoot), predicate);\n    const children$1 = (scope, predicate) => filter$2(children$2(scope), predicate);\n    const descendants$1 = (scope, predicate) => {\n      let result = [];\n      each$2(children$2(scope), x => {\n        if (predicate(x)) {\n          result = result.concat([x]);\n        }\n        result = result.concat(descendants$1(x, predicate));\n      });\n      return result;\n    };\n\n    const ancestors$3 = (scope, selector, isRoot) => ancestors$4(scope, e => is$2(e, selector), isRoot);\n    const children = (scope, selector) => children$1(scope, e => is$2(e, selector));\n    const descendants = (scope, selector) => all$1(selector, scope);\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$2 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$2 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$2, scope, predicate, isRoot);\n    };\n    const child$1 = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$1(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$1 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const ancestor$1 = (scope, selector, isRoot) => ancestor$2(scope, e => is$2(e, selector), isRoot);\n    const child = (scope, selector) => child$1(scope, e => is$2(e, selector));\n    const descendant = (scope, selector) => one(selector, scope);\n    const closest$1 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$2(element, selector);\n      return ClosestOrAncestor(is, ancestor$1, scope, selector, isRoot);\n    };\n\n    const is = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const bindFrom = (a, f) => a !== undefined && a !== null ? f(a) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const contains = (str, substr, start = 0, end) => {\n      const idx = str.indexOf(substr, start);\n      if (idx !== -1) {\n        return isUndefined(end) ? true : idx + substr.length <= end;\n      } else {\n        return false;\n      }\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim = blank(/^\\s+|\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const toFloat = value => {\n      const num = parseFloat(value);\n      return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$1 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each$1(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const get$a = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw$2 = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const remove$5 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is(getOpt(element, 'style').map(trim), '')) {\n        remove$7(element, 'style');\n      }\n    };\n    const copy$1 = (source, target) => {\n      const sourceDom = source.dom;\n      const targetDom = target.dom;\n      if (isSupported(sourceDom) && isSupported(targetDom)) {\n        targetDom.style.cssText = sourceDom.style.cssText;\n      }\n    };\n\n    const getAttrValue = (cell, name, fallback = 0) => getOpt(cell, name).map(value => parseInt(value, 10)).getOr(fallback);\n    const getSpan = (cell, type) => getAttrValue(cell, type, 1);\n    const hasColspan = cellOrCol => {\n      if (isTag('col')(cellOrCol)) {\n        return getAttrValue(cellOrCol, 'span', 1) > 1;\n      } else {\n        return getSpan(cellOrCol, 'colspan') > 1;\n      }\n    };\n    const hasRowspan = cell => getSpan(cell, 'rowspan') > 1;\n    const getCssValue = (element, property) => parseInt(get$a(element, property), 10);\n    const minWidth = constant(10);\n    const minHeight = constant(10);\n\n    const firstLayer = (scope, selector) => {\n      return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n      return bind$2(children$2(scope), x => {\n        if (is$2(x, selector)) {\n          return predicate(x) ? [x] : [];\n        } else {\n          return filterFirstLayer(x, selector, predicate);\n        }\n      });\n    };\n\n    const lookup = (tags, element, isRoot = never) => {\n      if (isRoot(element)) {\n        return Optional.none();\n      }\n      if (contains$2(tags, name(element))) {\n        return Optional.some(element);\n      }\n      const isRootOrUpperTable = elm => is$2(elm, 'table') || isRoot(elm);\n      return ancestor$1(element, tags.join(','), isRootOrUpperTable);\n    };\n    const cell = (element, isRoot) => lookup([\n      'td',\n      'th'\n    ], element, isRoot);\n    const cells$1 = ancestor => firstLayer(ancestor, 'th,td');\n    const columns$1 = ancestor => {\n      if (is$2(ancestor, 'colgroup')) {\n        return children(ancestor, 'col');\n      } else {\n        return bind$2(columnGroups(ancestor), columnGroup => children(columnGroup, 'col'));\n      }\n    };\n    const table = (element, isRoot) => closest$1(element, 'table', isRoot);\n    const rows$1 = ancestor => firstLayer(ancestor, 'tr');\n    const columnGroups = ancestor => table(ancestor).fold(constant([]), table => children(table, 'colgroup'));\n\n    const fromRowsOrColGroups = (elems, getSection) => map$1(elems, row => {\n      if (name(row) === 'colgroup') {\n        const cells = map$1(columns$1(row), column => {\n          const colspan = getAttrValue(column, 'span', 1);\n          return detail(column, 1, colspan);\n        });\n        return rowdetail(row, cells, 'colgroup');\n      } else {\n        const cells = map$1(cells$1(row), cell => {\n          const rowspan = getAttrValue(cell, 'rowspan', 1);\n          const colspan = getAttrValue(cell, 'colspan', 1);\n          return detail(cell, rowspan, colspan);\n        });\n        return rowdetail(row, cells, getSection(row));\n      }\n    });\n    const getParentSection = group => parent(group).map(parent => {\n      const parentName = name(parent);\n      return isValidSection(parentName) ? parentName : 'tbody';\n    }).getOr('tbody');\n    const fromTable$1 = table => {\n      const rows = rows$1(table);\n      const columnGroups$1 = columnGroups(table);\n      const elems = [\n        ...columnGroups$1,\n        ...rows\n      ];\n      return fromRowsOrColGroups(elems, getParentSection);\n    };\n    const fromPastedRows = (elems, section) => fromRowsOrColGroups(elems, () => section);\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant(isiPad),\n        isiPhone: constant(isiPhone),\n        isTablet: constant(isTablet),\n        isPhone: constant(isPhone),\n        isTouch: constant(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant(iOSwebview),\n        isDesktop: constant(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$2(group(1), group(2));\n    };\n    const detect$5 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$2();\n      }\n      return find(versionRegexes, cleanedAgent);\n    };\n    const unknown$2 = () => {\n      return nu$2(0, 0);\n    };\n    const nu$2 = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$2,\n      detect: detect$5,\n      unknown: unknown$2\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$1(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$4 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$1(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$4(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$4(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains(uastring, 'edge/') && contains(uastring, 'chrome') && contains(uastring, 'safari') && contains(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains(uastring, 'chrome') && !contains(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains(uastring, 'msie') || contains(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains(uastring, 'safari') || contains(uastring, 'mobile/')) && contains(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains(uastring, 'iphone') || contains(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant(browsers),\n      oses: constant(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$1 = () => {\n      return nu$1({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$1 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$1,\n      nu: nu$1,\n      edge: constant(edge),\n      chromium: constant(chromium),\n      ie: constant(ie),\n      opera: constant(opera),\n      firefox: constant(firefox),\n      safari: constant(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown = () => {\n      return nu({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown,\n      nu,\n      windows: constant(windows),\n      ios: constant(ios),\n      android: constant(android),\n      linux: constant(linux),\n      macos: constant(macos),\n      solaris: constant(solaris),\n      freebsd: constant(freebsd),\n      chromeos: constant(chromeos)\n    };\n\n    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$3 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n    const detect$2 = () => platform();\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$a(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$a(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const toNumber = (px, fallback) => toFloat(px).getOr(fallback);\n    const getProp = (element, name, fallback) => toNumber(get$a(element, name), fallback);\n    const calcContentBoxSize = (element, size, upper, lower) => {\n      const paddingUpper = getProp(element, `padding-${ upper }`, 0);\n      const paddingLower = getProp(element, `padding-${ lower }`, 0);\n      const borderUpper = getProp(element, `border-${ upper }-width`, 0);\n      const borderLower = getProp(element, `border-${ lower }-width`, 0);\n      return size - paddingUpper - paddingLower - borderUpper - borderLower;\n    };\n    const getCalculatedWidth = (element, boxSizing) => {\n      const dom = element.dom;\n      const width = dom.getBoundingClientRect().width || dom.offsetWidth;\n      return boxSizing === 'border-box' ? width : calcContentBoxSize(element, width, 'left', 'right');\n    };\n    const getHeight$1 = element => getProp(element, 'height', element.dom.offsetHeight);\n    const getWidth = element => getProp(element, 'width', element.dom.offsetWidth);\n    const getInnerWidth = element => getCalculatedWidth(element, 'content-box');\n\n    const api$2 = Dimension('width', element => element.dom.offsetWidth);\n    const get$9 = element => api$2.get(element);\n    const getOuter$2 = element => api$2.getOuter(element);\n    const getInner = getInnerWidth;\n    const getRuntime$1 = getWidth;\n\n    const addCells = (gridRow, index, cells) => {\n      const existingCells = gridRow.cells;\n      const before = existingCells.slice(0, index);\n      const after = existingCells.slice(index);\n      const newCells = before.concat(cells).concat(after);\n      return setCells(gridRow, newCells);\n    };\n    const addCell = (gridRow, index, cell) => addCells(gridRow, index, [cell]);\n    const mutateCell = (gridRow, index, cell) => {\n      const cells = gridRow.cells;\n      cells[index] = cell;\n    };\n    const setCells = (gridRow, cells) => rowcells(gridRow.element, cells, gridRow.section, gridRow.isNew);\n    const mapCells = (gridRow, f) => {\n      const cells = gridRow.cells;\n      const r = map$1(cells, f);\n      return rowcells(gridRow.element, r, gridRow.section, gridRow.isNew);\n    };\n    const getCell = (gridRow, index) => gridRow.cells[index];\n    const getCellElement = (gridRow, index) => getCell(gridRow, index).element;\n    const cellLength = gridRow => gridRow.cells.length;\n    const extractGridDetails = grid => {\n      const result = partition(grid, row => row.section === 'colgroup');\n      return {\n        rows: result.fail,\n        cols: result.pass\n      };\n    };\n    const clone = (gridRow, cloneRow, cloneCell) => {\n      const newCells = map$1(gridRow.cells, cloneCell);\n      return rowcells(cloneRow(gridRow.element), newCells, gridRow.section, true);\n    };\n\n    const LOCKED_COL_ATTR = 'data-snooker-locked-cols';\n    const getLockedColumnsFromTable = table => getOpt(table, LOCKED_COL_ATTR).bind(lockedColStr => Optional.from(lockedColStr.match(/\\d+/g))).map(lockedCols => mapToObject(lockedCols, always));\n    const getLockedColumnsFromGrid = grid => {\n      const locked = foldl(extractGridDetails(grid).rows, (acc, row) => {\n        each$2(row.cells, (cell, idx) => {\n          if (cell.isLocked) {\n            acc[idx] = true;\n          }\n        });\n        return acc;\n      }, {});\n      const lockedArr = mapToArray(locked, (_val, key) => parseInt(key, 10));\n      return sort$1(lockedArr);\n    };\n\n    const key = (row, column) => {\n      return row + ',' + column;\n    };\n    const getAt = (warehouse, row, column) => Optional.from(warehouse.access[key(row, column)]);\n    const findItem = (warehouse, item, comparator) => {\n      const filtered = filterItems(warehouse, detail => {\n        return comparator(item, detail.element);\n      });\n      return filtered.length > 0 ? Optional.some(filtered[0]) : Optional.none();\n    };\n    const filterItems = (warehouse, predicate) => {\n      const all = bind$2(warehouse.all, r => {\n        return r.cells;\n      });\n      return filter$2(all, predicate);\n    };\n    const generateColumns = rowData => {\n      const columnsGroup = {};\n      let index = 0;\n      each$2(rowData.cells, column => {\n        const colspan = column.colspan;\n        range$1(colspan, columnIndex => {\n          const colIndex = index + columnIndex;\n          columnsGroup[colIndex] = columnext(column.element, colspan, colIndex);\n        });\n        index += colspan;\n      });\n      return columnsGroup;\n    };\n    const generate$1 = list => {\n      const access = {};\n      const cells = [];\n      const tableOpt = head(list).map(rowData => rowData.element).bind(table);\n      const lockedColumns = tableOpt.bind(getLockedColumnsFromTable).getOr({});\n      let maxRows = 0;\n      let maxColumns = 0;\n      let rowCount = 0;\n      const {\n        pass: colgroupRows,\n        fail: rows\n      } = partition(list, rowData => rowData.section === 'colgroup');\n      each$2(rows, rowData => {\n        const currentRow = [];\n        each$2(rowData.cells, rowCell => {\n          let start = 0;\n          while (access[key(rowCount, start)] !== undefined) {\n            start++;\n          }\n          const isLocked = hasNonNullableKey(lockedColumns, start.toString());\n          const current = extended(rowCell.element, rowCell.rowspan, rowCell.colspan, rowCount, start, isLocked);\n          for (let occupiedColumnPosition = 0; occupiedColumnPosition < rowCell.colspan; occupiedColumnPosition++) {\n            for (let occupiedRowPosition = 0; occupiedRowPosition < rowCell.rowspan; occupiedRowPosition++) {\n              const rowPosition = rowCount + occupiedRowPosition;\n              const columnPosition = start + occupiedColumnPosition;\n              const newpos = key(rowPosition, columnPosition);\n              access[newpos] = current;\n              maxColumns = Math.max(maxColumns, columnPosition + 1);\n            }\n          }\n          currentRow.push(current);\n        });\n        maxRows++;\n        cells.push(rowdetail(rowData.element, currentRow, rowData.section));\n        rowCount++;\n      });\n      const {columns, colgroups} = last$2(colgroupRows).map(rowData => {\n        const columns = generateColumns(rowData);\n        const colgroup$1 = colgroup(rowData.element, values(columns));\n        return {\n          colgroups: [colgroup$1],\n          columns\n        };\n      }).getOrThunk(() => ({\n        colgroups: [],\n        columns: {}\n      }));\n      const grid$1 = grid(maxRows, maxColumns);\n      return {\n        grid: grid$1,\n        access,\n        all: cells,\n        columns,\n        colgroups\n      };\n    };\n    const fromTable = table => {\n      const list = fromTable$1(table);\n      return generate$1(list);\n    };\n    const justCells = warehouse => bind$2(warehouse.all, w => w.cells);\n    const justColumns = warehouse => values(warehouse.columns);\n    const hasColumns = warehouse => keys(warehouse.columns).length > 0;\n    const getColumnAt = (warehouse, columnIndex) => Optional.from(warehouse.columns[columnIndex]);\n    const Warehouse = {\n      fromTable,\n      generate: generate$1,\n      getAt,\n      findItem,\n      filterItems,\n      justCells,\n      justColumns,\n      hasColumns,\n      getColumnAt\n    };\n\n    const columns = (warehouse, isValidCell = always) => {\n      const grid = warehouse.grid;\n      const cols = range$1(grid.columns, identity);\n      const rowsArr = range$1(grid.rows, identity);\n      return map$1(cols, col => {\n        const getBlock = () => bind$2(rowsArr, r => Warehouse.getAt(warehouse, r, col).filter(detail => detail.column === col).toArray());\n        const isValid = detail => detail.colspan === 1 && isValidCell(detail.element);\n        const getFallback = () => Warehouse.getAt(warehouse, 0, col);\n        return decide(getBlock, isValid, getFallback);\n      });\n    };\n    const decide = (getBlock, isValid, getFallback) => {\n      const inBlock = getBlock();\n      const validInBlock = find$1(inBlock, isValid);\n      const detailOption = validInBlock.orThunk(() => Optional.from(inBlock[0]).orThunk(getFallback));\n      return detailOption.map(detail => detail.element);\n    };\n    const rows = warehouse => {\n      const grid = warehouse.grid;\n      const rowsArr = range$1(grid.rows, identity);\n      const cols = range$1(grid.columns, identity);\n      return map$1(rowsArr, row => {\n        const getBlock = () => bind$2(cols, c => Warehouse.getAt(warehouse, row, c).filter(detail => detail.row === row).fold(constant([]), detail => [detail]));\n        const isSingle = detail => detail.rowspan === 1;\n        const getFallback = () => Warehouse.getAt(warehouse, row, 0);\n        return decide(getBlock, isSingle, getFallback);\n      });\n    };\n\n    const deduce = (xs, index) => {\n      if (index < 0 || index >= xs.length - 1) {\n        return Optional.none();\n      }\n      const current = xs[index].fold(() => {\n        const rest = reverse(xs.slice(0, index));\n        return findMap(rest, (a, i) => a.map(aa => ({\n          value: aa,\n          delta: i + 1\n        })));\n      }, c => Optional.some({\n        value: c,\n        delta: 0\n      }));\n      const next = xs[index + 1].fold(() => {\n        const rest = xs.slice(index + 1);\n        return findMap(rest, (a, i) => a.map(aa => ({\n          value: aa,\n          delta: i + 1\n        })));\n      }, n => Optional.some({\n        value: n,\n        delta: 1\n      }));\n      return current.bind(c => next.map(n => {\n        const extras = n.delta + c.delta;\n        return Math.abs(n.value - c.value) / extras;\n      }));\n    };\n\n    const onDirection = (isLtr, isRtl) => element => getDirection(element) === 'rtl' ? isRtl : isLtr;\n    const getDirection = element => get$a(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';\n\n    const api$1 = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$8 = element => api$1.get(element);\n    const getOuter$1 = element => api$1.getOuter(element);\n    const getRuntime = getHeight$1;\n\n    const r = (left, top) => {\n      const translate = (x, y) => r(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const rowInfo = (row, y) => ({\n      row,\n      y\n    });\n    const colInfo = (col, x) => ({\n      col,\n      x\n    });\n    const rtlEdge = cell => {\n      const pos = absolute(cell);\n      return pos.left + getOuter$2(cell);\n    };\n    const ltrEdge = cell => {\n      return absolute(cell).left;\n    };\n    const getLeftEdge = (index, cell) => {\n      return colInfo(index, ltrEdge(cell));\n    };\n    const getRightEdge = (index, cell) => {\n      return colInfo(index, rtlEdge(cell));\n    };\n    const getTop$1 = cell => {\n      return absolute(cell).top;\n    };\n    const getTopEdge = (index, cell) => {\n      return rowInfo(index, getTop$1(cell));\n    };\n    const getBottomEdge = (index, cell) => {\n      return rowInfo(index, getTop$1(cell) + getOuter$1(cell));\n    };\n    const findPositions = (getInnerEdge, getOuterEdge, array) => {\n      if (array.length === 0) {\n        return [];\n      }\n      const lines = map$1(array.slice(1), (cellOption, index) => {\n        return cellOption.map(cell => {\n          return getInnerEdge(index, cell);\n        });\n      });\n      const lastLine = array[array.length - 1].map(cell => {\n        return getOuterEdge(array.length - 1, cell);\n      });\n      return lines.concat([lastLine]);\n    };\n    const negate = step => {\n      return -step;\n    };\n    const height = {\n      delta: identity,\n      positions: optElements => findPositions(getTopEdge, getBottomEdge, optElements),\n      edge: getTop$1\n    };\n    const ltr$1 = {\n      delta: identity,\n      edge: ltrEdge,\n      positions: optElements => findPositions(getLeftEdge, getRightEdge, optElements)\n    };\n    const rtl$1 = {\n      delta: negate,\n      edge: rtlEdge,\n      positions: optElements => findPositions(getRightEdge, getLeftEdge, optElements)\n    };\n    const detect$1 = onDirection(ltr$1, rtl$1);\n    const width = {\n      delta: (amount, table) => detect$1(table).delta(amount, table),\n      positions: (cols, table) => detect$1(table).positions(cols, table),\n      edge: cell => detect$1(cell).edge(cell)\n    };\n\n    const units = {\n      unsupportedLength: [\n        'em',\n        'ex',\n        'cap',\n        'ch',\n        'ic',\n        'rem',\n        'lh',\n        'rlh',\n        'vw',\n        'vh',\n        'vi',\n        'vb',\n        'vmin',\n        'vmax',\n        'cm',\n        'mm',\n        'Q',\n        'in',\n        'pc',\n        'pt',\n        'px'\n      ],\n      fixed: [\n        'px',\n        'pt'\n      ],\n      relative: ['%'],\n      empty: ['']\n    };\n    const pattern = (() => {\n      const decimalDigits = '[0-9]+';\n      const signedInteger = '[+-]?' + decimalDigits;\n      const exponentPart = '[eE]' + signedInteger;\n      const dot = '\\\\.';\n      const opt = input => `(?:${ input })?`;\n      const unsignedDecimalLiteral = [\n        'Infinity',\n        decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),\n        dot + decimalDigits + opt(exponentPart),\n        decimalDigits + opt(exponentPart)\n      ].join('|');\n      const float = `[+-]?(?:${ unsignedDecimalLiteral })`;\n      return new RegExp(`^(${ float })(.*)$`);\n    })();\n    const isUnit = (unit, accepted) => exists(accepted, acc => exists(units[acc], check => unit === check));\n    const parse = (input, accepted) => {\n      const match = Optional.from(pattern.exec(input));\n      return match.bind(array => {\n        const value = Number(array[1]);\n        const unitRaw = array[2];\n        if (isUnit(unitRaw, accepted)) {\n          return Optional.some({\n            value,\n            unit: unitRaw\n          });\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n\n    const rPercentageBasedSizeRegex = /(\\d+(\\.\\d+)?)%/;\n    const rPixelBasedSizeRegex = /(\\d+(\\.\\d+)?)px|em/;\n    const isCol$2 = isTag('col');\n    const getPercentSize = (elm, outerGetter, innerGetter) => {\n      const relativeParent = parentElement(elm).getOrThunk(() => getBody$1(owner(elm)));\n      return outerGetter(elm) / innerGetter(relativeParent) * 100;\n    };\n    const setPixelWidth = (cell, amount) => {\n      set$1(cell, 'width', amount + 'px');\n    };\n    const setPercentageWidth = (cell, amount) => {\n      set$1(cell, 'width', amount + '%');\n    };\n    const setHeight = (cell, amount) => {\n      set$1(cell, 'height', amount + 'px');\n    };\n    const getHeightValue = cell => getRuntime(cell) + 'px';\n    const convert = (cell, number, getter, setter) => {\n      const newSize = table(cell).map(table => {\n        const total = getter(table);\n        return Math.floor(number / 100 * total);\n      }).getOr(number);\n      setter(cell, newSize);\n      return newSize;\n    };\n    const normalizePixelSize = (value, cell, getter, setter) => {\n      const number = parseFloat(value);\n      return endsWith(value, '%') && name(cell) !== 'table' ? convert(cell, number, getter, setter) : number;\n    };\n    const getTotalHeight = cell => {\n      const value = getHeightValue(cell);\n      if (!value) {\n        return get$8(cell);\n      }\n      return normalizePixelSize(value, cell, get$8, setHeight);\n    };\n    const get$7 = (cell, type, f) => {\n      const v = f(cell);\n      const span = getSpan(cell, type);\n      return v / span;\n    };\n    const getRaw$1 = (element, prop) => {\n      return getRaw$2(element, prop).orThunk(() => {\n        return getOpt(element, prop).map(val => val + 'px');\n      });\n    };\n    const getRawWidth$1 = element => getRaw$1(element, 'width');\n    const getRawHeight = element => getRaw$1(element, 'height');\n    const getPercentageWidth = cell => getPercentSize(cell, get$9, getInner);\n    const getPixelWidth$1 = cell => isCol$2(cell) ? get$9(cell) : getRuntime$1(cell);\n    const getHeight = cell => {\n      return get$7(cell, 'rowspan', getTotalHeight);\n    };\n    const getGenericWidth = cell => {\n      const width = getRawWidth$1(cell);\n      return width.bind(w => parse(w, [\n        'fixed',\n        'relative',\n        'empty'\n      ]));\n    };\n    const setGenericWidth = (cell, amount, unit) => {\n      set$1(cell, 'width', amount + unit);\n    };\n    const getPixelTableWidth = table => get$9(table) + 'px';\n    const getPercentTableWidth = table => getPercentSize(table, get$9, getInner) + '%';\n    const isPercentSizing$1 = table => getRawWidth$1(table).exists(size => rPercentageBasedSizeRegex.test(size));\n    const isPixelSizing$1 = table => getRawWidth$1(table).exists(size => rPixelBasedSizeRegex.test(size));\n    const isNoneSizing$1 = table => getRawWidth$1(table).isNone();\n    const percentageBasedSizeRegex = constant(rPercentageBasedSizeRegex);\n\n    const isCol$1 = isTag('col');\n    const getRawW = cell => {\n      return getRawWidth$1(cell).getOrThunk(() => getPixelWidth$1(cell) + 'px');\n    };\n    const getRawH = cell => {\n      return getRawHeight(cell).getOrThunk(() => getHeight(cell) + 'px');\n    };\n    const justCols = warehouse => map$1(Warehouse.justColumns(warehouse), column => Optional.from(column.element));\n    const isValidColumn = cell => {\n      const browser = detect$2().browser;\n      const supportsColWidths = browser.isChromium() || browser.isFirefox();\n      return isCol$1(cell) ? supportsColWidths : true;\n    };\n    const getDimension = (cellOpt, index, backups, filter, getter, fallback) => cellOpt.filter(filter).fold(() => fallback(deduce(backups, index)), cell => getter(cell));\n    const getWidthFrom = (warehouse, table, getWidth, fallback) => {\n      const columnCells = columns(warehouse);\n      const columns$1 = Warehouse.hasColumns(warehouse) ? justCols(warehouse) : columnCells;\n      const backups = [Optional.some(width.edge(table))].concat(map$1(width.positions(columnCells, table), pos => pos.map(p => p.x)));\n      const colFilter = not(hasColspan);\n      return map$1(columns$1, (cellOption, c) => {\n        return getDimension(cellOption, c, backups, colFilter, column => {\n          if (isValidColumn(column)) {\n            return getWidth(column);\n          } else {\n            const cell = bindFrom(columnCells[c], identity);\n            return getDimension(cell, c, backups, colFilter, cell => fallback(Optional.some(get$9(cell))), fallback);\n          }\n        }, fallback);\n      });\n    };\n    const getDeduced = deduced => {\n      return deduced.map(d => {\n        return d + 'px';\n      }).getOr('');\n    };\n    const getRawWidths = (warehouse, table) => {\n      return getWidthFrom(warehouse, table, getRawW, getDeduced);\n    };\n    const getPercentageWidths = (warehouse, table, tableSize) => {\n      return getWidthFrom(warehouse, table, getPercentageWidth, deduced => {\n        return deduced.fold(() => {\n          return tableSize.minCellWidth();\n        }, cellWidth => {\n          return cellWidth / tableSize.pixelWidth() * 100;\n        });\n      });\n    };\n    const getPixelWidths = (warehouse, table, tableSize) => {\n      return getWidthFrom(warehouse, table, getPixelWidth$1, deduced => {\n        return deduced.getOrThunk(tableSize.minCellWidth);\n      });\n    };\n    const getHeightFrom = (warehouse, table, direction, getHeight, fallback) => {\n      const rows$1 = rows(warehouse);\n      const backups = [Optional.some(direction.edge(table))].concat(map$1(direction.positions(rows$1, table), pos => pos.map(p => p.y)));\n      return map$1(rows$1, (cellOption, c) => {\n        return getDimension(cellOption, c, backups, not(hasRowspan), getHeight, fallback);\n      });\n    };\n    const getPixelHeights = (warehouse, table, direction) => {\n      return getHeightFrom(warehouse, table, direction, getHeight, deduced => {\n        return deduced.getOrThunk(minHeight);\n      });\n    };\n    const getRawHeights = (warehouse, table, direction) => {\n      return getHeightFrom(warehouse, table, direction, getRawH, getDeduced);\n    };\n\n    const widthLookup = (table, getter) => () => {\n      if (inBody(table)) {\n        return getter(table);\n      } else {\n        return parseFloat(getRaw$2(table, 'width').getOr('0'));\n      }\n    };\n    const noneSize = table => {\n      const getWidth = widthLookup(table, get$9);\n      const zero = constant(0);\n      const getWidths = (warehouse, tableSize) => getPixelWidths(warehouse, table, tableSize);\n      return {\n        width: getWidth,\n        pixelWidth: getWidth,\n        getWidths,\n        getCellDelta: zero,\n        singleColumnWidth: constant([0]),\n        minCellWidth: zero,\n        setElementWidth: noop,\n        adjustTableWidth: noop,\n        isRelative: true,\n        label: 'none'\n      };\n    };\n    const percentageSize = table => {\n      const getFloatWidth = widthLookup(table, elem => parseFloat(getPercentTableWidth(elem)));\n      const getWidth = widthLookup(table, get$9);\n      const getCellDelta = delta => delta / getWidth() * 100;\n      const singleColumnWidth = (w, _delta) => [100 - w];\n      const minCellWidth = () => minWidth() / getWidth() * 100;\n      const adjustTableWidth = delta => {\n        const currentWidth = getFloatWidth();\n        const change = delta / 100 * currentWidth;\n        const newWidth = currentWidth + change;\n        setPercentageWidth(table, newWidth);\n      };\n      const getWidths = (warehouse, tableSize) => getPercentageWidths(warehouse, table, tableSize);\n      return {\n        width: getFloatWidth,\n        pixelWidth: getWidth,\n        getWidths,\n        getCellDelta,\n        singleColumnWidth,\n        minCellWidth,\n        setElementWidth: setPercentageWidth,\n        adjustTableWidth,\n        isRelative: true,\n        label: 'percent'\n      };\n    };\n    const pixelSize = table => {\n      const getWidth = widthLookup(table, get$9);\n      const getCellDelta = identity;\n      const singleColumnWidth = (w, delta) => {\n        const newNext = Math.max(minWidth(), w + delta);\n        return [newNext - w];\n      };\n      const adjustTableWidth = delta => {\n        const newWidth = getWidth() + delta;\n        setPixelWidth(table, newWidth);\n      };\n      const getWidths = (warehouse, tableSize) => getPixelWidths(warehouse, table, tableSize);\n      return {\n        width: getWidth,\n        pixelWidth: getWidth,\n        getWidths,\n        getCellDelta,\n        singleColumnWidth,\n        minCellWidth: minWidth,\n        setElementWidth: setPixelWidth,\n        adjustTableWidth,\n        isRelative: false,\n        label: 'pixel'\n      };\n    };\n    const chooseSize = (element, width) => {\n      const percentMatch = percentageBasedSizeRegex().exec(width);\n      if (percentMatch !== null) {\n        return percentageSize(element);\n      } else {\n        return pixelSize(element);\n      }\n    };\n    const getTableSize = table => {\n      const width = getRawWidth$1(table);\n      return width.fold(() => noneSize(table), w => chooseSize(table, w));\n    };\n    const TableSize = {\n      getTableSize,\n      pixelSize,\n      percentageSize,\n      noneSize\n    };\n\n    const statsStruct = (minRow, minCol, maxRow, maxCol, allCells, selectedCells) => ({\n      minRow,\n      minCol,\n      maxRow,\n      maxCol,\n      allCells,\n      selectedCells\n    });\n    const findSelectedStats = (house, isSelected) => {\n      const totalColumns = house.grid.columns;\n      const totalRows = house.grid.rows;\n      let minRow = totalRows;\n      let minCol = totalColumns;\n      let maxRow = 0;\n      let maxCol = 0;\n      const allCells = [];\n      const selectedCells = [];\n      each$1(house.access, detail => {\n        allCells.push(detail);\n        if (isSelected(detail)) {\n          selectedCells.push(detail);\n          const startRow = detail.row;\n          const endRow = startRow + detail.rowspan - 1;\n          const startCol = detail.column;\n          const endCol = startCol + detail.colspan - 1;\n          if (startRow < minRow) {\n            minRow = startRow;\n          } else if (endRow > maxRow) {\n            maxRow = endRow;\n          }\n          if (startCol < minCol) {\n            minCol = startCol;\n          } else if (endCol > maxCol) {\n            maxCol = endCol;\n          }\n        }\n      });\n      return statsStruct(minRow, minCol, maxRow, maxCol, allCells, selectedCells);\n    };\n    const makeCell = (list, seenSelected, rowIndex) => {\n      const row = list[rowIndex].element;\n      const td = SugarElement.fromTag('td');\n      append$1(td, SugarElement.fromTag('br'));\n      const f = seenSelected ? append$1 : prepend;\n      f(row, td);\n    };\n    const fillInGaps = (list, house, stats, isSelected) => {\n      const rows = filter$2(list, row => row.section !== 'colgroup');\n      const totalColumns = house.grid.columns;\n      const totalRows = house.grid.rows;\n      for (let i = 0; i < totalRows; i++) {\n        let seenSelected = false;\n        for (let j = 0; j < totalColumns; j++) {\n          if (!(i < stats.minRow || i > stats.maxRow || j < stats.minCol || j > stats.maxCol)) {\n            const needCell = Warehouse.getAt(house, i, j).filter(isSelected).isNone();\n            if (needCell) {\n              makeCell(rows, seenSelected, i);\n            } else {\n              seenSelected = true;\n            }\n          }\n        }\n      }\n    };\n    const clean = (replica, stats, house, widthDelta) => {\n      each$1(house.columns, col => {\n        if (col.column < stats.minCol || col.column > stats.maxCol) {\n          remove$6(col.element);\n        }\n      });\n      const emptyRows = filter$2(firstLayer(replica, 'tr'), row => row.dom.childElementCount === 0);\n      each$2(emptyRows, remove$6);\n      if (stats.minCol === stats.maxCol || stats.minRow === stats.maxRow) {\n        each$2(firstLayer(replica, 'th,td'), cell => {\n          remove$7(cell, 'rowspan');\n          remove$7(cell, 'colspan');\n        });\n      }\n      remove$7(replica, LOCKED_COL_ATTR);\n      remove$7(replica, 'data-snooker-col-series');\n      const tableSize = TableSize.getTableSize(replica);\n      tableSize.adjustTableWidth(widthDelta);\n    };\n    const getTableWidthDelta = (table, warehouse, tableSize, stats) => {\n      if (stats.minCol === 0 && warehouse.grid.columns === stats.maxCol + 1) {\n        return 0;\n      }\n      const colWidths = getPixelWidths(warehouse, table, tableSize);\n      const allColsWidth = foldl(colWidths, (acc, width) => acc + width, 0);\n      const selectedColsWidth = foldl(colWidths.slice(stats.minCol, stats.maxCol + 1), (acc, width) => acc + width, 0);\n      const newWidth = selectedColsWidth / allColsWidth * tableSize.pixelWidth();\n      const delta = newWidth - tableSize.pixelWidth();\n      return tableSize.getCellDelta(delta);\n    };\n    const extract$1 = (table, selectedSelector) => {\n      const isSelected = detail => is$2(detail.element, selectedSelector);\n      const replica = deep(table);\n      const list = fromTable$1(replica);\n      const tableSize = TableSize.getTableSize(table);\n      const replicaHouse = Warehouse.generate(list);\n      const replicaStats = findSelectedStats(replicaHouse, isSelected);\n      const selector = 'th:not(' + selectedSelector + ')' + ',td:not(' + selectedSelector + ')';\n      const unselectedCells = filterFirstLayer(replica, 'th,td', cell => is$2(cell, selector));\n      each$2(unselectedCells, remove$6);\n      fillInGaps(list, replicaHouse, replicaStats, isSelected);\n      const house = Warehouse.fromTable(table);\n      const widthDelta = getTableWidthDelta(table, house, tableSize, replicaStats);\n      clean(replica, replicaStats, replicaHouse, widthDelta);\n      return replica;\n    };\n\n    const nbsp = '\\xA0';\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api = NodeValue(isText, 'text');\n    const get$6 = element => api.get(element);\n    const getOption = element => api.getOption(element);\n    const set = (element, value) => api.set(element, value);\n\n    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children$2(element).length, v => v.length);\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n    const isContentEditableFalse = elem => isHTMLElement(elem) && get$b(elem, 'contenteditable') === 'false';\n    const elementsWithCursorPosition = [\n      'img',\n      'br'\n    ];\n    const isCursorPosition = elem => {\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse(elem);\n    };\n\n    const first = element => descendant$1(element, isCursorPosition);\n    const last$1 = element => descendantRtl(element, isCursorPosition);\n    const descendantRtl = (scope, predicate) => {\n      const descend = element => {\n        const children = children$2(element);\n        for (let i = children.length - 1; i >= 0; i--) {\n          const child = children[i];\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(child);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope);\n    };\n\n    const transferableAttributes = {\n      scope: [\n        'row',\n        'col'\n      ]\n    };\n    const createCell = doc => () => {\n      const td = SugarElement.fromTag('td', doc.dom);\n      append$1(td, SugarElement.fromTag('br', doc.dom));\n      return td;\n    };\n    const createCol = doc => () => {\n      return SugarElement.fromTag('col', doc.dom);\n    };\n    const createColgroup = doc => () => {\n      return SugarElement.fromTag('colgroup', doc.dom);\n    };\n    const createRow$1 = doc => () => {\n      return SugarElement.fromTag('tr', doc.dom);\n    };\n    const replace$1 = (cell, tag, attrs) => {\n      const replica = copy$2(cell, tag);\n      each$1(attrs, (v, k) => {\n        if (v === null) {\n          remove$7(replica, k);\n        } else {\n          set$2(replica, k, v);\n        }\n      });\n      return replica;\n    };\n    const pasteReplace = cell => {\n      return cell;\n    };\n    const cloneFormats = (oldCell, newCell, formats) => {\n      const first$1 = first(oldCell);\n      return first$1.map(firstText => {\n        const formatSelector = formats.join(',');\n        const parents = ancestors$3(firstText, formatSelector, element => {\n          return eq$1(element, oldCell);\n        });\n        return foldr(parents, (last, parent) => {\n          const clonedFormat = shallow(parent);\n          append$1(last, clonedFormat);\n          return clonedFormat;\n        }, newCell);\n      }).getOr(newCell);\n    };\n    const cloneAppropriateAttributes = (original, clone) => {\n      each$1(transferableAttributes, (validAttributes, attributeName) => getOpt(original, attributeName).filter(attribute => contains$2(validAttributes, attribute)).each(attribute => set$2(clone, attributeName, attribute)));\n    };\n    const cellOperations = (mutate, doc, formatsToClone) => {\n      const cloneCss = (prev, clone) => {\n        copy$1(prev.element, clone);\n        remove$5(clone, 'height');\n        if (prev.colspan !== 1) {\n          remove$5(clone, 'width');\n        }\n      };\n      const newCell = prev => {\n        const td = SugarElement.fromTag(name(prev.element), doc.dom);\n        const formats = formatsToClone.getOr([\n          'strong',\n          'em',\n          'b',\n          'i',\n          'span',\n          'font',\n          'h1',\n          'h2',\n          'h3',\n          'h4',\n          'h5',\n          'h6',\n          'p',\n          'div'\n        ]);\n        const lastNode = formats.length > 0 ? cloneFormats(prev.element, td, formats) : td;\n        append$1(lastNode, SugarElement.fromTag('br'));\n        cloneCss(prev, td);\n        cloneAppropriateAttributes(prev.element, td);\n        mutate(prev.element, td);\n        return td;\n      };\n      const newCol = prev => {\n        const col = SugarElement.fromTag(name(prev.element), doc.dom);\n        cloneCss(prev, col);\n        mutate(prev.element, col);\n        return col;\n      };\n      return {\n        col: newCol,\n        colgroup: createColgroup(doc),\n        row: createRow$1(doc),\n        cell: newCell,\n        replace: replace$1,\n        colGap: createCol(doc),\n        gap: createCell(doc)\n      };\n    };\n    const paste$1 = doc => {\n      return {\n        col: createCol(doc),\n        colgroup: createColgroup(doc),\n        row: createRow$1(doc),\n        cell: createCell(doc),\n        replace: pasteReplace,\n        colGap: createCol(doc),\n        gap: createCell(doc)\n      };\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children$2(SugarElement.fromDom(div));\n    };\n    const fromDom = nodes => map$1(nodes, SugarElement.fromDom);\n\n    const option = name => editor => editor.options.get(name);\n    const defaultWidth = '100%';\n    const getPixelForcedWidth = editor => {\n      var _a;\n      const dom = editor.dom;\n      const parentBlock = (_a = dom.getParent(editor.selection.getStart(), dom.isBlock)) !== null && _a !== void 0 ? _a : editor.getBody();\n      return getInner(SugarElement.fromDom(parentBlock)) + 'px';\n    };\n    const determineDefaultTableStyles = (editor, defaultStyles) => {\n      if (isTableResponsiveForced(editor) || !shouldStyleWithCss(editor)) {\n        return defaultStyles;\n      } else if (isTablePixelsForced(editor)) {\n        return {\n          ...defaultStyles,\n          width: getPixelForcedWidth(editor)\n        };\n      } else {\n        return {\n          ...defaultStyles,\n          width: defaultWidth\n        };\n      }\n    };\n    const determineDefaultTableAttributes = (editor, defaultAttributes) => {\n      if (isTableResponsiveForced(editor) || shouldStyleWithCss(editor)) {\n        return defaultAttributes;\n      } else if (isTablePixelsForced(editor)) {\n        return {\n          ...defaultAttributes,\n          width: getPixelForcedWidth(editor)\n        };\n      } else {\n        return {\n          ...defaultAttributes,\n          width: defaultWidth\n        };\n      }\n    };\n    const register = editor => {\n      const registerOption = editor.options.register;\n      registerOption('table_clone_elements', { processor: 'string[]' });\n      registerOption('table_use_colgroups', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('table_header_type', {\n        processor: value => {\n          const valid = contains$2([\n            'section',\n            'cells',\n            'sectionCells',\n            'auto'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: section, cells, sectionCells or auto.'\n          };\n        },\n        default: 'section'\n      });\n      registerOption('table_sizing_mode', {\n        processor: 'string',\n        default: 'auto'\n      });\n      registerOption('table_default_attributes', {\n        processor: 'object',\n        default: { border: '1' }\n      });\n      registerOption('table_default_styles', {\n        processor: 'object',\n        default: { 'border-collapse': 'collapse' }\n      });\n      registerOption('table_column_resizing', {\n        processor: value => {\n          const valid = contains$2([\n            'preservetable',\n            'resizetable'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be preservetable, or resizetable.'\n          };\n        },\n        default: 'preservetable'\n      });\n      registerOption('table_resize_bars', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('table_style_by_css', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('table_merge_content_on_paste', {\n        processor: 'boolean',\n        default: true\n      });\n    };\n    const getTableCloneElements = editor => {\n      return Optional.from(editor.options.get('table_clone_elements'));\n    };\n    const hasTableObjectResizing = editor => {\n      const objectResizing = editor.options.get('object_resizing');\n      return contains$2(objectResizing.split(','), 'table');\n    };\n    const getTableHeaderType = option('table_header_type');\n    const getTableColumnResizingBehaviour = option('table_column_resizing');\n    const isPreserveTableColumnResizing = editor => getTableColumnResizingBehaviour(editor) === 'preservetable';\n    const isResizeTableColumnResizing = editor => getTableColumnResizingBehaviour(editor) === 'resizetable';\n    const getTableSizingMode = option('table_sizing_mode');\n    const isTablePercentagesForced = editor => getTableSizingMode(editor) === 'relative';\n    const isTablePixelsForced = editor => getTableSizingMode(editor) === 'fixed';\n    const isTableResponsiveForced = editor => getTableSizingMode(editor) === 'responsive';\n    const hasTableResizeBars = option('table_resize_bars');\n    const shouldStyleWithCss = option('table_style_by_css');\n    const shouldMergeContentOnPaste = option('table_merge_content_on_paste');\n    const getTableDefaultAttributes = editor => {\n      const options = editor.options;\n      const defaultAttributes = options.get('table_default_attributes');\n      return options.isSet('table_default_attributes') ? defaultAttributes : determineDefaultTableAttributes(editor, defaultAttributes);\n    };\n    const getTableDefaultStyles = editor => {\n      const options = editor.options;\n      const defaultStyles = options.get('table_default_styles');\n      return options.isSet('table_default_styles') ? defaultStyles : determineDefaultTableStyles(editor, defaultStyles);\n    };\n    const tableUseColumnGroup = option('table_use_colgroups');\n\n    const closest = target => closest$1(target, '[contenteditable]');\n    const isEditable$1 = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest(element).fold(constant(assumeEditable), editable => getRaw(editable) === 'true');\n      }\n    };\n    const getRaw = element => element.dom.contentEditable;\n\n    const getBody = editor => SugarElement.fromDom(editor.getBody());\n    const getIsRoot = editor => element => eq$1(element, getBody(editor));\n    const removeDataStyle = table => {\n      remove$7(table, 'data-mce-style');\n      const removeStyleAttribute = element => remove$7(element, 'data-mce-style');\n      each$2(cells$1(table), removeStyleAttribute);\n      each$2(columns$1(table), removeStyleAttribute);\n      each$2(rows$1(table), removeStyleAttribute);\n    };\n    const getSelectionStart = editor => SugarElement.fromDom(editor.selection.getStart());\n    const getPixelWidth = elm => elm.getBoundingClientRect().width;\n    const getPixelHeight = elm => elm.getBoundingClientRect().height;\n    const getRawWidth = (editor, elm) => {\n      const raw = editor.dom.getStyle(elm, 'width') || editor.dom.getAttrib(elm, 'width');\n      return Optional.from(raw).filter(isNotEmpty);\n    };\n    const isPercentage$1 = value => /^(\\d+(\\.\\d+)?)%$/.test(value);\n    const isPixel = value => /^(\\d+(\\.\\d+)?)px$/.test(value);\n    const isInEditableContext$1 = cell => closest$2(cell, isTag('table')).exists(isEditable$1);\n\n    const inSelection = (bounds, detail) => {\n      const leftEdge = detail.column;\n      const rightEdge = detail.column + detail.colspan - 1;\n      const topEdge = detail.row;\n      const bottomEdge = detail.row + detail.rowspan - 1;\n      return leftEdge <= bounds.finishCol && rightEdge >= bounds.startCol && (topEdge <= bounds.finishRow && bottomEdge >= bounds.startRow);\n    };\n    const isWithin = (bounds, detail) => {\n      return detail.column >= bounds.startCol && detail.column + detail.colspan - 1 <= bounds.finishCol && detail.row >= bounds.startRow && detail.row + detail.rowspan - 1 <= bounds.finishRow;\n    };\n    const isRectangular = (warehouse, bounds) => {\n      let isRect = true;\n      const detailIsWithin = curry(isWithin, bounds);\n      for (let i = bounds.startRow; i <= bounds.finishRow; i++) {\n        for (let j = bounds.startCol; j <= bounds.finishCol; j++) {\n          isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);\n        }\n      }\n      return isRect ? Optional.some(bounds) : Optional.none();\n    };\n\n    const getBounds = (detailA, detailB) => {\n      return bounds(Math.min(detailA.row, detailB.row), Math.min(detailA.column, detailB.column), Math.max(detailA.row + detailA.rowspan - 1, detailB.row + detailB.rowspan - 1), Math.max(detailA.column + detailA.colspan - 1, detailB.column + detailB.colspan - 1));\n    };\n    const getAnyBox = (warehouse, startCell, finishCell) => {\n      const startCoords = Warehouse.findItem(warehouse, startCell, eq$1);\n      const finishCoords = Warehouse.findItem(warehouse, finishCell, eq$1);\n      return startCoords.bind(sc => {\n        return finishCoords.map(fc => {\n          return getBounds(sc, fc);\n        });\n      });\n    };\n    const getBox$1 = (warehouse, startCell, finishCell) => {\n      return getAnyBox(warehouse, startCell, finishCell).bind(bounds => {\n        return isRectangular(warehouse, bounds);\n      });\n    };\n\n    const moveBy$1 = (warehouse, cell, row, column) => {\n      return Warehouse.findItem(warehouse, cell, eq$1).bind(detail => {\n        const startRow = row > 0 ? detail.row + detail.rowspan - 1 : detail.row;\n        const startCol = column > 0 ? detail.column + detail.colspan - 1 : detail.column;\n        const dest = Warehouse.getAt(warehouse, startRow + row, startCol + column);\n        return dest.map(d => {\n          return d.element;\n        });\n      });\n    };\n    const intercepts$1 = (warehouse, start, finish) => {\n      return getAnyBox(warehouse, start, finish).map(bounds => {\n        const inside = Warehouse.filterItems(warehouse, curry(inSelection, bounds));\n        return map$1(inside, detail => {\n          return detail.element;\n        });\n      });\n    };\n    const parentCell = (warehouse, innerCell) => {\n      const isContainedBy = (c1, c2) => {\n        return contains$1(c2, c1);\n      };\n      return Warehouse.findItem(warehouse, innerCell, isContainedBy).map(detail => {\n        return detail.element;\n      });\n    };\n\n    const moveBy = (cell, deltaRow, deltaColumn) => {\n      return table(cell).bind(table => {\n        const warehouse = getWarehouse(table);\n        return moveBy$1(warehouse, cell, deltaRow, deltaColumn);\n      });\n    };\n    const intercepts = (table, first, last) => {\n      const warehouse = getWarehouse(table);\n      return intercepts$1(warehouse, first, last);\n    };\n    const nestedIntercepts = (table, first, firstTable, last, lastTable) => {\n      const warehouse = getWarehouse(table);\n      const optStartCell = eq$1(table, firstTable) ? Optional.some(first) : parentCell(warehouse, first);\n      const optLastCell = eq$1(table, lastTable) ? Optional.some(last) : parentCell(warehouse, last);\n      return optStartCell.bind(startCell => optLastCell.bind(lastCell => intercepts$1(warehouse, startCell, lastCell)));\n    };\n    const getBox = (table, first, last) => {\n      const warehouse = getWarehouse(table);\n      return getBox$1(warehouse, first, last);\n    };\n    const getWarehouse = Warehouse.fromTable;\n\n    var TagBoundaries = [\n      'body',\n      'p',\n      'div',\n      'article',\n      'aside',\n      'figcaption',\n      'figure',\n      'footer',\n      'header',\n      'nav',\n      'section',\n      'ol',\n      'ul',\n      'li',\n      'table',\n      'thead',\n      'tbody',\n      'tfoot',\n      'caption',\n      'tr',\n      'td',\n      'th',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'blockquote',\n      'pre',\n      'address'\n    ];\n\n    var DomUniverse = () => {\n      const clone = element => {\n        return SugarElement.fromDom(element.dom.cloneNode(false));\n      };\n      const document = element => documentOrOwner(element).dom;\n      const isBoundary = element => {\n        if (!isElement(element)) {\n          return false;\n        }\n        if (name(element) === 'body') {\n          return true;\n        }\n        return contains$2(TagBoundaries, name(element));\n      };\n      const isEmptyTag = element => {\n        if (!isElement(element)) {\n          return false;\n        }\n        return contains$2([\n          'br',\n          'img',\n          'hr',\n          'input'\n        ], name(element));\n      };\n      const isNonEditable = element => isElement(element) && get$b(element, 'contenteditable') === 'false';\n      const comparePosition = (element, other) => {\n        return element.dom.compareDocumentPosition(other.dom);\n      };\n      const copyAttributesTo = (source, destination) => {\n        const as = clone$2(source);\n        setAll$1(destination, as);\n      };\n      const isSpecial = element => {\n        const tag = name(element);\n        return contains$2([\n          'script',\n          'noscript',\n          'iframe',\n          'noframes',\n          'noembed',\n          'title',\n          'style',\n          'textarea',\n          'xmp'\n        ], tag);\n      };\n      const getLanguage = element => isElement(element) ? getOpt(element, 'lang') : Optional.none();\n      return {\n        up: constant({\n          selector: ancestor$1,\n          closest: closest$1,\n          predicate: ancestor$2,\n          all: parents\n        }),\n        down: constant({\n          selector: descendants,\n          predicate: descendants$1\n        }),\n        styles: constant({\n          get: get$a,\n          getRaw: getRaw$2,\n          set: set$1,\n          remove: remove$5\n        }),\n        attrs: constant({\n          get: get$b,\n          set: set$2,\n          remove: remove$7,\n          copyTo: copyAttributesTo\n        }),\n        insert: constant({\n          before: before$3,\n          after: after$5,\n          afterAll: after$4,\n          append: append$1,\n          appendAll: append,\n          prepend: prepend,\n          wrap: wrap\n        }),\n        remove: constant({\n          unwrap: unwrap,\n          remove: remove$6\n        }),\n        create: constant({\n          nu: SugarElement.fromTag,\n          clone,\n          text: SugarElement.fromText\n        }),\n        query: constant({\n          comparePosition,\n          prevSibling: prevSibling,\n          nextSibling: nextSibling\n        }),\n        property: constant({\n          children: children$2,\n          name: name,\n          parent: parent,\n          document,\n          isText: isText,\n          isComment: isComment,\n          isElement: isElement,\n          isSpecial,\n          getLanguage,\n          getText: get$6,\n          setText: set,\n          isBoundary,\n          isEmptyTag,\n          isNonEditable\n        }),\n        eq: eq$1,\n        is: is$1\n      };\n    };\n\n    const all = (universe, look, elements, f) => {\n      const head = elements[0];\n      const tail = elements.slice(1);\n      return f(universe, look, head, tail);\n    };\n    const oneAll = (universe, look, elements) => {\n      return elements.length > 0 ? all(universe, look, elements, unsafeOne) : Optional.none();\n    };\n    const unsafeOne = (universe, look, head, tail) => {\n      const start = look(universe, head);\n      return foldr(tail, (b, a) => {\n        const current = look(universe, a);\n        return commonElement(universe, b, current);\n      }, start);\n    };\n    const commonElement = (universe, start, end) => {\n      return start.bind(s => {\n        return end.filter(curry(universe.eq, s));\n      });\n    };\n\n    const eq = (universe, item) => {\n      return curry(universe.eq, item);\n    };\n    const ancestors$2 = (universe, start, end, isRoot = never) => {\n      const ps1 = [start].concat(universe.up().all(start));\n      const ps2 = [end].concat(universe.up().all(end));\n      const prune = path => {\n        const index = findIndex(path, isRoot);\n        return index.fold(() => {\n          return path;\n        }, ind => {\n          return path.slice(0, ind + 1);\n        });\n      };\n      const pruned1 = prune(ps1);\n      const pruned2 = prune(ps2);\n      const shared = find$1(pruned1, x => {\n        return exists(pruned2, eq(universe, x));\n      });\n      return {\n        firstpath: pruned1,\n        secondpath: pruned2,\n        shared\n      };\n    };\n\n    const sharedOne$1 = oneAll;\n    const ancestors$1 = ancestors$2;\n\n    const universe$3 = DomUniverse();\n    const sharedOne = (look, elements) => {\n      return sharedOne$1(universe$3, (_universe, element) => {\n        return look(element);\n      }, elements);\n    };\n    const ancestors = (start, finish, isRoot) => {\n      return ancestors$1(universe$3, start, finish, isRoot);\n    };\n\n    const lookupTable = container => {\n      return ancestor$1(container, 'table');\n    };\n    const identify = (start, finish, isRoot) => {\n      const getIsRoot = rootTable => {\n        return element => {\n          return isRoot !== undefined && isRoot(element) || eq$1(element, rootTable);\n        };\n      };\n      if (eq$1(start, finish)) {\n        return Optional.some({\n          boxes: Optional.some([start]),\n          start,\n          finish\n        });\n      } else {\n        return lookupTable(start).bind(startTable => {\n          return lookupTable(finish).bind(finishTable => {\n            if (eq$1(startTable, finishTable)) {\n              return Optional.some({\n                boxes: intercepts(startTable, start, finish),\n                start,\n                finish\n              });\n            } else if (contains$1(startTable, finishTable)) {\n              const ancestorCells = ancestors$3(finish, 'td,th', getIsRoot(startTable));\n              const finishCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : finish;\n              return Optional.some({\n                boxes: nestedIntercepts(startTable, start, startTable, finish, finishTable),\n                start,\n                finish: finishCell\n              });\n            } else if (contains$1(finishTable, startTable)) {\n              const ancestorCells = ancestors$3(start, 'td,th', getIsRoot(finishTable));\n              const startCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : start;\n              return Optional.some({\n                boxes: nestedIntercepts(finishTable, start, startTable, finish, finishTable),\n                start,\n                finish: startCell\n              });\n            } else {\n              return ancestors(start, finish).shared.bind(lca => {\n                return closest$1(lca, 'table', isRoot).bind(lcaTable => {\n                  const finishAncestorCells = ancestors$3(finish, 'td,th', getIsRoot(lcaTable));\n                  const finishCell = finishAncestorCells.length > 0 ? finishAncestorCells[finishAncestorCells.length - 1] : finish;\n                  const startAncestorCells = ancestors$3(start, 'td,th', getIsRoot(lcaTable));\n                  const startCell = startAncestorCells.length > 0 ? startAncestorCells[startAncestorCells.length - 1] : start;\n                  return Optional.some({\n                    boxes: nestedIntercepts(lcaTable, start, startTable, finish, finishTable),\n                    start: startCell,\n                    finish: finishCell\n                  });\n                });\n              });\n            }\n          });\n        });\n      }\n    };\n    const retrieve$1 = (container, selector) => {\n      const sels = descendants(container, selector);\n      return sels.length > 0 ? Optional.some(sels) : Optional.none();\n    };\n    const getLast = (boxes, lastSelectedSelector) => {\n      return find$1(boxes, box => {\n        return is$2(box, lastSelectedSelector);\n      });\n    };\n    const getEdges = (container, firstSelectedSelector, lastSelectedSelector) => {\n      return descendant(container, firstSelectedSelector).bind(first => {\n        return descendant(container, lastSelectedSelector).bind(last => {\n          return sharedOne(lookupTable, [\n            first,\n            last\n          ]).map(table => {\n            return {\n              first,\n              last,\n              table\n            };\n          });\n        });\n      });\n    };\n    const expandTo = (finish, firstSelectedSelector) => {\n      return ancestor$1(finish, 'table').bind(table => {\n        return descendant(table, firstSelectedSelector).bind(start => {\n          return identify(start, finish).bind(identified => {\n            return identified.boxes.map(boxes => {\n              return {\n                boxes,\n                start: identified.start,\n                finish: identified.finish\n              };\n            });\n          });\n        });\n      });\n    };\n    const shiftSelection = (boxes, deltaRow, deltaColumn, firstSelectedSelector, lastSelectedSelector) => {\n      return getLast(boxes, lastSelectedSelector).bind(last => {\n        return moveBy(last, deltaRow, deltaColumn).bind(finish => {\n          return expandTo(finish, firstSelectedSelector);\n        });\n      });\n    };\n\n    const retrieve = (container, selector) => {\n      return retrieve$1(container, selector);\n    };\n    const retrieveBox = (container, firstSelectedSelector, lastSelectedSelector) => {\n      return getEdges(container, firstSelectedSelector, lastSelectedSelector).bind(edges => {\n        const isRoot = ancestor => {\n          return eq$1(container, ancestor);\n        };\n        const sectionSelector = 'thead,tfoot,tbody,table';\n        const firstAncestor = ancestor$1(edges.first, sectionSelector, isRoot);\n        const lastAncestor = ancestor$1(edges.last, sectionSelector, isRoot);\n        return firstAncestor.bind(fA => {\n          return lastAncestor.bind(lA => {\n            return eq$1(fA, lA) ? getBox(edges.table, edges.first, edges.last) : Optional.none();\n          });\n        });\n      });\n    };\n\n    const selection = identity;\n    const unmergable = selectedCells => {\n      const hasSpan = (elem, type) => getOpt(elem, type).exists(span => parseInt(span, 10) > 1);\n      const hasRowOrColSpan = elem => hasSpan(elem, 'rowspan') || hasSpan(elem, 'colspan');\n      return selectedCells.length > 0 && forall(selectedCells, hasRowOrColSpan) ? Optional.some(selectedCells) : Optional.none();\n    };\n    const mergable = (table, selectedCells, ephemera) => {\n      if (selectedCells.length <= 1) {\n        return Optional.none();\n      } else {\n        return retrieveBox(table, ephemera.firstSelectedSelector, ephemera.lastSelectedSelector).map(bounds => ({\n          bounds,\n          cells: selectedCells\n        }));\n      }\n    };\n\n    const strSelected = 'data-mce-selected';\n    const strSelectedSelector = 'td[' + strSelected + '],th[' + strSelected + ']';\n    const strAttributeSelector = '[' + strSelected + ']';\n    const strFirstSelected = 'data-mce-first-selected';\n    const strFirstSelectedSelector = 'td[' + strFirstSelected + '],th[' + strFirstSelected + ']';\n    const strLastSelected = 'data-mce-last-selected';\n    const strLastSelectedSelector = 'td[' + strLastSelected + '],th[' + strLastSelected + ']';\n    const attributeSelector = strAttributeSelector;\n    const ephemera = {\n      selected: strSelected,\n      selectedSelector: strSelectedSelector,\n      firstSelected: strFirstSelected,\n      firstSelectedSelector: strFirstSelectedSelector,\n      lastSelected: strLastSelected,\n      lastSelectedSelector: strLastSelectedSelector\n    };\n\n    const forMenu = (selectedCells, table, cell) => ({\n      element: cell,\n      mergable: mergable(table, selectedCells, ephemera),\n      unmergable: unmergable(selectedCells),\n      selection: selection(selectedCells)\n    });\n    const paste = (element, clipboard, generators) => ({\n      element,\n      clipboard,\n      generators\n    });\n    const pasteRows = (selectedCells, _cell, clipboard, generators) => ({\n      selection: selection(selectedCells),\n      clipboard,\n      generators\n    });\n\n    const getSelectionCellFallback = element => table(element).bind(table => retrieve(table, ephemera.firstSelectedSelector)).fold(constant(element), cells => cells[0]);\n    const getSelectionFromSelector = selector => (initCell, isRoot) => {\n      const cellName = name(initCell);\n      const cell = cellName === 'col' || cellName === 'colgroup' ? getSelectionCellFallback(initCell) : initCell;\n      return closest$1(cell, selector, isRoot);\n    };\n    const getSelectionCellOrCaption = getSelectionFromSelector('th,td,caption');\n    const getSelectionCell = getSelectionFromSelector('th,td');\n    const getCellsFromSelection = editor => fromDom(editor.model.table.getSelectedCells());\n    const getCellsFromFakeSelection = editor => filter$2(getCellsFromSelection(editor), cell => is$2(cell, ephemera.selectedSelector));\n\n    const extractSelected = cells => {\n      return table(cells[0]).map(table => {\n        const replica = extract$1(table, attributeSelector);\n        removeDataStyle(replica);\n        return [replica];\n      });\n    };\n    const serializeElements = (editor, elements) => map$1(elements, elm => editor.selection.serializer.serialize(elm.dom, {})).join('');\n    const getTextContent = elements => map$1(elements, element => element.dom.innerText).join('');\n    const registerEvents = (editor, actions) => {\n      editor.on('BeforeGetContent', e => {\n        const multiCellContext = cells => {\n          e.preventDefault();\n          extractSelected(cells).each(elements => {\n            e.content = e.format === 'text' ? getTextContent(elements) : serializeElements(editor, elements);\n          });\n        };\n        if (e.selection === true) {\n          const cells = getCellsFromFakeSelection(editor);\n          if (cells.length >= 1) {\n            multiCellContext(cells);\n          }\n        }\n      });\n      editor.on('BeforeSetContent', e => {\n        if (e.selection === true && e.paste === true) {\n          const selectedCells = getCellsFromSelection(editor);\n          head(selectedCells).each(cell => {\n            table(cell).each(table => {\n              const elements = filter$2(fromHtml(e.content), content => {\n                return name(content) !== 'meta';\n              });\n              const isTable = isTag('table');\n              if (shouldMergeContentOnPaste(editor) && elements.length === 1 && isTable(elements[0])) {\n                e.preventDefault();\n                const doc = SugarElement.fromDom(editor.getDoc());\n                const generators = paste$1(doc);\n                const targets = paste(cell, elements[0], generators);\n                actions.pasteCells(table, targets).each(() => {\n                  editor.focus();\n                });\n              }\n            });\n          });\n        }\n      });\n    };\n\n    const point = (element, offset) => ({\n      element,\n      offset\n    });\n\n    const scan$1 = (universe, element, direction) => {\n      if (universe.property().isText(element) && universe.property().getText(element).trim().length === 0 || universe.property().isComment(element)) {\n        return direction(element).bind(elem => {\n          return scan$1(universe, elem, direction).orThunk(() => {\n            return Optional.some(elem);\n          });\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const toEnd = (universe, element) => {\n      if (universe.property().isText(element)) {\n        return universe.property().getText(element).length;\n      }\n      const children = universe.property().children(element);\n      return children.length;\n    };\n    const freefallRtl$2 = (universe, element) => {\n      const candidate = scan$1(universe, element, universe.query().prevSibling).getOr(element);\n      if (universe.property().isText(candidate)) {\n        return point(candidate, toEnd(universe, candidate));\n      }\n      const children = universe.property().children(candidate);\n      return children.length > 0 ? freefallRtl$2(universe, children[children.length - 1]) : point(candidate, toEnd(universe, candidate));\n    };\n\n    const freefallRtl$1 = freefallRtl$2;\n\n    const universe$2 = DomUniverse();\n    const freefallRtl = element => {\n      return freefallRtl$1(universe$2, element);\n    };\n\n    const halve = (main, other) => {\n      if (!hasColspan(main)) {\n        const width = getGenericWidth(main);\n        width.each(w => {\n          const newWidth = w.value / 2;\n          setGenericWidth(main, newWidth, w.unit);\n          setGenericWidth(other, newWidth, w.unit);\n        });\n      }\n    };\n\n    const zero = array => map$1(array, constant(0));\n    const surround = (sizes, startIndex, endIndex, results, f) => f(sizes.slice(0, startIndex)).concat(results).concat(f(sizes.slice(endIndex)));\n    const clampDeltaHelper = predicate => (sizes, index, delta, minCellSize) => {\n      if (!predicate(delta)) {\n        return delta;\n      } else {\n        const newSize = Math.max(minCellSize, sizes[index] - Math.abs(delta));\n        const diff = Math.abs(newSize - sizes[index]);\n        return delta >= 0 ? diff : -diff;\n      }\n    };\n    const clampNegativeDelta = clampDeltaHelper(delta => delta < 0);\n    const clampDelta = clampDeltaHelper(always);\n    const resizeTable = () => {\n      const calcFixedDeltas = (sizes, index, next, delta, minCellSize) => {\n        const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);\n        return surround(sizes, index, next + 1, [\n          clampedDelta,\n          0\n        ], zero);\n      };\n      const calcRelativeDeltas = (sizes, index, delta, minCellSize) => {\n        const ratio = (100 + delta) / 100;\n        const newThis = Math.max(minCellSize, (sizes[index] + delta) / ratio);\n        return map$1(sizes, (size, idx) => {\n          const newSize = idx === index ? newThis : size / ratio;\n          return newSize - size;\n        });\n      };\n      const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize, isRelative) => {\n        if (isRelative) {\n          return calcRelativeDeltas(sizes, index, delta, minCellSize);\n        } else {\n          return calcFixedDeltas(sizes, index, next, delta, minCellSize);\n        }\n      };\n      const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize, isRelative) => calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize, isRelative);\n      const resizeTable = (resizer, delta) => resizer(delta);\n      const calcRightEdgeDeltas = (sizes, _prev, index, delta, minCellSize, isRelative) => {\n        if (isRelative) {\n          return calcRelativeDeltas(sizes, index, delta, minCellSize);\n        } else {\n          const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);\n          return zero(sizes.slice(0, index)).concat([clampedDelta]);\n        }\n      };\n      const calcRedestributedWidths = (sizes, totalWidth, pixelDelta, isRelative) => {\n        if (isRelative) {\n          const tableWidth = totalWidth + pixelDelta;\n          const ratio = tableWidth / totalWidth;\n          const newSizes = map$1(sizes, size => size / ratio);\n          return {\n            delta: ratio * 100 - 100,\n            newSizes\n          };\n        } else {\n          return {\n            delta: pixelDelta,\n            newSizes: sizes\n          };\n        }\n      };\n      return {\n        resizeTable,\n        clampTableDelta: clampNegativeDelta,\n        calcLeftEdgeDeltas,\n        calcMiddleDeltas,\n        calcRightEdgeDeltas,\n        calcRedestributedWidths\n      };\n    };\n    const preserveTable = () => {\n      const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize) => {\n        const idx = delta >= 0 ? next : index;\n        const clampedDelta = clampDelta(sizes, idx, delta, minCellSize);\n        return surround(sizes, index, next + 1, [\n          clampedDelta,\n          -clampedDelta\n        ], zero);\n      };\n      const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize) => calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize);\n      const resizeTable = (resizer, delta, isLastColumn) => {\n        if (isLastColumn) {\n          resizer(delta);\n        }\n      };\n      const calcRightEdgeDeltas = (sizes, _prev, _index, delta, _minCellSize, isRelative) => {\n        if (isRelative) {\n          return zero(sizes);\n        } else {\n          const diff = delta / sizes.length;\n          return map$1(sizes, constant(diff));\n        }\n      };\n      const clampTableDelta = (sizes, index, delta, minCellSize, isLastColumn) => {\n        if (isLastColumn) {\n          if (delta >= 0) {\n            return delta;\n          } else {\n            const maxDelta = foldl(sizes, (a, b) => a + b - minCellSize, 0);\n            return Math.max(-maxDelta, delta);\n          }\n        } else {\n          return clampNegativeDelta(sizes, index, delta, minCellSize);\n        }\n      };\n      const calcRedestributedWidths = (sizes, _totalWidth, _pixelDelta, _isRelative) => ({\n        delta: 0,\n        newSizes: sizes\n      });\n      return {\n        resizeTable,\n        clampTableDelta,\n        calcLeftEdgeDeltas,\n        calcMiddleDeltas,\n        calcRightEdgeDeltas,\n        calcRedestributedWidths\n      };\n    };\n\n    const getGridSize = table => {\n      const warehouse = Warehouse.fromTable(table);\n      return warehouse.grid;\n    };\n\n    const isHeaderCell = isTag('th');\n    const isHeaderCells = cells => forall(cells, cell => isHeaderCell(cell.element));\n    const getRowHeaderType = (isHeaderRow, isHeaderCells) => {\n      if (isHeaderRow && isHeaderCells) {\n        return 'sectionCells';\n      } else if (isHeaderRow) {\n        return 'section';\n      } else {\n        return 'cells';\n      }\n    };\n    const getRowType = row => {\n      const isHeaderRow = row.section === 'thead';\n      const isHeaderCells = is(findCommonCellType(row.cells), 'th');\n      if (row.section === 'tfoot') {\n        return { type: 'footer' };\n      } else if (isHeaderRow || isHeaderCells) {\n        return {\n          type: 'header',\n          subType: getRowHeaderType(isHeaderRow, isHeaderCells)\n        };\n      } else {\n        return { type: 'body' };\n      }\n    };\n    const findCommonCellType = cells => {\n      const headerCells = filter$2(cells, cell => isHeaderCell(cell.element));\n      if (headerCells.length === 0) {\n        return Optional.some('td');\n      } else if (headerCells.length === cells.length) {\n        return Optional.some('th');\n      } else {\n        return Optional.none();\n      }\n    };\n    const findCommonRowType = rows => {\n      const rowTypes = map$1(rows, row => getRowType(row).type);\n      const hasHeader = contains$2(rowTypes, 'header');\n      const hasFooter = contains$2(rowTypes, 'footer');\n      if (!hasHeader && !hasFooter) {\n        return Optional.some('body');\n      } else {\n        const hasBody = contains$2(rowTypes, 'body');\n        if (hasHeader && !hasBody && !hasFooter) {\n          return Optional.some('header');\n        } else if (!hasHeader && !hasBody && hasFooter) {\n          return Optional.some('footer');\n        } else {\n          return Optional.none();\n        }\n      }\n    };\n    const findTableRowHeaderType = warehouse => findMap(warehouse.all, row => {\n      const rowType = getRowType(row);\n      return rowType.type === 'header' ? Optional.from(rowType.subType) : Optional.none();\n    });\n\n    const transformCell = (cell, comparator, substitution) => elementnew(substitution(cell.element, comparator), true, cell.isLocked);\n    const transformRow = (row, section) => row.section !== section ? rowcells(row.element, row.cells, section, row.isNew) : row;\n    const section = () => ({\n      transformRow,\n      transformCell: (cell, comparator, substitution) => {\n        const newCell = substitution(cell.element, comparator);\n        const fixedCell = name(newCell) !== 'td' ? mutate$1(newCell, 'td') : newCell;\n        return elementnew(fixedCell, cell.isNew, cell.isLocked);\n      }\n    });\n    const sectionCells = () => ({\n      transformRow,\n      transformCell\n    });\n    const cells = () => ({\n      transformRow: (row, section) => {\n        const newSection = section === 'thead' ? 'tbody' : section;\n        return transformRow(row, newSection);\n      },\n      transformCell\n    });\n    const fallback = () => ({\n      transformRow: identity,\n      transformCell\n    });\n    const getTableSectionType = (table, fallback) => {\n      const warehouse = Warehouse.fromTable(table);\n      const type = findTableRowHeaderType(warehouse).getOr(fallback);\n      switch (type) {\n      case 'section':\n        return section();\n      case 'sectionCells':\n        return sectionCells();\n      case 'cells':\n        return cells();\n      }\n    };\n    const TableSection = {\n      getTableSectionType,\n      section,\n      sectionCells,\n      cells,\n      fallback\n    };\n\n    const setIfNot = (element, property, value, ignore) => {\n      if (value === ignore) {\n        remove$7(element, property);\n      } else {\n        set$2(element, property, value);\n      }\n    };\n    const insert$1 = (table, selector, element) => {\n      last$2(children(table, selector)).fold(() => prepend(table, element), child => after$5(child, element));\n    };\n    const generateSection = (table, sectionName) => {\n      const section = child(table, sectionName).getOrThunk(() => {\n        const newSection = SugarElement.fromTag(sectionName, owner(table).dom);\n        if (sectionName === 'thead') {\n          insert$1(table, 'caption,colgroup', newSection);\n        } else if (sectionName === 'colgroup') {\n          insert$1(table, 'caption', newSection);\n        } else {\n          append$1(table, newSection);\n        }\n        return newSection;\n      });\n      empty(section);\n      return section;\n    };\n    const render$1 = (table, grid) => {\n      const newRows = [];\n      const newCells = [];\n      const syncRows = gridSection => map$1(gridSection, row => {\n        if (row.isNew) {\n          newRows.push(row.element);\n        }\n        const tr = row.element;\n        empty(tr);\n        each$2(row.cells, cell => {\n          if (cell.isNew) {\n            newCells.push(cell.element);\n          }\n          setIfNot(cell.element, 'colspan', cell.colspan, 1);\n          setIfNot(cell.element, 'rowspan', cell.rowspan, 1);\n          append$1(tr, cell.element);\n        });\n        return tr;\n      });\n      const syncColGroup = gridSection => bind$2(gridSection, colGroup => map$1(colGroup.cells, col => {\n        setIfNot(col.element, 'span', col.colspan, 1);\n        return col.element;\n      }));\n      const renderSection = (gridSection, sectionName) => {\n        const section = generateSection(table, sectionName);\n        const sync = sectionName === 'colgroup' ? syncColGroup : syncRows;\n        const sectionElems = sync(gridSection);\n        append(section, sectionElems);\n      };\n      const removeSection = sectionName => {\n        child(table, sectionName).each(remove$6);\n      };\n      const renderOrRemoveSection = (gridSection, sectionName) => {\n        if (gridSection.length > 0) {\n          renderSection(gridSection, sectionName);\n        } else {\n          removeSection(sectionName);\n        }\n      };\n      const headSection = [];\n      const bodySection = [];\n      const footSection = [];\n      const columnGroupsSection = [];\n      each$2(grid, row => {\n        switch (row.section) {\n        case 'thead':\n          headSection.push(row);\n          break;\n        case 'tbody':\n          bodySection.push(row);\n          break;\n        case 'tfoot':\n          footSection.push(row);\n          break;\n        case 'colgroup':\n          columnGroupsSection.push(row);\n          break;\n        }\n      });\n      renderOrRemoveSection(columnGroupsSection, 'colgroup');\n      renderOrRemoveSection(headSection, 'thead');\n      renderOrRemoveSection(bodySection, 'tbody');\n      renderOrRemoveSection(footSection, 'tfoot');\n      return {\n        newRows,\n        newCells\n      };\n    };\n    const copy = grid => map$1(grid, row => {\n      const tr = shallow(row.element);\n      each$2(row.cells, cell => {\n        const clonedCell = deep(cell.element);\n        setIfNot(clonedCell, 'colspan', cell.colspan, 1);\n        setIfNot(clonedCell, 'rowspan', cell.rowspan, 1);\n        append$1(tr, clonedCell);\n      });\n      return tr;\n    });\n\n    const getColumn = (grid, index) => {\n      return map$1(grid, row => {\n        return getCell(row, index);\n      });\n    };\n    const getRow = (grid, index) => {\n      return grid[index];\n    };\n    const findDiff = (xs, comp) => {\n      if (xs.length === 0) {\n        return 0;\n      }\n      const first = xs[0];\n      const index = findIndex(xs, x => {\n        return !comp(first.element, x.element);\n      });\n      return index.getOr(xs.length);\n    };\n    const subgrid = (grid, row, column, comparator) => {\n      const gridRow = getRow(grid, row);\n      const isColRow = gridRow.section === 'colgroup';\n      const colspan = findDiff(gridRow.cells.slice(column), comparator);\n      const rowspan = isColRow ? 1 : findDiff(getColumn(grid.slice(row), column), comparator);\n      return {\n        colspan,\n        rowspan\n      };\n    };\n\n    const toDetails = (grid, comparator) => {\n      const seen = map$1(grid, row => map$1(row.cells, never));\n      const updateSeen = (rowIndex, columnIndex, rowspan, colspan) => {\n        for (let row = rowIndex; row < rowIndex + rowspan; row++) {\n          for (let column = columnIndex; column < columnIndex + colspan; column++) {\n            seen[row][column] = true;\n          }\n        }\n      };\n      return map$1(grid, (row, rowIndex) => {\n        const details = bind$2(row.cells, (cell, columnIndex) => {\n          if (seen[rowIndex][columnIndex] === false) {\n            const result = subgrid(grid, rowIndex, columnIndex, comparator);\n            updateSeen(rowIndex, columnIndex, result.rowspan, result.colspan);\n            return [detailnew(cell.element, result.rowspan, result.colspan, cell.isNew)];\n          } else {\n            return [];\n          }\n        });\n        return rowdetailnew(row.element, details, row.section, row.isNew);\n      });\n    };\n    const toGrid = (warehouse, generators, isNew) => {\n      const grid = [];\n      each$2(warehouse.colgroups, colgroup => {\n        const colgroupCols = [];\n        for (let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {\n          const element = Warehouse.getColumnAt(warehouse, columnIndex).map(column => elementnew(column.element, isNew, false)).getOrThunk(() => elementnew(generators.colGap(), true, false));\n          colgroupCols.push(element);\n        }\n        grid.push(rowcells(colgroup.element, colgroupCols, 'colgroup', isNew));\n      });\n      for (let rowIndex = 0; rowIndex < warehouse.grid.rows; rowIndex++) {\n        const rowCells = [];\n        for (let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {\n          const element = Warehouse.getAt(warehouse, rowIndex, columnIndex).map(item => elementnew(item.element, isNew, item.isLocked)).getOrThunk(() => elementnew(generators.gap(), true, false));\n          rowCells.push(element);\n        }\n        const rowDetail = warehouse.all[rowIndex];\n        const row = rowcells(rowDetail.element, rowCells, rowDetail.section, isNew);\n        grid.push(row);\n      }\n      return grid;\n    };\n\n    const fromWarehouse = (warehouse, generators) => toGrid(warehouse, generators, false);\n    const toDetailList = grid => toDetails(grid, eq$1);\n    const findInWarehouse = (warehouse, element) => findMap(warehouse.all, r => find$1(r.cells, e => eq$1(element, e.element)));\n    const extractCells = (warehouse, target, predicate) => {\n      const details = map$1(target.selection, cell$1 => {\n        return cell(cell$1).bind(lc => findInWarehouse(warehouse, lc)).filter(predicate);\n      });\n      const cells = cat(details);\n      return someIf(cells.length > 0, cells);\n    };\n    const run = (operation, extract, adjustment, postAction, genWrappers) => (table, target, generators, behaviours) => {\n      const warehouse = Warehouse.fromTable(table);\n      const tableSection = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.section).getOrThunk(TableSection.fallback);\n      const output = extract(warehouse, target).map(info => {\n        const model = fromWarehouse(warehouse, generators);\n        const result = operation(model, info, eq$1, genWrappers(generators), tableSection);\n        const lockedColumns = getLockedColumnsFromGrid(result.grid);\n        const grid = toDetailList(result.grid);\n        return {\n          info,\n          grid,\n          cursor: result.cursor,\n          lockedColumns\n        };\n      });\n      return output.bind(out => {\n        const newElements = render$1(table, out.grid);\n        const tableSizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.sizing).getOrThunk(() => TableSize.getTableSize(table));\n        const resizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.resize).getOrThunk(preserveTable);\n        adjustment(table, out.grid, out.info, {\n          sizing: tableSizing,\n          resize: resizing,\n          section: tableSection\n        });\n        postAction(table);\n        remove$7(table, LOCKED_COL_ATTR);\n        if (out.lockedColumns.length > 0) {\n          set$2(table, LOCKED_COL_ATTR, out.lockedColumns.join(','));\n        }\n        return Optional.some({\n          cursor: out.cursor,\n          newRows: newElements.newRows,\n          newCells: newElements.newCells\n        });\n      });\n    };\n    const onPaste = (warehouse, target) => cell(target.element).bind(cell => findInWarehouse(warehouse, cell).map(details => {\n      const value = {\n        ...details,\n        generators: target.generators,\n        clipboard: target.clipboard\n      };\n      return value;\n    }));\n    const onPasteByEditor = (warehouse, target) => extractCells(warehouse, target, always).map(cells => ({\n      cells,\n      generators: target.generators,\n      clipboard: target.clipboard\n    }));\n    const onMergable = (_warehouse, target) => target.mergable;\n    const onUnmergable = (_warehouse, target) => target.unmergable;\n    const onCells = (warehouse, target) => extractCells(warehouse, target, always);\n    const onUnlockedCells = (warehouse, target) => extractCells(warehouse, target, detail => !detail.isLocked);\n    const isUnlockedTableCell = (warehouse, cell) => findInWarehouse(warehouse, cell).exists(detail => !detail.isLocked);\n    const allUnlocked = (warehouse, cells) => forall(cells, cell => isUnlockedTableCell(warehouse, cell));\n    const onUnlockedMergable = (warehouse, target) => onMergable(warehouse, target).filter(mergeable => allUnlocked(warehouse, mergeable.cells));\n    const onUnlockedUnmergable = (warehouse, target) => onUnmergable(warehouse, target).filter(cells => allUnlocked(warehouse, cells));\n\n    const merge$2 = (grid, bounds, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      if (rows.length === 0) {\n        return grid;\n      }\n      for (let i = bounds.startRow; i <= bounds.finishRow; i++) {\n        for (let j = bounds.startCol; j <= bounds.finishCol; j++) {\n          const row = rows[i];\n          const isLocked = getCell(row, j).isLocked;\n          mutateCell(row, j, elementnew(substitution(), false, isLocked));\n        }\n      }\n      return grid;\n    };\n    const unmerge = (grid, target, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      let first = true;\n      for (let i = 0; i < rows.length; i++) {\n        for (let j = 0; j < cellLength(rows[0]); j++) {\n          const row = rows[i];\n          const currentCell = getCell(row, j);\n          const currentCellElm = currentCell.element;\n          const isToReplace = comparator(currentCellElm, target);\n          if (isToReplace && !first) {\n            mutateCell(row, j, elementnew(substitution(), true, currentCell.isLocked));\n          } else if (isToReplace) {\n            first = false;\n          }\n        }\n      }\n      return grid;\n    };\n    const uniqueCells = (row, comparator) => {\n      return foldl(row, (rest, cell) => {\n        return exists(rest, currentCell => {\n          return comparator(currentCell.element, cell.element);\n        }) ? rest : rest.concat([cell]);\n      }, []);\n    };\n    const splitCols = (grid, index, comparator, substitution) => {\n      if (index > 0 && index < grid[0].cells.length) {\n        each$2(grid, row => {\n          const prevCell = row.cells[index - 1];\n          let offset = 0;\n          const substitute = substitution();\n          while (row.cells.length > index + offset && comparator(prevCell.element, row.cells[index + offset].element)) {\n            mutateCell(row, index + offset, elementnew(substitute, true, row.cells[index + offset].isLocked));\n            offset++;\n          }\n        });\n      }\n      return grid;\n    };\n    const splitRows = (grid, index, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      if (index > 0 && index < rows.length) {\n        const rowPrevCells = rows[index - 1].cells;\n        const cells = uniqueCells(rowPrevCells, comparator);\n        each$2(cells, cell => {\n          let replacement = Optional.none();\n          for (let i = index; i < rows.length; i++) {\n            for (let j = 0; j < cellLength(rows[0]); j++) {\n              const row = rows[i];\n              const current = getCell(row, j);\n              const isToReplace = comparator(current.element, cell.element);\n              if (isToReplace) {\n                if (replacement.isNone()) {\n                  replacement = Optional.some(substitution());\n                }\n                replacement.each(sub => {\n                  mutateCell(row, j, elementnew(sub, true, current.isLocked));\n                });\n              }\n            }\n          }\n        });\n      }\n      return grid;\n    };\n\n    const value$1 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply,\n        orThunk: apply,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n    const Result = {\n      value: value$1,\n      error,\n      fromOption\n    };\n\n    const measure = (startAddress, gridA, gridB) => {\n      if (startAddress.row >= gridA.length || startAddress.column > cellLength(gridA[0])) {\n        return Result.error('invalid start address out of table bounds, row: ' + startAddress.row + ', column: ' + startAddress.column);\n      }\n      const rowRemainder = gridA.slice(startAddress.row);\n      const colRemainder = rowRemainder[0].cells.slice(startAddress.column);\n      const colRequired = cellLength(gridB[0]);\n      const rowRequired = gridB.length;\n      return Result.value({\n        rowDelta: rowRemainder.length - rowRequired,\n        colDelta: colRemainder.length - colRequired\n      });\n    };\n    const measureWidth = (gridA, gridB) => {\n      const colLengthA = cellLength(gridA[0]);\n      const colLengthB = cellLength(gridB[0]);\n      return {\n        rowDelta: 0,\n        colDelta: colLengthA - colLengthB\n      };\n    };\n    const measureHeight = (gridA, gridB) => {\n      const rowLengthA = gridA.length;\n      const rowLengthB = gridB.length;\n      return {\n        rowDelta: rowLengthA - rowLengthB,\n        colDelta: 0\n      };\n    };\n    const generateElements = (amount, row, generators, isLocked) => {\n      const generator = row.section === 'colgroup' ? generators.col : generators.cell;\n      return range$1(amount, idx => elementnew(generator(), true, isLocked(idx)));\n    };\n    const rowFill = (grid, amount, generators, lockedColumns) => {\n      const exampleRow = grid[grid.length - 1];\n      return grid.concat(range$1(amount, () => {\n        const generator = exampleRow.section === 'colgroup' ? generators.colgroup : generators.row;\n        const row = clone(exampleRow, generator, identity);\n        const elements = generateElements(row.cells.length, row, generators, idx => has$1(lockedColumns, idx.toString()));\n        return setCells(row, elements);\n      }));\n    };\n    const colFill = (grid, amount, generators, startIndex) => map$1(grid, row => {\n      const newChildren = generateElements(amount, row, generators, never);\n      return addCells(row, startIndex, newChildren);\n    });\n    const lockedColFill = (grid, generators, lockedColumns) => map$1(grid, row => {\n      return foldl(lockedColumns, (acc, colNum) => {\n        const newChild = generateElements(1, row, generators, always)[0];\n        return addCell(acc, colNum, newChild);\n      }, row);\n    });\n    const tailor = (gridA, delta, generators) => {\n      const fillCols = delta.colDelta < 0 ? colFill : identity;\n      const fillRows = delta.rowDelta < 0 ? rowFill : identity;\n      const lockedColumns = getLockedColumnsFromGrid(gridA);\n      const gridWidth = cellLength(gridA[0]);\n      const isLastColLocked = exists(lockedColumns, locked => locked === gridWidth - 1);\n      const modifiedCols = fillCols(gridA, Math.abs(delta.colDelta), generators, isLastColLocked ? gridWidth - 1 : gridWidth);\n      const newLockedColumns = getLockedColumnsFromGrid(modifiedCols);\n      return fillRows(modifiedCols, Math.abs(delta.rowDelta), generators, mapToObject(newLockedColumns, always));\n    };\n\n    const isSpanning = (grid, row, col, comparator) => {\n      const candidate = getCell(grid[row], col);\n      const matching = curry(comparator, candidate.element);\n      const currentRow = grid[row];\n      return grid.length > 1 && cellLength(currentRow) > 1 && (col > 0 && matching(getCellElement(currentRow, col - 1)) || col < currentRow.cells.length - 1 && matching(getCellElement(currentRow, col + 1)) || row > 0 && matching(getCellElement(grid[row - 1], col)) || row < grid.length - 1 && matching(getCellElement(grid[row + 1], col)));\n    };\n    const mergeTables = (startAddress, gridA, gridBRows, generator, comparator, lockedColumns) => {\n      const startRow = startAddress.row;\n      const startCol = startAddress.column;\n      const mergeHeight = gridBRows.length;\n      const mergeWidth = cellLength(gridBRows[0]);\n      const endRow = startRow + mergeHeight;\n      const endCol = startCol + mergeWidth + lockedColumns.length;\n      const lockedColumnObj = mapToObject(lockedColumns, always);\n      for (let r = startRow; r < endRow; r++) {\n        let skippedCol = 0;\n        for (let c = startCol; c < endCol; c++) {\n          if (lockedColumnObj[c]) {\n            skippedCol++;\n            continue;\n          }\n          if (isSpanning(gridA, r, c, comparator)) {\n            unmerge(gridA, getCellElement(gridA[r], c), comparator, generator.cell);\n          }\n          const gridBColIndex = c - startCol - skippedCol;\n          const newCell = getCell(gridBRows[r - startRow], gridBColIndex);\n          const newCellElm = newCell.element;\n          const replacement = generator.replace(newCellElm);\n          mutateCell(gridA[r], c, elementnew(replacement, true, newCell.isLocked));\n        }\n      }\n      return gridA;\n    };\n    const getValidStartAddress = (currentStartAddress, grid, lockedColumns) => {\n      const gridColLength = cellLength(grid[0]);\n      const adjustedRowAddress = extractGridDetails(grid).cols.length + currentStartAddress.row;\n      const possibleColAddresses = range$1(gridColLength - currentStartAddress.column, num => num + currentStartAddress.column);\n      const validColAddress = find$1(possibleColAddresses, num => forall(lockedColumns, col => col !== num)).getOr(gridColLength - 1);\n      return {\n        row: adjustedRowAddress,\n        column: validColAddress\n      };\n    };\n    const getLockedColumnsWithinBounds = (startAddress, rows, lockedColumns) => filter$2(lockedColumns, colNum => colNum >= startAddress.column && colNum <= cellLength(rows[0]) + startAddress.column);\n    const merge$1 = (startAddress, gridA, gridB, generator, comparator) => {\n      const lockedColumns = getLockedColumnsFromGrid(gridA);\n      const validStartAddress = getValidStartAddress(startAddress, gridA, lockedColumns);\n      const gridBRows = extractGridDetails(gridB).rows;\n      const lockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, lockedColumns);\n      const result = measure(validStartAddress, gridA, gridBRows);\n      return result.map(diff => {\n        const delta = {\n          ...diff,\n          colDelta: diff.colDelta - lockedColumnsWithinBounds.length\n        };\n        const fittedGrid = tailor(gridA, delta, generator);\n        const newLockedColumns = getLockedColumnsFromGrid(fittedGrid);\n        const newLockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, newLockedColumns);\n        return mergeTables(validStartAddress, fittedGrid, gridBRows, generator, comparator, newLockedColumnsWithinBounds);\n      });\n    };\n    const insertCols = (index, gridA, gridB, generator, comparator) => {\n      splitCols(gridA, index, comparator, generator.cell);\n      const delta = measureHeight(gridB, gridA);\n      const fittedNewGrid = tailor(gridB, delta, generator);\n      const secondDelta = measureHeight(gridA, fittedNewGrid);\n      const fittedOldGrid = tailor(gridA, secondDelta, generator);\n      return map$1(fittedOldGrid, (gridRow, i) => {\n        return addCells(gridRow, index, fittedNewGrid[i].cells);\n      });\n    };\n    const insertRows = (index, gridA, gridB, generator, comparator) => {\n      splitRows(gridA, index, comparator, generator.cell);\n      const locked = getLockedColumnsFromGrid(gridA);\n      const diff = measureWidth(gridA, gridB);\n      const delta = {\n        ...diff,\n        colDelta: diff.colDelta - locked.length\n      };\n      const fittedOldGrid = tailor(gridA, delta, generator);\n      const {\n        cols: oldCols,\n        rows: oldRows\n      } = extractGridDetails(fittedOldGrid);\n      const newLocked = getLockedColumnsFromGrid(fittedOldGrid);\n      const secondDiff = measureWidth(gridB, gridA);\n      const secondDelta = {\n        ...secondDiff,\n        colDelta: secondDiff.colDelta + newLocked.length\n      };\n      const fittedGridB = lockedColFill(gridB, generator, newLocked);\n      const fittedNewGrid = tailor(fittedGridB, secondDelta, generator);\n      return [\n        ...oldCols,\n        ...oldRows.slice(0, index),\n        ...fittedNewGrid,\n        ...oldRows.slice(index, oldRows.length)\n      ];\n    };\n\n    const cloneRow = (row, cloneCell, comparator, substitution) => clone(row, elem => substitution(elem, comparator), cloneCell);\n    const insertRowAt = (grid, index, example, comparator, substitution) => {\n      const {rows, cols} = extractGridDetails(grid);\n      const before = rows.slice(0, index);\n      const after = rows.slice(index);\n      const newRow = cloneRow(rows[example], (ex, c) => {\n        const withinSpan = index > 0 && index < rows.length && comparator(getCellElement(rows[index - 1], c), getCellElement(rows[index], c));\n        const ret = withinSpan ? getCell(rows[index], c) : elementnew(substitution(ex.element, comparator), true, ex.isLocked);\n        return ret;\n      }, comparator, substitution);\n      return [\n        ...cols,\n        ...before,\n        newRow,\n        ...after\n      ];\n    };\n    const getElementFor = (row, column, section, withinSpan, example, comparator, substitution) => {\n      if (section === 'colgroup' || !withinSpan) {\n        const cell = getCell(row, example);\n        return elementnew(substitution(cell.element, comparator), true, false);\n      } else {\n        return getCell(row, column);\n      }\n    };\n    const insertColumnAt = (grid, index, example, comparator, substitution) => map$1(grid, row => {\n      const withinSpan = index > 0 && index < cellLength(row) && comparator(getCellElement(row, index - 1), getCellElement(row, index));\n      const sub = getElementFor(row, index, row.section, withinSpan, example, comparator, substitution);\n      return addCell(row, index, sub);\n    });\n    const deleteColumnsAt = (grid, columns) => bind$2(grid, row => {\n      const existingCells = row.cells;\n      const cells = foldr(columns, (acc, column) => column >= 0 && column < acc.length ? acc.slice(0, column).concat(acc.slice(column + 1)) : acc, existingCells);\n      return cells.length > 0 ? [rowcells(row.element, cells, row.section, row.isNew)] : [];\n    });\n    const deleteRowsAt = (grid, start, finish) => {\n      const {rows, cols} = extractGridDetails(grid);\n      return [\n        ...cols,\n        ...rows.slice(0, start),\n        ...rows.slice(finish + 1)\n      ];\n    };\n\n    const notInStartRow = (grid, rowIndex, colIndex, comparator) => getCellElement(grid[rowIndex], colIndex) !== undefined && (rowIndex > 0 && comparator(getCellElement(grid[rowIndex - 1], colIndex), getCellElement(grid[rowIndex], colIndex)));\n    const notInStartColumn = (row, index, comparator) => index > 0 && comparator(getCellElement(row, index - 1), getCellElement(row, index));\n    const isDuplicatedCell = (grid, rowIndex, colIndex, comparator) => notInStartRow(grid, rowIndex, colIndex, comparator) || notInStartColumn(grid[rowIndex], colIndex, comparator);\n    const rowReplacerPredicate = (targetRow, columnHeaders) => {\n      const entireTableIsHeader = forall(columnHeaders, identity) && isHeaderCells(targetRow.cells);\n      return entireTableIsHeader ? always : (cell, _rowIndex, colIndex) => {\n        const type = name(cell.element);\n        return !(type === 'th' && columnHeaders[colIndex]);\n      };\n    };\n    const columnReplacePredicate = (targetColumn, rowHeaders) => {\n      const entireTableIsHeader = forall(rowHeaders, identity) && isHeaderCells(targetColumn);\n      return entireTableIsHeader ? always : (cell, rowIndex, _colIndex) => {\n        const type = name(cell.element);\n        return !(type === 'th' && rowHeaders[rowIndex]);\n      };\n    };\n    const determineScope = (applyScope, cell, newScope, isInHeader) => {\n      const hasSpan = scope => scope === 'row' ? hasRowspan(cell) : hasColspan(cell);\n      const getScope = scope => hasSpan(scope) ? `${ scope }group` : scope;\n      if (applyScope) {\n        return isHeaderCell(cell) ? getScope(newScope) : null;\n      } else if (isInHeader && isHeaderCell(cell)) {\n        const oppositeScope = newScope === 'row' ? 'col' : 'row';\n        return getScope(oppositeScope);\n      } else {\n        return null;\n      }\n    };\n    const rowScopeGenerator = (applyScope, columnHeaders) => (cell, rowIndex, columnIndex) => Optional.some(determineScope(applyScope, cell.element, 'col', columnHeaders[columnIndex]));\n    const columnScopeGenerator = (applyScope, rowHeaders) => (cell, rowIndex) => Optional.some(determineScope(applyScope, cell.element, 'row', rowHeaders[rowIndex]));\n    const replace = (cell, comparator, substitute) => elementnew(substitute(cell.element, comparator), true, cell.isLocked);\n    const replaceIn = (grid, targets, comparator, substitute, replacer, genScope, shouldReplace) => {\n      const isTarget = cell => {\n        return exists(targets, target => {\n          return comparator(cell.element, target.element);\n        });\n      };\n      return map$1(grid, (row, rowIndex) => {\n        return mapCells(row, (cell, colIndex) => {\n          if (isTarget(cell)) {\n            const newCell = shouldReplace(cell, rowIndex, colIndex) ? replacer(cell, comparator, substitute) : cell;\n            genScope(newCell, rowIndex, colIndex).each(scope => {\n              setOptions(newCell.element, { scope: Optional.from(scope) });\n            });\n            return newCell;\n          } else {\n            return cell;\n          }\n        });\n      });\n    };\n    const getColumnCells = (rows, columnIndex, comparator) => bind$2(rows, (row, i) => {\n      return isDuplicatedCell(rows, i, columnIndex, comparator) ? [] : [getCell(row, columnIndex)];\n    });\n    const getRowCells = (rows, rowIndex, comparator) => {\n      const targetRow = rows[rowIndex];\n      return bind$2(targetRow.cells, (item, i) => {\n        return isDuplicatedCell(rows, rowIndex, i, comparator) ? [] : [item];\n      });\n    };\n    const replaceColumns = (grid, indexes, applyScope, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      const targets = bind$2(indexes, index => getColumnCells(rows, index, comparator));\n      const rowHeaders = map$1(rows, row => isHeaderCells(row.cells));\n      const shouldReplaceCell = columnReplacePredicate(targets, rowHeaders);\n      const scopeGenerator = columnScopeGenerator(applyScope, rowHeaders);\n      return replaceIn(grid, targets, comparator, substitution, replace, scopeGenerator, shouldReplaceCell);\n    };\n    const replaceRows = (grid, indexes, section, applyScope, comparator, substitution, tableSection) => {\n      const {cols, rows} = extractGridDetails(grid);\n      const targetRow = rows[indexes[0]];\n      const targets = bind$2(indexes, index => getRowCells(rows, index, comparator));\n      const columnHeaders = map$1(targetRow.cells, (_cell, index) => isHeaderCells(getColumnCells(rows, index, comparator)));\n      const newRows = [...rows];\n      each$2(indexes, index => {\n        newRows[index] = tableSection.transformRow(rows[index], section);\n      });\n      const newGrid = [\n        ...cols,\n        ...newRows\n      ];\n      const shouldReplaceCell = rowReplacerPredicate(targetRow, columnHeaders);\n      const scopeGenerator = rowScopeGenerator(applyScope, columnHeaders);\n      return replaceIn(newGrid, targets, comparator, substitution, tableSection.transformCell, scopeGenerator, shouldReplaceCell);\n    };\n    const replaceCells = (grid, details, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      const targetCells = map$1(details, detail => getCell(rows[detail.row], detail.column));\n      return replaceIn(grid, targetCells, comparator, substitution, replace, Optional.none, always);\n    };\n\n    const generate = cases => {\n      if (!isArray(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$2(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate };\n\n    const adt$6 = Adt.generate([\n      { none: [] },\n      { only: ['index'] },\n      {\n        left: [\n          'index',\n          'next'\n        ]\n      },\n      {\n        middle: [\n          'prev',\n          'index',\n          'next'\n        ]\n      },\n      {\n        right: [\n          'prev',\n          'index'\n        ]\n      }\n    ]);\n    const ColumnContext = { ...adt$6 };\n\n    const neighbours = (input, index) => {\n      if (input.length === 0) {\n        return ColumnContext.none();\n      }\n      if (input.length === 1) {\n        return ColumnContext.only(0);\n      }\n      if (index === 0) {\n        return ColumnContext.left(0, 1);\n      }\n      if (index === input.length - 1) {\n        return ColumnContext.right(index - 1, index);\n      }\n      if (index > 0 && index < input.length - 1) {\n        return ColumnContext.middle(index - 1, index, index + 1);\n      }\n      return ColumnContext.none();\n    };\n    const determine = (input, column, step, tableSize, resize) => {\n      const result = input.slice(0);\n      const context = neighbours(input, column);\n      const onNone = constant(map$1(result, constant(0)));\n      const onOnly = index => tableSize.singleColumnWidth(result[index], step);\n      const onLeft = (index, next) => resize.calcLeftEdgeDeltas(result, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);\n      const onMiddle = (prev, index, next) => resize.calcMiddleDeltas(result, prev, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);\n      const onRight = (prev, index) => resize.calcRightEdgeDeltas(result, prev, index, step, tableSize.minCellWidth(), tableSize.isRelative);\n      return context.fold(onNone, onOnly, onLeft, onMiddle, onRight);\n    };\n\n    const total = (start, end, measures) => {\n      let r = 0;\n      for (let i = start; i < end; i++) {\n        r += measures[i] !== undefined ? measures[i] : 0;\n      }\n      return r;\n    };\n    const recalculateWidthForCells = (warehouse, widths) => {\n      const all = Warehouse.justCells(warehouse);\n      return map$1(all, cell => {\n        const width = total(cell.column, cell.column + cell.colspan, widths);\n        return {\n          element: cell.element,\n          width,\n          colspan: cell.colspan\n        };\n      });\n    };\n    const recalculateWidthForColumns = (warehouse, widths) => {\n      const groups = Warehouse.justColumns(warehouse);\n      return map$1(groups, (column, index) => ({\n        element: column.element,\n        width: widths[index],\n        colspan: column.colspan\n      }));\n    };\n    const recalculateHeightForCells = (warehouse, heights) => {\n      const all = Warehouse.justCells(warehouse);\n      return map$1(all, cell => {\n        const height = total(cell.row, cell.row + cell.rowspan, heights);\n        return {\n          element: cell.element,\n          height,\n          rowspan: cell.rowspan\n        };\n      });\n    };\n    const matchRowHeight = (warehouse, heights) => {\n      return map$1(warehouse.all, (row, i) => {\n        return {\n          element: row.element,\n          height: heights[i]\n        };\n      });\n    };\n\n    const sumUp = newSize => foldr(newSize, (b, a) => b + a, 0);\n    const recalculate = (warehouse, widths) => {\n      if (Warehouse.hasColumns(warehouse)) {\n        return recalculateWidthForColumns(warehouse, widths);\n      } else {\n        return recalculateWidthForCells(warehouse, widths);\n      }\n    };\n    const recalculateAndApply = (warehouse, widths, tableSize) => {\n      const newSizes = recalculate(warehouse, widths);\n      each$2(newSizes, cell => {\n        tableSize.setElementWidth(cell.element, cell.width);\n      });\n    };\n    const adjustWidth = (table, delta, index, resizing, tableSize) => {\n      const warehouse = Warehouse.fromTable(table);\n      const step = tableSize.getCellDelta(delta);\n      const widths = tableSize.getWidths(warehouse, tableSize);\n      const isLastColumn = index === warehouse.grid.columns - 1;\n      const clampedStep = resizing.clampTableDelta(widths, index, step, tableSize.minCellWidth(), isLastColumn);\n      const deltas = determine(widths, index, clampedStep, tableSize, resizing);\n      const newWidths = map$1(deltas, (dx, i) => dx + widths[i]);\n      recalculateAndApply(warehouse, newWidths, tableSize);\n      resizing.resizeTable(tableSize.adjustTableWidth, clampedStep, isLastColumn);\n    };\n    const adjustHeight = (table, delta, index, direction) => {\n      const warehouse = Warehouse.fromTable(table);\n      const heights = getPixelHeights(warehouse, table, direction);\n      const newHeights = map$1(heights, (dy, i) => index === i ? Math.max(delta + dy, minHeight()) : dy);\n      const newCellSizes = recalculateHeightForCells(warehouse, newHeights);\n      const newRowSizes = matchRowHeight(warehouse, newHeights);\n      each$2(newRowSizes, row => {\n        setHeight(row.element, row.height);\n      });\n      each$2(newCellSizes, cell => {\n        setHeight(cell.element, cell.height);\n      });\n      const total = sumUp(newHeights);\n      setHeight(table, total);\n    };\n    const adjustAndRedistributeWidths$1 = (_table, list, details, tableSize, resizeBehaviour) => {\n      const warehouse = Warehouse.generate(list);\n      const sizes = tableSize.getWidths(warehouse, tableSize);\n      const tablePixelWidth = tableSize.pixelWidth();\n      const {newSizes, delta} = resizeBehaviour.calcRedestributedWidths(sizes, tablePixelWidth, details.pixelDelta, tableSize.isRelative);\n      recalculateAndApply(warehouse, newSizes, tableSize);\n      tableSize.adjustTableWidth(delta);\n    };\n    const adjustWidthTo = (_table, list, _info, tableSize) => {\n      const warehouse = Warehouse.generate(list);\n      const widths = tableSize.getWidths(warehouse, tableSize);\n      recalculateAndApply(warehouse, widths, tableSize);\n    };\n\n    const uniqueColumns = details => {\n      const uniqueCheck = (rest, detail) => {\n        const columnExists = exists(rest, currentDetail => currentDetail.column === detail.column);\n        return columnExists ? rest : rest.concat([detail]);\n      };\n      return foldl(details, uniqueCheck, []).sort((detailA, detailB) => detailA.column - detailB.column);\n    };\n\n    const isCol = isTag('col');\n    const isColgroup = isTag('colgroup');\n    const isRow$1 = element => name(element) === 'tr' || isColgroup(element);\n    const elementToData = element => {\n      const colspan = getAttrValue(element, 'colspan', 1);\n      const rowspan = getAttrValue(element, 'rowspan', 1);\n      return {\n        element,\n        colspan,\n        rowspan\n      };\n    };\n    const modification = (generators, toData = elementToData) => {\n      const nuCell = data => isCol(data.element) ? generators.col(data) : generators.cell(data);\n      const nuRow = data => isColgroup(data.element) ? generators.colgroup(data) : generators.row(data);\n      const add = element => {\n        if (isRow$1(element)) {\n          return nuRow({ element });\n        } else {\n          const cell = element;\n          const replacement = nuCell(toData(cell));\n          recent = Optional.some({\n            item: cell,\n            replacement\n          });\n          return replacement;\n        }\n      };\n      let recent = Optional.none();\n      const getOrInit = (element, comparator) => {\n        return recent.fold(() => {\n          return add(element);\n        }, p => {\n          return comparator(element, p.item) ? p.replacement : add(element);\n        });\n      };\n      return { getOrInit };\n    };\n    const transform$1 = tag => {\n      return generators => {\n        const list = [];\n        const find = (element, comparator) => {\n          return find$1(list, x => {\n            return comparator(x.item, element);\n          });\n        };\n        const makeNew = element => {\n          const attrs = tag === 'td' ? { scope: null } : {};\n          const cell = generators.replace(element, tag, attrs);\n          list.push({\n            item: element,\n            sub: cell\n          });\n          return cell;\n        };\n        const replaceOrInit = (element, comparator) => {\n          if (isRow$1(element) || isCol(element)) {\n            return element;\n          } else {\n            const cell = element;\n            return find(cell, comparator).fold(() => {\n              return makeNew(cell);\n            }, p => {\n              return comparator(element, p.item) ? p.sub : makeNew(cell);\n            });\n          }\n        };\n        return { replaceOrInit };\n      };\n    };\n    const getScopeAttribute = cell => getOpt(cell, 'scope').map(attribute => attribute.substr(0, 3));\n    const merging = generators => {\n      const unmerge = cell => {\n        const scope = getScopeAttribute(cell);\n        scope.each(attribute => set$2(cell, 'scope', attribute));\n        return () => {\n          const raw = generators.cell({\n            element: cell,\n            colspan: 1,\n            rowspan: 1\n          });\n          remove$5(raw, 'width');\n          remove$5(cell, 'width');\n          scope.each(attribute => set$2(raw, 'scope', attribute));\n          return raw;\n        };\n      };\n      const merge = cells => {\n        const getScopeProperty = () => {\n          const stringAttributes = cat(map$1(cells, getScopeAttribute));\n          if (stringAttributes.length === 0) {\n            return Optional.none();\n          } else {\n            const baseScope = stringAttributes[0];\n            const scopes = [\n              'row',\n              'col'\n            ];\n            const isMixed = exists(stringAttributes, attribute => {\n              return attribute !== baseScope && contains$2(scopes, attribute);\n            });\n            return isMixed ? Optional.none() : Optional.from(baseScope);\n          }\n        };\n        remove$5(cells[0], 'width');\n        getScopeProperty().fold(() => remove$7(cells[0], 'scope'), attribute => set$2(cells[0], 'scope', attribute + 'group'));\n        return constant(cells[0]);\n      };\n      return {\n        unmerge,\n        merge\n      };\n    };\n    const Generators = {\n      modification,\n      transform: transform$1,\n      merging\n    };\n\n    const blockList = [\n      'body',\n      'p',\n      'div',\n      'article',\n      'aside',\n      'figcaption',\n      'figure',\n      'footer',\n      'header',\n      'nav',\n      'section',\n      'ol',\n      'ul',\n      'table',\n      'thead',\n      'tfoot',\n      'tbody',\n      'caption',\n      'tr',\n      'td',\n      'th',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'blockquote',\n      'pre',\n      'address'\n    ];\n    const isList$1 = (universe, item) => {\n      const tagName = universe.property().name(item);\n      return contains$2([\n        'ol',\n        'ul'\n      ], tagName);\n    };\n    const isBlock$1 = (universe, item) => {\n      const tagName = universe.property().name(item);\n      return contains$2(blockList, tagName);\n    };\n    const isEmptyTag$1 = (universe, item) => {\n      return contains$2([\n        'br',\n        'img',\n        'hr',\n        'input'\n      ], universe.property().name(item));\n    };\n\n    const universe$1 = DomUniverse();\n    const isBlock = element => {\n      return isBlock$1(universe$1, element);\n    };\n    const isList = element => {\n      return isList$1(universe$1, element);\n    };\n    const isEmptyTag = element => {\n      return isEmptyTag$1(universe$1, element);\n    };\n\n    const merge = cells => {\n      const isBr = isTag('br');\n      const advancedBr = children => {\n        return forall(children, c => {\n          return isBr(c) || isText(c) && get$6(c).trim().length === 0;\n        });\n      };\n      const isListItem = el => {\n        return name(el) === 'li' || ancestor$2(el, isList).isSome();\n      };\n      const siblingIsBlock = el => {\n        return nextSibling(el).map(rightSibling => {\n          if (isBlock(rightSibling)) {\n            return true;\n          }\n          if (isEmptyTag(rightSibling)) {\n            return name(rightSibling) === 'img' ? false : true;\n          }\n          return false;\n        }).getOr(false);\n      };\n      const markCell = cell => {\n        return last$1(cell).bind(rightEdge => {\n          const rightSiblingIsBlock = siblingIsBlock(rightEdge);\n          return parent(rightEdge).map(parent => {\n            return rightSiblingIsBlock === true || isListItem(parent) || isBr(rightEdge) || isBlock(parent) && !eq$1(cell, parent) ? [] : [SugarElement.fromTag('br')];\n          });\n        }).getOr([]);\n      };\n      const markContent = () => {\n        const content = bind$2(cells, cell => {\n          const children = children$2(cell);\n          return advancedBr(children) ? [] : children.concat(markCell(cell));\n        });\n        return content.length === 0 ? [SugarElement.fromTag('br')] : content;\n      };\n      const contents = markContent();\n      empty(cells[0]);\n      append(cells[0], contents);\n    };\n\n    const isEditable = elem => isEditable$1(elem, true);\n    const prune = table => {\n      const cells = cells$1(table);\n      if (cells.length === 0) {\n        remove$6(table);\n      }\n    };\n    const outcome = (grid, cursor) => ({\n      grid,\n      cursor\n    });\n    const findEditableCursorPosition = rows => findMap(rows, row => findMap(row.cells, cell => {\n      const elem = cell.element;\n      return someIf(isEditable(elem), elem);\n    }));\n    const elementFromGrid = (grid, row, column) => {\n      var _a, _b;\n      const rows = extractGridDetails(grid).rows;\n      return Optional.from((_b = (_a = rows[row]) === null || _a === void 0 ? void 0 : _a.cells[column]) === null || _b === void 0 ? void 0 : _b.element).filter(isEditable).orThunk(() => findEditableCursorPosition(rows));\n    };\n    const bundle = (grid, row, column) => {\n      const cursorElement = elementFromGrid(grid, row, column);\n      return outcome(grid, cursorElement);\n    };\n    const uniqueRows = details => {\n      const rowCompilation = (rest, detail) => {\n        const rowExists = exists(rest, currentDetail => currentDetail.row === detail.row);\n        return rowExists ? rest : rest.concat([detail]);\n      };\n      return foldl(details, rowCompilation, []).sort((detailA, detailB) => detailA.row - detailB.row);\n    };\n    const opInsertRowsBefore = (grid, details, comparator, genWrappers) => {\n      const targetIndex = details[0].row;\n      const rows = uniqueRows(details);\n      const newGrid = foldr(rows, (acc, row) => {\n        const newG = insertRowAt(acc.grid, targetIndex, row.row + acc.delta, comparator, genWrappers.getOrInit);\n        return {\n          grid: newG,\n          delta: acc.delta + 1\n        };\n      }, {\n        grid,\n        delta: 0\n      }).grid;\n      return bundle(newGrid, targetIndex, details[0].column);\n    };\n    const opInsertRowsAfter = (grid, details, comparator, genWrappers) => {\n      const rows = uniqueRows(details);\n      const target = rows[rows.length - 1];\n      const targetIndex = target.row + target.rowspan;\n      const newGrid = foldr(rows, (newG, row) => {\n        return insertRowAt(newG, targetIndex, row.row, comparator, genWrappers.getOrInit);\n      }, grid);\n      return bundle(newGrid, targetIndex, details[0].column);\n    };\n    const opInsertColumnsBefore = (grid, extractDetail, comparator, genWrappers) => {\n      const details = extractDetail.details;\n      const columns = uniqueColumns(details);\n      const targetIndex = columns[0].column;\n      const newGrid = foldr(columns, (acc, col) => {\n        const newG = insertColumnAt(acc.grid, targetIndex, col.column + acc.delta, comparator, genWrappers.getOrInit);\n        return {\n          grid: newG,\n          delta: acc.delta + 1\n        };\n      }, {\n        grid,\n        delta: 0\n      }).grid;\n      return bundle(newGrid, details[0].row, targetIndex);\n    };\n    const opInsertColumnsAfter = (grid, extractDetail, comparator, genWrappers) => {\n      const details = extractDetail.details;\n      const target = details[details.length - 1];\n      const targetIndex = target.column + target.colspan;\n      const columns = uniqueColumns(details);\n      const newGrid = foldr(columns, (newG, col) => {\n        return insertColumnAt(newG, targetIndex, col.column, comparator, genWrappers.getOrInit);\n      }, grid);\n      return bundle(newGrid, details[0].row, targetIndex);\n    };\n    const opMakeColumnsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const columns = uniqueColumns(details);\n      const columnIndexes = map$1(columns, detail => detail.column);\n      const newGrid = replaceColumns(initialGrid, columnIndexes, true, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opMakeCellsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opUnmakeColumnsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const columns = uniqueColumns(details);\n      const columnIndexes = map$1(columns, detail => detail.column);\n      const newGrid = replaceColumns(initialGrid, columnIndexes, false, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opUnmakeCellsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const makeRowsSection = (section, applyScope) => (initialGrid, details, comparator, genWrappers, tableSection) => {\n      const rows = uniqueRows(details);\n      const rowIndexes = map$1(rows, detail => detail.row);\n      const newGrid = replaceRows(initialGrid, rowIndexes, section, applyScope, comparator, genWrappers.replaceOrInit, tableSection);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opMakeRowsHeader = makeRowsSection('thead', true);\n    const opMakeRowsBody = makeRowsSection('tbody', false);\n    const opMakeRowsFooter = makeRowsSection('tfoot', false);\n    const opEraseColumns = (grid, extractDetail, _comparator, _genWrappers) => {\n      const columns = uniqueColumns(extractDetail.details);\n      const newGrid = deleteColumnsAt(grid, map$1(columns, column => column.column));\n      const maxColIndex = newGrid.length > 0 ? newGrid[0].cells.length - 1 : 0;\n      return bundle(newGrid, columns[0].row, Math.min(columns[0].column, maxColIndex));\n    };\n    const opEraseRows = (grid, details, _comparator, _genWrappers) => {\n      const rows = uniqueRows(details);\n      const newGrid = deleteRowsAt(grid, rows[0].row, rows[rows.length - 1].row);\n      const maxRowIndex = newGrid.length > 0 ? newGrid.length - 1 : 0;\n      return bundle(newGrid, Math.min(details[0].row, maxRowIndex), details[0].column);\n    };\n    const opMergeCells = (grid, mergable, comparator, genWrappers) => {\n      const cells = mergable.cells;\n      merge(cells);\n      const newGrid = merge$2(grid, mergable.bounds, comparator, genWrappers.merge(cells));\n      return outcome(newGrid, Optional.from(cells[0]));\n    };\n    const opUnmergeCells = (grid, unmergable, comparator, genWrappers) => {\n      const unmerge$1 = (b, cell) => unmerge(b, cell, comparator, genWrappers.unmerge(cell));\n      const newGrid = foldr(unmergable, unmerge$1, grid);\n      return outcome(newGrid, Optional.from(unmergable[0]));\n    };\n    const opPasteCells = (grid, pasteDetails, comparator, _genWrappers) => {\n      const gridify = (table, generators) => {\n        const wh = Warehouse.fromTable(table);\n        return toGrid(wh, generators, true);\n      };\n      const gridB = gridify(pasteDetails.clipboard, pasteDetails.generators);\n      const startAddress = address(pasteDetails.row, pasteDetails.column);\n      const mergedGrid = merge$1(startAddress, grid, gridB, pasteDetails.generators, comparator);\n      return mergedGrid.fold(() => outcome(grid, Optional.some(pasteDetails.element)), newGrid => {\n        return bundle(newGrid, pasteDetails.row, pasteDetails.column);\n      });\n    };\n    const gridifyRows = (rows, generators, context) => {\n      const pasteDetails = fromPastedRows(rows, context.section);\n      const wh = Warehouse.generate(pasteDetails);\n      return toGrid(wh, generators, true);\n    };\n    const opPasteColsBefore = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[0].column;\n      const context = rows[pasteDetails.cells[0].row];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertCols(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opPasteColsAfter = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[pasteDetails.cells.length - 1].column + pasteDetails.cells[pasteDetails.cells.length - 1].colspan;\n      const context = rows[pasteDetails.cells[0].row];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertCols(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opPasteRowsBefore = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[0].row;\n      const context = rows[index];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertRows(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opPasteRowsAfter = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[pasteDetails.cells.length - 1].row + pasteDetails.cells[pasteDetails.cells.length - 1].rowspan;\n      const context = rows[pasteDetails.cells[0].row];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertRows(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opGetColumnsType = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onCells(house, target);\n      return details.bind(selectedCells => {\n        const lastSelectedCell = selectedCells[selectedCells.length - 1];\n        const minColRange = selectedCells[0].column;\n        const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;\n        const selectedColumnCells = flatten(map$1(house.all, row => filter$2(row.cells, cell => cell.column >= minColRange && cell.column < maxColRange)));\n        return findCommonCellType(selectedColumnCells);\n      }).getOr('');\n    };\n    const opGetCellsType = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onCells(house, target);\n      return details.bind(findCommonCellType).getOr('');\n    };\n    const opGetRowsType = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onCells(house, target);\n      return details.bind(selectedCells => {\n        const lastSelectedCell = selectedCells[selectedCells.length - 1];\n        const minRowRange = selectedCells[0].row;\n        const maxRowRange = lastSelectedCell.row + lastSelectedCell.rowspan;\n        const selectedRows = house.all.slice(minRowRange, maxRowRange);\n        return findCommonRowType(selectedRows);\n      }).getOr('');\n    };\n    const resize = (table, list, details, behaviours) => adjustWidthTo(table, list, details, behaviours.sizing);\n    const adjustAndRedistributeWidths = (table, list, details, behaviours) => adjustAndRedistributeWidths$1(table, list, details, behaviours.sizing, behaviours.resize);\n    const firstColumnIsLocked = (_warehouse, details) => exists(details, detail => detail.column === 0 && detail.isLocked);\n    const lastColumnIsLocked = (warehouse, details) => exists(details, detail => detail.column + detail.colspan >= warehouse.grid.columns && detail.isLocked);\n    const getColumnsWidth = (warehouse, details) => {\n      const columns$1 = columns(warehouse);\n      const uniqueCols = uniqueColumns(details);\n      return foldl(uniqueCols, (acc, detail) => {\n        const column = columns$1[detail.column];\n        const colWidth = column.map(getOuter$2).getOr(0);\n        return acc + colWidth;\n      }, 0);\n    };\n    const insertColumnsExtractor = before => (warehouse, target) => onCells(warehouse, target).filter(details => {\n      const checkLocked = before ? firstColumnIsLocked : lastColumnIsLocked;\n      return !checkLocked(warehouse, details);\n    }).map(details => ({\n      details,\n      pixelDelta: getColumnsWidth(warehouse, details)\n    }));\n    const eraseColumnsExtractor = (warehouse, target) => onUnlockedCells(warehouse, target).map(details => ({\n      details,\n      pixelDelta: -getColumnsWidth(warehouse, details)\n    }));\n    const pasteColumnsExtractor = before => (warehouse, target) => onPasteByEditor(warehouse, target).filter(details => {\n      const checkLocked = before ? firstColumnIsLocked : lastColumnIsLocked;\n      return !checkLocked(warehouse, details.cells);\n    });\n    const headerCellGenerator = Generators.transform('th');\n    const bodyCellGenerator = Generators.transform('td');\n    const insertRowsBefore = run(opInsertRowsBefore, onCells, noop, noop, Generators.modification);\n    const insertRowsAfter = run(opInsertRowsAfter, onCells, noop, noop, Generators.modification);\n    const insertColumnsBefore = run(opInsertColumnsBefore, insertColumnsExtractor(true), adjustAndRedistributeWidths, noop, Generators.modification);\n    const insertColumnsAfter = run(opInsertColumnsAfter, insertColumnsExtractor(false), adjustAndRedistributeWidths, noop, Generators.modification);\n    const eraseColumns = run(opEraseColumns, eraseColumnsExtractor, adjustAndRedistributeWidths, prune, Generators.modification);\n    const eraseRows = run(opEraseRows, onCells, noop, prune, Generators.modification);\n    const makeColumnsHeader = run(opMakeColumnsHeader, onUnlockedCells, noop, noop, headerCellGenerator);\n    const unmakeColumnsHeader = run(opUnmakeColumnsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const makeRowsHeader = run(opMakeRowsHeader, onUnlockedCells, noop, noop, headerCellGenerator);\n    const makeRowsBody = run(opMakeRowsBody, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const makeRowsFooter = run(opMakeRowsFooter, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const makeCellsHeader = run(opMakeCellsHeader, onUnlockedCells, noop, noop, headerCellGenerator);\n    const unmakeCellsHeader = run(opUnmakeCellsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const mergeCells = run(opMergeCells, onUnlockedMergable, resize, noop, Generators.merging);\n    const unmergeCells = run(opUnmergeCells, onUnlockedUnmergable, resize, noop, Generators.merging);\n    const pasteCells = run(opPasteCells, onPaste, resize, noop, Generators.modification);\n    const pasteColsBefore = run(opPasteColsBefore, pasteColumnsExtractor(true), noop, noop, Generators.modification);\n    const pasteColsAfter = run(opPasteColsAfter, pasteColumnsExtractor(false), noop, noop, Generators.modification);\n    const pasteRowsBefore = run(opPasteRowsBefore, onPasteByEditor, noop, noop, Generators.modification);\n    const pasteRowsAfter = run(opPasteRowsAfter, onPasteByEditor, noop, noop, Generators.modification);\n    const getColumnsType = opGetColumnsType;\n    const getCellsType = opGetCellsType;\n    const getRowsType = opGetRowsType;\n\n    const fireNewRow = (editor, row) => editor.dispatch('NewRow', { node: row });\n    const fireNewCell = (editor, cell) => editor.dispatch('NewCell', { node: cell });\n    const fireTableModified = (editor, table, data) => {\n      editor.dispatch('TableModified', {\n        ...data,\n        table\n      });\n    };\n    const fireTableSelectionChange = (editor, cells, start, finish, otherCells) => {\n      editor.dispatch('TableSelectionChange', {\n        cells,\n        start,\n        finish,\n        otherCells\n      });\n    };\n    const fireTableSelectionClear = editor => {\n      editor.dispatch('TableSelectionClear');\n    };\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResizeStart', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const fireObjectResized = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResized', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const styleModified = {\n      structure: false,\n      style: true\n    };\n    const structureModified = {\n      structure: true,\n      style: false\n    };\n    const styleAndStructureModified = {\n      structure: true,\n      style: true\n    };\n\n    const get$5 = (editor, table) => {\n      if (isTablePercentagesForced(editor)) {\n        return TableSize.percentageSize(table);\n      } else if (isTablePixelsForced(editor)) {\n        return TableSize.pixelSize(table);\n      } else {\n        return TableSize.getTableSize(table);\n      }\n    };\n\n    const TableActions = (editor, resizeHandler, cellSelectionHandler) => {\n      const isTableBody = editor => name(getBody(editor)) === 'table';\n      const lastRowGuard = table => !isTableBody(editor) || getGridSize(table).rows > 1;\n      const lastColumnGuard = table => !isTableBody(editor) || getGridSize(table).columns > 1;\n      const cloneFormats = getTableCloneElements(editor);\n      const colMutationOp = isResizeTableColumnResizing(editor) ? noop : halve;\n      const getTableSectionType = table => {\n        switch (getTableHeaderType(editor)) {\n        case 'section':\n          return TableSection.section();\n        case 'sectionCells':\n          return TableSection.sectionCells();\n        case 'cells':\n          return TableSection.cells();\n        default:\n          return TableSection.getTableSectionType(table, 'section');\n        }\n      };\n      const setSelectionFromAction = (table, result) => result.cursor.fold(() => {\n        const cells = cells$1(table);\n        return head(cells).filter(inBody).map(firstCell => {\n          cellSelectionHandler.clearSelectedCells(table.dom);\n          const rng = editor.dom.createRng();\n          rng.selectNode(firstCell.dom);\n          editor.selection.setRng(rng);\n          set$2(firstCell, 'data-mce-selected', '1');\n          return rng;\n        });\n      }, cell => {\n        const des = freefallRtl(cell);\n        const rng = editor.dom.createRng();\n        rng.setStart(des.element.dom, des.offset);\n        rng.setEnd(des.element.dom, des.offset);\n        editor.selection.setRng(rng);\n        cellSelectionHandler.clearSelectedCells(table.dom);\n        return Optional.some(rng);\n      });\n      const execute = (operation, guard, mutate, effect) => (table, target, noEvents = false) => {\n        removeDataStyle(table);\n        const doc = SugarElement.fromDom(editor.getDoc());\n        const generators = cellOperations(mutate, doc, cloneFormats);\n        const behaviours = {\n          sizing: get$5(editor, table),\n          resize: isResizeTableColumnResizing(editor) ? resizeTable() : preserveTable(),\n          section: getTableSectionType(table)\n        };\n        return guard(table) ? operation(table, target, generators, behaviours).bind(result => {\n          resizeHandler.refresh(table.dom);\n          each$2(result.newRows, row => {\n            fireNewRow(editor, row.dom);\n          });\n          each$2(result.newCells, cell => {\n            fireNewCell(editor, cell.dom);\n          });\n          const range = setSelectionFromAction(table, result);\n          if (inBody(table)) {\n            removeDataStyle(table);\n            if (!noEvents) {\n              fireTableModified(editor, table.dom, effect);\n            }\n          }\n          return range.map(rng => ({\n            rng,\n            effect\n          }));\n        }) : Optional.none();\n      };\n      const deleteRow = execute(eraseRows, lastRowGuard, noop, structureModified);\n      const deleteColumn = execute(eraseColumns, lastColumnGuard, noop, structureModified);\n      const insertRowsBefore$1 = execute(insertRowsBefore, always, noop, structureModified);\n      const insertRowsAfter$1 = execute(insertRowsAfter, always, noop, structureModified);\n      const insertColumnsBefore$1 = execute(insertColumnsBefore, always, colMutationOp, structureModified);\n      const insertColumnsAfter$1 = execute(insertColumnsAfter, always, colMutationOp, structureModified);\n      const mergeCells$1 = execute(mergeCells, always, noop, structureModified);\n      const unmergeCells$1 = execute(unmergeCells, always, noop, structureModified);\n      const pasteColsBefore$1 = execute(pasteColsBefore, always, noop, structureModified);\n      const pasteColsAfter$1 = execute(pasteColsAfter, always, noop, structureModified);\n      const pasteRowsBefore$1 = execute(pasteRowsBefore, always, noop, structureModified);\n      const pasteRowsAfter$1 = execute(pasteRowsAfter, always, noop, structureModified);\n      const pasteCells$1 = execute(pasteCells, always, noop, styleAndStructureModified);\n      const makeCellsHeader$1 = execute(makeCellsHeader, always, noop, structureModified);\n      const unmakeCellsHeader$1 = execute(unmakeCellsHeader, always, noop, structureModified);\n      const makeColumnsHeader$1 = execute(makeColumnsHeader, always, noop, structureModified);\n      const unmakeColumnsHeader$1 = execute(unmakeColumnsHeader, always, noop, structureModified);\n      const makeRowsHeader$1 = execute(makeRowsHeader, always, noop, structureModified);\n      const makeRowsBody$1 = execute(makeRowsBody, always, noop, structureModified);\n      const makeRowsFooter$1 = execute(makeRowsFooter, always, noop, structureModified);\n      const getTableCellType = getCellsType;\n      const getTableColType = getColumnsType;\n      const getTableRowType = getRowsType;\n      return {\n        deleteRow,\n        deleteColumn,\n        insertRowsBefore: insertRowsBefore$1,\n        insertRowsAfter: insertRowsAfter$1,\n        insertColumnsBefore: insertColumnsBefore$1,\n        insertColumnsAfter: insertColumnsAfter$1,\n        mergeCells: mergeCells$1,\n        unmergeCells: unmergeCells$1,\n        pasteColsBefore: pasteColsBefore$1,\n        pasteColsAfter: pasteColsAfter$1,\n        pasteRowsBefore: pasteRowsBefore$1,\n        pasteRowsAfter: pasteRowsAfter$1,\n        pasteCells: pasteCells$1,\n        makeCellsHeader: makeCellsHeader$1,\n        unmakeCellsHeader: unmakeCellsHeader$1,\n        makeColumnsHeader: makeColumnsHeader$1,\n        unmakeColumnsHeader: unmakeColumnsHeader$1,\n        makeRowsHeader: makeRowsHeader$1,\n        makeRowsBody: makeRowsBody$1,\n        makeRowsFooter: makeRowsFooter$1,\n        getTableRowType,\n        getTableCellType,\n        getTableColType\n      };\n    };\n\n    const constrainSpan = (element, property, value) => {\n      const currentColspan = getAttrValue(element, property, 1);\n      if (value === 1 || currentColspan <= 1) {\n        remove$7(element, property);\n      } else {\n        set$2(element, property, Math.min(value, currentColspan));\n      }\n    };\n    const isColInRange = (minColRange, maxColRange) => cell => {\n      const endCol = cell.column + cell.colspan - 1;\n      const startCol = cell.column;\n      return endCol >= minColRange && startCol < maxColRange;\n    };\n    const generateColGroup = (house, minColRange, maxColRange) => {\n      if (Warehouse.hasColumns(house)) {\n        const colsToCopy = filter$2(Warehouse.justColumns(house), isColInRange(minColRange, maxColRange));\n        const copiedCols = map$1(colsToCopy, c => {\n          const clonedCol = deep(c.element);\n          constrainSpan(clonedCol, 'span', maxColRange - minColRange);\n          return clonedCol;\n        });\n        const fakeColgroup = SugarElement.fromTag('colgroup');\n        append(fakeColgroup, copiedCols);\n        return [fakeColgroup];\n      } else {\n        return [];\n      }\n    };\n    const generateRows = (house, minColRange, maxColRange) => map$1(house.all, row => {\n      const cellsToCopy = filter$2(row.cells, isColInRange(minColRange, maxColRange));\n      const copiedCells = map$1(cellsToCopy, cell => {\n        const clonedCell = deep(cell.element);\n        constrainSpan(clonedCell, 'colspan', maxColRange - minColRange);\n        return clonedCell;\n      });\n      const fakeTR = SugarElement.fromTag('tr');\n      append(fakeTR, copiedCells);\n      return fakeTR;\n    });\n    const copyCols = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onUnlockedCells(house, target);\n      return details.map(selectedCells => {\n        const lastSelectedCell = selectedCells[selectedCells.length - 1];\n        const minColRange = selectedCells[0].column;\n        const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;\n        const fakeColGroups = generateColGroup(house, minColRange, maxColRange);\n        const fakeRows = generateRows(house, minColRange, maxColRange);\n        return [\n          ...fakeColGroups,\n          ...fakeRows\n        ];\n      });\n    };\n\n    const copyRows = (table, target, generators) => {\n      const warehouse = Warehouse.fromTable(table);\n      const details = onCells(warehouse, target);\n      return details.bind(selectedCells => {\n        const grid = toGrid(warehouse, generators, false);\n        const rows = extractGridDetails(grid).rows;\n        const slicedGrid = rows.slice(selectedCells[0].row, selectedCells[selectedCells.length - 1].row + selectedCells[selectedCells.length - 1].rowspan);\n        const filteredGrid = bind$2(slicedGrid, row => {\n          const newCells = filter$2(row.cells, cell => !cell.isLocked);\n          return newCells.length > 0 ? [{\n              ...row,\n              cells: newCells\n            }] : [];\n        });\n        const slicedDetails = toDetailList(filteredGrid);\n        return someIf(slicedDetails.length > 0, slicedDetails);\n      }).map(slicedDetails => copy(slicedDetails));\n    };\n\n    const adt$5 = Adt.generate([\n      { invalid: ['raw'] },\n      { pixels: ['value'] },\n      { percent: ['value'] }\n    ]);\n    const validateFor = (suffix, type, value) => {\n      const rawAmount = value.substring(0, value.length - suffix.length);\n      const amount = parseFloat(rawAmount);\n      return rawAmount === amount.toString() ? type(amount) : adt$5.invalid(value);\n    };\n    const from = value => {\n      if (endsWith(value, '%')) {\n        return validateFor('%', adt$5.percent, value);\n      }\n      if (endsWith(value, 'px')) {\n        return validateFor('px', adt$5.pixels, value);\n      }\n      return adt$5.invalid(value);\n    };\n    const Size = {\n      ...adt$5,\n      from\n    };\n\n    const redistributeToPercent = (widths, totalWidth) => {\n      return map$1(widths, w => {\n        const colType = Size.from(w);\n        return colType.fold(() => {\n          return w;\n        }, px => {\n          const ratio = px / totalWidth * 100;\n          return ratio + '%';\n        }, pc => {\n          return pc + '%';\n        });\n      });\n    };\n    const redistributeToPx = (widths, totalWidth, newTotalWidth) => {\n      const scale = newTotalWidth / totalWidth;\n      return map$1(widths, w => {\n        const colType = Size.from(w);\n        return colType.fold(() => {\n          return w;\n        }, px => {\n          return px * scale + 'px';\n        }, pc => {\n          return pc / 100 * newTotalWidth + 'px';\n        });\n      });\n    };\n    const redistributeEmpty = (newWidthType, columns) => {\n      const f = newWidthType.fold(() => constant(''), pixels => {\n        const num = pixels / columns;\n        return constant(num + 'px');\n      }, () => {\n        const num = 100 / columns;\n        return constant(num + '%');\n      });\n      return range$1(columns, f);\n    };\n    const redistributeValues = (newWidthType, widths, totalWidth) => {\n      return newWidthType.fold(() => {\n        return widths;\n      }, px => {\n        return redistributeToPx(widths, totalWidth, px);\n      }, _pc => {\n        return redistributeToPercent(widths, totalWidth);\n      });\n    };\n    const redistribute$1 = (widths, totalWidth, newWidth) => {\n      const newType = Size.from(newWidth);\n      const floats = forall(widths, s => {\n        return s === '0px';\n      }) ? redistributeEmpty(newType, widths.length) : redistributeValues(newType, widths, totalWidth);\n      return normalize(floats);\n    };\n    const sum = (values, fallback) => {\n      if (values.length === 0) {\n        return fallback;\n      }\n      return foldr(values, (rest, v) => {\n        return Size.from(v).fold(constant(0), identity, identity) + rest;\n      }, 0);\n    };\n    const roundDown = (num, unit) => {\n      const floored = Math.floor(num);\n      return {\n        value: floored + unit,\n        remainder: num - floored\n      };\n    };\n    const add$3 = (value, amount) => {\n      return Size.from(value).fold(constant(value), px => {\n        return px + amount + 'px';\n      }, pc => {\n        return pc + amount + '%';\n      });\n    };\n    const normalize = values => {\n      if (values.length === 0) {\n        return values;\n      }\n      const scan = foldr(values, (rest, value) => {\n        const info = Size.from(value).fold(() => ({\n          value,\n          remainder: 0\n        }), num => roundDown(num, 'px'), num => ({\n          value: num + '%',\n          remainder: 0\n        }));\n        return {\n          output: [info.value].concat(rest.output),\n          remainder: rest.remainder + info.remainder\n        };\n      }, {\n        output: [],\n        remainder: 0\n      });\n      const r = scan.output;\n      return r.slice(0, r.length - 1).concat([add$3(r[r.length - 1], Math.round(scan.remainder))]);\n    };\n    const validate = Size.from;\n\n    const redistributeToW = (newWidths, cells, unit) => {\n      each$2(cells, cell => {\n        const widths = newWidths.slice(cell.column, cell.colspan + cell.column);\n        const w = sum(widths, minWidth());\n        set$1(cell.element, 'width', w + unit);\n      });\n    };\n    const redistributeToColumns = (newWidths, columns, unit) => {\n      each$2(columns, (column, index) => {\n        const width = sum([newWidths[index]], minWidth());\n        set$1(column.element, 'width', width + unit);\n      });\n    };\n    const redistributeToH = (newHeights, rows, cells, unit) => {\n      each$2(cells, cell => {\n        const heights = newHeights.slice(cell.row, cell.rowspan + cell.row);\n        const h = sum(heights, minHeight());\n        set$1(cell.element, 'height', h + unit);\n      });\n      each$2(rows, (row, i) => {\n        set$1(row.element, 'height', newHeights[i]);\n      });\n    };\n    const getUnit = newSize => {\n      return validate(newSize).fold(constant('px'), constant('px'), constant('%'));\n    };\n    const redistribute = (table, optWidth, optHeight) => {\n      const warehouse = Warehouse.fromTable(table);\n      const rows = warehouse.all;\n      const cells = Warehouse.justCells(warehouse);\n      const columns = Warehouse.justColumns(warehouse);\n      optWidth.each(newWidth => {\n        const widthUnit = getUnit(newWidth);\n        const totalWidth = get$9(table);\n        const oldWidths = getRawWidths(warehouse, table);\n        const nuWidths = redistribute$1(oldWidths, totalWidth, newWidth);\n        if (Warehouse.hasColumns(warehouse)) {\n          redistributeToColumns(nuWidths, columns, widthUnit);\n        } else {\n          redistributeToW(nuWidths, cells, widthUnit);\n        }\n        set$1(table, 'width', newWidth);\n      });\n      optHeight.each(newHeight => {\n        const hUnit = getUnit(newHeight);\n        const totalHeight = get$8(table);\n        const oldHeights = getRawHeights(warehouse, table, height);\n        const nuHeights = redistribute$1(oldHeights, totalHeight, newHeight);\n        redistributeToH(nuHeights, rows, cells, hUnit);\n        set$1(table, 'height', newHeight);\n      });\n    };\n    const isPercentSizing = isPercentSizing$1;\n    const isPixelSizing = isPixelSizing$1;\n    const isNoneSizing = isNoneSizing$1;\n\n    const cleanupLegacyAttributes = element => {\n      remove$7(element, 'width');\n    };\n    const convertToPercentSize = table => {\n      const newWidth = getPercentTableWidth(table);\n      redistribute(table, Optional.some(newWidth), Optional.none());\n      cleanupLegacyAttributes(table);\n    };\n    const convertToPixelSize = table => {\n      const newWidth = getPixelTableWidth(table);\n      redistribute(table, Optional.some(newWidth), Optional.none());\n      cleanupLegacyAttributes(table);\n    };\n    const convertToNoneSize = table => {\n      remove$5(table, 'width');\n      const columns = columns$1(table);\n      const rowElements = columns.length > 0 ? columns : cells$1(table);\n      each$2(rowElements, cell => {\n        remove$5(cell, 'width');\n        cleanupLegacyAttributes(cell);\n      });\n      cleanupLegacyAttributes(table);\n    };\n\n    const DefaultRenderOptions = {\n      styles: {\n        'border-collapse': 'collapse',\n        'width': '100%'\n      },\n      attributes: { border: '1' },\n      colGroups: false\n    };\n    const tableHeaderCell = () => SugarElement.fromTag('th');\n    const tableCell = () => SugarElement.fromTag('td');\n    const tableColumn = () => SugarElement.fromTag('col');\n    const createRow = (columns, rowHeaders, columnHeaders, rowIndex) => {\n      const tr = SugarElement.fromTag('tr');\n      for (let j = 0; j < columns; j++) {\n        const td = rowIndex < rowHeaders || j < columnHeaders ? tableHeaderCell() : tableCell();\n        if (j < columnHeaders) {\n          set$2(td, 'scope', 'row');\n        }\n        if (rowIndex < rowHeaders) {\n          set$2(td, 'scope', 'col');\n        }\n        append$1(td, SugarElement.fromTag('br'));\n        append$1(tr, td);\n      }\n      return tr;\n    };\n    const createGroupRow = columns => {\n      const columnGroup = SugarElement.fromTag('colgroup');\n      range$1(columns, () => append$1(columnGroup, tableColumn()));\n      return columnGroup;\n    };\n    const createRows = (rows, columns, rowHeaders, columnHeaders) => range$1(rows, r => createRow(columns, rowHeaders, columnHeaders, r));\n    const render = (rows, columns, rowHeaders, columnHeaders, headerType, renderOpts = DefaultRenderOptions) => {\n      const table = SugarElement.fromTag('table');\n      const rowHeadersGoInThead = headerType !== 'cells';\n      setAll(table, renderOpts.styles);\n      setAll$1(table, renderOpts.attributes);\n      if (renderOpts.colGroups) {\n        append$1(table, createGroupRow(columns));\n      }\n      const actualRowHeaders = Math.min(rows, rowHeaders);\n      if (rowHeadersGoInThead && rowHeaders > 0) {\n        const thead = SugarElement.fromTag('thead');\n        append$1(table, thead);\n        const theadRowHeaders = headerType === 'sectionCells' ? actualRowHeaders : 0;\n        const theadRows = createRows(rowHeaders, columns, theadRowHeaders, columnHeaders);\n        append(thead, theadRows);\n      }\n      const tbody = SugarElement.fromTag('tbody');\n      append$1(table, tbody);\n      const numRows = rowHeadersGoInThead ? rows - actualRowHeaders : rows;\n      const numRowHeaders = rowHeadersGoInThead ? 0 : rowHeaders;\n      const tbodyRows = createRows(numRows, columns, numRowHeaders, columnHeaders);\n      append(tbody, tbodyRows);\n      return table;\n    };\n\n    const get$4 = element => element.dom.innerHTML;\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$1(container, clone);\n      return get$4(container);\n    };\n\n    const placeCaretInCell = (editor, cell) => {\n      editor.selection.select(cell.dom, true);\n      editor.selection.collapse(true);\n    };\n    const selectFirstCellInTable = (editor, tableElm) => {\n      descendant(tableElm, 'td,th').each(curry(placeCaretInCell, editor));\n    };\n    const fireEvents = (editor, table) => {\n      each$2(descendants(table, 'tr'), row => {\n        fireNewRow(editor, row.dom);\n        each$2(descendants(row, 'th,td'), cell => {\n          fireNewCell(editor, cell.dom);\n        });\n      });\n    };\n    const isPercentage = width => isString(width) && width.indexOf('%') !== -1;\n    const insert = (editor, columns, rows, colHeaders, rowHeaders) => {\n      const defaultStyles = getTableDefaultStyles(editor);\n      const options = {\n        styles: defaultStyles,\n        attributes: getTableDefaultAttributes(editor),\n        colGroups: tableUseColumnGroup(editor)\n      };\n      editor.undoManager.ignore(() => {\n        const table = render(rows, columns, rowHeaders, colHeaders, getTableHeaderType(editor), options);\n        set$2(table, 'data-mce-id', '__mce');\n        const html = getOuter(table);\n        editor.insertContent(html);\n        editor.addVisual();\n      });\n      return descendant(getBody(editor), 'table[data-mce-id=\"__mce\"]').map(table => {\n        if (isTablePixelsForced(editor)) {\n          convertToPixelSize(table);\n        } else if (isTableResponsiveForced(editor)) {\n          convertToNoneSize(table);\n        } else if (isTablePercentagesForced(editor) || isPercentage(defaultStyles.width)) {\n          convertToPercentSize(table);\n        }\n        removeDataStyle(table);\n        remove$7(table, 'data-mce-id');\n        fireEvents(editor, table);\n        selectFirstCellInTable(editor, table);\n        return table.dom;\n      }).getOrNull();\n    };\n    const insertTable = (editor, rows, columns, options = {}) => {\n      const checkInput = val => isNumber(val) && val > 0;\n      if (checkInput(rows) && checkInput(columns)) {\n        const headerRows = options.headerRows || 0;\n        const headerColumns = options.headerColumns || 0;\n        return insert(editor, columns, rows, headerColumns, headerRows);\n      } else {\n        console.error('Invalid values for mceInsertTable - rows and columns values are required to insert a table.');\n        return null;\n      }\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.FakeClipboard');\n\n    const tableTypeBase = 'x-tinymce/dom-table-';\n    const tableTypeRow = tableTypeBase + 'rows';\n    const tableTypeColumn = tableTypeBase + 'columns';\n    const setData = items => {\n      const fakeClipboardItem = global.FakeClipboardItem(items);\n      global.write([fakeClipboardItem]);\n    };\n    const getData = type => {\n      var _a;\n      const items = (_a = global.read()) !== null && _a !== void 0 ? _a : [];\n      return findMap(items, item => Optional.from(item.getType(type)));\n    };\n    const clearData = type => {\n      if (getData(type).isSome()) {\n        global.clear();\n      }\n    };\n    const setRows = rowsOpt => {\n      rowsOpt.fold(clearRows, rows => setData({ [tableTypeRow]: rows }));\n    };\n    const getRows = () => getData(tableTypeRow);\n    const clearRows = () => clearData(tableTypeRow);\n    const setColumns = columnsOpt => {\n      columnsOpt.fold(clearColumns, columns => setData({ [tableTypeColumn]: columns }));\n    };\n    const getColumns = () => getData(tableTypeColumn);\n    const clearColumns = () => clearData(tableTypeColumn);\n\n    const getSelectionStartCellOrCaption = editor => getSelectionCellOrCaption(getSelectionStart(editor), getIsRoot(editor)).filter(isInEditableContext$1);\n    const getSelectionStartCell = editor => getSelectionCell(getSelectionStart(editor), getIsRoot(editor)).filter(isInEditableContext$1);\n    const registerCommands = (editor, actions) => {\n      const isRoot = getIsRoot(editor);\n      const eraseTable = () => getSelectionStartCellOrCaption(editor).each(cellOrCaption => {\n        table(cellOrCaption, isRoot).filter(not(isRoot)).each(table => {\n          const cursor = SugarElement.fromText('');\n          after$5(table, cursor);\n          remove$6(table);\n          if (editor.dom.isEmpty(editor.getBody())) {\n            editor.setContent('');\n            editor.selection.setCursorLocation();\n          } else {\n            const rng = editor.dom.createRng();\n            rng.setStart(cursor.dom, 0);\n            rng.setEnd(cursor.dom, 0);\n            editor.selection.setRng(rng);\n            editor.nodeChanged();\n          }\n        });\n      });\n      const setSizingMode = sizing => getSelectionStartCellOrCaption(editor).each(cellOrCaption => {\n        const isForcedSizing = isTableResponsiveForced(editor) || isTablePixelsForced(editor) || isTablePercentagesForced(editor);\n        if (!isForcedSizing) {\n          table(cellOrCaption, isRoot).each(table => {\n            if (sizing === 'relative' && !isPercentSizing(table)) {\n              convertToPercentSize(table);\n            } else if (sizing === 'fixed' && !isPixelSizing(table)) {\n              convertToPixelSize(table);\n            } else if (sizing === 'responsive' && !isNoneSizing(table)) {\n              convertToNoneSize(table);\n            }\n            removeDataStyle(table);\n            fireTableModified(editor, table.dom, structureModified);\n          });\n        }\n      });\n      const getTableFromCell = cell => table(cell, isRoot);\n      const performActionOnSelection = action => getSelectionStartCell(editor).bind(cell => getTableFromCell(cell).map(table => action(table, cell)));\n      const toggleTableClass = (_ui, clazz) => {\n        performActionOnSelection(table => {\n          editor.formatter.toggle('tableclass', { value: clazz }, table.dom);\n          fireTableModified(editor, table.dom, styleModified);\n        });\n      };\n      const toggleTableCellClass = (_ui, clazz) => {\n        performActionOnSelection(table => {\n          const selectedCells = getCellsFromSelection(editor);\n          const allHaveClass = forall(selectedCells, cell => editor.formatter.match('tablecellclass', { value: clazz }, cell.dom));\n          const formatterAction = allHaveClass ? editor.formatter.remove : editor.formatter.apply;\n          each$2(selectedCells, cell => formatterAction('tablecellclass', { value: clazz }, cell.dom));\n          fireTableModified(editor, table.dom, styleModified);\n        });\n      };\n      const toggleCaption = () => {\n        getSelectionStartCellOrCaption(editor).each(cellOrCaption => {\n          table(cellOrCaption, isRoot).each(table => {\n            child(table, 'caption').fold(() => {\n              const caption = SugarElement.fromTag('caption');\n              append$1(caption, SugarElement.fromText('Caption'));\n              appendAt(table, caption, 0);\n              editor.selection.setCursorLocation(caption.dom, 0);\n            }, caption => {\n              if (isTag('caption')(cellOrCaption)) {\n                one('td', table).each(td => editor.selection.setCursorLocation(td.dom, 0));\n              }\n              remove$6(caption);\n            });\n            fireTableModified(editor, table.dom, structureModified);\n          });\n        });\n      };\n      const postExecute = _data => {\n        editor.focus();\n      };\n      const actOnSelection = (execute, noEvents = false) => performActionOnSelection((table, startCell) => {\n        const targets = forMenu(getCellsFromSelection(editor), table, startCell);\n        execute(table, targets, noEvents).each(postExecute);\n      });\n      const copyRowSelection = () => performActionOnSelection((table, startCell) => {\n        const targets = forMenu(getCellsFromSelection(editor), table, startCell);\n        const generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), Optional.none());\n        return copyRows(table, targets, generators);\n      });\n      const copyColSelection = () => performActionOnSelection((table, startCell) => {\n        const targets = forMenu(getCellsFromSelection(editor), table, startCell);\n        return copyCols(table, targets);\n      });\n      const pasteOnSelection = (execute, getRows) => getRows().each(rows => {\n        const clonedRows = map$1(rows, row => deep(row));\n        performActionOnSelection((table, startCell) => {\n          const generators = paste$1(SugarElement.fromDom(editor.getDoc()));\n          const targets = pasteRows(getCellsFromSelection(editor), startCell, clonedRows, generators);\n          execute(table, targets).each(postExecute);\n        });\n      });\n      const actOnType = getAction => (_ui, args) => get$c(args, 'type').each(type => {\n        actOnSelection(getAction(type), args.no_events);\n      });\n      each$1({\n        mceTableSplitCells: () => actOnSelection(actions.unmergeCells),\n        mceTableMergeCells: () => actOnSelection(actions.mergeCells),\n        mceTableInsertRowBefore: () => actOnSelection(actions.insertRowsBefore),\n        mceTableInsertRowAfter: () => actOnSelection(actions.insertRowsAfter),\n        mceTableInsertColBefore: () => actOnSelection(actions.insertColumnsBefore),\n        mceTableInsertColAfter: () => actOnSelection(actions.insertColumnsAfter),\n        mceTableDeleteCol: () => actOnSelection(actions.deleteColumn),\n        mceTableDeleteRow: () => actOnSelection(actions.deleteRow),\n        mceTableCutCol: () => copyColSelection().each(selection => {\n          setColumns(selection);\n          actOnSelection(actions.deleteColumn);\n        }),\n        mceTableCutRow: () => copyRowSelection().each(selection => {\n          setRows(selection);\n          actOnSelection(actions.deleteRow);\n        }),\n        mceTableCopyCol: () => copyColSelection().each(selection => setColumns(selection)),\n        mceTableCopyRow: () => copyRowSelection().each(selection => setRows(selection)),\n        mceTablePasteColBefore: () => pasteOnSelection(actions.pasteColsBefore, getColumns),\n        mceTablePasteColAfter: () => pasteOnSelection(actions.pasteColsAfter, getColumns),\n        mceTablePasteRowBefore: () => pasteOnSelection(actions.pasteRowsBefore, getRows),\n        mceTablePasteRowAfter: () => pasteOnSelection(actions.pasteRowsAfter, getRows),\n        mceTableDelete: eraseTable,\n        mceTableCellToggleClass: toggleTableCellClass,\n        mceTableToggleClass: toggleTableClass,\n        mceTableToggleCaption: toggleCaption,\n        mceTableSizingMode: (_ui, sizing) => setSizingMode(sizing),\n        mceTableCellType: actOnType(type => type === 'th' ? actions.makeCellsHeader : actions.unmakeCellsHeader),\n        mceTableColType: actOnType(type => type === 'th' ? actions.makeColumnsHeader : actions.unmakeColumnsHeader),\n        mceTableRowType: actOnType(type => {\n          switch (type) {\n          case 'header':\n            return actions.makeRowsHeader;\n          case 'footer':\n            return actions.makeRowsFooter;\n          default:\n            return actions.makeRowsBody;\n          }\n        })\n      }, (func, name) => editor.addCommand(name, func));\n      editor.addCommand('mceInsertTable', (_ui, args) => {\n        insertTable(editor, args.rows, args.columns, args.options);\n      });\n      editor.addCommand('mceTableApplyCellStyle', (_ui, args) => {\n        const getFormatName = style => 'tablecell' + style.toLowerCase().replace('-', '');\n        if (!isObject(args)) {\n          return;\n        }\n        const cells = filter$2(getCellsFromSelection(editor), isInEditableContext$1);\n        if (cells.length === 0) {\n          return;\n        }\n        const validArgs = filter$1(args, (value, style) => editor.formatter.has(getFormatName(style)) && isString(value));\n        if (isEmpty(validArgs)) {\n          return;\n        }\n        each$1(validArgs, (value, style) => {\n          const formatName = getFormatName(style);\n          each$2(cells, cell => {\n            if (value === '') {\n              editor.formatter.remove(formatName, { value: null }, cell.dom, true);\n            } else {\n              editor.formatter.apply(formatName, { value }, cell.dom);\n            }\n          });\n        });\n        getTableFromCell(cells[0]).each(table => fireTableModified(editor, table.dom, styleModified));\n      });\n    };\n\n    const registerQueryCommands = (editor, actions) => {\n      const isRoot = getIsRoot(editor);\n      const lookupOnSelection = action => getSelectionCell(getSelectionStart(editor)).bind(cell => table(cell, isRoot).map(table => {\n        const targets = forMenu(getCellsFromSelection(editor), table, cell);\n        return action(table, targets);\n      })).getOr('');\n      each$1({\n        mceTableRowType: () => lookupOnSelection(actions.getTableRowType),\n        mceTableCellType: () => lookupOnSelection(actions.getTableCellType),\n        mceTableColType: () => lookupOnSelection(actions.getTableColType)\n      }, (func, name) => editor.addQueryValueHandler(name, func));\n    };\n\n    const adt$4 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata$1 = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$1 = situ => situ.fold(identity, identity, identity);\n    const before$2 = adt$4.before;\n    const on = adt$4.on;\n    const after$3 = adt$4.after;\n    const Situ = {\n      before: before$2,\n      on,\n      after: after$3,\n      cata: cata$1,\n      getStart: getStart$1\n    };\n\n    const create$4 = (selection, kill) => ({\n      selection,\n      kill\n    });\n    const Response = { create: create$4 };\n\n    const selectNode = (win, element) => {\n      const rng = win.document.createRange();\n      rng.selectNode(element.dom);\n      return rng;\n    };\n    const selectNodeContents = (win, element) => {\n      const rng = win.document.createRange();\n      selectNodeContentsUsing(rng, element);\n      return rng;\n    };\n    const selectNodeContentsUsing = (rng, element) => rng.selectNodeContents(element.dom);\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n    const toRect = rect => ({\n      left: rect.left,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      width: rect.width,\n      height: rect.height\n    });\n    const getFirstRect$1 = rng => {\n      const rects = rng.getClientRects();\n      const rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();\n      return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();\n    };\n\n    const adt$3 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n      } else {\n        return fromRange(win, adt$3.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    const asLtrRange = (win, selection) => {\n      const diagnosis = diagnose(win, selection);\n      return diagnosis.match({\n        ltr: (start, soffset, finish, foffset) => {\n          const rng = win.document.createRange();\n          rng.setStart(start.dom, soffset);\n          rng.setEnd(finish.dom, foffset);\n          return rng;\n        },\n        rtl: (start, soffset, finish, foffset) => {\n          const rng = win.document.createRange();\n          rng.setStart(finish.dom, foffset);\n          rng.setEnd(start.dom, soffset);\n          return rng;\n        }\n      });\n    };\n    adt$3.ltr;\n    adt$3.rtl;\n\n    const create$3 = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$3 };\n\n    const create$2 = (start, soffset, finish, foffset) => {\n      return {\n        start: Situ.on(start, soffset),\n        finish: Situ.on(finish, foffset)\n      };\n    };\n    const Situs = { create: create$2 };\n\n    const convertToRange = (win, selection) => {\n      const rng = asLtrRange(win, selection);\n      return SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset);\n    };\n    const makeSitus = Situs.create;\n\n    const sync = (container, isRoot, start, soffset, finish, foffset, selectRange) => {\n      if (!(eq$1(start, finish) && soffset === foffset)) {\n        return closest$1(start, 'td,th', isRoot).bind(s => {\n          return closest$1(finish, 'td,th', isRoot).bind(f => {\n            return detect(container, isRoot, s, f, selectRange);\n          });\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const detect = (container, isRoot, start, finish, selectRange) => {\n      if (!eq$1(start, finish)) {\n        return identify(start, finish, isRoot).bind(cellSel => {\n          const boxes = cellSel.boxes.getOr([]);\n          if (boxes.length > 1) {\n            selectRange(container, boxes, cellSel.start, cellSel.finish);\n            return Optional.some(Response.create(Optional.some(makeSitus(start, 0, start, getEnd(start))), true));\n          } else {\n            return Optional.none();\n          }\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const update = (rows, columns, container, selected, annotations) => {\n      const updateSelection = newSels => {\n        annotations.clearBeforeUpdate(container);\n        annotations.selectRange(container, newSels.boxes, newSels.start, newSels.finish);\n        return newSels.boxes;\n      };\n      return shiftSelection(selected, rows, columns, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(updateSelection);\n    };\n\n    const traverse = (item, mode) => ({\n      item,\n      mode\n    });\n    const backtrack = (universe, item, _direction, transition = sidestep) => {\n      return universe.property().parent(item).map(p => {\n        return traverse(p, transition);\n      });\n    };\n    const sidestep = (universe, item, direction, transition = advance) => {\n      return direction.sibling(universe, item).map(p => {\n        return traverse(p, transition);\n      });\n    };\n    const advance = (universe, item, direction, transition = advance) => {\n      const children = universe.property().children(item);\n      const result = direction.first(children);\n      return result.map(r => {\n        return traverse(r, transition);\n      });\n    };\n    const successors = [\n      {\n        current: backtrack,\n        next: sidestep,\n        fallback: Optional.none()\n      },\n      {\n        current: sidestep,\n        next: advance,\n        fallback: Optional.some(backtrack)\n      },\n      {\n        current: advance,\n        next: advance,\n        fallback: Optional.some(sidestep)\n      }\n    ];\n    const go = (universe, item, mode, direction, rules = successors) => {\n      const ruleOpt = find$1(rules, succ => {\n        return succ.current === mode;\n      });\n      return ruleOpt.bind(rule => {\n        return rule.current(universe, item, direction, rule.next).orThunk(() => {\n          return rule.fallback.bind(fb => {\n            return go(universe, item, fb, direction);\n          });\n        });\n      });\n    };\n\n    const left$1 = () => {\n      const sibling = (universe, item) => {\n        return universe.query().prevSibling(item);\n      };\n      const first = children => {\n        return children.length > 0 ? Optional.some(children[children.length - 1]) : Optional.none();\n      };\n      return {\n        sibling,\n        first\n      };\n    };\n    const right$1 = () => {\n      const sibling = (universe, item) => {\n        return universe.query().nextSibling(item);\n      };\n      const first = children => {\n        return children.length > 0 ? Optional.some(children[0]) : Optional.none();\n      };\n      return {\n        sibling,\n        first\n      };\n    };\n    const Walkers = {\n      left: left$1,\n      right: right$1\n    };\n\n    const hone = (universe, item, predicate, mode, direction, isRoot) => {\n      const next = go(universe, item, mode, direction);\n      return next.bind(n => {\n        if (isRoot(n.item)) {\n          return Optional.none();\n        } else {\n          return predicate(n.item) ? Optional.some(n.item) : hone(universe, n.item, predicate, n.mode, direction, isRoot);\n        }\n      });\n    };\n    const left = (universe, item, predicate, isRoot) => {\n      return hone(universe, item, predicate, sidestep, Walkers.left(), isRoot);\n    };\n    const right = (universe, item, predicate, isRoot) => {\n      return hone(universe, item, predicate, sidestep, Walkers.right(), isRoot);\n    };\n\n    const isLeaf = universe => element => universe.property().children(element).length === 0;\n    const before$1 = (universe, item, isRoot) => {\n      return seekLeft$1(universe, item, isLeaf(universe), isRoot);\n    };\n    const after$2 = (universe, item, isRoot) => {\n      return seekRight$1(universe, item, isLeaf(universe), isRoot);\n    };\n    const seekLeft$1 = left;\n    const seekRight$1 = right;\n\n    const universe = DomUniverse();\n    const before = (element, isRoot) => {\n      return before$1(universe, element, isRoot);\n    };\n    const after$1 = (element, isRoot) => {\n      return after$2(universe, element, isRoot);\n    };\n    const seekLeft = (element, predicate, isRoot) => {\n      return seekLeft$1(universe, element, predicate, isRoot);\n    };\n    const seekRight = (element, predicate, isRoot) => {\n      return seekRight$1(universe, element, predicate, isRoot);\n    };\n\n    const ancestor = (scope, predicate, isRoot) => ancestor$2(scope, predicate, isRoot).isSome();\n\n    const adt$2 = Adt.generate([\n      { none: ['message'] },\n      { success: [] },\n      { failedUp: ['cell'] },\n      { failedDown: ['cell'] }\n    ]);\n    const isOverlapping = (bridge, before, after) => {\n      const beforeBounds = bridge.getRect(before);\n      const afterBounds = bridge.getRect(after);\n      return afterBounds.right > beforeBounds.left && afterBounds.left < beforeBounds.right;\n    };\n    const isRow = elem => {\n      return closest$1(elem, 'tr');\n    };\n    const verify = (bridge, before, beforeOffset, after, afterOffset, failure, isRoot) => {\n      return closest$1(after, 'td,th', isRoot).bind(afterCell => {\n        return closest$1(before, 'td,th', isRoot).map(beforeCell => {\n          if (!eq$1(afterCell, beforeCell)) {\n            return sharedOne(isRow, [\n              afterCell,\n              beforeCell\n            ]).fold(() => {\n              return isOverlapping(bridge, beforeCell, afterCell) ? adt$2.success() : failure(beforeCell);\n            }, _sharedRow => {\n              return failure(beforeCell);\n            });\n          } else {\n            return eq$1(after, afterCell) && getEnd(afterCell) === afterOffset ? failure(beforeCell) : adt$2.none('in same cell');\n          }\n        });\n      }).getOr(adt$2.none('default'));\n    };\n    const cata = (subject, onNone, onSuccess, onFailedUp, onFailedDown) => {\n      return subject.fold(onNone, onSuccess, onFailedUp, onFailedDown);\n    };\n    const BeforeAfter = {\n      ...adt$2,\n      verify,\n      cata\n    };\n\n    const inParent = (parent, children, element, index) => ({\n      parent,\n      children,\n      element,\n      index\n    });\n    const indexInParent = element => parent(element).bind(parent => {\n      const children = children$2(parent);\n      return indexOf(children, element).map(index => inParent(parent, children, element, index));\n    });\n    const indexOf = (elements, element) => findIndex(elements, curry(eq$1, element));\n\n    const isBr = isTag('br');\n    const gatherer = (cand, gather, isRoot) => {\n      return gather(cand, isRoot).bind(target => {\n        return isText(target) && get$6(target).trim().length === 0 ? gatherer(target, gather, isRoot) : Optional.some(target);\n      });\n    };\n    const handleBr = (isRoot, element, direction) => {\n      return direction.traverse(element).orThunk(() => {\n        return gatherer(element, direction.gather, isRoot);\n      }).map(direction.relative);\n    };\n    const findBr = (element, offset) => {\n      return child$2(element, offset).filter(isBr).orThunk(() => {\n        return child$2(element, offset - 1).filter(isBr);\n      });\n    };\n    const handleParent = (isRoot, element, offset, direction) => {\n      return findBr(element, offset).bind(br => {\n        return direction.traverse(br).fold(() => {\n          return gatherer(br, direction.gather, isRoot).map(direction.relative);\n        }, adjacent => {\n          return indexInParent(adjacent).map(info => {\n            return Situ.on(info.parent, info.index);\n          });\n        });\n      });\n    };\n    const tryBr = (isRoot, element, offset, direction) => {\n      const target = isBr(element) ? handleBr(isRoot, element, direction) : handleParent(isRoot, element, offset, direction);\n      return target.map(tgt => {\n        return {\n          start: tgt,\n          finish: tgt\n        };\n      });\n    };\n    const process = analysis => {\n      return BeforeAfter.cata(analysis, _message => {\n        return Optional.none();\n      }, () => {\n        return Optional.none();\n      }, cell => {\n        return Optional.some(point(cell, 0));\n      }, cell => {\n        return Optional.some(point(cell, getEnd(cell)));\n      });\n    };\n\n    const moveDown = (caret, amount) => {\n      return {\n        left: caret.left,\n        top: caret.top + amount,\n        right: caret.right,\n        bottom: caret.bottom + amount\n      };\n    };\n    const moveUp = (caret, amount) => {\n      return {\n        left: caret.left,\n        top: caret.top - amount,\n        right: caret.right,\n        bottom: caret.bottom - amount\n      };\n    };\n    const translate = (caret, xDelta, yDelta) => {\n      return {\n        left: caret.left + xDelta,\n        top: caret.top + yDelta,\n        right: caret.right + xDelta,\n        bottom: caret.bottom + yDelta\n      };\n    };\n    const getTop = caret => {\n      return caret.top;\n    };\n    const getBottom = caret => {\n      return caret.bottom;\n    };\n\n    const getPartialBox = (bridge, element, offset) => {\n      if (offset >= 0 && offset < getEnd(element)) {\n        return bridge.getRangedRect(element, offset, element, offset + 1);\n      } else if (offset > 0) {\n        return bridge.getRangedRect(element, offset - 1, element, offset);\n      }\n      return Optional.none();\n    };\n    const toCaret = rect => ({\n      left: rect.left,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom\n    });\n    const getElemBox = (bridge, element) => {\n      return Optional.some(bridge.getRect(element));\n    };\n    const getBoxAt = (bridge, element, offset) => {\n      if (isElement(element)) {\n        return getElemBox(bridge, element).map(toCaret);\n      } else if (isText(element)) {\n        return getPartialBox(bridge, element, offset).map(toCaret);\n      } else {\n        return Optional.none();\n      }\n    };\n    const getEntireBox = (bridge, element) => {\n      if (isElement(element)) {\n        return getElemBox(bridge, element).map(toCaret);\n      } else if (isText(element)) {\n        return bridge.getRangedRect(element, 0, element, getEnd(element)).map(toCaret);\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const JUMP_SIZE = 5;\n    const NUM_RETRIES = 100;\n    const adt$1 = Adt.generate([\n      { none: [] },\n      { retry: ['caret'] }\n    ]);\n    const isOutside = (caret, box) => {\n      return caret.left < box.left || Math.abs(box.right - caret.left) < 1 || caret.left > box.right;\n    };\n    const inOutsideBlock = (bridge, element, caret) => {\n      return closest$2(element, isBlock).fold(never, cell => {\n        return getEntireBox(bridge, cell).exists(box => {\n          return isOutside(caret, box);\n        });\n      });\n    };\n    const adjustDown = (bridge, element, guessBox, original, caret) => {\n      const lowerCaret = moveDown(caret, JUMP_SIZE);\n      if (Math.abs(guessBox.bottom - original.bottom) < 1) {\n        return adt$1.retry(lowerCaret);\n      } else if (guessBox.top > caret.bottom) {\n        return adt$1.retry(lowerCaret);\n      } else if (guessBox.top === caret.bottom) {\n        return adt$1.retry(moveDown(caret, 1));\n      } else {\n        return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate(lowerCaret, JUMP_SIZE, 0)) : adt$1.none();\n      }\n    };\n    const adjustUp = (bridge, element, guessBox, original, caret) => {\n      const higherCaret = moveUp(caret, JUMP_SIZE);\n      if (Math.abs(guessBox.top - original.top) < 1) {\n        return adt$1.retry(higherCaret);\n      } else if (guessBox.bottom < caret.top) {\n        return adt$1.retry(higherCaret);\n      } else if (guessBox.bottom === caret.top) {\n        return adt$1.retry(moveUp(caret, 1));\n      } else {\n        return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate(higherCaret, JUMP_SIZE, 0)) : adt$1.none();\n      }\n    };\n    const upMovement = {\n      point: getTop,\n      adjuster: adjustUp,\n      move: moveUp,\n      gather: before\n    };\n    const downMovement = {\n      point: getBottom,\n      adjuster: adjustDown,\n      move: moveDown,\n      gather: after$1\n    };\n    const isAtTable = (bridge, x, y) => {\n      return bridge.elementFromPoint(x, y).filter(elm => {\n        return name(elm) === 'table';\n      }).isSome();\n    };\n    const adjustForTable = (bridge, movement, original, caret, numRetries) => {\n      return adjustTil(bridge, movement, original, movement.move(caret, JUMP_SIZE), numRetries);\n    };\n    const adjustTil = (bridge, movement, original, caret, numRetries) => {\n      if (numRetries === 0) {\n        return Optional.some(caret);\n      }\n      if (isAtTable(bridge, caret.left, movement.point(caret))) {\n        return adjustForTable(bridge, movement, original, caret, numRetries - 1);\n      }\n      return bridge.situsFromPoint(caret.left, movement.point(caret)).bind(guess => {\n        return guess.start.fold(Optional.none, element => {\n          return getEntireBox(bridge, element).bind(guessBox => {\n            return movement.adjuster(bridge, element, guessBox, original, caret).fold(Optional.none, newCaret => {\n              return adjustTil(bridge, movement, original, newCaret, numRetries - 1);\n            });\n          }).orThunk(() => {\n            return Optional.some(caret);\n          });\n        }, Optional.none);\n      });\n    };\n    const checkScroll = (movement, adjusted, bridge) => {\n      if (movement.point(adjusted) > bridge.getInnerHeight()) {\n        return Optional.some(movement.point(adjusted) - bridge.getInnerHeight());\n      } else if (movement.point(adjusted) < 0) {\n        return Optional.some(-movement.point(adjusted));\n      } else {\n        return Optional.none();\n      }\n    };\n    const retry = (movement, bridge, caret) => {\n      const moved = movement.move(caret, JUMP_SIZE);\n      const adjusted = adjustTil(bridge, movement, caret, moved, NUM_RETRIES).getOr(moved);\n      return checkScroll(movement, adjusted, bridge).fold(() => {\n        return bridge.situsFromPoint(adjusted.left, movement.point(adjusted));\n      }, delta => {\n        bridge.scrollBy(0, delta);\n        return bridge.situsFromPoint(adjusted.left, movement.point(adjusted) - delta);\n      });\n    };\n    const Retries = {\n      tryUp: curry(retry, upMovement),\n      tryDown: curry(retry, downMovement),\n      getJumpSize: constant(JUMP_SIZE)\n    };\n\n    const MAX_RETRIES = 20;\n    const findSpot = (bridge, isRoot, direction) => {\n      return bridge.getSelection().bind(sel => {\n        return tryBr(isRoot, sel.finish, sel.foffset, direction).fold(() => {\n          return Optional.some(point(sel.finish, sel.foffset));\n        }, brNeighbour => {\n          const range = bridge.fromSitus(brNeighbour);\n          const analysis = BeforeAfter.verify(bridge, sel.finish, sel.foffset, range.finish, range.foffset, direction.failure, isRoot);\n          return process(analysis);\n        });\n      });\n    };\n    const scan = (bridge, isRoot, element, offset, direction, numRetries) => {\n      if (numRetries === 0) {\n        return Optional.none();\n      }\n      return tryCursor(bridge, isRoot, element, offset, direction).bind(situs => {\n        const range = bridge.fromSitus(situs);\n        const analysis = BeforeAfter.verify(bridge, element, offset, range.finish, range.foffset, direction.failure, isRoot);\n        return BeforeAfter.cata(analysis, () => {\n          return Optional.none();\n        }, () => {\n          return Optional.some(situs);\n        }, cell => {\n          if (eq$1(element, cell) && offset === 0) {\n            return tryAgain(bridge, element, offset, moveUp, direction);\n          } else {\n            return scan(bridge, isRoot, cell, 0, direction, numRetries - 1);\n          }\n        }, cell => {\n          if (eq$1(element, cell) && offset === getEnd(cell)) {\n            return tryAgain(bridge, element, offset, moveDown, direction);\n          } else {\n            return scan(bridge, isRoot, cell, getEnd(cell), direction, numRetries - 1);\n          }\n        });\n      });\n    };\n    const tryAgain = (bridge, element, offset, move, direction) => {\n      return getBoxAt(bridge, element, offset).bind(box => {\n        return tryAt(bridge, direction, move(box, Retries.getJumpSize()));\n      });\n    };\n    const tryAt = (bridge, direction, box) => {\n      const browser = detect$2().browser;\n      if (browser.isChromium() || browser.isSafari() || browser.isFirefox()) {\n        return direction.retry(bridge, box);\n      } else {\n        return Optional.none();\n      }\n    };\n    const tryCursor = (bridge, isRoot, element, offset, direction) => {\n      return getBoxAt(bridge, element, offset).bind(box => {\n        return tryAt(bridge, direction, box);\n      });\n    };\n    const handle$1 = (bridge, isRoot, direction) => {\n      return findSpot(bridge, isRoot, direction).bind(spot => {\n        return scan(bridge, isRoot, spot.element, spot.offset, direction, MAX_RETRIES).map(bridge.fromSitus);\n      });\n    };\n\n    const inSameTable = (elem, table) => {\n      return ancestor(elem, e => {\n        return parent(e).exists(p => {\n          return eq$1(p, table);\n        });\n      });\n    };\n    const simulate = (bridge, isRoot, direction, initial, anchor) => {\n      return closest$1(initial, 'td,th', isRoot).bind(start => {\n        return closest$1(start, 'table', isRoot).bind(table => {\n          if (!inSameTable(anchor, table)) {\n            return Optional.none();\n          }\n          return handle$1(bridge, isRoot, direction).bind(range => {\n            return closest$1(range.finish, 'td,th', isRoot).map(finish => {\n              return {\n                start,\n                finish,\n                range\n              };\n            });\n          });\n        });\n      });\n    };\n    const navigate = (bridge, isRoot, direction, initial, anchor, precheck) => {\n      return precheck(initial, isRoot).orThunk(() => {\n        return simulate(bridge, isRoot, direction, initial, anchor).map(info => {\n          const range = info.range;\n          return Response.create(Optional.some(makeSitus(range.start, range.soffset, range.finish, range.foffset)), true);\n        });\n      });\n    };\n    const firstUpCheck = (initial, isRoot) => {\n      return closest$1(initial, 'tr', isRoot).bind(startRow => {\n        return closest$1(startRow, 'table', isRoot).bind(table => {\n          const rows = descendants(table, 'tr');\n          if (eq$1(startRow, rows[0])) {\n            return seekLeft(table, element => {\n              return last$1(element).isSome();\n            }, isRoot).map(last => {\n              const lastOffset = getEnd(last);\n              return Response.create(Optional.some(makeSitus(last, lastOffset, last, lastOffset)), true);\n            });\n          } else {\n            return Optional.none();\n          }\n        });\n      });\n    };\n    const lastDownCheck = (initial, isRoot) => {\n      return closest$1(initial, 'tr', isRoot).bind(startRow => {\n        return closest$1(startRow, 'table', isRoot).bind(table => {\n          const rows = descendants(table, 'tr');\n          if (eq$1(startRow, rows[rows.length - 1])) {\n            return seekRight(table, element => {\n              return first(element).isSome();\n            }, isRoot).map(first => {\n              return Response.create(Optional.some(makeSitus(first, 0, first, 0)), true);\n            });\n          } else {\n            return Optional.none();\n          }\n        });\n      });\n    };\n    const select = (bridge, container, isRoot, direction, initial, anchor, selectRange) => {\n      return simulate(bridge, isRoot, direction, initial, anchor).bind(info => {\n        return detect(container, isRoot, info.start, info.finish, selectRange);\n      });\n    };\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const findCell = (target, isRoot) => closest$1(target, 'td,th', isRoot);\n    const isInEditableContext = cell => parentElement(cell).exists(isEditable$1);\n    const MouseSelection = (bridge, container, isRoot, annotations) => {\n      const cursor = value();\n      const clearstate = cursor.clear;\n      const applySelection = event => {\n        cursor.on(start => {\n          annotations.clearBeforeUpdate(container);\n          findCell(event.target, isRoot).each(finish => {\n            identify(start, finish, isRoot).each(cellSel => {\n              const boxes = cellSel.boxes.getOr([]);\n              if (boxes.length === 1) {\n                const singleCell = boxes[0];\n                const isNonEditableCell = getRaw(singleCell) === 'false';\n                const isCellClosestContentEditable = is(closest(event.target), singleCell, eq$1);\n                if (isNonEditableCell && isCellClosestContentEditable) {\n                  annotations.selectRange(container, boxes, singleCell, singleCell);\n                  bridge.selectContents(singleCell);\n                }\n              } else if (boxes.length > 1) {\n                annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);\n                bridge.selectContents(finish);\n              }\n            });\n          });\n        });\n      };\n      const mousedown = event => {\n        annotations.clear(container);\n        findCell(event.target, isRoot).filter(isInEditableContext).each(cursor.set);\n      };\n      const mouseover = event => {\n        applySelection(event);\n      };\n      const mouseup = event => {\n        applySelection(event);\n        clearstate();\n      };\n      return {\n        clearstate,\n        mousedown,\n        mouseover,\n        mouseup\n      };\n    };\n\n    const down = {\n      traverse: nextSibling,\n      gather: after$1,\n      relative: Situ.before,\n      retry: Retries.tryDown,\n      failure: BeforeAfter.failedDown\n    };\n    const up = {\n      traverse: prevSibling,\n      gather: before,\n      relative: Situ.before,\n      retry: Retries.tryUp,\n      failure: BeforeAfter.failedUp\n    };\n\n    const isKey = key => {\n      return keycode => {\n        return keycode === key;\n      };\n    };\n    const isUp = isKey(38);\n    const isDown = isKey(40);\n    const isNavigation = keycode => {\n      return keycode >= 37 && keycode <= 40;\n    };\n    const ltr = {\n      isBackward: isKey(37),\n      isForward: isKey(39)\n    };\n    const rtl = {\n      isBackward: isKey(39),\n      isForward: isKey(37)\n    };\n\n    const get$3 = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const by = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollBy(x, y);\n      }\n    };\n\n    const adt = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt.domRange;\n    const relative = adt.relative;\n    const exact = adt.exact;\n    const getWin = selection => {\n      const start = getStart(selection);\n      return defaultView(start);\n    };\n    const range = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range\n    };\n\n    const caretPositionFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n        if (pos.offsetNode === null) {\n          return Optional.none();\n        }\n        const r = doc.dom.createRange();\n        r.setStart(pos.offsetNode, pos.offset);\n        r.collapse();\n        return Optional.some(r);\n      });\n    };\n    const caretRangeFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n    };\n    const availableSearch = (() => {\n      if (document.caretPositionFromPoint) {\n        return caretPositionFromPoint;\n      } else if (document.caretRangeFromPoint) {\n        return caretRangeFromPoint;\n      } else {\n        return Optional.none;\n      }\n    })();\n    const fromPoint = (win, x, y) => {\n      const doc = SugarElement.fromDom(win.document);\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n    };\n\n    const beforeSpecial = (element, offset) => {\n      const name$1 = name(element);\n      if ('input' === name$1) {\n        return Situ.after(element);\n      } else if (!contains$2([\n          'br',\n          'img'\n        ], name$1)) {\n        return Situ.on(element, offset);\n      } else {\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\n      }\n    };\n    const preprocessRelative = (startSitu, finishSitu) => {\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      return SimSelection.relative(start, finish);\n    };\n    const preprocessExact = (start, soffset, finish, foffset) => {\n      const startSitu = beforeSpecial(start, soffset);\n      const finishSitu = beforeSpecial(finish, foffset);\n      return SimSelection.relative(startSitu, finishSitu);\n    };\n\n    const makeRange = (start, soffset, finish, foffset) => {\n      const doc = owner(start);\n      const rng = doc.dom.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n    const after = (start, soffset, finish, foffset) => {\n      const r = makeRange(start, soffset, finish, foffset);\n      const same = eq$1(start, finish) && soffset === foffset;\n      return r.collapsed && !same;\n    };\n\n    const getNativeSelection = win => Optional.from(win.getSelection());\n    const doSetNativeRange = (win, rng) => {\n      getNativeSelection(win).each(selection => {\n        selection.removeAllRanges();\n        selection.addRange(rng);\n      });\n    };\n    const doSetRange = (win, start, soffset, finish, foffset) => {\n      const rng = exactToNative(win, start, soffset, finish, foffset);\n      doSetNativeRange(win, rng);\n    };\n    const setLegacyRtlRange = (win, selection, start, soffset, finish, foffset) => {\n      selection.collapse(start.dom, soffset);\n      selection.extend(finish.dom, foffset);\n    };\n    const setRangeFromRelative = (win, relative) => diagnose(win, relative).match({\n      ltr: (start, soffset, finish, foffset) => {\n        doSetRange(win, start, soffset, finish, foffset);\n      },\n      rtl: (start, soffset, finish, foffset) => {\n        getNativeSelection(win).each(selection => {\n          if (selection.setBaseAndExtent) {\n            selection.setBaseAndExtent(start.dom, soffset, finish.dom, foffset);\n          } else if (selection.extend) {\n            try {\n              setLegacyRtlRange(win, selection, start, soffset, finish, foffset);\n            } catch (e) {\n              doSetRange(win, finish, foffset, start, soffset);\n            }\n          } else {\n            doSetRange(win, finish, foffset, start, soffset);\n          }\n        });\n      }\n    });\n    const setExact = (win, start, soffset, finish, foffset) => {\n      const relative = preprocessExact(start, soffset, finish, foffset);\n      setRangeFromRelative(win, relative);\n    };\n    const setRelative = (win, startSitu, finishSitu) => {\n      const relative = preprocessRelative(startSitu, finishSitu);\n      setRangeFromRelative(win, relative);\n    };\n    const readRange = selection => {\n      if (selection.rangeCount > 0) {\n        const firstRng = selection.getRangeAt(0);\n        const lastRng = selection.getRangeAt(selection.rangeCount - 1);\n        return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const doGetExact = selection => {\n      if (selection.anchorNode === null || selection.focusNode === null) {\n        return readRange(selection);\n      } else {\n        const anchor = SugarElement.fromDom(selection.anchorNode);\n        const focus = SugarElement.fromDom(selection.focusNode);\n        return after(anchor, selection.anchorOffset, focus, selection.focusOffset) ? Optional.some(SimRange.create(anchor, selection.anchorOffset, focus, selection.focusOffset)) : readRange(selection);\n      }\n    };\n    const setToElement = (win, element, selectNodeContents$1 = true) => {\n      const rngGetter = selectNodeContents$1 ? selectNodeContents : selectNode;\n      const rng = rngGetter(win, element);\n      doSetNativeRange(win, rng);\n    };\n    const getExact = win => getNativeSelection(win).filter(sel => sel.rangeCount > 0).bind(doGetExact);\n    const get$2 = win => getExact(win).map(range => SimSelection.exact(range.start, range.soffset, range.finish, range.foffset));\n    const getFirstRect = (win, selection) => {\n      const rng = asLtrRange(win, selection);\n      return getFirstRect$1(rng);\n    };\n    const getAtPoint = (win, x, y) => fromPoint(win, x, y);\n    const clear = win => {\n      getNativeSelection(win).each(selection => selection.removeAllRanges());\n    };\n\n    const WindowBridge = win => {\n      const elementFromPoint = (x, y) => {\n        return SugarElement.fromPoint(SugarElement.fromDom(win.document), x, y);\n      };\n      const getRect = element => {\n        return element.dom.getBoundingClientRect();\n      };\n      const getRangedRect = (start, soffset, finish, foffset) => {\n        const sel = SimSelection.exact(start, soffset, finish, foffset);\n        return getFirstRect(win, sel);\n      };\n      const getSelection = () => {\n        return get$2(win).map(exactAdt => {\n          return convertToRange(win, exactAdt);\n        });\n      };\n      const fromSitus = situs => {\n        const relative = SimSelection.relative(situs.start, situs.finish);\n        return convertToRange(win, relative);\n      };\n      const situsFromPoint = (x, y) => {\n        return getAtPoint(win, x, y).map(exact => {\n          return Situs.create(exact.start, exact.soffset, exact.finish, exact.foffset);\n        });\n      };\n      const clearSelection = () => {\n        clear(win);\n      };\n      const collapseSelection = (toStart = false) => {\n        get$2(win).each(sel => sel.fold(rng => rng.collapse(toStart), (startSitu, finishSitu) => {\n          const situ = toStart ? startSitu : finishSitu;\n          setRelative(win, situ, situ);\n        }, (start, soffset, finish, foffset) => {\n          const node = toStart ? start : finish;\n          const offset = toStart ? soffset : foffset;\n          setExact(win, node, offset, node, offset);\n        }));\n      };\n      const selectNode = element => {\n        setToElement(win, element, false);\n      };\n      const selectContents = element => {\n        setToElement(win, element);\n      };\n      const setSelection = sel => {\n        setExact(win, sel.start, sel.soffset, sel.finish, sel.foffset);\n      };\n      const setRelativeSelection = (start, finish) => {\n        setRelative(win, start, finish);\n      };\n      const getInnerHeight = () => {\n        return win.innerHeight;\n      };\n      const getScrollY = () => {\n        const pos = get$3(SugarElement.fromDom(win.document));\n        return pos.top;\n      };\n      const scrollBy = (x, y) => {\n        by(x, y, SugarElement.fromDom(win.document));\n      };\n      return {\n        elementFromPoint,\n        getRect,\n        getRangedRect,\n        getSelection,\n        fromSitus,\n        situsFromPoint,\n        clearSelection,\n        collapseSelection,\n        setSelection,\n        setRelativeSelection,\n        selectNode,\n        selectContents,\n        getInnerHeight,\n        getScrollY,\n        scrollBy\n      };\n    };\n\n    const rc = (rows, cols) => ({\n      rows,\n      cols\n    });\n    const mouse = (win, container, isRoot, annotations) => {\n      const bridge = WindowBridge(win);\n      const handlers = MouseSelection(bridge, container, isRoot, annotations);\n      return {\n        clearstate: handlers.clearstate,\n        mousedown: handlers.mousedown,\n        mouseover: handlers.mouseover,\n        mouseup: handlers.mouseup\n      };\n    };\n    const isEditableNode = node => closest$2(node, isHTMLElement).exists(isEditable$1);\n    const isEditableSelection = (start, finish) => isEditableNode(start) || isEditableNode(finish);\n    const keyboard = (win, container, isRoot, annotations) => {\n      const bridge = WindowBridge(win);\n      const clearToNavigate = () => {\n        annotations.clear(container);\n        return Optional.none();\n      };\n      const keydown = (event, start, soffset, finish, foffset, direction) => {\n        const realEvent = event.raw;\n        const keycode = realEvent.which;\n        const shiftKey = realEvent.shiftKey === true;\n        const handler = retrieve$1(container, annotations.selectedSelector).fold(() => {\n          if (isNavigation(keycode) && !shiftKey) {\n            annotations.clearBeforeUpdate(container);\n          }\n          if (isNavigation(keycode) && shiftKey && !isEditableSelection(start, finish)) {\n            return Optional.none;\n          } else if (isDown(keycode) && shiftKey) {\n            return curry(select, bridge, container, isRoot, down, finish, start, annotations.selectRange);\n          } else if (isUp(keycode) && shiftKey) {\n            return curry(select, bridge, container, isRoot, up, finish, start, annotations.selectRange);\n          } else if (isDown(keycode)) {\n            return curry(navigate, bridge, isRoot, down, finish, start, lastDownCheck);\n          } else if (isUp(keycode)) {\n            return curry(navigate, bridge, isRoot, up, finish, start, firstUpCheck);\n          } else {\n            return Optional.none;\n          }\n        }, selected => {\n          const update$1 = attempts => {\n            return () => {\n              const navigation = findMap(attempts, delta => {\n                return update(delta.rows, delta.cols, container, selected, annotations);\n              });\n              return navigation.fold(() => {\n                return getEdges(container, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(edges => {\n                  const relative = isDown(keycode) || direction.isForward(keycode) ? Situ.after : Situ.before;\n                  bridge.setRelativeSelection(Situ.on(edges.first, 0), relative(edges.table));\n                  annotations.clear(container);\n                  return Response.create(Optional.none(), true);\n                });\n              }, _ => {\n                return Optional.some(Response.create(Optional.none(), true));\n              });\n            };\n          };\n          if (isNavigation(keycode) && shiftKey && !isEditableSelection(start, finish)) {\n            return Optional.none;\n          } else if (isDown(keycode) && shiftKey) {\n            return update$1([rc(+1, 0)]);\n          } else if (isUp(keycode) && shiftKey) {\n            return update$1([rc(-1, 0)]);\n          } else if (direction.isBackward(keycode) && shiftKey) {\n            return update$1([\n              rc(0, -1),\n              rc(-1, 0)\n            ]);\n          } else if (direction.isForward(keycode) && shiftKey) {\n            return update$1([\n              rc(0, +1),\n              rc(+1, 0)\n            ]);\n          } else if (isNavigation(keycode) && !shiftKey) {\n            return clearToNavigate;\n          } else {\n            return Optional.none;\n          }\n        });\n        return handler();\n      };\n      const keyup = (event, start, soffset, finish, foffset) => {\n        return retrieve$1(container, annotations.selectedSelector).fold(() => {\n          const realEvent = event.raw;\n          const keycode = realEvent.which;\n          const shiftKey = realEvent.shiftKey === true;\n          if (!shiftKey) {\n            return Optional.none();\n          }\n          if (isNavigation(keycode) && isEditableSelection(start, finish)) {\n            return sync(container, isRoot, start, soffset, finish, foffset, annotations.selectRange);\n          } else {\n            return Optional.none();\n          }\n        }, Optional.none);\n      };\n      return {\n        keydown,\n        keyup\n      };\n    };\n    const external = (win, container, isRoot, annotations) => {\n      const bridge = WindowBridge(win);\n      return (start, finish) => {\n        annotations.clearBeforeUpdate(container);\n        identify(start, finish, isRoot).each(cellSel => {\n          const boxes = cellSel.boxes.getOr([]);\n          annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);\n          bridge.selectContents(finish);\n          bridge.collapseSelection();\n        });\n      };\n    };\n\n    const read = (element, attr) => {\n      const value = get$b(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$2 = (element, attr, id) => {\n      const old = read(element, attr);\n      const nu = old.concat([id]);\n      set$2(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$4 = (element, attr, id) => {\n      const nu = filter$2(read(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$2(element, attr, nu.join(' '));\n      } else {\n        remove$7(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$1 = element => read(element, 'class');\n    const add$1 = (element, clazz) => add$2(element, 'class', clazz);\n    const remove$3 = (element, clazz) => remove$4(element, 'class', clazz);\n\n    const add = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$1(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$1(element);\n      if (classList.length === 0) {\n        remove$7(element, 'class');\n      }\n    };\n    const remove$2 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$3(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const remove$1 = (element, classes) => {\n      each$2(classes, x => {\n        remove$2(element, x);\n      });\n    };\n\n    const addClass = clazz => element => {\n      add(element, clazz);\n    };\n    const removeClasses = classes => element => {\n      remove$1(element, classes);\n    };\n\n    const byClass = ephemera => {\n      const addSelectionClass = addClass(ephemera.selected);\n      const removeSelectionClasses = removeClasses([\n        ephemera.selected,\n        ephemera.lastSelected,\n        ephemera.firstSelected\n      ]);\n      const clear = container => {\n        const sels = descendants(container, ephemera.selectedSelector);\n        each$2(sels, removeSelectionClasses);\n      };\n      const selectRange = (container, cells, start, finish) => {\n        clear(container);\n        each$2(cells, addSelectionClass);\n        add(start, ephemera.firstSelected);\n        add(finish, ephemera.lastSelected);\n      };\n      return {\n        clearBeforeUpdate: clear,\n        clear,\n        selectRange,\n        selectedSelector: ephemera.selectedSelector,\n        firstSelectedSelector: ephemera.firstSelectedSelector,\n        lastSelectedSelector: ephemera.lastSelectedSelector\n      };\n    };\n    const byAttr = (ephemera, onSelection, onClear) => {\n      const removeSelectionAttributes = element => {\n        remove$7(element, ephemera.selected);\n        remove$7(element, ephemera.firstSelected);\n        remove$7(element, ephemera.lastSelected);\n      };\n      const addSelectionAttribute = element => {\n        set$2(element, ephemera.selected, '1');\n      };\n      const clear = container => {\n        clearBeforeUpdate(container);\n        onClear();\n      };\n      const clearBeforeUpdate = container => {\n        const sels = descendants(container, `${ ephemera.selectedSelector },${ ephemera.firstSelectedSelector },${ ephemera.lastSelectedSelector }`);\n        each$2(sels, removeSelectionAttributes);\n      };\n      const selectRange = (container, cells, start, finish) => {\n        clear(container);\n        each$2(cells, addSelectionAttribute);\n        set$2(start, ephemera.firstSelected, '1');\n        set$2(finish, ephemera.lastSelected, '1');\n        onSelection(cells, start, finish);\n      };\n      return {\n        clearBeforeUpdate,\n        clear,\n        selectRange,\n        selectedSelector: ephemera.selectedSelector,\n        firstSelectedSelector: ephemera.firstSelectedSelector,\n        lastSelectedSelector: ephemera.lastSelectedSelector\n      };\n    };\n    const SelectionAnnotation = {\n      byClass,\n      byAttr\n    };\n\n    const fold = (subject, onNone, onMultiple, onSingle) => {\n      switch (subject.tag) {\n      case 'none':\n        return onNone();\n      case 'single':\n        return onSingle(subject.element);\n      case 'multiple':\n        return onMultiple(subject.elements);\n      }\n    };\n    const none = () => ({ tag: 'none' });\n    const multiple = elements => ({\n      tag: 'multiple',\n      elements\n    });\n    const single = element => ({\n      tag: 'single',\n      element\n    });\n\n    const Selections = (lazyRoot, getStart, selectedSelector) => {\n      const get = () => retrieve(lazyRoot(), selectedSelector).fold(() => getStart().fold(none, single), multiple);\n      return { get };\n    };\n\n    const getUpOrLeftCells = (grid, selectedCells) => {\n      const upGrid = grid.slice(0, selectedCells[selectedCells.length - 1].row + 1);\n      const upDetails = toDetailList(upGrid);\n      return bind$2(upDetails, detail => {\n        const slicedCells = detail.cells.slice(0, selectedCells[selectedCells.length - 1].column + 1);\n        return map$1(slicedCells, cell => cell.element);\n      });\n    };\n    const getDownOrRightCells = (grid, selectedCells) => {\n      const downGrid = grid.slice(selectedCells[0].row + selectedCells[0].rowspan - 1, grid.length);\n      const downDetails = toDetailList(downGrid);\n      return bind$2(downDetails, detail => {\n        const slicedCells = detail.cells.slice(selectedCells[0].column + selectedCells[0].colspan - 1, detail.cells.length);\n        return map$1(slicedCells, cell => cell.element);\n      });\n    };\n    const getOtherCells = (table, target, generators) => {\n      const warehouse = Warehouse.fromTable(table);\n      const details = onCells(warehouse, target);\n      return details.map(selectedCells => {\n        const grid = toGrid(warehouse, generators, false);\n        const {rows} = extractGridDetails(grid);\n        const upOrLeftCells = getUpOrLeftCells(rows, selectedCells);\n        const downOrRightCells = getDownOrRightCells(rows, selectedCells);\n        return {\n          upOrLeftCells,\n          downOrRightCells\n        };\n      });\n    };\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent$1 = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent$1(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$1 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const filter = always;\n    const bind = (element, event, handler) => bind$1(element, event, filter, handler);\n    const fromRawEvent = fromRawEvent$1;\n\n    const hasInternalTarget = e => !has(SugarElement.fromDom(e.target), 'ephox-snooker-resizer-bar');\n    const TableCellSelectionHandler = (editor, resizeHandler) => {\n      const cellSelection = Selections(() => SugarElement.fromDom(editor.getBody()), () => getSelectionCell(getSelectionStart(editor), getIsRoot(editor)), ephemera.selectedSelector);\n      const onSelection = (cells, start, finish) => {\n        const tableOpt = table(start);\n        tableOpt.each(table => {\n          const cloneFormats = getTableCloneElements(editor);\n          const generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), cloneFormats);\n          const selectedCells = getCellsFromSelection(editor);\n          const otherCells = getOtherCells(table, { selection: selectedCells }, generators);\n          fireTableSelectionChange(editor, cells, start, finish, otherCells);\n        });\n      };\n      const onClear = () => fireTableSelectionClear(editor);\n      const annotations = SelectionAnnotation.byAttr(ephemera, onSelection, onClear);\n      editor.on('init', _e => {\n        const win = editor.getWin();\n        const body = getBody(editor);\n        const isRoot = getIsRoot(editor);\n        const syncSelection = () => {\n          const sel = editor.selection;\n          const start = SugarElement.fromDom(sel.getStart());\n          const end = SugarElement.fromDom(sel.getEnd());\n          const shared = sharedOne(table, [\n            start,\n            end\n          ]);\n          shared.fold(() => annotations.clear(body), noop);\n        };\n        const mouseHandlers = mouse(win, body, isRoot, annotations);\n        const keyHandlers = keyboard(win, body, isRoot, annotations);\n        const external$1 = external(win, body, isRoot, annotations);\n        const hasShiftKey = event => event.raw.shiftKey === true;\n        editor.on('TableSelectorChange', e => external$1(e.start, e.finish));\n        const handleResponse = (event, response) => {\n          if (!hasShiftKey(event)) {\n            return;\n          }\n          if (response.kill) {\n            event.kill();\n          }\n          response.selection.each(ns => {\n            const relative = SimSelection.relative(ns.start, ns.finish);\n            const rng = asLtrRange(win, relative);\n            editor.selection.setRng(rng);\n          });\n        };\n        const keyup = event => {\n          const wrappedEvent = fromRawEvent(event);\n          if (wrappedEvent.raw.shiftKey && isNavigation(wrappedEvent.raw.which)) {\n            const rng = editor.selection.getRng();\n            const start = SugarElement.fromDom(rng.startContainer);\n            const end = SugarElement.fromDom(rng.endContainer);\n            keyHandlers.keyup(wrappedEvent, start, rng.startOffset, end, rng.endOffset).each(response => {\n              handleResponse(wrappedEvent, response);\n            });\n          }\n        };\n        const keydown = event => {\n          const wrappedEvent = fromRawEvent(event);\n          resizeHandler.hide();\n          const rng = editor.selection.getRng();\n          const start = SugarElement.fromDom(rng.startContainer);\n          const end = SugarElement.fromDom(rng.endContainer);\n          const direction = onDirection(ltr, rtl)(SugarElement.fromDom(editor.selection.getStart()));\n          keyHandlers.keydown(wrappedEvent, start, rng.startOffset, end, rng.endOffset, direction).each(response => {\n            handleResponse(wrappedEvent, response);\n          });\n          resizeHandler.show();\n        };\n        const isLeftMouse = raw => raw.button === 0;\n        const isLeftButtonPressed = raw => {\n          if (raw.buttons === undefined) {\n            return true;\n          }\n          return (raw.buttons & 1) !== 0;\n        };\n        const dragStart = _e => {\n          mouseHandlers.clearstate();\n        };\n        const mouseDown = e => {\n          if (isLeftMouse(e) && hasInternalTarget(e)) {\n            mouseHandlers.mousedown(fromRawEvent(e));\n          }\n        };\n        const mouseOver = e => {\n          if (isLeftButtonPressed(e) && hasInternalTarget(e)) {\n            mouseHandlers.mouseover(fromRawEvent(e));\n          }\n        };\n        const mouseUp = e => {\n          if (isLeftMouse(e) && hasInternalTarget(e)) {\n            mouseHandlers.mouseup(fromRawEvent(e));\n          }\n        };\n        const getDoubleTap = () => {\n          const lastTarget = Cell(SugarElement.fromDom(body));\n          const lastTimeStamp = Cell(0);\n          const touchEnd = t => {\n            const target = SugarElement.fromDom(t.target);\n            if (isTag('td')(target) || isTag('th')(target)) {\n              const lT = lastTarget.get();\n              const lTS = lastTimeStamp.get();\n              if (eq$1(lT, target) && t.timeStamp - lTS < 300) {\n                t.preventDefault();\n                external$1(target, target);\n              }\n            }\n            lastTarget.set(target);\n            lastTimeStamp.set(t.timeStamp);\n          };\n          return { touchEnd };\n        };\n        const doubleTap = getDoubleTap();\n        editor.on('dragstart', dragStart);\n        editor.on('mousedown', mouseDown);\n        editor.on('mouseover', mouseOver);\n        editor.on('mouseup', mouseUp);\n        editor.on('touchend', doubleTap.touchEnd);\n        editor.on('keyup', keyup);\n        editor.on('keydown', keydown);\n        editor.on('NodeChange', syncSelection);\n      });\n      editor.on('PreInit', () => {\n        editor.serializer.addTempAttr(ephemera.firstSelected);\n        editor.serializer.addTempAttr(ephemera.lastSelected);\n      });\n      const clearSelectedCells = container => annotations.clear(SugarElement.fromDom(container));\n      const getSelectedCells = () => fold(cellSelection.get(), constant([]), cells => {\n        return map$1(cells, cell => cell.dom);\n      }, cell => [cell.dom]);\n      return {\n        getSelectedCells,\n        clearSelectedCells\n      };\n    };\n\n    const Event = fields => {\n      let handlers = [];\n      const bind = handler => {\n        if (handler === undefined) {\n          throw new Error('Event bind error: undefined handler');\n        }\n        handlers.push(handler);\n      };\n      const unbind = handler => {\n        handlers = filter$2(handlers, h => {\n          return h !== handler;\n        });\n      };\n      const trigger = (...args) => {\n        const event = {};\n        each$2(fields, (name, i) => {\n          event[name] = args[i];\n        });\n        each$2(handlers, handler => {\n          handler(event);\n        });\n      };\n      return {\n        bind,\n        unbind,\n        trigger\n      };\n    };\n\n    const create$1 = typeDefs => {\n      const registry = map(typeDefs, event => {\n        return {\n          bind: event.bind,\n          unbind: event.unbind\n        };\n      });\n      const trigger = map(typeDefs, event => {\n        return event.trigger;\n      });\n      return {\n        registry,\n        trigger\n      };\n    };\n\n    const last = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const sort = arr => {\n      return arr.slice(0).sort();\n    };\n    const reqMessage = (required, keys) => {\n      throw new Error('All required keys (' + sort(required).join(', ') + ') were not specified. Specified keys were: ' + sort(keys).join(', ') + '.');\n    };\n    const unsuppMessage = unsupported => {\n      throw new Error('Unsupported keys for object: ' + sort(unsupported).join(', '));\n    };\n    const validateStrArr = (label, array) => {\n      if (!isArray(array)) {\n        throw new Error('The ' + label + ' fields must be an array. Was: ' + array + '.');\n      }\n      each$2(array, a => {\n        if (!isString(a)) {\n          throw new Error('The value ' + a + ' in the ' + label + ' fields was not a string.');\n        }\n      });\n    };\n    const invalidTypeMessage = (incorrect, type) => {\n      throw new Error('All values need to be of type: ' + type + '. Keys (' + sort(incorrect).join(', ') + ') were not.');\n    };\n    const checkDupes = everything => {\n      const sorted = sort(everything);\n      const dupe = find$1(sorted, (s, i) => {\n        return i < sorted.length - 1 && s === sorted[i + 1];\n      });\n      dupe.each(d => {\n        throw new Error('The field: ' + d + ' occurs more than once in the combined fields: [' + sorted.join(', ') + '].');\n      });\n    };\n\n    const base = (handleUnsupported, required) => {\n      return baseWith(handleUnsupported, required, {\n        validate: isFunction,\n        label: 'function'\n      });\n    };\n    const baseWith = (handleUnsupported, required, pred) => {\n      if (required.length === 0) {\n        throw new Error('You must specify at least one required field.');\n      }\n      validateStrArr('required', required);\n      checkDupes(required);\n      return obj => {\n        const keys$1 = keys(obj);\n        const allReqd = forall(required, req => {\n          return contains$2(keys$1, req);\n        });\n        if (!allReqd) {\n          reqMessage(required, keys$1);\n        }\n        handleUnsupported(required, keys$1);\n        const invalidKeys = filter$2(required, key => {\n          return !pred.validate(obj[key], key);\n        });\n        if (invalidKeys.length > 0) {\n          invalidTypeMessage(invalidKeys, pred.label);\n        }\n        return obj;\n      };\n    };\n    const handleExact = (required, keys) => {\n      const unsupported = filter$2(keys, key => {\n        return !contains$2(required, key);\n      });\n      if (unsupported.length > 0) {\n        unsuppMessage(unsupported);\n      }\n    };\n    const exactly = required => base(handleExact, required);\n\n    const DragMode = exactly([\n      'compare',\n      'extract',\n      'mutate',\n      'sink'\n    ]);\n    const DragSink = exactly([\n      'element',\n      'start',\n      'stop',\n      'destroy'\n    ]);\n    const DragApi = exactly([\n      'forceDrop',\n      'drop',\n      'move',\n      'delayDrop'\n    ]);\n\n    const InDrag = () => {\n      let previous = Optional.none();\n      const reset = () => {\n        previous = Optional.none();\n      };\n      const update = (mode, nu) => {\n        const result = previous.map(old => {\n          return mode.compare(old, nu);\n        });\n        previous = Optional.some(nu);\n        return result;\n      };\n      const onEvent = (event, mode) => {\n        const dataOption = mode.extract(event);\n        dataOption.each(data => {\n          const offset = update(mode, data);\n          offset.each(d => {\n            events.trigger.move(d);\n          });\n        });\n      };\n      const events = create$1({ move: Event(['info']) });\n      return {\n        onEvent,\n        reset,\n        events: events.registry\n      };\n    };\n\n    const NoDrag = () => {\n      const events = create$1({ move: Event(['info']) });\n      return {\n        onEvent: noop,\n        reset: noop,\n        events: events.registry\n      };\n    };\n\n    const Movement = () => {\n      const noDragState = NoDrag();\n      const inDragState = InDrag();\n      let dragState = noDragState;\n      const on = () => {\n        dragState.reset();\n        dragState = inDragState;\n      };\n      const off = () => {\n        dragState.reset();\n        dragState = noDragState;\n      };\n      const onEvent = (event, mode) => {\n        dragState.onEvent(event, mode);\n      };\n      const isOn = () => {\n        return dragState === inDragState;\n      };\n      return {\n        on,\n        off,\n        isOn,\n        onEvent,\n        events: inDragState.events\n      };\n    };\n\n    const setup = (mutation, mode, settings) => {\n      let active = false;\n      const events = create$1({\n        start: Event([]),\n        stop: Event([])\n      });\n      const movement = Movement();\n      const drop = () => {\n        sink.stop();\n        if (movement.isOn()) {\n          movement.off();\n          events.trigger.stop();\n        }\n      };\n      const throttledDrop = last(drop, 200);\n      const go = parent => {\n        sink.start(parent);\n        movement.on();\n        events.trigger.start();\n      };\n      const mousemove = event => {\n        throttledDrop.cancel();\n        movement.onEvent(event, mode);\n      };\n      movement.events.move.bind(event => {\n        mode.mutate(mutation, event.info);\n      });\n      const on = () => {\n        active = true;\n      };\n      const off = () => {\n        active = false;\n      };\n      const isActive = () => active;\n      const runIfActive = f => {\n        return (...args) => {\n          if (active) {\n            f.apply(null, args);\n          }\n        };\n      };\n      const sink = mode.sink(DragApi({\n        forceDrop: drop,\n        drop: runIfActive(drop),\n        move: runIfActive(mousemove),\n        delayDrop: runIfActive(throttledDrop.throttle)\n      }), settings);\n      const destroy = () => {\n        sink.destroy();\n      };\n      return {\n        element: sink.element,\n        go,\n        on,\n        off,\n        isActive,\n        destroy,\n        events: events.registry\n      };\n    };\n\n    const css = namespace => {\n      const dashNamespace = namespace.replace(/\\./g, '-');\n      const resolve = str => {\n        return dashNamespace + '-' + str;\n      };\n      return { resolve };\n    };\n\n    const styles$1 = css('ephox-dragster');\n    const resolve$1 = styles$1.resolve;\n\n    const Blocker = options => {\n      const settings = {\n        layerClass: resolve$1('blocker'),\n        ...options\n      };\n      const div = SugarElement.fromTag('div');\n      set$2(div, 'role', 'presentation');\n      setAll(div, {\n        position: 'fixed',\n        left: '0px',\n        top: '0px',\n        width: '100%',\n        height: '100%'\n      });\n      add(div, resolve$1('blocker'));\n      add(div, settings.layerClass);\n      const element = constant(div);\n      const destroy = () => {\n        remove$6(div);\n      };\n      return {\n        element,\n        destroy\n      };\n    };\n\n    const compare = (old, nu) => {\n      return SugarPosition(nu.left - old.left, nu.top - old.top);\n    };\n    const extract = event => {\n      return Optional.some(SugarPosition(event.x, event.y));\n    };\n    const mutate = (mutation, info) => {\n      mutation.mutate(info.left, info.top);\n    };\n    const sink = (dragApi, settings) => {\n      const blocker = Blocker(settings);\n      const mdown = bind(blocker.element(), 'mousedown', dragApi.forceDrop);\n      const mup = bind(blocker.element(), 'mouseup', dragApi.drop);\n      const mmove = bind(blocker.element(), 'mousemove', dragApi.move);\n      const mout = bind(blocker.element(), 'mouseout', dragApi.delayDrop);\n      const destroy = () => {\n        blocker.destroy();\n        mup.unbind();\n        mmove.unbind();\n        mout.unbind();\n        mdown.unbind();\n      };\n      const start = parent => {\n        append$1(parent, blocker.element());\n      };\n      const stop = () => {\n        remove$6(blocker.element());\n      };\n      return DragSink({\n        element: blocker.element,\n        start,\n        stop,\n        destroy\n      });\n    };\n    var MouseDrag = DragMode({\n      compare,\n      extract,\n      sink,\n      mutate\n    });\n\n    const transform = (mutation, settings = {}) => {\n      var _a;\n      const mode = (_a = settings.mode) !== null && _a !== void 0 ? _a : MouseDrag;\n      return setup(mutation, mode, settings);\n    };\n\n    const styles = css('ephox-snooker');\n    const resolve = styles.resolve;\n\n    const Mutation = () => {\n      const events = create$1({\n        drag: Event([\n          'xDelta',\n          'yDelta'\n        ])\n      });\n      const mutate = (x, y) => {\n        events.trigger.drag(x, y);\n      };\n      return {\n        mutate,\n        events: events.registry\n      };\n    };\n\n    const BarMutation = () => {\n      const events = create$1({\n        drag: Event([\n          'xDelta',\n          'yDelta',\n          'target'\n        ])\n      });\n      let target = Optional.none();\n      const delegate = Mutation();\n      delegate.events.drag.bind(event => {\n        target.each(t => {\n          events.trigger.drag(event.xDelta, event.yDelta, t);\n        });\n      });\n      const assign = t => {\n        target = Optional.some(t);\n      };\n      const get = () => {\n        return target;\n      };\n      return {\n        assign,\n        get,\n        mutate: delegate.mutate,\n        events: events.registry\n      };\n    };\n\n    const col = (column, x, y, w, h) => {\n      const bar = SugarElement.fromTag('div');\n      setAll(bar, {\n        position: 'absolute',\n        left: x - w / 2 + 'px',\n        top: y + 'px',\n        height: h + 'px',\n        width: w + 'px'\n      });\n      setAll$1(bar, {\n        'data-column': column,\n        'role': 'presentation'\n      });\n      return bar;\n    };\n    const row = (r, x, y, w, h) => {\n      const bar = SugarElement.fromTag('div');\n      setAll(bar, {\n        position: 'absolute',\n        left: x + 'px',\n        top: y - h / 2 + 'px',\n        height: h + 'px',\n        width: w + 'px'\n      });\n      setAll$1(bar, {\n        'data-row': r,\n        'role': 'presentation'\n      });\n      return bar;\n    };\n\n    const resizeBar = resolve('resizer-bar');\n    const resizeRowBar = resolve('resizer-rows');\n    const resizeColBar = resolve('resizer-cols');\n    const BAR_THICKNESS = 7;\n    const resizableRows = (warehouse, isResizable) => bind$2(warehouse.all, (row, i) => isResizable(row.element) ? [i] : []);\n    const resizableColumns = (warehouse, isResizable) => {\n      const resizableCols = [];\n      range$1(warehouse.grid.columns, index => {\n        const colElmOpt = Warehouse.getColumnAt(warehouse, index).map(col => col.element);\n        if (colElmOpt.forall(isResizable)) {\n          resizableCols.push(index);\n        }\n      });\n      return filter$2(resizableCols, colIndex => {\n        const columnCells = Warehouse.filterItems(warehouse, cell => cell.column === colIndex);\n        return forall(columnCells, cell => isResizable(cell.element));\n      });\n    };\n    const destroy = wire => {\n      const previous = descendants(wire.parent(), '.' + resizeBar);\n      each$2(previous, remove$6);\n    };\n    const drawBar = (wire, positions, create) => {\n      const origin = wire.origin();\n      each$2(positions, cpOption => {\n        cpOption.each(cp => {\n          const bar = create(origin, cp);\n          add(bar, resizeBar);\n          append$1(wire.parent(), bar);\n        });\n      });\n    };\n    const refreshCol = (wire, colPositions, position, tableHeight) => {\n      drawBar(wire, colPositions, (origin, cp) => {\n        const colBar = col(cp.col, cp.x - origin.left, position.top - origin.top, BAR_THICKNESS, tableHeight);\n        add(colBar, resizeColBar);\n        return colBar;\n      });\n    };\n    const refreshRow = (wire, rowPositions, position, tableWidth) => {\n      drawBar(wire, rowPositions, (origin, cp) => {\n        const rowBar = row(cp.row, position.left - origin.left, cp.y - origin.top, tableWidth, BAR_THICKNESS);\n        add(rowBar, resizeRowBar);\n        return rowBar;\n      });\n    };\n    const refreshGrid = (warhouse, wire, table, rows, cols) => {\n      const position = absolute(table);\n      const isResizable = wire.isResizable;\n      const rowPositions = rows.length > 0 ? height.positions(rows, table) : [];\n      const resizableRowBars = rowPositions.length > 0 ? resizableRows(warhouse, isResizable) : [];\n      const resizableRowPositions = filter$2(rowPositions, (_pos, i) => exists(resizableRowBars, barIndex => i === barIndex));\n      refreshRow(wire, resizableRowPositions, position, getOuter$2(table));\n      const colPositions = cols.length > 0 ? width.positions(cols, table) : [];\n      const resizableColBars = colPositions.length > 0 ? resizableColumns(warhouse, isResizable) : [];\n      const resizableColPositions = filter$2(colPositions, (_pos, i) => exists(resizableColBars, barIndex => i === barIndex));\n      refreshCol(wire, resizableColPositions, position, getOuter$1(table));\n    };\n    const refresh = (wire, table) => {\n      destroy(wire);\n      if (wire.isResizable(table)) {\n        const warehouse = Warehouse.fromTable(table);\n        const rows$1 = rows(warehouse);\n        const cols = columns(warehouse);\n        refreshGrid(warehouse, wire, table, rows$1, cols);\n      }\n    };\n    const each = (wire, f) => {\n      const bars = descendants(wire.parent(), '.' + resizeBar);\n      each$2(bars, f);\n    };\n    const hide = wire => {\n      each(wire, bar => {\n        set$1(bar, 'display', 'none');\n      });\n    };\n    const show = wire => {\n      each(wire, bar => {\n        set$1(bar, 'display', 'block');\n      });\n    };\n    const isRowBar = element => {\n      return has(element, resizeRowBar);\n    };\n    const isColBar = element => {\n      return has(element, resizeColBar);\n    };\n\n    const resizeBarDragging = resolve('resizer-bar-dragging');\n    const BarManager = wire => {\n      const mutation = BarMutation();\n      const resizing = transform(mutation, {});\n      let hoverTable = Optional.none();\n      const getResizer = (element, type) => {\n        return Optional.from(get$b(element, type));\n      };\n      mutation.events.drag.bind(event => {\n        getResizer(event.target, 'data-row').each(_dataRow => {\n          const currentRow = getCssValue(event.target, 'top');\n          set$1(event.target, 'top', currentRow + event.yDelta + 'px');\n        });\n        getResizer(event.target, 'data-column').each(_dataCol => {\n          const currentCol = getCssValue(event.target, 'left');\n          set$1(event.target, 'left', currentCol + event.xDelta + 'px');\n        });\n      });\n      const getDelta = (target, dir) => {\n        const newX = getCssValue(target, dir);\n        const oldX = getAttrValue(target, 'data-initial-' + dir, 0);\n        return newX - oldX;\n      };\n      resizing.events.stop.bind(() => {\n        mutation.get().each(target => {\n          hoverTable.each(table => {\n            getResizer(target, 'data-row').each(row => {\n              const delta = getDelta(target, 'top');\n              remove$7(target, 'data-initial-top');\n              events.trigger.adjustHeight(table, delta, parseInt(row, 10));\n            });\n            getResizer(target, 'data-column').each(column => {\n              const delta = getDelta(target, 'left');\n              remove$7(target, 'data-initial-left');\n              events.trigger.adjustWidth(table, delta, parseInt(column, 10));\n            });\n            refresh(wire, table);\n          });\n        });\n      });\n      const handler = (target, dir) => {\n        events.trigger.startAdjust();\n        mutation.assign(target);\n        set$2(target, 'data-initial-' + dir, getCssValue(target, dir));\n        add(target, resizeBarDragging);\n        set$1(target, 'opacity', '0.2');\n        resizing.go(wire.parent());\n      };\n      const mousedown = bind(wire.parent(), 'mousedown', event => {\n        if (isRowBar(event.target)) {\n          handler(event.target, 'top');\n        }\n        if (isColBar(event.target)) {\n          handler(event.target, 'left');\n        }\n      });\n      const isRoot = e => {\n        return eq$1(e, wire.view());\n      };\n      const findClosestEditableTable = target => closest$1(target, 'table', isRoot).filter(isEditable$1);\n      const mouseover = bind(wire.view(), 'mouseover', event => {\n        findClosestEditableTable(event.target).fold(() => {\n          if (inBody(event.target)) {\n            destroy(wire);\n          }\n        }, table => {\n          if (resizing.isActive()) {\n            hoverTable = Optional.some(table);\n            refresh(wire, table);\n          }\n        });\n      });\n      const destroy$1 = () => {\n        mousedown.unbind();\n        mouseover.unbind();\n        resizing.destroy();\n        destroy(wire);\n      };\n      const refresh$1 = tbl => {\n        refresh(wire, tbl);\n      };\n      const events = create$1({\n        adjustHeight: Event([\n          'table',\n          'delta',\n          'row'\n        ]),\n        adjustWidth: Event([\n          'table',\n          'delta',\n          'column'\n        ]),\n        startAdjust: Event([])\n      });\n      return {\n        destroy: destroy$1,\n        refresh: refresh$1,\n        on: resizing.on,\n        off: resizing.off,\n        hideBars: curry(hide, wire),\n        showBars: curry(show, wire),\n        events: events.registry\n      };\n    };\n\n    const create = (wire, resizing, lazySizing) => {\n      const hdirection = height;\n      const vdirection = width;\n      const manager = BarManager(wire);\n      const events = create$1({\n        beforeResize: Event([\n          'table',\n          'type'\n        ]),\n        afterResize: Event([\n          'table',\n          'type'\n        ]),\n        startDrag: Event([])\n      });\n      manager.events.adjustHeight.bind(event => {\n        const table = event.table;\n        events.trigger.beforeResize(table, 'row');\n        const delta = hdirection.delta(event.delta, table);\n        adjustHeight(table, delta, event.row, hdirection);\n        events.trigger.afterResize(table, 'row');\n      });\n      manager.events.startAdjust.bind(_event => {\n        events.trigger.startDrag();\n      });\n      manager.events.adjustWidth.bind(event => {\n        const table = event.table;\n        events.trigger.beforeResize(table, 'col');\n        const delta = vdirection.delta(event.delta, table);\n        const tableSize = lazySizing(table);\n        adjustWidth(table, delta, event.column, resizing, tableSize);\n        events.trigger.afterResize(table, 'col');\n      });\n      return {\n        on: manager.on,\n        off: manager.off,\n        refreshBars: manager.refresh,\n        hideBars: manager.hideBars,\n        showBars: manager.showBars,\n        destroy: manager.destroy,\n        events: events.registry\n      };\n    };\n    const TableResize = { create };\n\n    const only = (element, isResizable) => {\n      const parent = isDocument(element) ? documentElement(element) : element;\n      return {\n        parent: constant(parent),\n        view: constant(element),\n        origin: constant(SugarPosition(0, 0)),\n        isResizable\n      };\n    };\n    const detached = (editable, chrome, isResizable) => {\n      const origin = () => absolute(chrome);\n      return {\n        parent: constant(chrome),\n        view: constant(editable),\n        origin,\n        isResizable\n      };\n    };\n    const body = (editable, chrome, isResizable) => {\n      return {\n        parent: constant(chrome),\n        view: constant(editable),\n        origin: constant(SugarPosition(0, 0)),\n        isResizable\n      };\n    };\n    const ResizeWire = {\n      only,\n      detached,\n      body\n    };\n\n    const createContainer = () => {\n      const container = SugarElement.fromTag('div');\n      setAll(container, {\n        position: 'static',\n        height: '0',\n        width: '0',\n        padding: '0',\n        margin: '0',\n        border: '0'\n      });\n      append$1(body$1(), container);\n      return container;\n    };\n    const get = (editor, isResizable) => {\n      return editor.inline ? ResizeWire.body(SugarElement.fromDom(editor.getBody()), createContainer(), isResizable) : ResizeWire.only(SugarElement.fromDom(editor.getDoc()), isResizable);\n    };\n    const remove = (editor, wire) => {\n      if (editor.inline) {\n        remove$6(wire.parent());\n      }\n    };\n\n    const isTable = node => isNonNullable(node) && node.nodeName === 'TABLE';\n    const barResizerPrefix = 'bar-';\n    const isResizable = elm => get$b(elm, 'data-mce-resize') !== 'false';\n    const syncPixels = table => {\n      const warehouse = Warehouse.fromTable(table);\n      if (!Warehouse.hasColumns(warehouse)) {\n        each$2(cells$1(table), cell => {\n          const computedWidth = get$a(cell, 'width');\n          set$1(cell, 'width', computedWidth);\n          remove$7(cell, 'width');\n        });\n      }\n    };\n    const TableResizeHandler = editor => {\n      const selectionRng = value();\n      const tableResize = value();\n      const resizeWire = value();\n      let startW;\n      let startRawW;\n      const lazySizing = table => get$5(editor, table);\n      const lazyResizingBehaviour = () => isPreserveTableColumnResizing(editor) ? preserveTable() : resizeTable();\n      const getNumColumns = table => getGridSize(table).columns;\n      const afterCornerResize = (table, origin, width) => {\n        const isRightEdgeResize = endsWith(origin, 'e');\n        if (startRawW === '') {\n          convertToPercentSize(table);\n        }\n        if (width !== startW && startRawW !== '') {\n          set$1(table, 'width', startRawW);\n          const resizing = lazyResizingBehaviour();\n          const tableSize = lazySizing(table);\n          const col = isPreserveTableColumnResizing(editor) || isRightEdgeResize ? getNumColumns(table) - 1 : 0;\n          adjustWidth(table, width - startW, col, resizing, tableSize);\n        } else if (isPercentage$1(startRawW)) {\n          const percentW = parseFloat(startRawW.replace('%', ''));\n          const targetPercentW = width * percentW / startW;\n          set$1(table, 'width', targetPercentW + '%');\n        }\n        if (isPixel(startRawW)) {\n          syncPixels(table);\n        }\n      };\n      const destroy = () => {\n        tableResize.on(sz => {\n          sz.destroy();\n        });\n        resizeWire.on(w => {\n          remove(editor, w);\n        });\n      };\n      editor.on('init', () => {\n        const rawWire = get(editor, isResizable);\n        resizeWire.set(rawWire);\n        if (hasTableObjectResizing(editor) && hasTableResizeBars(editor)) {\n          const resizing = lazyResizingBehaviour();\n          const sz = TableResize.create(rawWire, resizing, lazySizing);\n          sz.on();\n          sz.events.startDrag.bind(_event => {\n            selectionRng.set(editor.selection.getRng());\n          });\n          sz.events.beforeResize.bind(event => {\n            const rawTable = event.table.dom;\n            fireObjectResizeStart(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);\n          });\n          sz.events.afterResize.bind(event => {\n            const table = event.table;\n            const rawTable = table.dom;\n            removeDataStyle(table);\n            selectionRng.on(rng => {\n              editor.selection.setRng(rng);\n              editor.focus();\n            });\n            fireObjectResized(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);\n            editor.undoManager.add();\n          });\n          tableResize.set(sz);\n        }\n      });\n      editor.on('ObjectResizeStart', e => {\n        const targetElm = e.target;\n        if (isTable(targetElm)) {\n          const table = SugarElement.fromDom(targetElm);\n          each$2(editor.dom.select('.mce-clonedresizable'), clone => {\n            editor.dom.addClass(clone, 'mce-' + getTableColumnResizingBehaviour(editor) + '-columns');\n          });\n          if (!isPixelSizing(table) && isTablePixelsForced(editor)) {\n            convertToPixelSize(table);\n          } else if (!isPercentSizing(table) && isTablePercentagesForced(editor)) {\n            convertToPercentSize(table);\n          }\n          if (isNoneSizing(table) && startsWith(e.origin, barResizerPrefix)) {\n            convertToPercentSize(table);\n          }\n          startW = e.width;\n          startRawW = isTableResponsiveForced(editor) ? '' : getRawWidth(editor, targetElm).getOr('');\n        }\n      });\n      editor.on('ObjectResized', e => {\n        const targetElm = e.target;\n        if (isTable(targetElm)) {\n          const table = SugarElement.fromDom(targetElm);\n          const origin = e.origin;\n          if (startsWith(origin, 'corner-')) {\n            afterCornerResize(table, origin, e.width);\n          }\n          removeDataStyle(table);\n          fireTableModified(editor, table.dom, styleModified);\n        }\n      });\n      editor.on('SwitchMode', () => {\n        tableResize.on(resize => {\n          if (editor.mode.isReadOnly()) {\n            resize.hideBars();\n          } else {\n            resize.showBars();\n          }\n        });\n      });\n      editor.on('dragstart dragend', e => {\n        tableResize.on(resize => {\n          if (e.type === 'dragstart') {\n            resize.hideBars();\n            resize.off();\n          } else {\n            resize.on();\n            resize.showBars();\n          }\n        });\n      });\n      editor.on('remove', () => {\n        destroy();\n      });\n      const refresh = table => {\n        tableResize.on(resize => resize.refreshBars(SugarElement.fromDom(table)));\n      };\n      const hide = () => {\n        tableResize.on(resize => resize.hideBars());\n      };\n      const show = () => {\n        tableResize.on(resize => resize.showBars());\n      };\n      return {\n        refresh,\n        hide,\n        show\n      };\n    };\n\n    const setupTable = editor => {\n      register(editor);\n      const resizeHandler = TableResizeHandler(editor);\n      const cellSelectionHandler = TableCellSelectionHandler(editor, resizeHandler);\n      const actions = TableActions(editor, resizeHandler, cellSelectionHandler);\n      registerCommands(editor, actions);\n      registerQueryCommands(editor, actions);\n      registerEvents(editor, actions);\n      return {\n        getSelectedCells: cellSelectionHandler.getSelectedCells,\n        clearSelectedCells: cellSelectionHandler.clearSelectedCells\n      };\n    };\n\n    const DomModel = editor => {\n      const table = setupTable(editor);\n      return { table };\n    };\n    var Model = () => {\n      global$1.add('dom', DomModel);\n    };\n\n    Model();\n\n})();\n"],"names":["global$1","hasProto","v","constructor","predicate","_a","typeOf","x","t","o","proto","isType$1","type","value","isSimpleType","eq$2","a","isString","isObject","isArray","isNull","isBoolean","isUndefined","isNullable","isNonNullable","isFunction","isNumber","noop","compose","fa","fb","args","compose1","fbc","fab","constant","identity","tripleEquals","b","curry","fn","initialArgs","restArgs","all","not","f","die","msg","apply","never","always","Optional","tag","onNone","onSome","mapper","binder","replacement","thunk","message","worker","nativeSlice","nativeIndexOf","nativePush","rawIndexOf","ts","contains$2","xs","exists","pred","i","len","range$1","num","r","map$1","each$2","eachr","partition","pass","fail","filter$2","foldr","acc","foldl","findUntil","until","find$1","findIndex","flatten","bind$2","forall","reverse","mapToObject","sort$1","comparator","copy","get$d","head","last$2","findMap","arr","keys","hasOwnProperty","each$1","obj","props","k","map","tupleMap","tuple","objAcc","internalFilter","onTrue","onFalse","filter$1","mapToArray","name","values","get$c","key","has$1","hasNonNullableKey","isEmpty","Global","path","parts","scope","resolve$2","p","unsafe","getOrDie","actual","getPrototypeOf","sandHTMLElement","isPrototypeOf","COMMENT","DOCUMENT","DOCUMENT_FRAGMENT","ELEMENT","TEXT","element","isType","isComment","isHTMLElement","isElement","isText","isDocument","isDocumentFragment","isTag","rawSet","dom","set$2","setAll$1","attrs","setOptions","remove$7","get$b","getOpt","clone$2","attr","fromHtml$1","html","div","fromDom$1","fromTag","node","fromText","text","SugarElement","docElm","y","is$2","selector","elem","bypassSelector","all$1","base","one","eq$1","e1","e2","contains$1","d1","d2","is$1","owner","documentOrOwner","dos","documentElement","defaultView","parent","parentElement","parents","isRoot","stop","ret","rawParent","prevSibling","nextSibling","children$2","child$2","index","cs","firstChild","before$3","marker","after$5","append$1","prepend","appendAt","wrap","wrapper","after$4","elements","e","append","empty","rogue","remove$6","unwrap","children","clone$1","original","isDeep","shallow","deep","shallowAs","nu","attributes","copy$2","cloneChildren","mutate$1","validSectionList","isValidSection","parentName","grid","rows","columns","address","row","column","detail","rowspan","colspan","detailnew","isNew","extended","isLocked","rowdetail","cells","section","rowdetailnew","elementnew","rowcells","bounds","startRow","startCol","finishRow","finishCol","columnext","colgroup","isShadowRoot","supported","isSupported$1","getRootNode","getShadowRoot","getShadowHost","getOriginalEventTarget","event","el","isOpenShadowHost","composedPath","inBody","doc","body$1","getBody$1","ancestors$4","children$1","descendants$1","result","ancestors$3","descendants","ClosestOrAncestor","is","ancestor","ancestor$2","closest$2","test","child$1","descendant$1","descend","child","res","ancestor$1","descendant","closest$1","lhs","rhs","left","cat","push","bindFrom","someIf","checkRange","str","substr","start","contains","end","idx","startsWith","prefix","endsWith","suffix","trim","s","isNotEmpty","toFloat","isSupported","internalSet","property","internalRemove","set$1","setAll","css","get$a","getUnsafeProperty","getRaw$2","raw","remove$5","copy$1","source","target","sourceDom","targetDom","getAttrValue","cell","fallback","getSpan","hasColspan","cellOrCol","hasRowspan","getCssValue","minWidth","minHeight","firstLayer","filterFirstLayer","lookup","tags","isRootOrUpperTable","elm","cells$1","columns$1","columnGroups","columnGroup","table","rows$1","fromRowsOrColGroups","elems","getSection","getParentSection","group","fromTable$1","fromPastedRows","cached","called","DeviceType","os","browser","userAgent","mediaMatch","isiPad","isiPhone","isMobile","isTouch","isTablet","isPhone","iOSwebview","isDesktop","firstMatch","regexes","find","agent","nu$2","detect$5","versionRegexes","cleanedAgent","unknown$2","major","minor","Version","detectBrowser$1","browsers","userAgentData","uaBrand","lcBrand","info","detect$4","candidates","candidate","detectBrowser","version","detectOs","oses","normalVersionRegex","checkContains","uastring","PlatformInfo","edge","chromium","ie","opera","firefox","safari","unknown$1","nu$1","current","isBrowser","Browser","windows","ios","android","linux","macos","solaris","freebsd","chromeos","unknown","isOS","OperatingSystem","PlatformDetection","userAgentDataOpt","deviceType","query","platform","detect$2","Dimension","getOffset","set","h","get","getOuter","aggregate","properties","val","cumulativeInclusions","toNumber","px","getProp","calcContentBoxSize","size","upper","lower","paddingUpper","paddingLower","borderUpper","borderLower","getCalculatedWidth","boxSizing","width","getHeight$1","getWidth","getInnerWidth","api$2","get$9","getOuter$2","getInner","getRuntime$1","addCells","gridRow","existingCells","before","after","newCells","setCells","addCell","mutateCell","mapCells","getCell","getCellElement","cellLength","extractGridDetails","clone","cloneRow","cloneCell","LOCKED_COL_ATTR","getLockedColumnsFromTable","lockedColStr","lockedCols","getLockedColumnsFromGrid","locked","lockedArr","_val","getAt","warehouse","findItem","item","filtered","filterItems","generateColumns","rowData","columnsGroup","columnIndex","colIndex","generate$1","list","access","lockedColumns","maxRows","maxColumns","rowCount","colgroupRows","currentRow","rowCell","occupiedColumnPosition","occupiedRowPosition","rowPosition","columnPosition","newpos","colgroups","Warehouse","w","isValidCell","cols","rowsArr","col","decide","getBlock","isValid","getFallback","inBlock","c","deduce","rest","aa","next","n","extras","onDirection","isLtr","isRtl","getDirection","api$1","get$8","getOuter$1","getRuntime","top","SugarPosition","boxPosition","box","firstDefinedOrZero","absolute","body","win","scrollTop","scrollLeft","clientTop","clientLeft","viewport","rowInfo","colInfo","rtlEdge","ltrEdge","getLeftEdge","getRightEdge","getTop$1","getTopEdge","getBottomEdge","findPositions","getInnerEdge","getOuterEdge","array","lines","cellOption","lastLine","negate","step","height","optElements","detect$1","amount","units","pattern","decimalDigits","exponentPart","dot","opt","input","float","isUnit","unit","accepted","check","parse","unitRaw","rPercentageBasedSizeRegex","rPixelBasedSizeRegex","isCol$2","getPercentSize","outerGetter","innerGetter","relativeParent","setPixelWidth","setPercentageWidth","setHeight","getHeightValue","convert","number","getter","setter","newSize","total","normalizePixelSize","getTotalHeight","get$7","span","getRaw$1","prop","getRawWidth$1","getRawHeight","getPercentageWidth","getPixelWidth$1","getHeight","getGenericWidth","setGenericWidth","getPixelTableWidth","getPercentTableWidth","isPercentSizing$1","isPixelSizing$1","isNoneSizing$1","percentageBasedSizeRegex","isCol$1","getRawW","getRawH","justCols","isValidColumn","supportsColWidths","getDimension","cellOpt","backups","filter","getWidthFrom","columnCells","pos","colFilter","getDeduced","deduced","d","getRawWidths","getPercentageWidths","tableSize","cellWidth","getPixelWidths","getHeightFrom","direction","getPixelHeights","getRawHeights","widthLookup","noneSize","zero","percentageSize","getFloatWidth","delta","_delta","currentWidth","change","newWidth","pixelSize","chooseSize","TableSize","statsStruct","minRow","minCol","maxRow","maxCol","allCells","selectedCells","findSelectedStats","house","isSelected","totalColumns","endRow","endCol","makeCell","seenSelected","rowIndex","td","fillInGaps","stats","totalRows","j","clean","replica","widthDelta","emptyRows","getTableWidthDelta","colWidths","allColsWidth","extract$1","selectedSelector","replicaHouse","replicaStats","unselectedCells","nbsp","api","getOption","get$6","getEnd","isTextNodeWithCursorPosition","isContentEditableFalse","elementsWithCursorPosition","isCursorPosition","first","last$1","descendantRtl","transferableAttributes","createCell","createCol","createColgroup","createRow$1","replace$1","pasteReplace","cloneFormats","oldCell","newCell","formats","firstText","formatSelector","last","clonedFormat","cloneAppropriateAttributes","validAttributes","attributeName","attribute","cellOperations","mutate","formatsToClone","cloneCss","prev","lastNode","paste$1","fromHtml","fromDom","nodes","option","editor","defaultWidth","getPixelForcedWidth","parentBlock","determineDefaultTableStyles","defaultStyles","isTableResponsiveForced","shouldStyleWithCss","isTablePixelsForced","determineDefaultTableAttributes","defaultAttributes","register","registerOption","valid","getTableCloneElements","hasTableObjectResizing","objectResizing","getTableHeaderType","getTableColumnResizingBehaviour","isPreserveTableColumnResizing","isResizeTableColumnResizing","getTableSizingMode","isTablePercentagesForced","hasTableResizeBars","shouldMergeContentOnPaste","getTableDefaultAttributes","options","getTableDefaultStyles","tableUseColumnGroup","closest","isEditable$1","assumeEditable","editable","getRaw","getBody","getIsRoot","removeDataStyle","removeStyleAttribute","getSelectionStart","getPixelWidth","getPixelHeight","getRawWidth","isPercentage$1","isPixel","isInEditableContext$1","inSelection","leftEdge","rightEdge","topEdge","bottomEdge","isWithin","isRectangular","isRect","detailIsWithin","getBounds","detailA","detailB","getAnyBox","startCell","finishCell","startCoords","finishCoords","sc","fc","getBox$1","moveBy$1","intercepts$1","finish","inside","parentCell","innerCell","isContainedBy","c1","c2","moveBy","deltaRow","deltaColumn","getWarehouse","intercepts","nestedIntercepts","firstTable","lastTable","optStartCell","optLastCell","lastCell","getBox","TagBoundaries","DomUniverse","document","isBoundary","isEmptyTag","isNonEditable","comparePosition","other","copyAttributesTo","destination","as","isSpecial","getLanguage","universe","look","tail","oneAll","unsafeOne","commonElement","eq","ancestors$2","ps1","ps2","prune","ind","pruned1","pruned2","shared","sharedOne$1","ancestors$1","universe$3","sharedOne","_universe","ancestors","lookupTable","container","identify","rootTable","startTable","finishTable","ancestorCells","lca","lcaTable","finishAncestorCells","startAncestorCells","retrieve$1","sels","getLast","boxes","lastSelectedSelector","getEdges","firstSelectedSelector","expandTo","identified","shiftSelection","retrieve","retrieveBox","edges","sectionSelector","firstAncestor","lastAncestor","fA","lA","selection","unmergable","hasSpan","hasRowOrColSpan","mergable","ephemera","strSelected","strSelectedSelector","strAttributeSelector","strFirstSelected","strFirstSelectedSelector","strLastSelected","strLastSelectedSelector","attributeSelector","forMenu","paste","clipboard","generators","pasteRows","_cell","getSelectionCellFallback","getSelectionFromSelector","initCell","cellName","getSelectionCellOrCaption","getSelectionCell","getCellsFromSelection","getCellsFromFakeSelection","extractSelected","serializeElements","getTextContent","registerEvents","actions","multiCellContext","content","isTable","targets","point","offset","scan$1","toEnd","freefallRtl$2","freefallRtl$1","universe$2","freefallRtl","halve","main","surround","sizes","startIndex","endIndex","results","clampDeltaHelper","minCellSize","diff","clampNegativeDelta","clampDelta","resizeTable","calcFixedDeltas","clampedDelta","calcRelativeDeltas","ratio","newThis","calcLeftEdgeDeltas","isRelative","resizer","_prev","totalWidth","pixelDelta","newSizes","preserveTable","isLastColumn","maxDelta","_index","_minCellSize","_totalWidth","_pixelDelta","_isRelative","getGridSize","isHeaderCell","isHeaderCells","getRowHeaderType","isHeaderRow","getRowType","findCommonCellType","headerCells","findCommonRowType","rowTypes","hasHeader","hasFooter","hasBody","findTableRowHeaderType","rowType","transformCell","substitution","transformRow","fixedCell","sectionCells","TableSection","setIfNot","ignore","insert$1","generateSection","sectionName","newSection","render$1","newRows","syncRows","gridSection","tr","syncColGroup","colGroup","renderSection","sectionElems","removeSection","renderOrRemoveSection","headSection","bodySection","footSection","columnGroupsSection","clonedCell","getColumn","getRow","findDiff","comp","subgrid","isColRow","toDetails","seen","updateSeen","details","toGrid","colgroupCols","rowCells","rowDetail","fromWarehouse","toDetailList","findInWarehouse","extractCells","cell$1","lc","run","operation","extract","adjustment","postAction","genWrappers","behaviours","tableSection","model","out","newElements","tableSizing","resizing","onPaste","onPasteByEditor","onMergable","_warehouse","onUnmergable","onCells","onUnlockedCells","isUnlockedTableCell","allUnlocked","onUnlockedMergable","mergeable","onUnlockedUnmergable","merge$2","unmerge","currentCell","currentCellElm","isToReplace","uniqueCells","splitCols","prevCell","substitute","splitRows","rowPrevCells","sub","value$1","applyHelper","constHelper","outputHelper","output","_onError","onValue","Result","error","onError","_onValue","optional","err","measure","startAddress","gridA","gridB","rowRemainder","colRemainder","colRequired","rowRequired","measureWidth","colLengthA","colLengthB","measureHeight","rowLengthA","rowLengthB","generateElements","generator","rowFill","exampleRow","colFill","newChildren","lockedColFill","colNum","newChild","tailor","fillCols","fillRows","gridWidth","isLastColLocked","modifiedCols","newLockedColumns","isSpanning","matching","mergeTables","gridBRows","mergeHeight","mergeWidth","lockedColumnObj","skippedCol","gridBColIndex","newCellElm","getValidStartAddress","currentStartAddress","gridColLength","adjustedRowAddress","possibleColAddresses","validColAddress","getLockedColumnsWithinBounds","merge$1","validStartAddress","lockedColumnsWithinBounds","fittedGrid","newLockedColumnsWithinBounds","insertCols","fittedNewGrid","secondDelta","fittedOldGrid","insertRows","oldCols","oldRows","newLocked","secondDiff","fittedGridB","insertRowAt","example","newRow","ex","getElementFor","withinSpan","insertColumnAt","deleteColumnsAt","deleteRowsAt","notInStartRow","notInStartColumn","isDuplicatedCell","rowReplacerPredicate","targetRow","columnHeaders","_rowIndex","columnReplacePredicate","targetColumn","rowHeaders","_colIndex","determineScope","applyScope","newScope","isInHeader","getScope","rowScopeGenerator","columnScopeGenerator","replace","replaceIn","replacer","genScope","shouldReplace","isTarget","getColumnCells","getRowCells","replaceColumns","indexes","shouldReplaceCell","scopeGenerator","replaceRows","newGrid","replaceCells","targetCells","Adt","cases","constructors","adt","acase","count","keys$1","argLength","foldArgs","branches","branchKeys","reqKey","label","ColumnContext","neighbours","determine","resize","context","onOnly","onLeft","onMiddle","onRight","measures","recalculateWidthForCells","widths","recalculateWidthForColumns","groups","recalculateHeightForCells","heights","matchRowHeight","sumUp","recalculate","recalculateAndApply","adjustWidth","clampedStep","deltas","newWidths","dx","adjustHeight","newHeights","dy","newCellSizes","newRowSizes","adjustAndRedistributeWidths$1","_table","resizeBehaviour","tablePixelWidth","adjustWidthTo","_info","uniqueColumns","currentDetail","isCol","isColgroup","isRow$1","elementToData","modification","toData","nuCell","data","nuRow","add","recent","transform$1","makeNew","getScopeAttribute","Generators","getScopeProperty","stringAttributes","baseScope","scopes","blockList","isList$1","tagName","isBlock$1","isEmptyTag$1","universe$1","isBlock","isList","merge","isBr","advancedBr","isListItem","siblingIsBlock","rightSibling","markCell","rightSiblingIsBlock","contents","isEditable","outcome","cursor","findEditableCursorPosition","elementFromGrid","_b","bundle","cursorElement","uniqueRows","opInsertRowsBefore","targetIndex","opInsertRowsAfter","newG","opInsertColumnsBefore","extractDetail","opInsertColumnsAfter","opMakeColumnsHeader","initialGrid","columnIndexes","opMakeCellsHeader","opUnmakeColumnsHeader","opUnmakeCellsHeader","makeRowsSection","rowIndexes","opMakeRowsHeader","opMakeRowsBody","opMakeRowsFooter","opEraseColumns","_comparator","_genWrappers","maxColIndex","opEraseRows","maxRowIndex","opMergeCells","opUnmergeCells","opPasteCells","pasteDetails","wh","gridifyRows","opPasteColsBefore","mergedGrid","opPasteColsAfter","opPasteRowsBefore","opPasteRowsAfter","opGetColumnsType","lastSelectedCell","minColRange","maxColRange","selectedColumnCells","opGetCellsType","opGetRowsType","minRowRange","maxRowRange","selectedRows","adjustAndRedistributeWidths","firstColumnIsLocked","lastColumnIsLocked","getColumnsWidth","uniqueCols","colWidth","insertColumnsExtractor","eraseColumnsExtractor","pasteColumnsExtractor","headerCellGenerator","bodyCellGenerator","insertRowsBefore","insertRowsAfter","insertColumnsBefore","insertColumnsAfter","eraseColumns","eraseRows","makeColumnsHeader","unmakeColumnsHeader","makeRowsHeader","makeRowsBody","makeRowsFooter","makeCellsHeader","unmakeCellsHeader","mergeCells","unmergeCells","pasteCells","pasteColsBefore","pasteColsAfter","pasteRowsBefore","pasteRowsAfter","getColumnsType","getCellsType","getRowsType","fireNewRow","fireNewCell","fireTableModified","fireTableSelectionChange","otherCells","fireTableSelectionClear","fireObjectResizeStart","origin","fireObjectResized","styleModified","structureModified","styleAndStructureModified","get$5","TableActions","resizeHandler","cellSelectionHandler","isTableBody","lastRowGuard","lastColumnGuard","colMutationOp","getTableSectionType","setSelectionFromAction","firstCell","rng","des","execute","guard","effect","noEvents","range","deleteRow","deleteColumn","insertRowsBefore$1","insertRowsAfter$1","insertColumnsBefore$1","insertColumnsAfter$1","mergeCells$1","unmergeCells$1","pasteColsBefore$1","pasteColsAfter$1","pasteRowsBefore$1","pasteRowsAfter$1","pasteCells$1","makeCellsHeader$1","unmakeCellsHeader$1","makeColumnsHeader$1","unmakeColumnsHeader$1","makeRowsHeader$1","makeRowsBody$1","makeRowsFooter$1","constrainSpan","currentColspan","isColInRange","generateColGroup","colsToCopy","copiedCols","clonedCol","fakeColgroup","generateRows","cellsToCopy","copiedCells","fakeTR","copyCols","fakeColGroups","fakeRows","copyRows","slicedGrid","filteredGrid","slicedDetails","adt$5","validateFor","rawAmount","Size","redistributeToPercent","pc","redistributeToPx","newTotalWidth","scale","redistributeEmpty","newWidthType","pixels","redistributeValues","_pc","redistribute$1","newType","floats","normalize","sum","roundDown","floored","add$3","scan","validate","redistributeToW","redistributeToColumns","redistributeToH","getUnit","redistribute","optWidth","optHeight","widthUnit","oldWidths","nuWidths","newHeight","hUnit","totalHeight","oldHeights","nuHeights","isPercentSizing","isPixelSizing","isNoneSizing","cleanupLegacyAttributes","convertToPercentSize","convertToPixelSize","convertToNoneSize","rowElements","DefaultRenderOptions","tableHeaderCell","tableCell","tableColumn","createRow","createGroupRow","createRows","render","headerType","renderOpts","rowHeadersGoInThead","actualRowHeaders","thead","theadRows","tbody","numRows","tbodyRows","get$4","placeCaretInCell","selectFirstCellInTable","tableElm","fireEvents","isPercentage","insert","colHeaders","insertTable","checkInput","headerRows","headerColumns","global","tableTypeBase","tableTypeRow","tableTypeColumn","setData","items","fakeClipboardItem","getData","clearData","setRows","rowsOpt","clearRows","getRows","setColumns","columnsOpt","clearColumns","getColumns","getSelectionStartCellOrCaption","getSelectionStartCell","registerCommands","eraseTable","cellOrCaption","setSizingMode","sizing","getTableFromCell","performActionOnSelection","action","toggleTableClass","_ui","clazz","toggleTableCellClass","formatterAction","toggleCaption","caption","postExecute","_data","actOnSelection","copyRowSelection","copyColSelection","pasteOnSelection","clonedRows","actOnType","getAction","func","getFormatName","style","validArgs","formatName","registerQueryCommands","lookupOnSelection","adt$4","cata$1","subject","onBefore","onOn","onAfter","getStart$1","situ","before$2","on","after$3","Situ","Response","kill","selectNode","selectNodeContents","selectNodeContentsUsing","setStart","setFinish","relativeToNative","startSitu","finishSitu","exactToNative","soffset","foffset","toRect","rect","getFirstRect$1","rects","adt$3","fromRange","getRanges","doDiagnose","ranges","rev","diagnose","asLtrRange","SimRange","Situs","convertToRange","makeSitus","sync","selectRange","detect","cellSel","update","selected","annotations","updateSelection","newSels","traverse","mode","backtrack","_direction","transition","sidestep","advance","successors","go","rules","succ","rule","Walkers","hone","right","isLeaf","before$1","seekLeft$1","after$2","seekRight$1","after$1","seekLeft","seekRight","adt$2","isOverlapping","bridge","beforeBounds","afterBounds","isRow","BeforeAfter","beforeOffset","afterOffset","failure","afterCell","beforeCell","_sharedRow","onSuccess","onFailedUp","onFailedDown","inParent","indexInParent","indexOf","gatherer","cand","gather","handleBr","findBr","handleParent","br","adjacent","tryBr","tgt","process","analysis","_message","moveDown","caret","moveUp","translate","xDelta","yDelta","getTop","getBottom","getPartialBox","toCaret","getElemBox","getBoxAt","getEntireBox","JUMP_SIZE","NUM_RETRIES","adt$1","isOutside","inOutsideBlock","adjustDown","guessBox","lowerCaret","upMovement","higherCaret","downMovement","isAtTable","adjustForTable","movement","numRetries","adjustTil","guess","newCaret","checkScroll","adjusted","retry","moved","Retries","MAX_RETRIES","findSpot","sel","brNeighbour","tryCursor","situs","tryAgain","move","tryAt","handle$1","spot","inSameTable","simulate","initial","anchor","navigate","precheck","firstUpCheck","lastOffset","lastDownCheck","select","Cell","singleton","doRevoke","revoke","findCell","isInEditableContext","MouseSelection","clearstate","applySelection","singleCell","isNonEditableCell","isCellClosestContentEditable","down","up","isKey","keycode","isUp","isDown","isNavigation","ltr","rtl","get$3","_DOC","by","exactFromRange","simRange","getStart","_finishSitu","_soffset","_finish","_foffset","domRange","relative","exact","getWin","SimSelection","caretPositionFromPoint","caretRangeFromPoint","availableSearch","fromPoint","beforeSpecial","name$1","preprocessRelative","preprocessExact","makeRange","same","getNativeSelection","doSetNativeRange","doSetRange","setLegacyRtlRange","setRangeFromRelative","setExact","setRelative","readRange","firstRng","lastRng","doGetExact","focus","setToElement","selectNodeContents$1","getExact","get$2","getFirstRect","getAtPoint","clear","WindowBridge","exactAdt","toStart","rc","mouse","handlers","isEditableNode","isEditableSelection","keyboard","clearToNavigate","realEvent","shiftKey","update$1","attempts","_","external","read","add$2","id","remove$4","supports","get$1","add$1","remove$3","cleanClass","remove$2","has","remove$1","classes","addClass","removeClasses","SelectionAnnotation","addSelectionClass","removeSelectionClasses","onSelection","onClear","removeSelectionAttributes","addSelectionAttribute","clearBeforeUpdate","fold","onMultiple","onSingle","none","multiple","single","Selections","lazyRoot","getUpOrLeftCells","upGrid","upDetails","slicedCells","getDownOrRightCells","downGrid","downDetails","getOtherCells","upOrLeftCells","downOrRightCells","mkEvent","prevent","fromRawEvent$1","rawEvent","handle","handler","useCapture","wrapped","unbind","bind$1","bind","fromRawEvent","hasInternalTarget","TableCellSelectionHandler","cellSelection","_e","syncSelection","mouseHandlers","keyHandlers","external$1","hasShiftKey","handleResponse","response","ns","keyup","wrappedEvent","keydown","isLeftMouse","isLeftButtonPressed","dragStart","mouseDown","mouseOver","mouseUp","doubleTap","lastTarget","lastTimeStamp","lT","lTS","Event","fields","create$1","typeDefs","registry","trigger","rate","timer","cancel","sort","reqMessage","required","unsuppMessage","unsupported","validateStrArr","invalidTypeMessage","incorrect","checkDupes","everything","sorted","handleUnsupported","baseWith","req","invalidKeys","handleExact","exactly","DragMode","DragSink","DragApi","InDrag","previous","reset","old","onEvent","events","NoDrag","Movement","noDragState","inDragState","dragState","setup","mutation","settings","active","drop","sink","throttledDrop","mousemove","off","isActive","runIfActive","destroy","namespace","dashNamespace","resolve","resolve$1","Blocker","MouseDrag","dragApi","blocker","mdown","mup","mmove","mout","transform","Mutation","BarMutation","delegate","bar","resizeBar","resizeRowBar","resizeColBar","BAR_THICKNESS","resizableRows","isResizable","resizableColumns","resizableCols","wire","drawBar","positions","create","cpOption","cp","refreshCol","colPositions","position","tableHeight","colBar","refreshRow","rowPositions","tableWidth","rowBar","refreshGrid","warhouse","resizableRowBars","resizableRowPositions","_pos","barIndex","resizableColBars","resizableColPositions","refresh","each","bars","hide","show","isRowBar","isColBar","resizeBarDragging","BarManager","hoverTable","getResizer","_dataRow","_dataCol","currentCol","getDelta","dir","newX","oldX","mousedown","findClosestEditableTable","mouseover","destroy$1","refresh$1","tbl","TableResize","lazySizing","hdirection","vdirection","manager","_event","ResizeWire","chrome","createContainer","remove","barResizerPrefix","syncPixels","computedWidth","TableResizeHandler","selectionRng","tableResize","resizeWire","startW","startRawW","lazyResizingBehaviour","getNumColumns","afterCornerResize","isRightEdgeResize","percentW","targetPercentW","sz","rawWire","rawTable","targetElm","setupTable","DomModel","Model"],"mappings":"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","x_google_ignoreList":[0]}