{"version":3,"file":"index-DrQW0O16.js","sources":["../node_modules/.pnpm/tinymce@6.8.6/node_modules/tinymce/plugins/lists/plugin.js"],"sourcesContent":["/**\n * TinyMCE version 6.8.6 (TBD)\n */\n\n(function () {\n    'use strict';\n\n    var global$7 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isArray = isType$1('array');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    const noop = () => {\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const never = constant(false);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains$1 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const map = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$1 = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const filter$1 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const groupBy = (xs, f) => {\n      if (xs.length === 0) {\n        return [];\n      } else {\n        let wasType = f(xs[0]);\n        const r = [];\n        let group = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n          const x = xs[i];\n          const type = f(x);\n          if (type !== wasType) {\n            r.push(group);\n            group = [];\n          }\n          wasType = type;\n          group.push(x);\n        }\n        if (group.length !== 0) {\n          r.push(group);\n        }\n        return r;\n      }\n    };\n    const foldl = (xs, f, acc) => {\n      each$1(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find = (xs, pred) => {\n      return findUntil(xs, pred, never);\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind = (xs, f) => flatten(map(xs, f));\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const get$1 = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$1(xs, 0);\n    const last = xs => get$1(xs, xs.length - 1);\n    const unique = (xs, comparator) => {\n      const r = [];\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$1(r, x);\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (!isDuplicated(x)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$1(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$1(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$1(node);\n    };\n    const fromDom$1 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);\n    const SugarElement = {\n      fromHtml,\n      fromTag,\n      fromText,\n      fromDom: fromDom$1,\n      fromPoint\n    };\n\n    const is$1 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n    const is = is$1;\n\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const path = (parts, scope) => {\n      let o = scope !== undefined && scope !== null ? scope : Global;\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n        o = o[parts[i]];\n      }\n      return o;\n    };\n    const resolve = (p, scope) => {\n      const parts = p.split('.');\n      return path(parts, scope);\n    };\n\n    const unsafe = (name, scope) => {\n      return resolve(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n      const actual = unsafe(name, scope);\n      if (actual === undefined || actual === null) {\n        throw new Error(name + ' not available on this browser');\n      }\n      return actual;\n    };\n\n    const getPrototypeOf = Object.getPrototypeOf;\n    const sandHTMLElement = scope => {\n      return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = x => {\n      const scope = resolve('ownerDocument.defaultView', x);\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf(x).constructor.name));\n    };\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type = element => element.dom.nodeType;\n    const isType = t => element => type(element) === t;\n    const isComment = element => type(element) === COMMENT || name(element) === '#comment';\n    const isHTMLElement = element => isElement$1(element) && isPrototypeOf(element.dom);\n    const isElement$1 = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocument = isType(DOCUMENT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement$1(e) && name(e) === tag;\n\n    const owner = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument(dos) ? dos : owner(dos);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const children = element => map(element.dom.childNodes, SugarElement.fromDom);\n    const child = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child(element, 0);\n    const lastChild = element => child(element, element.dom.childNodes.length - 1);\n\n    const isShadowRoot = dos => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n\n    const inBody = element => {\n      const dom = isText(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$3 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$2 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$3, scope, predicate, isRoot);\n    };\n\n    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, e => is$1(e, selector), isRoot);\n    const closest$1 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$1(element, selector);\n      return ClosestOrAncestor(is, ancestor$2, scope, selector, isRoot);\n    };\n\n    const closest = target => closest$1(target, '[contenteditable]');\n    const isEditable = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest(element).fold(constant(assumeEditable), editable => getRaw(editable) === 'true');\n      }\n    };\n    const getRaw = element => element.dom.contentEditable;\n\n    const before$1 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$1(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n\n    const before = (marker, elements) => {\n      each$1(elements, x => {\n        before$1(marker, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$1(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$1(children(element), rogue => {\n        remove(rogue);\n      });\n    };\n    const remove = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n\n    var global$6 = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils');\n\n    var global$5 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.util.VK');\n\n    const fromDom = nodes => map(nodes, SugarElement.fromDom);\n\n    const keys = Object.keys;\n    const each = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const filter = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const setAll = (element, attrs) => {\n      const dom = element.dom;\n      each(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const clone$1 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const clone = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const deep = original => clone(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$1(original);\n      setAll(nu, attributes);\n      return nu;\n    };\n    const mutate = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after(original, nu);\n      const children$1 = children(original);\n      append(nu, children$1);\n      remove(original);\n      return nu;\n    };\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const matchNodeName = name => node => isNonNullable(node) && node.nodeName.toLowerCase() === name;\n    const matchNodeNames = regex => node => isNonNullable(node) && regex.test(node.nodeName);\n    const isTextNode$1 = node => isNonNullable(node) && node.nodeType === 3;\n    const isElement = node => isNonNullable(node) && node.nodeType === 1;\n    const isListNode = matchNodeNames(/^(OL|UL|DL)$/);\n    const isOlUlNode = matchNodeNames(/^(OL|UL)$/);\n    const isOlNode = matchNodeName('ol');\n    const isListItemNode = matchNodeNames(/^(LI|DT|DD)$/);\n    const isDlItemNode = matchNodeNames(/^(DT|DD)$/);\n    const isTableCellNode = matchNodeNames(/^(TH|TD)$/);\n    const isBr = matchNodeName('br');\n    const isFirstChild = node => {\n      var _a;\n      return ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === node;\n    };\n    const isTextBlock = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getTextBlockElements();\n    const isBlock = (node, blockElements) => isNonNullable(node) && node.nodeName in blockElements;\n    const isVoid = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getVoidElements();\n    const isBogusBr = (dom, node) => {\n      if (!isBr(node)) {\n        return false;\n      }\n      return dom.isBlock(node.nextSibling) && !isBr(node.previousSibling);\n    };\n    const isEmpty$2 = (dom, elm, keepBookmarks) => {\n      const empty = dom.isEmpty(elm);\n      if (keepBookmarks && dom.select('span[data-mce-type=bookmark]', elm).length > 0) {\n        return false;\n      }\n      return empty;\n    };\n    const isChildOfBody = (dom, elm) => dom.isChildOf(elm, dom.getRoot());\n\n    const option = name => editor => editor.options.get(name);\n    const register$3 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('lists_indent_on_tab', {\n        processor: 'boolean',\n        default: true\n      });\n    };\n    const shouldIndentOnTab = option('lists_indent_on_tab');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n\n    const createTextBlock = (editor, contentNode) => {\n      const dom = editor.dom;\n      const blockElements = editor.schema.getBlockElements();\n      const fragment = dom.createFragment();\n      const blockName = getForcedRootBlock(editor);\n      const blockAttrs = getForcedRootBlockAttrs(editor);\n      let node;\n      let textBlock;\n      let hasContentNode = false;\n      textBlock = dom.create(blockName, blockAttrs);\n      if (!isBlock(contentNode.firstChild, blockElements)) {\n        fragment.appendChild(textBlock);\n      }\n      while (node = contentNode.firstChild) {\n        const nodeName = node.nodeName;\n        if (!hasContentNode && (nodeName !== 'SPAN' || node.getAttribute('data-mce-type') !== 'bookmark')) {\n          hasContentNode = true;\n        }\n        if (isBlock(node, blockElements)) {\n          fragment.appendChild(node);\n          textBlock = null;\n        } else {\n          if (!textBlock) {\n            textBlock = dom.create(blockName, blockAttrs);\n            fragment.appendChild(textBlock);\n          }\n          textBlock.appendChild(node);\n        }\n      }\n      if (!hasContentNode && textBlock) {\n        textBlock.appendChild(dom.create('br', { 'data-mce-bogus': '1' }));\n      }\n      return fragment;\n    };\n\n    const DOM$2 = global$3.DOM;\n    const splitList = (editor, list, li) => {\n      const removeAndKeepBookmarks = targetNode => {\n        const parent = targetNode.parentNode;\n        if (parent) {\n          global$2.each(bookmarks, node => {\n            parent.insertBefore(node, li.parentNode);\n          });\n        }\n        DOM$2.remove(targetNode);\n      };\n      const bookmarks = DOM$2.select('span[data-mce-type=\"bookmark\"]', list);\n      const newBlock = createTextBlock(editor, li);\n      const tmpRng = DOM$2.createRng();\n      tmpRng.setStartAfter(li);\n      tmpRng.setEndAfter(list);\n      const fragment = tmpRng.extractContents();\n      for (let node = fragment.firstChild; node; node = node.firstChild) {\n        if (node.nodeName === 'LI' && editor.dom.isEmpty(node)) {\n          DOM$2.remove(node);\n          break;\n        }\n      }\n      if (!editor.dom.isEmpty(fragment)) {\n        DOM$2.insertAfter(fragment, list);\n      }\n      DOM$2.insertAfter(newBlock, list);\n      const parent = li.parentElement;\n      if (parent && isEmpty$2(editor.dom, parent)) {\n        removeAndKeepBookmarks(parent);\n      }\n      DOM$2.remove(li);\n      if (isEmpty$2(editor.dom, list)) {\n        DOM$2.remove(list);\n      }\n    };\n\n    const isDescriptionDetail = isTag('dd');\n    const isDescriptionTerm = isTag('dt');\n    const outdentDlItem = (editor, item) => {\n      if (isDescriptionDetail(item)) {\n        mutate(item, 'dt');\n      } else if (isDescriptionTerm(item)) {\n        parentElement(item).each(dl => splitList(editor, dl.dom, item.dom));\n      }\n    };\n    const indentDlItem = item => {\n      if (isDescriptionTerm(item)) {\n        mutate(item, 'dd');\n      }\n    };\n    const dlIndentation = (editor, indentation, dlItems) => {\n      if (indentation === 'Indent') {\n        each$1(dlItems, indentDlItem);\n      } else {\n        each$1(dlItems, item => outdentDlItem(editor, item));\n      }\n    };\n\n    const getNormalizedPoint = (container, offset) => {\n      if (isTextNode$1(container)) {\n        return {\n          container,\n          offset\n        };\n      }\n      const node = global$6.getNode(container, offset);\n      if (isTextNode$1(node)) {\n        return {\n          container: node,\n          offset: offset >= container.childNodes.length ? node.data.length : 0\n        };\n      } else if (node.previousSibling && isTextNode$1(node.previousSibling)) {\n        return {\n          container: node.previousSibling,\n          offset: node.previousSibling.data.length\n        };\n      } else if (node.nextSibling && isTextNode$1(node.nextSibling)) {\n        return {\n          container: node.nextSibling,\n          offset: 0\n        };\n      }\n      return {\n        container,\n        offset\n      };\n    };\n    const normalizeRange = rng => {\n      const outRng = rng.cloneRange();\n      const rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);\n      outRng.setStart(rangeStart.container, rangeStart.offset);\n      const rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);\n      outRng.setEnd(rangeEnd.container, rangeEnd.offset);\n      return outRng;\n    };\n\n    const listNames = [\n      'OL',\n      'UL',\n      'DL'\n    ];\n    const listSelector = listNames.join(',');\n    const getParentList = (editor, node) => {\n      const selectionStart = node || editor.selection.getStart(true);\n      return editor.dom.getParent(selectionStart, listSelector, getClosestListHost(editor, selectionStart));\n    };\n    const isParentListSelected = (parentList, selectedBlocks) => isNonNullable(parentList) && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;\n    const findSubLists = parentList => filter$1(parentList.querySelectorAll(listSelector), isListNode);\n    const getSelectedSubLists = editor => {\n      const parentList = getParentList(editor);\n      const selectedBlocks = editor.selection.getSelectedBlocks();\n      if (isParentListSelected(parentList, selectedBlocks)) {\n        return findSubLists(parentList);\n      } else {\n        return filter$1(selectedBlocks, elm => {\n          return isListNode(elm) && parentList !== elm;\n        });\n      }\n    };\n    const findParentListItemsNodes = (editor, elms) => {\n      const listItemsElms = global$2.map(elms, elm => {\n        const parentLi = editor.dom.getParent(elm, 'li,dd,dt', getClosestListHost(editor, elm));\n        return parentLi ? parentLi : elm;\n      });\n      return unique(listItemsElms);\n    };\n    const getSelectedListItems = editor => {\n      const selectedBlocks = editor.selection.getSelectedBlocks();\n      return filter$1(findParentListItemsNodes(editor, selectedBlocks), isListItemNode);\n    };\n    const getSelectedDlItems = editor => filter$1(getSelectedListItems(editor), isDlItemNode);\n    const getClosestEditingHost = (editor, elm) => {\n      const parentTableCell = editor.dom.getParents(elm, 'TD,TH');\n      return parentTableCell.length > 0 ? parentTableCell[0] : editor.getBody();\n    };\n    const isListHost = (schema, node) => !isListNode(node) && !isListItemNode(node) && exists(listNames, listName => schema.isValidChild(node.nodeName, listName));\n    const getClosestListHost = (editor, elm) => {\n      const parentBlocks = editor.dom.getParents(elm, editor.dom.isBlock);\n      const parentBlock = find(parentBlocks, elm => isListHost(editor.schema, elm));\n      return parentBlock.getOr(editor.getBody());\n    };\n    const isListInsideAnLiWithFirstAndLastNotListElement = list => parent(list).exists(parent => isListItemNode(parent.dom) && firstChild(parent).exists(firstChild => !isListNode(firstChild.dom)) && lastChild(parent).exists(lastChild => !isListNode(lastChild.dom)));\n    const findLastParentListNode = (editor, elm) => {\n      const parentLists = editor.dom.getParents(elm, 'ol,ul', getClosestListHost(editor, elm));\n      return last(parentLists);\n    };\n    const getSelectedLists = editor => {\n      const firstList = findLastParentListNode(editor, editor.selection.getStart());\n      const subsequentLists = filter$1(editor.selection.getSelectedBlocks(), isOlUlNode);\n      return firstList.toArray().concat(subsequentLists);\n    };\n    const getParentLists = editor => {\n      const elm = editor.selection.getStart();\n      return editor.dom.getParents(elm, 'ol,ul', getClosestListHost(editor, elm));\n    };\n    const getSelectedListRoots = editor => {\n      const selectedLists = getSelectedLists(editor);\n      const parentLists = getParentLists(editor);\n      return find(parentLists, p => isListInsideAnLiWithFirstAndLastNotListElement(SugarElement.fromDom(p))).fold(() => getUniqueListRoots(editor, selectedLists), l => [l]);\n    };\n    const getUniqueListRoots = (editor, lists) => {\n      const listRoots = map(lists, list => findLastParentListNode(editor, list).getOr(list));\n      return unique(listRoots);\n    };\n\n    const isCustomList = list => /\\btox\\-/.test(list.className);\n    const inList = (parents, listName) => findUntil(parents, isListNode, isTableCellNode).exists(list => list.nodeName === listName && !isCustomList(list));\n    const isWithinNonEditable = (editor, element) => element !== null && !editor.dom.isEditable(element);\n    const selectionIsWithinNonEditableList = editor => {\n      const parentList = getParentList(editor);\n      return isWithinNonEditable(editor, parentList);\n    };\n    const isWithinNonEditableList = (editor, element) => {\n      const parentList = editor.dom.getParent(element, 'ol,ul,dl');\n      return isWithinNonEditable(editor, parentList);\n    };\n    const setNodeChangeHandler = (editor, nodeChangeHandler) => {\n      const initialNode = editor.selection.getNode();\n      nodeChangeHandler({\n        parents: editor.dom.getParents(initialNode),\n        element: initialNode\n      });\n      editor.on('NodeChange', nodeChangeHandler);\n      return () => editor.off('NodeChange', nodeChangeHandler);\n    };\n\n    const fromElements = (elements, scope) => {\n      const doc = scope || document;\n      const fragment = doc.createDocumentFragment();\n      each$1(elements, element => {\n        fragment.appendChild(element.dom);\n      });\n      return SugarElement.fromDom(fragment);\n    };\n\n    const fireListEvent = (editor, action, element) => editor.dispatch('ListMutation', {\n      action,\n      element\n    });\n\n    const blank = r => s => s.replace(r, '');\n    const trim = blank(/^\\s+|\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty$1 = s => !isNotEmpty(s);\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const set = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n\n    const isList = el => is(el, 'OL,UL');\n    const isListItem = el => is(el, 'LI');\n    const hasFirstChildList = el => firstChild(el).exists(isList);\n    const hasLastChildList = el => lastChild(el).exists(isList);\n\n    const isEntryList = entry => 'listAttributes' in entry;\n    const isEntryComment = entry => 'isComment' in entry;\n    const isEntryFragment = entry => 'isFragment' in entry;\n    const isIndented = entry => entry.depth > 0;\n    const isSelected = entry => entry.isSelected;\n    const cloneItemContent = li => {\n      const children$1 = children(li);\n      const content = hasLastChildList(li) ? children$1.slice(0, -1) : children$1;\n      return map(content, deep);\n    };\n    const createEntry = (li, depth, isSelected) => parent(li).filter(isElement$1).map(list => ({\n      depth,\n      dirty: false,\n      isSelected,\n      content: cloneItemContent(li),\n      itemAttributes: clone$1(li),\n      listAttributes: clone$1(list),\n      listType: name(list),\n      isInPreviousLi: false\n    }));\n\n    const joinSegment = (parent, child) => {\n      append$1(parent.item, child.list);\n    };\n    const joinSegments = segments => {\n      for (let i = 1; i < segments.length; i++) {\n        joinSegment(segments[i - 1], segments[i]);\n      }\n    };\n    const appendSegments = (head$1, tail) => {\n      lift2(last(head$1), head(tail), joinSegment);\n    };\n    const createSegment = (scope, listType) => {\n      const segment = {\n        list: SugarElement.fromTag(listType, scope),\n        item: SugarElement.fromTag('li', scope)\n      };\n      append$1(segment.list, segment.item);\n      return segment;\n    };\n    const createSegments = (scope, entry, size) => {\n      const segments = [];\n      for (let i = 0; i < size; i++) {\n        segments.push(createSegment(scope, isEntryList(entry) ? entry.listType : entry.parentListType));\n      }\n      return segments;\n    };\n    const populateSegments = (segments, entry) => {\n      for (let i = 0; i < segments.length - 1; i++) {\n        set(segments[i].item, 'list-style-type', 'none');\n      }\n      last(segments).each(segment => {\n        if (isEntryList(entry)) {\n          setAll(segment.list, entry.listAttributes);\n          setAll(segment.item, entry.itemAttributes);\n        }\n        append(segment.item, entry.content);\n      });\n    };\n    const normalizeSegment = (segment, entry) => {\n      if (name(segment.list) !== entry.listType) {\n        segment.list = mutate(segment.list, entry.listType);\n      }\n      setAll(segment.list, entry.listAttributes);\n    };\n    const createItem = (scope, attr, content) => {\n      const item = SugarElement.fromTag('li', scope);\n      setAll(item, attr);\n      append(item, content);\n      return item;\n    };\n    const appendItem = (segment, item) => {\n      append$1(segment.list, item);\n      segment.item = item;\n    };\n    const writeShallow = (scope, cast, entry) => {\n      const newCast = cast.slice(0, entry.depth);\n      last(newCast).each(segment => {\n        if (isEntryList(entry)) {\n          const item = createItem(scope, entry.itemAttributes, entry.content);\n          appendItem(segment, item);\n          normalizeSegment(segment, entry);\n        } else if (isEntryFragment(entry)) {\n          append(segment.item, entry.content);\n        } else {\n          const item = SugarElement.fromHtml(`<!--${ entry.content }-->`);\n          append$1(segment.list, item);\n        }\n      });\n      return newCast;\n    };\n    const writeDeep = (scope, cast, entry) => {\n      const segments = createSegments(scope, entry, entry.depth - cast.length);\n      joinSegments(segments);\n      populateSegments(segments, entry);\n      appendSegments(cast, segments);\n      return cast.concat(segments);\n    };\n    const composeList = (scope, entries) => {\n      let firstCommentEntryOpt = Optional.none();\n      const cast = foldl(entries, (cast, entry, i) => {\n        if (!isEntryComment(entry)) {\n          return entry.depth > cast.length ? writeDeep(scope, cast, entry) : writeShallow(scope, cast, entry);\n        } else {\n          if (i === 0) {\n            firstCommentEntryOpt = Optional.some(entry);\n            return cast;\n          }\n          return writeShallow(scope, cast, entry);\n        }\n      }, []);\n      firstCommentEntryOpt.each(firstCommentEntry => {\n        const item = SugarElement.fromHtml(`<!--${ firstCommentEntry.content }-->`);\n        head(cast).each(fistCast => {\n          prepend(fistCast.list, item);\n        });\n      });\n      return head(cast).map(segment => segment.list);\n    };\n\n    const indentEntry = (indentation, entry) => {\n      switch (indentation) {\n      case 'Indent':\n        entry.depth++;\n        break;\n      case 'Outdent':\n        entry.depth--;\n        break;\n      case 'Flatten':\n        entry.depth = 0;\n      }\n      entry.dirty = true;\n    };\n\n    const cloneListProperties = (target, source) => {\n      if (isEntryList(target) && isEntryList(source)) {\n        target.listType = source.listType;\n        target.listAttributes = { ...source.listAttributes };\n      }\n    };\n    const cleanListProperties = entry => {\n      entry.listAttributes = filter(entry.listAttributes, (_value, key) => key !== 'start');\n    };\n    const closestSiblingEntry = (entries, start) => {\n      const depth = entries[start].depth;\n      const matches = entry => entry.depth === depth && !entry.dirty;\n      const until = entry => entry.depth < depth;\n      return findUntil(reverse(entries.slice(0, start)), matches, until).orThunk(() => findUntil(entries.slice(start + 1), matches, until));\n    };\n    const normalizeEntries = entries => {\n      each$1(entries, (entry, i) => {\n        closestSiblingEntry(entries, i).fold(() => {\n          if (entry.dirty && isEntryList(entry)) {\n            cleanListProperties(entry);\n          }\n        }, matchingEntry => cloneListProperties(entry, matchingEntry));\n      });\n      return entries;\n    };\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const parseSingleItem = (depth, itemSelection, selectionState, item) => {\n      var _a;\n      if (isComment(item)) {\n        return [{\n            depth: depth + 1,\n            content: (_a = item.dom.nodeValue) !== null && _a !== void 0 ? _a : '',\n            dirty: false,\n            isSelected: false,\n            isComment: true\n          }];\n      }\n      itemSelection.each(selection => {\n        if (eq(selection.start, item)) {\n          selectionState.set(true);\n        }\n      });\n      const currentItemEntry = createEntry(item, depth, selectionState.get());\n      itemSelection.each(selection => {\n        if (eq(selection.end, item)) {\n          selectionState.set(false);\n        }\n      });\n      const childListEntries = lastChild(item).filter(isList).map(list => parseList(depth, itemSelection, selectionState, list)).getOr([]);\n      return currentItemEntry.toArray().concat(childListEntries);\n    };\n    const parseItem = (depth, itemSelection, selectionState, item) => firstChild(item).filter(isList).fold(() => parseSingleItem(depth, itemSelection, selectionState, item), list => {\n      const parsedSiblings = foldl(children(item), (acc, liChild, i) => {\n        if (i === 0) {\n          return acc;\n        } else {\n          if (isListItem(liChild)) {\n            return acc.concat(parseSingleItem(depth, itemSelection, selectionState, liChild));\n          } else {\n            const fragment = {\n              isFragment: true,\n              depth,\n              content: [liChild],\n              isSelected: false,\n              dirty: false,\n              parentListType: name(list)\n            };\n            return acc.concat(fragment);\n          }\n        }\n      }, []);\n      return parseList(depth, itemSelection, selectionState, list).concat(parsedSiblings);\n    });\n    const parseList = (depth, itemSelection, selectionState, list) => bind(children(list), element => {\n      const parser = isList(element) ? parseList : parseItem;\n      const newDepth = depth + 1;\n      return parser(newDepth, itemSelection, selectionState, element);\n    });\n    const parseLists = (lists, itemSelection) => {\n      const selectionState = Cell(false);\n      const initialDepth = 0;\n      return map(lists, list => ({\n        sourceList: list,\n        entries: parseList(initialDepth, itemSelection, selectionState, list)\n      }));\n    };\n\n    const outdentedComposer = (editor, entries) => {\n      const normalizedEntries = normalizeEntries(entries);\n      return map(normalizedEntries, entry => {\n        const content = !isEntryComment(entry) ? fromElements(entry.content) : fromElements([SugarElement.fromHtml(`<!--${ entry.content }-->`)]);\n        return SugarElement.fromDom(createTextBlock(editor, content.dom));\n      });\n    };\n    const indentedComposer = (editor, entries) => {\n      const normalizedEntries = normalizeEntries(entries);\n      return composeList(editor.contentDocument, normalizedEntries).toArray();\n    };\n    const composeEntries = (editor, entries) => bind(groupBy(entries, isIndented), entries => {\n      const groupIsIndented = head(entries).exists(isIndented);\n      return groupIsIndented ? indentedComposer(editor, entries) : outdentedComposer(editor, entries);\n    });\n    const indentSelectedEntries = (entries, indentation) => {\n      each$1(filter$1(entries, isSelected), entry => indentEntry(indentation, entry));\n    };\n    const getItemSelection = editor => {\n      const selectedListItems = map(getSelectedListItems(editor), SugarElement.fromDom);\n      return lift2(find(selectedListItems, not(hasFirstChildList)), find(reverse(selectedListItems), not(hasFirstChildList)), (start, end) => ({\n        start,\n        end\n      }));\n    };\n    const listIndentation = (editor, lists, indentation) => {\n      const entrySets = parseLists(lists, getItemSelection(editor));\n      each$1(entrySets, entrySet => {\n        indentSelectedEntries(entrySet.entries, indentation);\n        const composedLists = composeEntries(editor, entrySet.entries);\n        each$1(composedLists, composedList => {\n          fireListEvent(editor, indentation === 'Indent' ? 'IndentList' : 'OutdentList', composedList.dom);\n        });\n        before(entrySet.sourceList, composedLists);\n        remove(entrySet.sourceList);\n      });\n    };\n\n    const selectionIndentation = (editor, indentation) => {\n      const lists = fromDom(getSelectedListRoots(editor));\n      const dlItems = fromDom(getSelectedDlItems(editor));\n      let isHandled = false;\n      if (lists.length || dlItems.length) {\n        const bookmark = editor.selection.getBookmark();\n        listIndentation(editor, lists, indentation);\n        dlIndentation(editor, indentation, dlItems);\n        editor.selection.moveToBookmark(bookmark);\n        editor.selection.setRng(normalizeRange(editor.selection.getRng()));\n        editor.nodeChanged();\n        isHandled = true;\n      }\n      return isHandled;\n    };\n    const handleIndentation = (editor, indentation) => !selectionIsWithinNonEditableList(editor) && selectionIndentation(editor, indentation);\n    const indentListSelection = editor => handleIndentation(editor, 'Indent');\n    const outdentListSelection = editor => handleIndentation(editor, 'Outdent');\n    const flattenListSelection = editor => handleIndentation(editor, 'Flatten');\n\n    const zeroWidth = '\\uFEFF';\n    const isZwsp = char => char === zeroWidth;\n\n    const ancestor$1 = (scope, predicate, isRoot) => ancestor$3(scope, predicate, isRoot).isSome();\n\n    const ancestor = (element, target) => ancestor$1(element, curry(eq, target));\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.dom.BookmarkManager');\n\n    const DOM$1 = global$3.DOM;\n    const createBookmark = rng => {\n      const bookmark = {};\n      const setupEndPoint = start => {\n        let container = rng[start ? 'startContainer' : 'endContainer'];\n        let offset = rng[start ? 'startOffset' : 'endOffset'];\n        if (isElement(container)) {\n          const offsetNode = DOM$1.create('span', { 'data-mce-type': 'bookmark' });\n          if (container.hasChildNodes()) {\n            offset = Math.min(offset, container.childNodes.length - 1);\n            if (start) {\n              container.insertBefore(offsetNode, container.childNodes[offset]);\n            } else {\n              DOM$1.insertAfter(offsetNode, container.childNodes[offset]);\n            }\n          } else {\n            container.appendChild(offsetNode);\n          }\n          container = offsetNode;\n          offset = 0;\n        }\n        bookmark[start ? 'startContainer' : 'endContainer'] = container;\n        bookmark[start ? 'startOffset' : 'endOffset'] = offset;\n      };\n      setupEndPoint(true);\n      if (!rng.collapsed) {\n        setupEndPoint();\n      }\n      return bookmark;\n    };\n    const resolveBookmark = bookmark => {\n      const restoreEndPoint = start => {\n        const nodeIndex = container => {\n          var _a;\n          let node = (_a = container.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild;\n          let idx = 0;\n          while (node) {\n            if (node === container) {\n              return idx;\n            }\n            if (!isElement(node) || node.getAttribute('data-mce-type') !== 'bookmark') {\n              idx++;\n            }\n            node = node.nextSibling;\n          }\n          return -1;\n        };\n        let container = bookmark[start ? 'startContainer' : 'endContainer'];\n        let offset = bookmark[start ? 'startOffset' : 'endOffset'];\n        if (!container) {\n          return;\n        }\n        if (isElement(container) && container.parentNode) {\n          const node = container;\n          offset = nodeIndex(container);\n          container = container.parentNode;\n          DOM$1.remove(node);\n          if (!container.hasChildNodes() && DOM$1.isBlock(container)) {\n            container.appendChild(DOM$1.create('br'));\n          }\n        }\n        bookmark[start ? 'startContainer' : 'endContainer'] = container;\n        bookmark[start ? 'startOffset' : 'endOffset'] = offset;\n      };\n      restoreEndPoint(true);\n      restoreEndPoint();\n      const rng = DOM$1.createRng();\n      rng.setStart(bookmark.startContainer, bookmark.startOffset);\n      if (bookmark.endContainer) {\n        rng.setEnd(bookmark.endContainer, bookmark.endOffset);\n      }\n      return normalizeRange(rng);\n    };\n\n    const listToggleActionFromListName = listName => {\n      switch (listName) {\n      case 'UL':\n        return 'ToggleUlList';\n      case 'OL':\n        return 'ToggleOlList';\n      case 'DL':\n        return 'ToggleDLList';\n      }\n    };\n\n    const updateListStyle = (dom, el, detail) => {\n      const type = detail['list-style-type'] ? detail['list-style-type'] : null;\n      dom.setStyle(el, 'list-style-type', type);\n    };\n    const setAttribs = (elm, attrs) => {\n      global$2.each(attrs, (value, key) => {\n        elm.setAttribute(key, value);\n      });\n    };\n    const updateListAttrs = (dom, el, detail) => {\n      setAttribs(el, detail['list-attributes']);\n      global$2.each(dom.select('li', el), li => {\n        setAttribs(li, detail['list-item-attributes']);\n      });\n    };\n    const updateListWithDetails = (dom, el, detail) => {\n      updateListStyle(dom, el, detail);\n      updateListAttrs(dom, el, detail);\n    };\n    const removeStyles = (dom, element, styles) => {\n      global$2.each(styles, style => dom.setStyle(element, style, ''));\n    };\n    const isInline = (editor, node) => isNonNullable(node) && !isBlock(node, editor.schema.getBlockElements());\n    const getEndPointNode = (editor, rng, start, root) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      const offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement(container)) {\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n      }\n      if (!start && isBr(container.nextSibling)) {\n        container = container.nextSibling;\n      }\n      const findBlockAncestor = node => {\n        while (!editor.dom.isBlock(node) && node.parentNode && root !== node) {\n          node = node.parentNode;\n        }\n        return node;\n      };\n      const findBetterContainer = (container, forward) => {\n        var _a;\n        const walker = new global$5(container, findBlockAncestor(container));\n        const dir = forward ? 'next' : 'prev';\n        let node;\n        while (node = walker[dir]()) {\n          if (!(isVoid(editor, node) || isZwsp(node.textContent) || ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) === 0)) {\n            return Optional.some(node);\n          }\n        }\n        return Optional.none();\n      };\n      if (start && isTextNode$1(container)) {\n        if (isZwsp(container.textContent)) {\n          container = findBetterContainer(container, false).getOr(container);\n        } else {\n          if (container.parentNode !== null && isInline(editor, container.parentNode)) {\n            container = container.parentNode;\n          }\n          while (container.previousSibling !== null && (isInline(editor, container.previousSibling) || isTextNode$1(container.previousSibling))) {\n            container = container.previousSibling;\n          }\n        }\n      }\n      if (!start && isTextNode$1(container)) {\n        if (isZwsp(container.textContent)) {\n          container = findBetterContainer(container, true).getOr(container);\n        } else {\n          if (container.parentNode !== null && isInline(editor, container.parentNode)) {\n            container = container.parentNode;\n          }\n          while (container.nextSibling !== null && (isInline(editor, container.nextSibling) || isTextNode$1(container.nextSibling))) {\n            container = container.nextSibling;\n          }\n        }\n      }\n      while (container.parentNode !== root) {\n        const parent = container.parentNode;\n        if (isTextBlock(editor, container)) {\n          return container;\n        }\n        if (/^(TD|TH)$/.test(parent.nodeName)) {\n          return container;\n        }\n        container = parent;\n      }\n      return container;\n    };\n    const getSelectedTextBlocks = (editor, rng, root) => {\n      const textBlocks = [];\n      const dom = editor.dom;\n      const startNode = getEndPointNode(editor, rng, true, root);\n      const endNode = getEndPointNode(editor, rng, false, root);\n      let block;\n      const siblings = [];\n      for (let node = startNode; node; node = node.nextSibling) {\n        siblings.push(node);\n        if (node === endNode) {\n          break;\n        }\n      }\n      global$2.each(siblings, node => {\n        var _a;\n        if (isTextBlock(editor, node)) {\n          textBlocks.push(node);\n          block = null;\n          return;\n        }\n        if (dom.isBlock(node) || isBr(node)) {\n          if (isBr(node)) {\n            dom.remove(node);\n          }\n          block = null;\n          return;\n        }\n        const nextSibling = node.nextSibling;\n        if (global$1.isBookmarkNode(node)) {\n          if (isListNode(nextSibling) || isTextBlock(editor, nextSibling) || !nextSibling && node.parentNode === root) {\n            block = null;\n            return;\n          }\n        }\n        if (!block) {\n          block = dom.create('p');\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(block, node);\n          textBlocks.push(block);\n        }\n        block.appendChild(node);\n      });\n      return textBlocks;\n    };\n    const hasCompatibleStyle = (dom, sib, detail) => {\n      const sibStyle = dom.getStyle(sib, 'list-style-type');\n      let detailStyle = detail ? detail['list-style-type'] : '';\n      detailStyle = detailStyle === null ? '' : detailStyle;\n      return sibStyle === detailStyle;\n    };\n    const getRootSearchStart = (editor, range) => {\n      const start = editor.selection.getStart(true);\n      const startPoint = getEndPointNode(editor, range, true, editor.getBody());\n      if (ancestor(SugarElement.fromDom(startPoint), SugarElement.fromDom(range.commonAncestorContainer))) {\n        return range.commonAncestorContainer;\n      } else {\n        return start;\n      }\n    };\n    const applyList = (editor, listName, detail) => {\n      const rng = editor.selection.getRng();\n      let listItemName = 'LI';\n      const root = getClosestListHost(editor, getRootSearchStart(editor, rng));\n      const dom = editor.dom;\n      if (dom.getContentEditable(editor.selection.getNode()) === 'false') {\n        return;\n      }\n      listName = listName.toUpperCase();\n      if (listName === 'DL') {\n        listItemName = 'DT';\n      }\n      const bookmark = createBookmark(rng);\n      const selectedTextBlocks = filter$1(getSelectedTextBlocks(editor, rng, root), editor.dom.isEditable);\n      global$2.each(selectedTextBlocks, block => {\n        let listBlock;\n        const sibling = block.previousSibling;\n        const parent = block.parentNode;\n        if (!isListItemNode(parent)) {\n          if (sibling && isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {\n            listBlock = sibling;\n            block = dom.rename(block, listItemName);\n            sibling.appendChild(block);\n          } else {\n            listBlock = dom.create(listName);\n            parent.insertBefore(listBlock, block);\n            listBlock.appendChild(block);\n            block = dom.rename(block, listItemName);\n          }\n          removeStyles(dom, block, [\n            'margin',\n            'margin-right',\n            'margin-bottom',\n            'margin-left',\n            'margin-top',\n            'padding',\n            'padding-right',\n            'padding-bottom',\n            'padding-left',\n            'padding-top'\n          ]);\n          updateListWithDetails(dom, listBlock, detail);\n          mergeWithAdjacentLists(editor.dom, listBlock);\n        }\n      });\n      editor.selection.setRng(resolveBookmark(bookmark));\n    };\n    const isValidLists = (list1, list2) => {\n      return isListNode(list1) && list1.nodeName === (list2 === null || list2 === void 0 ? void 0 : list2.nodeName);\n    };\n    const hasSameListStyle = (dom, list1, list2) => {\n      const targetStyle = dom.getStyle(list1, 'list-style-type', true);\n      const style = dom.getStyle(list2, 'list-style-type', true);\n      return targetStyle === style;\n    };\n    const hasSameClasses = (elm1, elm2) => {\n      return elm1.className === elm2.className;\n    };\n    const shouldMerge = (dom, list1, list2) => {\n      return isValidLists(list1, list2) && hasSameListStyle(dom, list1, list2) && hasSameClasses(list1, list2);\n    };\n    const mergeWithAdjacentLists = (dom, listBlock) => {\n      let node;\n      let sibling = listBlock.nextSibling;\n      if (shouldMerge(dom, listBlock, sibling)) {\n        const liSibling = sibling;\n        while (node = liSibling.firstChild) {\n          listBlock.appendChild(node);\n        }\n        dom.remove(liSibling);\n      }\n      sibling = listBlock.previousSibling;\n      if (shouldMerge(dom, listBlock, sibling)) {\n        const liSibling = sibling;\n        while (node = liSibling.lastChild) {\n          listBlock.insertBefore(node, listBlock.firstChild);\n        }\n        dom.remove(liSibling);\n      }\n    };\n    const updateList$1 = (editor, list, listName, detail) => {\n      if (list.nodeName !== listName) {\n        const newList = editor.dom.rename(list, listName);\n        updateListWithDetails(editor.dom, newList, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), newList);\n      } else {\n        updateListWithDetails(editor.dom, list, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), list);\n      }\n    };\n    const updateCustomList = (editor, list, listName, detail) => {\n      list.classList.forEach((cls, _, classList) => {\n        if (cls.startsWith('tox-')) {\n          classList.remove(cls);\n          if (classList.length === 0) {\n            list.removeAttribute('class');\n          }\n        }\n      });\n      if (list.nodeName !== listName) {\n        const newList = editor.dom.rename(list, listName);\n        updateListWithDetails(editor.dom, newList, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), newList);\n      } else {\n        updateListWithDetails(editor.dom, list, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), list);\n      }\n    };\n    const toggleMultipleLists = (editor, parentList, lists, listName, detail) => {\n      const parentIsList = isListNode(parentList);\n      if (parentIsList && parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {\n        flattenListSelection(editor);\n      } else {\n        applyList(editor, listName, detail);\n        const bookmark = createBookmark(editor.selection.getRng());\n        const allLists = parentIsList ? [\n          parentList,\n          ...lists\n        ] : lists;\n        const updateFunction = parentIsList && isCustomList(parentList) ? updateCustomList : updateList$1;\n        global$2.each(allLists, elm => {\n          updateFunction(editor, elm, listName, detail);\n        });\n        editor.selection.setRng(resolveBookmark(bookmark));\n      }\n    };\n    const hasListStyleDetail = detail => {\n      return 'list-style-type' in detail;\n    };\n    const toggleSingleList = (editor, parentList, listName, detail) => {\n      if (parentList === editor.getBody()) {\n        return;\n      }\n      if (parentList) {\n        if (parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {\n          flattenListSelection(editor);\n        } else {\n          const bookmark = createBookmark(editor.selection.getRng());\n          if (isCustomList(parentList)) {\n            parentList.classList.forEach((cls, _, classList) => {\n              if (cls.startsWith('tox-')) {\n                classList.remove(cls);\n                if (classList.length === 0) {\n                  parentList.removeAttribute('class');\n                }\n              }\n            });\n          }\n          updateListWithDetails(editor.dom, parentList, detail);\n          const newList = editor.dom.rename(parentList, listName);\n          mergeWithAdjacentLists(editor.dom, newList);\n          editor.selection.setRng(resolveBookmark(bookmark));\n          applyList(editor, listName, detail);\n          fireListEvent(editor, listToggleActionFromListName(listName), newList);\n        }\n      } else {\n        applyList(editor, listName, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), parentList);\n      }\n    };\n    const toggleList = (editor, listName, _detail) => {\n      const parentList = getParentList(editor);\n      if (isWithinNonEditableList(editor, parentList)) {\n        return;\n      }\n      const selectedSubLists = getSelectedSubLists(editor);\n      const detail = isObject(_detail) ? _detail : {};\n      if (selectedSubLists.length > 0) {\n        toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);\n      } else {\n        toggleSingleList(editor, parentList, listName, detail);\n      }\n    };\n\n    const DOM = global$3.DOM;\n    const normalizeList = (dom, list) => {\n      const parentNode = list.parentElement;\n      if (parentNode && parentNode.nodeName === 'LI' && parentNode.firstChild === list) {\n        const sibling = parentNode.previousSibling;\n        if (sibling && sibling.nodeName === 'LI') {\n          sibling.appendChild(list);\n          if (isEmpty$2(dom, parentNode)) {\n            DOM.remove(parentNode);\n          }\n        } else {\n          DOM.setStyle(parentNode, 'listStyleType', 'none');\n        }\n      }\n      if (isListNode(parentNode)) {\n        const sibling = parentNode.previousSibling;\n        if (sibling && sibling.nodeName === 'LI') {\n          sibling.appendChild(list);\n        }\n      }\n    };\n    const normalizeLists = (dom, element) => {\n      const lists = global$2.grep(dom.select('ol,ul', element));\n      global$2.each(lists, list => {\n        normalizeList(dom, list);\n      });\n    };\n\n    const findNextCaretContainer = (editor, rng, isForward, root) => {\n      let node = rng.startContainer;\n      const offset = rng.startOffset;\n      if (isTextNode$1(node) && (isForward ? offset < node.data.length : offset > 0)) {\n        return node;\n      }\n      const nonEmptyBlocks = editor.schema.getNonEmptyElements();\n      if (isElement(node)) {\n        node = global$6.getNode(node, offset);\n      }\n      const walker = new global$5(node, root);\n      if (isForward) {\n        if (isBogusBr(editor.dom, node)) {\n          walker.next();\n        }\n      }\n      const walkFn = isForward ? walker.next.bind(walker) : walker.prev2.bind(walker);\n      while (node = walkFn()) {\n        if (node.nodeName === 'LI' && !node.hasChildNodes()) {\n          return node;\n        }\n        if (nonEmptyBlocks[node.nodeName]) {\n          return node;\n        }\n        if (isTextNode$1(node) && node.data.length > 0) {\n          return node;\n        }\n      }\n      return null;\n    };\n    const hasOnlyOneBlockChild = (dom, elm) => {\n      const childNodes = elm.childNodes;\n      return childNodes.length === 1 && !isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);\n    };\n    const isUnwrappable = node => Optional.from(node).map(SugarElement.fromDom).filter(isHTMLElement).exists(el => isEditable(el) && !contains$1(['details'], name(el)));\n    const unwrapSingleBlockChild = (dom, elm) => {\n      if (hasOnlyOneBlockChild(dom, elm) && isUnwrappable(elm.firstChild)) {\n        dom.remove(elm.firstChild, true);\n      }\n    };\n    const moveChildren = (dom, fromElm, toElm) => {\n      let node;\n      const targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;\n      unwrapSingleBlockChild(dom, fromElm);\n      if (!isEmpty$2(dom, fromElm, true)) {\n        while (node = fromElm.firstChild) {\n          targetElm.appendChild(node);\n        }\n      }\n    };\n    const mergeLiElements = (dom, fromElm, toElm) => {\n      let listNode;\n      const ul = fromElm.parentNode;\n      if (!isChildOfBody(dom, fromElm) || !isChildOfBody(dom, toElm)) {\n        return;\n      }\n      if (isListNode(toElm.lastChild)) {\n        listNode = toElm.lastChild;\n      }\n      if (ul === toElm.lastChild) {\n        if (isBr(ul.previousSibling)) {\n          dom.remove(ul.previousSibling);\n        }\n      }\n      const node = toElm.lastChild;\n      if (node && isBr(node) && fromElm.hasChildNodes()) {\n        dom.remove(node);\n      }\n      if (isEmpty$2(dom, toElm, true)) {\n        empty(SugarElement.fromDom(toElm));\n      }\n      moveChildren(dom, fromElm, toElm);\n      if (listNode) {\n        toElm.appendChild(listNode);\n      }\n      const contains$1 = contains(SugarElement.fromDom(toElm), SugarElement.fromDom(fromElm));\n      const nestedLists = contains$1 ? dom.getParents(fromElm, isListNode, toElm) : [];\n      dom.remove(fromElm);\n      each$1(nestedLists, list => {\n        if (isEmpty$2(dom, list) && list !== dom.getRoot()) {\n          dom.remove(list);\n        }\n      });\n    };\n    const mergeIntoEmptyLi = (editor, fromLi, toLi) => {\n      empty(SugarElement.fromDom(toLi));\n      mergeLiElements(editor.dom, fromLi, toLi);\n      editor.selection.setCursorLocation(toLi, 0);\n    };\n    const mergeForward = (editor, rng, fromLi, toLi) => {\n      const dom = editor.dom;\n      if (dom.isEmpty(toLi)) {\n        mergeIntoEmptyLi(editor, fromLi, toLi);\n      } else {\n        const bookmark = createBookmark(rng);\n        mergeLiElements(dom, fromLi, toLi);\n        editor.selection.setRng(resolveBookmark(bookmark));\n      }\n    };\n    const mergeBackward = (editor, rng, fromLi, toLi) => {\n      const bookmark = createBookmark(rng);\n      mergeLiElements(editor.dom, fromLi, toLi);\n      const resolvedBookmark = resolveBookmark(bookmark);\n      editor.selection.setRng(resolvedBookmark);\n    };\n    const backspaceDeleteFromListToListCaret = (editor, isForward) => {\n      const dom = editor.dom, selection = editor.selection;\n      const selectionStartElm = selection.getStart();\n      const root = getClosestEditingHost(editor, selectionStartElm);\n      const li = dom.getParent(selection.getStart(), 'LI', root);\n      if (li) {\n        const ul = li.parentElement;\n        if (ul === editor.getBody() && isEmpty$2(dom, ul)) {\n          return true;\n        }\n        const rng = normalizeRange(selection.getRng());\n        const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);\n        const willMergeParentIntoChild = otherLi && (isForward ? dom.isChildOf(li, otherLi) : dom.isChildOf(otherLi, li));\n        if (otherLi && otherLi !== li && !willMergeParentIntoChild) {\n          editor.undoManager.transact(() => {\n            if (isForward) {\n              mergeForward(editor, rng, otherLi, li);\n            } else {\n              if (isFirstChild(li)) {\n                outdentListSelection(editor);\n              } else {\n                mergeBackward(editor, rng, li, otherLi);\n              }\n            }\n          });\n          return true;\n        } else if (willMergeParentIntoChild && !isForward && otherLi !== li) {\n          editor.undoManager.transact(() => {\n            if (rng.commonAncestorContainer.parentElement) {\n              const bookmark = createBookmark(rng);\n              const oldParentElRef = rng.commonAncestorContainer.parentElement;\n              moveChildren(dom, rng.commonAncestorContainer.parentElement, otherLi);\n              oldParentElRef.remove();\n              const resolvedBookmark = resolveBookmark(bookmark);\n              editor.selection.setRng(resolvedBookmark);\n            }\n          });\n          return true;\n        } else if (!otherLi) {\n          if (!isForward && rng.startOffset === 0 && rng.endOffset === 0) {\n            editor.undoManager.transact(() => {\n              flattenListSelection(editor);\n            });\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const removeBlock = (dom, block, root) => {\n      const parentBlock = dom.getParent(block.parentNode, dom.isBlock, root);\n      dom.remove(block);\n      if (parentBlock && dom.isEmpty(parentBlock)) {\n        dom.remove(parentBlock);\n      }\n    };\n    const backspaceDeleteIntoListCaret = (editor, isForward) => {\n      const dom = editor.dom;\n      const selectionStartElm = editor.selection.getStart();\n      const root = getClosestEditingHost(editor, selectionStartElm);\n      const block = dom.getParent(selectionStartElm, dom.isBlock, root);\n      if (block && dom.isEmpty(block)) {\n        const rng = normalizeRange(editor.selection.getRng());\n        const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);\n        if (otherLi) {\n          const findValidElement = element => contains$1([\n            'td',\n            'th',\n            'caption'\n          ], name(element));\n          const findRoot = node => node.dom === root;\n          const otherLiCell = closest$2(SugarElement.fromDom(otherLi), findValidElement, findRoot);\n          const caretCell = closest$2(SugarElement.fromDom(rng.startContainer), findValidElement, findRoot);\n          if (!equals(otherLiCell, caretCell, eq)) {\n            return false;\n          }\n          editor.undoManager.transact(() => {\n            const parentNode = otherLi.parentNode;\n            removeBlock(dom, block, root);\n            mergeWithAdjacentLists(dom, parentNode);\n            editor.selection.select(otherLi, true);\n            editor.selection.collapse(isForward);\n          });\n          return true;\n        }\n      }\n      return false;\n    };\n    const backspaceDeleteCaret = (editor, isForward) => {\n      return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);\n    };\n    const hasListSelection = editor => {\n      const selectionStartElm = editor.selection.getStart();\n      const root = getClosestEditingHost(editor, selectionStartElm);\n      const startListParent = editor.dom.getParent(selectionStartElm, 'LI,DT,DD', root);\n      return startListParent || getSelectedListItems(editor).length > 0;\n    };\n    const backspaceDeleteRange = editor => {\n      if (hasListSelection(editor)) {\n        editor.undoManager.transact(() => {\n          editor.execCommand('Delete');\n          normalizeLists(editor.dom, editor.getBody());\n        });\n        return true;\n      }\n      return false;\n    };\n    const backspaceDelete = (editor, isForward) => {\n      const selection = editor.selection;\n      return !isWithinNonEditableList(editor, selection.getNode()) && (selection.isCollapsed() ? backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor));\n    };\n    const setup$2 = editor => {\n      editor.on('ExecCommand', e => {\n        const cmd = e.command.toLowerCase();\n        if ((cmd === 'delete' || cmd === 'forwarddelete') && hasListSelection(editor)) {\n          normalizeLists(editor.dom, editor.getBody());\n        }\n      });\n      editor.on('keydown', e => {\n        if (e.keyCode === global$4.BACKSPACE) {\n          if (backspaceDelete(editor, false)) {\n            e.preventDefault();\n          }\n        } else if (e.keyCode === global$4.DELETE) {\n          if (backspaceDelete(editor, true)) {\n            e.preventDefault();\n          }\n        }\n      });\n    };\n\n    const get = editor => ({\n      backspaceDelete: isForward => {\n        backspaceDelete(editor, isForward);\n      }\n    });\n\n    const updateList = (editor, update) => {\n      const parentList = getParentList(editor);\n      if (parentList === null || isWithinNonEditableList(editor, parentList)) {\n        return;\n      }\n      editor.undoManager.transact(() => {\n        if (isObject(update.styles)) {\n          editor.dom.setStyles(parentList, update.styles);\n        }\n        if (isObject(update.attrs)) {\n          each(update.attrs, (v, k) => editor.dom.setAttrib(parentList, k, v));\n        }\n      });\n    };\n\n    const parseAlphabeticBase26 = str => {\n      const chars = reverse(trim(str).split(''));\n      const values = map(chars, (char, i) => {\n        const charValue = char.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0) + 1;\n        return Math.pow(26, i) * charValue;\n      });\n      return foldl(values, (sum, v) => sum + v, 0);\n    };\n    const composeAlphabeticBase26 = value => {\n      value--;\n      if (value < 0) {\n        return '';\n      } else {\n        const remainder = value % 26;\n        const quotient = Math.floor(value / 26);\n        const rest = composeAlphabeticBase26(quotient);\n        const char = String.fromCharCode('A'.charCodeAt(0) + remainder);\n        return rest + char;\n      }\n    };\n    const isUppercase = str => /^[A-Z]+$/.test(str);\n    const isLowercase = str => /^[a-z]+$/.test(str);\n    const isNumeric = str => /^[0-9]+$/.test(str);\n    const deduceListType = start => {\n      if (isNumeric(start)) {\n        return 2;\n      } else if (isUppercase(start)) {\n        return 0;\n      } else if (isLowercase(start)) {\n        return 1;\n      } else if (isEmpty$1(start)) {\n        return 3;\n      } else {\n        return 4;\n      }\n    };\n    const parseStartValue = start => {\n      switch (deduceListType(start)) {\n      case 2:\n        return Optional.some({\n          listStyleType: Optional.none(),\n          start\n        });\n      case 0:\n        return Optional.some({\n          listStyleType: Optional.some('upper-alpha'),\n          start: parseAlphabeticBase26(start).toString()\n        });\n      case 1:\n        return Optional.some({\n          listStyleType: Optional.some('lower-alpha'),\n          start: parseAlphabeticBase26(start).toString()\n        });\n      case 3:\n        return Optional.some({\n          listStyleType: Optional.none(),\n          start: ''\n        });\n      case 4:\n        return Optional.none();\n      }\n    };\n    const parseDetail = detail => {\n      const start = parseInt(detail.start, 10);\n      if (is$2(detail.listStyleType, 'upper-alpha')) {\n        return composeAlphabeticBase26(start);\n      } else if (is$2(detail.listStyleType, 'lower-alpha')) {\n        return composeAlphabeticBase26(start).toLowerCase();\n      } else {\n        return detail.start;\n      }\n    };\n\n    const open = editor => {\n      const currentList = getParentList(editor);\n      if (!isOlNode(currentList) || isWithinNonEditableList(editor, currentList)) {\n        return;\n      }\n      editor.windowManager.open({\n        title: 'List Properties',\n        body: {\n          type: 'panel',\n          items: [{\n              type: 'input',\n              name: 'start',\n              label: 'Start list at number',\n              inputMode: 'numeric'\n            }]\n        },\n        initialData: {\n          start: parseDetail({\n            start: editor.dom.getAttrib(currentList, 'start', '1'),\n            listStyleType: Optional.from(editor.dom.getStyle(currentList, 'list-style-type'))\n          })\n        },\n        buttons: [\n          {\n            type: 'cancel',\n            name: 'cancel',\n            text: 'Cancel'\n          },\n          {\n            type: 'submit',\n            name: 'save',\n            text: 'Save',\n            primary: true\n          }\n        ],\n        onSubmit: api => {\n          const data = api.getData();\n          parseStartValue(data.start).each(detail => {\n            editor.execCommand('mceListUpdate', false, {\n              attrs: { start: detail.start === '1' ? '' : detail.start },\n              styles: { 'list-style-type': detail.listStyleType.getOr('') }\n            });\n          });\n          api.close();\n        }\n      });\n    };\n\n    const queryListCommandState = (editor, listName) => () => {\n      const parentList = getParentList(editor);\n      return isNonNullable(parentList) && parentList.nodeName === listName;\n    };\n    const registerDialog = editor => {\n      editor.addCommand('mceListProps', () => {\n        open(editor);\n      });\n    };\n    const register$2 = editor => {\n      editor.on('BeforeExecCommand', e => {\n        const cmd = e.command.toLowerCase();\n        if (cmd === 'indent') {\n          indentListSelection(editor);\n        } else if (cmd === 'outdent') {\n          outdentListSelection(editor);\n        }\n      });\n      editor.addCommand('InsertUnorderedList', (ui, detail) => {\n        toggleList(editor, 'UL', detail);\n      });\n      editor.addCommand('InsertOrderedList', (ui, detail) => {\n        toggleList(editor, 'OL', detail);\n      });\n      editor.addCommand('InsertDefinitionList', (ui, detail) => {\n        toggleList(editor, 'DL', detail);\n      });\n      editor.addCommand('RemoveList', () => {\n        flattenListSelection(editor);\n      });\n      registerDialog(editor);\n      editor.addCommand('mceListUpdate', (ui, detail) => {\n        if (isObject(detail)) {\n          updateList(editor, detail);\n        }\n      });\n      editor.addQueryStateHandler('InsertUnorderedList', queryListCommandState(editor, 'UL'));\n      editor.addQueryStateHandler('InsertOrderedList', queryListCommandState(editor, 'OL'));\n      editor.addQueryStateHandler('InsertDefinitionList', queryListCommandState(editor, 'DL'));\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.html.Node');\n\n    const isTextNode = node => node.type === 3;\n    const isEmpty = nodeBuffer => nodeBuffer.length === 0;\n    const wrapInvalidChildren = list => {\n      const insertListItem = (buffer, refNode) => {\n        const li = global.create('li');\n        each$1(buffer, node => li.append(node));\n        if (refNode) {\n          list.insert(li, refNode, true);\n        } else {\n          list.append(li);\n        }\n      };\n      const reducer = (buffer, node) => {\n        if (isTextNode(node)) {\n          return [\n            ...buffer,\n            node\n          ];\n        } else if (!isEmpty(buffer) && !isTextNode(node)) {\n          insertListItem(buffer, node);\n          return [];\n        } else {\n          return buffer;\n        }\n      };\n      const restBuffer = foldl(list.children(), reducer, []);\n      if (!isEmpty(restBuffer)) {\n        insertListItem(restBuffer);\n      }\n    };\n    const setup$1 = editor => {\n      editor.on('PreInit', () => {\n        const {parser} = editor;\n        parser.addNodeFilter('ul,ol', nodes => each$1(nodes, wrapInvalidChildren));\n      });\n    };\n\n    const setupTabKey = editor => {\n      editor.on('keydown', e => {\n        if (e.keyCode !== global$4.TAB || global$4.metaKeyPressed(e)) {\n          return;\n        }\n        editor.undoManager.transact(() => {\n          if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) {\n            e.preventDefault();\n          }\n        });\n      });\n    };\n    const setup = editor => {\n      if (shouldIndentOnTab(editor)) {\n        setupTabKey(editor);\n      }\n      setup$2(editor);\n    };\n\n    const setupToggleButtonHandler = (editor, listName) => api => {\n      const toggleButtonHandler = e => {\n        api.setActive(inList(e.parents, listName));\n        api.setEnabled(!isWithinNonEditableList(editor, e.element) && editor.selection.isEditable());\n      };\n      api.setEnabled(editor.selection.isEditable());\n      return setNodeChangeHandler(editor, toggleButtonHandler);\n    };\n    const register$1 = editor => {\n      const exec = command => () => editor.execCommand(command);\n      if (!editor.hasPlugin('advlist')) {\n        editor.ui.registry.addToggleButton('numlist', {\n          icon: 'ordered-list',\n          active: false,\n          tooltip: 'Numbered list',\n          onAction: exec('InsertOrderedList'),\n          onSetup: setupToggleButtonHandler(editor, 'OL')\n        });\n        editor.ui.registry.addToggleButton('bullist', {\n          icon: 'unordered-list',\n          active: false,\n          tooltip: 'Bullet list',\n          onAction: exec('InsertUnorderedList'),\n          onSetup: setupToggleButtonHandler(editor, 'UL')\n        });\n      }\n    };\n\n    const setupMenuButtonHandler = (editor, listName) => api => {\n      const menuButtonHandler = e => api.setEnabled(inList(e.parents, listName) && !isWithinNonEditableList(editor, e.element));\n      return setNodeChangeHandler(editor, menuButtonHandler);\n    };\n    const register = editor => {\n      const listProperties = {\n        text: 'List properties...',\n        icon: 'ordered-list',\n        onAction: () => editor.execCommand('mceListProps'),\n        onSetup: setupMenuButtonHandler(editor, 'OL')\n      };\n      editor.ui.registry.addMenuItem('listprops', listProperties);\n      editor.ui.registry.addContextMenu('lists', {\n        update: node => {\n          const parentList = getParentList(editor, node);\n          return isOlNode(parentList) ? ['listprops'] : [];\n        }\n      });\n    };\n\n    var Plugin = () => {\n      global$7.add('lists', editor => {\n        register$3(editor);\n        setup$1(editor);\n        if (!editor.hasPlugin('rtc', true)) {\n          setup(editor);\n          register$2(editor);\n        } else {\n          registerDialog(editor);\n        }\n        register$1(editor);\n        register(editor);\n        return get(editor);\n      });\n    };\n\n    Plugin();\n\n})();\n"],"names":["global$7","hasProto","v","constructor","predicate","_a","typeOf","x","t","o","proto","isType$1","type","value","isSimpleType","isString","isObject","isArray","isBoolean","isNullable","a","isNonNullable","isFunction","isNumber","noop","compose1","fbc","fab","constant","tripleEquals","b","curry","fn","initialArgs","restArgs","all","not","f","never","Optional","tag","onNone","onSome","mapper","binder","replacement","thunk","message","worker","nativeSlice","nativeIndexOf","nativePush","rawIndexOf","ts","contains$1","xs","exists","pred","i","len","map","r","each$1","filter$1","groupBy","wasType","group","foldl","acc","findUntil","until","find","flatten","bind","reverse","get$1","head","last","unique","comparator","isDuplicated","is$2","lhs","rhs","left","equals","lift2","oa","ob","COMMENT","DOCUMENT","DOCUMENT_FRAGMENT","ELEMENT","TEXT","fromHtml","html","scope","div","fromDom$1","fromTag","node","fromText","text","SugarElement","docElm","y","is$1","element","selector","dom","elem","eq","e1","e2","contains","d1","d2","is","Global","path","parts","resolve","p","unsafe","name","getOrDie","actual","getPrototypeOf","sandHTMLElement","isPrototypeOf","isType","isComment","isHTMLElement","isElement$1","isText","isDocument","isDocumentFragment","isTag","owner","documentOrOwner","dos","parent","parentElement","nextSibling","children","child","index","cs","firstChild","lastChild","isShadowRoot","getRootNode","e","getShadowRoot","getShadowHost","inBody","doc","ClosestOrAncestor","ancestor","isRoot","ancestor$3","stop","el","closest$2","s","test","ancestor$2","closest$1","closest","target","isEditable","assumeEditable","editable","getRaw","before$1","marker","after","append$1","prepend","before","elements","append","empty","rogue","remove","global$6","global$5","global$4","fromDom","nodes","keys","each","obj","props","k","objAcc","internalFilter","onTrue","onFalse","filter","rawSet","key","setAll","attrs","clone$1","attr","clone","original","isDeep","deep","shallowAs","nu","attributes","mutate","children$1","global$3","global$2","matchNodeName","matchNodeNames","regex","isTextNode$1","isElement","isListNode","isOlUlNode","isOlNode","isListItemNode","isDlItemNode","isTableCellNode","isBr","isFirstChild","isTextBlock","editor","isBlock","blockElements","isVoid","isBogusBr","isEmpty$2","elm","keepBookmarks","isChildOfBody","option","register$3","registerOption","shouldIndentOnTab","getForcedRootBlock","getForcedRootBlockAttrs","createTextBlock","contentNode","fragment","blockName","blockAttrs","textBlock","hasContentNode","nodeName","DOM$2","splitList","list","li","removeAndKeepBookmarks","targetNode","bookmarks","newBlock","tmpRng","isDescriptionDetail","isDescriptionTerm","outdentDlItem","item","dl","indentDlItem","dlIndentation","indentation","dlItems","getNormalizedPoint","container","offset","normalizeRange","rng","outRng","rangeStart","rangeEnd","listNames","listSelector","getParentList","selectionStart","getClosestListHost","isParentListSelected","parentList","selectedBlocks","findSubLists","getSelectedSubLists","findParentListItemsNodes","elms","listItemsElms","parentLi","getSelectedListItems","getSelectedDlItems","getClosestEditingHost","parentTableCell","isListHost","schema","listName","parentBlocks","isListInsideAnLiWithFirstAndLastNotListElement","findLastParentListNode","parentLists","getSelectedLists","firstList","subsequentLists","getParentLists","getSelectedListRoots","selectedLists","getUniqueListRoots","l","lists","listRoots","isCustomList","inList","parents","isWithinNonEditable","selectionIsWithinNonEditableList","isWithinNonEditableList","setNodeChangeHandler","nodeChangeHandler","initialNode","fromElements","fireListEvent","action","trim","isNotEmpty","isEmpty$1","isSupported","internalSet","property","set","isList","isListItem","hasFirstChildList","hasLastChildList","isEntryList","entry","isEntryComment","isEntryFragment","isIndented","isSelected","cloneItemContent","content","createEntry","depth","joinSegment","joinSegments","segments","appendSegments","head$1","tail","createSegment","listType","segment","createSegments","size","populateSegments","normalizeSegment","createItem","appendItem","writeShallow","cast","newCast","writeDeep","composeList","entries","firstCommentEntryOpt","firstCommentEntry","fistCast","indentEntry","cloneListProperties","source","cleanListProperties","_value","closestSiblingEntry","start","matches","normalizeEntries","matchingEntry","Cell","initial","parseSingleItem","itemSelection","selectionState","selection","currentItemEntry","childListEntries","parseList","parseItem","parsedSiblings","liChild","parser","newDepth","parseLists","initialDepth","outdentedComposer","normalizedEntries","indentedComposer","composeEntries","indentSelectedEntries","getItemSelection","selectedListItems","end","listIndentation","entrySets","entrySet","composedLists","composedList","selectionIndentation","isHandled","bookmark","handleIndentation","indentListSelection","outdentListSelection","flattenListSelection","zeroWidth","isZwsp","char","ancestor$1","global$1","DOM$1","createBookmark","setupEndPoint","offsetNode","resolveBookmark","restoreEndPoint","nodeIndex","idx","listToggleActionFromListName","updateListStyle","detail","setAttribs","updateListAttrs","updateListWithDetails","removeStyles","styles","style","isInline","getEndPointNode","root","findBlockAncestor","findBetterContainer","forward","walker","dir","getSelectedTextBlocks","textBlocks","startNode","endNode","block","siblings","hasCompatibleStyle","sib","sibStyle","detailStyle","getRootSearchStart","range","startPoint","applyList","listItemName","selectedTextBlocks","listBlock","sibling","mergeWithAdjacentLists","isValidLists","list1","list2","hasSameListStyle","targetStyle","hasSameClasses","elm1","elm2","shouldMerge","liSibling","updateList$1","newList","updateCustomList","cls","_","classList","toggleMultipleLists","parentIsList","hasListStyleDetail","allLists","updateFunction","toggleSingleList","toggleList","_detail","selectedSubLists","DOM","normalizeList","parentNode","normalizeLists","findNextCaretContainer","isForward","nonEmptyBlocks","walkFn","hasOnlyOneBlockChild","childNodes","isUnwrappable","unwrapSingleBlockChild","moveChildren","fromElm","toElm","targetElm","mergeLiElements","listNode","ul","nestedLists","mergeIntoEmptyLi","fromLi","toLi","mergeForward","mergeBackward","resolvedBookmark","backspaceDeleteFromListToListCaret","selectionStartElm","otherLi","willMergeParentIntoChild","oldParentElRef","removeBlock","parentBlock","backspaceDeleteIntoListCaret","findValidElement","findRoot","otherLiCell","caretCell","backspaceDeleteCaret","hasListSelection","backspaceDeleteRange","backspaceDelete","setup$2","cmd","get","updateList","update","parseAlphabeticBase26","str","chars","values","charValue","sum","composeAlphabeticBase26","remainder","quotient","rest","isUppercase","isLowercase","isNumeric","deduceListType","parseStartValue","parseDetail","open","currentList","api","data","queryListCommandState","registerDialog","register$2","ui","global","isTextNode","isEmpty","nodeBuffer","wrapInvalidChildren","insertListItem","buffer","refNode","reducer","restBuffer","setup$1","setupTabKey","setup","setupToggleButtonHandler","toggleButtonHandler","register$1","exec","command","setupMenuButtonHandler","register","listProperties","Plugin"],"mappings":"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","x_google_ignoreList":[0]}